[{:doc "A shim namespace for the Node.js process library", :end-row 10, :filename "process/env.cljs", :name "process.env", :row 9, :ns nil, :var-definitions [{:end-row 12, :filename "process/env.cljs", :name "NODE_ENV", :ns "process.env", :row 12}]} {:end-row 15, :filename "cljs/stacktrace.cljc", :lang :clj, :name "cljs.stacktrace", :row 9, :ns nil, :var-definitions [{:doc "Parse a JavaScript stacktrace string into a canonical data form. The\n  arguments:\n\n  repl-env - the repl environment, an optional map with :host and :port keys\n             if the stacktrace includes url, not file references\n  st       - the original stacktrace string to parse\n  err      - an error map. :ua-product key defines the type of stacktrace parser\n             to use, for example :chrome\n  opts     - additional options. :output-dir maybe given in this argument if\n             :host and :port do not apply, for example, a file path\n\n  The canonical stacktrace representation can easily be mapped to a\n  ClojureScript one see mapped-stacktrace and mapped-stacktrace-str", :end-row 31, :filename "cljs/stacktrace.cljc", :lang :clj, :name "parse-stacktrace", :ns "cljs.stacktrace", :row 17} {:arglist-strs ["[s]"], :end-row 35, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :clj, :name "parse-int", :ns "cljs.stacktrace", :row 33} {:arglist-strs ["[s0 s1]"], :end-row 41, :filename "cljs/stacktrace.cljc", :fixed-arities #{2}, :lang :clj, :name "starts-with?", :ns "cljs.stacktrace", :row 37} {:arglist-strs ["[s0 s1]"], :end-row 47, :filename "cljs/stacktrace.cljc", :fixed-arities #{2}, :lang :clj, :name "ends-with?", :ns "cljs.stacktrace", :row 43} {:arglist-strs ["[s]"], :end-row 51, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :clj, :name "string->regex", :ns "cljs.stacktrace", :row 49} {:arglist-strs ["[opts]"], :end-row 55, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :clj, :name "output-directory", :ns "cljs.stacktrace", :row 53} {:arglist-strs ["[flc]"], :end-row 79, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :clj, :name "parse-file-line-column", :ns "cljs.stacktrace", :row 60} {:fixed-arities #{3}, :end-row 106, :ns "cljs.stacktrace", :name "parse-file", :lang :clj, :filename "cljs/stacktrace.cljc", :arglist-strs ["[{:keys [host host-port port] :as repl-env} file {:keys [asset-path] :as opts}]"], :doc "Given a browser file url convert it into a relative path that can be used\n   to locate the original source.", :row 81} {:arglist-strs ["[repl-env st-el opts]"], :end-row 129, :filename "cljs/stacktrace.cljc", :fixed-arities #{3}, :lang :clj, :name "chrome-st-el->frame", :ns "cljs.stacktrace", :row 111} {:arglist-strs ["[repl-env st-el opts]"], :end-row 227, :filename "cljs/stacktrace.cljc", :fixed-arities #{3}, :lang :clj, :name "safari-st-el->frame", :ns "cljs.stacktrace", :row 212} {:arglist-strs ["[f]"], :end-row 304, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :clj, :name "firefox-clean-function", :ns "cljs.stacktrace", :row 294} {:arglist-strs ["[repl-env st-el opts]"], :end-row 321, :filename "cljs/stacktrace.cljc", :fixed-arities #{3}, :lang :clj, :name "firefox-st-el->frame", :ns "cljs.stacktrace", :row 306} {:arglist-strs ["[file]"], :end-row 448, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :clj, :name "remove-ext", :ns "cljs.stacktrace", :row 443} {:fixed-arities #{4}, :end-row 469, :ns "cljs.stacktrace", :name "mapped-line-column-call", :lang :clj, :filename "cljs/stacktrace.cljc", :arglist-strs ["[sms file line column]"], :doc "Given a cljs.source-map source map data structure map a generated line\n   and column back to the original line, column, and function called.", :row 450} {:fixed-arities #{3}, :end-row 489, :ns "cljs.stacktrace", :name "mapped-frame", :lang :clj, :filename "cljs/stacktrace.cljc", :arglist-strs ["[{:keys [function file line column]} sms opts]"], :doc "Given opts and a canonicalized JavaScript stacktrace frame, return the\n  ClojureScript frame.", :row 471} {:fixed-arities #{3 2}, :end-row 526, :ns "cljs.stacktrace", :name "mapped-stacktrace", :lang :clj, :filename "cljs/stacktrace.cljc", :arglist-strs ["[stacktrace sms]" "[stacktrace sms opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   return the ClojureScript stacktrace. The canonical stacktrace must be\n   in the form:\n\n    [{:file <string>\n      :function <string>\n      :line <integer>\n      :column <integer>}*]\n\n   :file must be a URL path (without protocol) relative to :output-dir or a\n   identifier delimited by angle brackets. The returned mapped stacktrace will\n   also contain :url entries to the original sources if it can be determined\n   from the classpath.", :row 491} {:fixed-arities #{3 2}, :end-row 541, :ns "cljs.stacktrace", :name "mapped-stacktrace-str", :lang :clj, :filename "cljs/stacktrace.cljc", :arglist-strs ["[stacktrace sms]" "[stacktrace sms opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace and a map\n  of library names to decoded source maps, print the ClojureScript stacktrace .\n  See mapped-stacktrace.", :row 528} {:end-row 560, :filename "cljs/stacktrace.cljc", :lang :clj, :name "sms", :ns "cljs.stacktrace", :row 555} {:doc "Parse a JavaScript stacktrace string into a canonical data form. The\n  arguments:\n\n  repl-env - the repl environment, an optional map with :host and :port keys\n             if the stacktrace includes url, not file references\n  st       - the original stacktrace string to parse\n  err      - an error map. :ua-product key defines the type of stacktrace parser\n             to use, for example :chrome\n  opts     - additional options. :output-dir maybe given in this argument if\n             :host and :port do not apply, for example, a file path\n\n  The canonical stacktrace representation can easily be mapped to a\n  ClojureScript one see mapped-stacktrace and mapped-stacktrace-str", :end-row 31, :filename "cljs/stacktrace.cljc", :lang :cljs, :name "parse-stacktrace", :ns "cljs.stacktrace", :row 17} {:arglist-strs ["[s]"], :end-row 35, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :cljs, :name "parse-int", :ns "cljs.stacktrace", :row 33} {:arglist-strs ["[s0 s1]"], :end-row 41, :filename "cljs/stacktrace.cljc", :fixed-arities #{2}, :lang :cljs, :name "starts-with?", :ns "cljs.stacktrace", :row 37} {:arglist-strs ["[s0 s1]"], :end-row 47, :filename "cljs/stacktrace.cljc", :fixed-arities #{2}, :lang :cljs, :name "ends-with?", :ns "cljs.stacktrace", :row 43} {:arglist-strs ["[s]"], :end-row 51, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :cljs, :name "string->regex", :ns "cljs.stacktrace", :row 49} {:arglist-strs ["[opts]"], :end-row 55, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :cljs, :name "output-directory", :ns "cljs.stacktrace", :row 53} {:arglist-strs ["[flc]"], :end-row 79, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :cljs, :name "parse-file-line-column", :ns "cljs.stacktrace", :row 60} {:fixed-arities #{3}, :end-row 106, :ns "cljs.stacktrace", :name "parse-file", :lang :cljs, :filename "cljs/stacktrace.cljc", :arglist-strs ["[{:keys [host host-port port] :as repl-env} file {:keys [asset-path] :as opts}]"], :doc "Given a browser file url convert it into a relative path that can be used\n   to locate the original source.", :row 81} {:arglist-strs ["[repl-env st-el opts]"], :end-row 129, :filename "cljs/stacktrace.cljc", :fixed-arities #{3}, :lang :cljs, :name "chrome-st-el->frame", :ns "cljs.stacktrace", :row 111} {:arglist-strs ["[repl-env st-el opts]"], :end-row 227, :filename "cljs/stacktrace.cljc", :fixed-arities #{3}, :lang :cljs, :name "safari-st-el->frame", :ns "cljs.stacktrace", :row 212} {:arglist-strs ["[f]"], :end-row 304, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :cljs, :name "firefox-clean-function", :ns "cljs.stacktrace", :row 294} {:arglist-strs ["[repl-env st-el opts]"], :end-row 321, :filename "cljs/stacktrace.cljc", :fixed-arities #{3}, :lang :cljs, :name "firefox-st-el->frame", :ns "cljs.stacktrace", :row 306} {:arglist-strs ["[file]"], :end-row 448, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :cljs, :name "remove-ext", :ns "cljs.stacktrace", :row 443} {:fixed-arities #{4}, :end-row 469, :ns "cljs.stacktrace", :name "mapped-line-column-call", :lang :cljs, :filename "cljs/stacktrace.cljc", :arglist-strs ["[sms file line column]"], :doc "Given a cljs.source-map source map data structure map a generated line\n   and column back to the original line, column, and function called.", :row 450} {:fixed-arities #{3}, :end-row 489, :ns "cljs.stacktrace", :name "mapped-frame", :lang :cljs, :filename "cljs/stacktrace.cljc", :arglist-strs ["[{:keys [function file line column]} sms opts]"], :doc "Given opts and a canonicalized JavaScript stacktrace frame, return the\n  ClojureScript frame.", :row 471} {:fixed-arities #{3 2}, :end-row 526, :ns "cljs.stacktrace", :name "mapped-stacktrace", :lang :cljs, :filename "cljs/stacktrace.cljc", :arglist-strs ["[stacktrace sms]" "[stacktrace sms opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   return the ClojureScript stacktrace. The canonical stacktrace must be\n   in the form:\n\n    [{:file <string>\n      :function <string>\n      :line <integer>\n      :column <integer>}*]\n\n   :file must be a URL path (without protocol) relative to :output-dir or a\n   identifier delimited by angle brackets. The returned mapped stacktrace will\n   also contain :url entries to the original sources if it can be determined\n   from the classpath.", :row 491} {:fixed-arities #{3 2}, :end-row 541, :ns "cljs.stacktrace", :name "mapped-stacktrace-str", :lang :cljs, :filename "cljs/stacktrace.cljc", :arglist-strs ["[stacktrace sms]" "[stacktrace sms opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace and a map\n  of library names to decoded source maps, print the ClojureScript stacktrace .\n  See mapped-stacktrace.", :row 528} {:end-row 560, :filename "cljs/stacktrace.cljc", :lang :cljs, :name "sms", :ns "cljs.stacktrace", :row 555}]} {:end-row 15, :filename "cljs/stacktrace.cljc", :lang :cljs, :name "cljs.stacktrace", :row 9, :ns nil, :var-definitions [{:doc "Parse a JavaScript stacktrace string into a canonical data form. The\n  arguments:\n\n  repl-env - the repl environment, an optional map with :host and :port keys\n             if the stacktrace includes url, not file references\n  st       - the original stacktrace string to parse\n  err      - an error map. :ua-product key defines the type of stacktrace parser\n             to use, for example :chrome\n  opts     - additional options. :output-dir maybe given in this argument if\n             :host and :port do not apply, for example, a file path\n\n  The canonical stacktrace representation can easily be mapped to a\n  ClojureScript one see mapped-stacktrace and mapped-stacktrace-str", :end-row 31, :filename "cljs/stacktrace.cljc", :lang :clj, :name "parse-stacktrace", :ns "cljs.stacktrace", :row 17} {:arglist-strs ["[s]"], :end-row 35, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :clj, :name "parse-int", :ns "cljs.stacktrace", :row 33} {:arglist-strs ["[s0 s1]"], :end-row 41, :filename "cljs/stacktrace.cljc", :fixed-arities #{2}, :lang :clj, :name "starts-with?", :ns "cljs.stacktrace", :row 37} {:arglist-strs ["[s0 s1]"], :end-row 47, :filename "cljs/stacktrace.cljc", :fixed-arities #{2}, :lang :clj, :name "ends-with?", :ns "cljs.stacktrace", :row 43} {:arglist-strs ["[s]"], :end-row 51, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :clj, :name "string->regex", :ns "cljs.stacktrace", :row 49} {:arglist-strs ["[opts]"], :end-row 55, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :clj, :name "output-directory", :ns "cljs.stacktrace", :row 53} {:arglist-strs ["[flc]"], :end-row 79, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :clj, :name "parse-file-line-column", :ns "cljs.stacktrace", :row 60} {:fixed-arities #{3}, :end-row 106, :ns "cljs.stacktrace", :name "parse-file", :lang :clj, :filename "cljs/stacktrace.cljc", :arglist-strs ["[{:keys [host host-port port] :as repl-env} file {:keys [asset-path] :as opts}]"], :doc "Given a browser file url convert it into a relative path that can be used\n   to locate the original source.", :row 81} {:arglist-strs ["[repl-env st-el opts]"], :end-row 129, :filename "cljs/stacktrace.cljc", :fixed-arities #{3}, :lang :clj, :name "chrome-st-el->frame", :ns "cljs.stacktrace", :row 111} {:arglist-strs ["[repl-env st-el opts]"], :end-row 227, :filename "cljs/stacktrace.cljc", :fixed-arities #{3}, :lang :clj, :name "safari-st-el->frame", :ns "cljs.stacktrace", :row 212} {:arglist-strs ["[f]"], :end-row 304, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :clj, :name "firefox-clean-function", :ns "cljs.stacktrace", :row 294} {:arglist-strs ["[repl-env st-el opts]"], :end-row 321, :filename "cljs/stacktrace.cljc", :fixed-arities #{3}, :lang :clj, :name "firefox-st-el->frame", :ns "cljs.stacktrace", :row 306} {:arglist-strs ["[file]"], :end-row 448, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :clj, :name "remove-ext", :ns "cljs.stacktrace", :row 443} {:fixed-arities #{4}, :end-row 469, :ns "cljs.stacktrace", :name "mapped-line-column-call", :lang :clj, :filename "cljs/stacktrace.cljc", :arglist-strs ["[sms file line column]"], :doc "Given a cljs.source-map source map data structure map a generated line\n   and column back to the original line, column, and function called.", :row 450} {:fixed-arities #{3}, :end-row 489, :ns "cljs.stacktrace", :name "mapped-frame", :lang :clj, :filename "cljs/stacktrace.cljc", :arglist-strs ["[{:keys [function file line column]} sms opts]"], :doc "Given opts and a canonicalized JavaScript stacktrace frame, return the\n  ClojureScript frame.", :row 471} {:fixed-arities #{3 2}, :end-row 526, :ns "cljs.stacktrace", :name "mapped-stacktrace", :lang :clj, :filename "cljs/stacktrace.cljc", :arglist-strs ["[stacktrace sms]" "[stacktrace sms opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   return the ClojureScript stacktrace. The canonical stacktrace must be\n   in the form:\n\n    [{:file <string>\n      :function <string>\n      :line <integer>\n      :column <integer>}*]\n\n   :file must be a URL path (without protocol) relative to :output-dir or a\n   identifier delimited by angle brackets. The returned mapped stacktrace will\n   also contain :url entries to the original sources if it can be determined\n   from the classpath.", :row 491} {:fixed-arities #{3 2}, :end-row 541, :ns "cljs.stacktrace", :name "mapped-stacktrace-str", :lang :clj, :filename "cljs/stacktrace.cljc", :arglist-strs ["[stacktrace sms]" "[stacktrace sms opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace and a map\n  of library names to decoded source maps, print the ClojureScript stacktrace .\n  See mapped-stacktrace.", :row 528} {:end-row 560, :filename "cljs/stacktrace.cljc", :lang :clj, :name "sms", :ns "cljs.stacktrace", :row 555} {:doc "Parse a JavaScript stacktrace string into a canonical data form. The\n  arguments:\n\n  repl-env - the repl environment, an optional map with :host and :port keys\n             if the stacktrace includes url, not file references\n  st       - the original stacktrace string to parse\n  err      - an error map. :ua-product key defines the type of stacktrace parser\n             to use, for example :chrome\n  opts     - additional options. :output-dir maybe given in this argument if\n             :host and :port do not apply, for example, a file path\n\n  The canonical stacktrace representation can easily be mapped to a\n  ClojureScript one see mapped-stacktrace and mapped-stacktrace-str", :end-row 31, :filename "cljs/stacktrace.cljc", :lang :cljs, :name "parse-stacktrace", :ns "cljs.stacktrace", :row 17} {:arglist-strs ["[s]"], :end-row 35, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :cljs, :name "parse-int", :ns "cljs.stacktrace", :row 33} {:arglist-strs ["[s0 s1]"], :end-row 41, :filename "cljs/stacktrace.cljc", :fixed-arities #{2}, :lang :cljs, :name "starts-with?", :ns "cljs.stacktrace", :row 37} {:arglist-strs ["[s0 s1]"], :end-row 47, :filename "cljs/stacktrace.cljc", :fixed-arities #{2}, :lang :cljs, :name "ends-with?", :ns "cljs.stacktrace", :row 43} {:arglist-strs ["[s]"], :end-row 51, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :cljs, :name "string->regex", :ns "cljs.stacktrace", :row 49} {:arglist-strs ["[opts]"], :end-row 55, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :cljs, :name "output-directory", :ns "cljs.stacktrace", :row 53} {:arglist-strs ["[flc]"], :end-row 79, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :cljs, :name "parse-file-line-column", :ns "cljs.stacktrace", :row 60} {:fixed-arities #{3}, :end-row 106, :ns "cljs.stacktrace", :name "parse-file", :lang :cljs, :filename "cljs/stacktrace.cljc", :arglist-strs ["[{:keys [host host-port port] :as repl-env} file {:keys [asset-path] :as opts}]"], :doc "Given a browser file url convert it into a relative path that can be used\n   to locate the original source.", :row 81} {:arglist-strs ["[repl-env st-el opts]"], :end-row 129, :filename "cljs/stacktrace.cljc", :fixed-arities #{3}, :lang :cljs, :name "chrome-st-el->frame", :ns "cljs.stacktrace", :row 111} {:arglist-strs ["[repl-env st-el opts]"], :end-row 227, :filename "cljs/stacktrace.cljc", :fixed-arities #{3}, :lang :cljs, :name "safari-st-el->frame", :ns "cljs.stacktrace", :row 212} {:arglist-strs ["[f]"], :end-row 304, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :cljs, :name "firefox-clean-function", :ns "cljs.stacktrace", :row 294} {:arglist-strs ["[repl-env st-el opts]"], :end-row 321, :filename "cljs/stacktrace.cljc", :fixed-arities #{3}, :lang :cljs, :name "firefox-st-el->frame", :ns "cljs.stacktrace", :row 306} {:arglist-strs ["[file]"], :end-row 448, :filename "cljs/stacktrace.cljc", :fixed-arities #{1}, :lang :cljs, :name "remove-ext", :ns "cljs.stacktrace", :row 443} {:fixed-arities #{4}, :end-row 469, :ns "cljs.stacktrace", :name "mapped-line-column-call", :lang :cljs, :filename "cljs/stacktrace.cljc", :arglist-strs ["[sms file line column]"], :doc "Given a cljs.source-map source map data structure map a generated line\n   and column back to the original line, column, and function called.", :row 450} {:fixed-arities #{3}, :end-row 489, :ns "cljs.stacktrace", :name "mapped-frame", :lang :cljs, :filename "cljs/stacktrace.cljc", :arglist-strs ["[{:keys [function file line column]} sms opts]"], :doc "Given opts and a canonicalized JavaScript stacktrace frame, return the\n  ClojureScript frame.", :row 471} {:fixed-arities #{3 2}, :end-row 526, :ns "cljs.stacktrace", :name "mapped-stacktrace", :lang :cljs, :filename "cljs/stacktrace.cljc", :arglist-strs ["[stacktrace sms]" "[stacktrace sms opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   return the ClojureScript stacktrace. The canonical stacktrace must be\n   in the form:\n\n    [{:file <string>\n      :function <string>\n      :line <integer>\n      :column <integer>}*]\n\n   :file must be a URL path (without protocol) relative to :output-dir or a\n   identifier delimited by angle brackets. The returned mapped stacktrace will\n   also contain :url entries to the original sources if it can be determined\n   from the classpath.", :row 491} {:fixed-arities #{3 2}, :end-row 541, :ns "cljs.stacktrace", :name "mapped-stacktrace-str", :lang :cljs, :filename "cljs/stacktrace.cljc", :arglist-strs ["[stacktrace sms]" "[stacktrace sms opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace and a map\n  of library names to decoded source maps, print the ClojureScript stacktrace .\n  See mapped-stacktrace.", :row 528} {:end-row 560, :filename "cljs/stacktrace.cljc", :lang :cljs, :name "sms", :ns "cljs.stacktrace", :row 555}]} {:end-row 12, :filename "cljs/pprint.cljc", :lang :clj, :name "cljs.pprint", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[base-writer & body]"], :end-row 25, :filename "cljs/pprint.cljc", :lang :clj, :macro true, :name "with-pretty-writer", :ns "cljs.pprint", :row 18} {:fixed-arities #{1}, :end-row 31, :ns "cljs.pprint", :name "getf", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[sym]"], :doc "Get the value of the field a named by the argument (which should be a keyword).", :row 28} {:fixed-arities #{2}, :end-row 38, :ns "cljs.pprint", :name "setf", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[sym new-val]"], :doc "Set the value of the field SYM to NEW-VAL", :row 35} {:arglist-strs ["[type-name & fields]"], :end-row 49, :filename "cljs/pprint.cljc", :lang :clj, :macro true, :name "deftype", :ns "cljs.pprint", :row 40} {:fixed-arities #{2}, :end-row 56, :private true, :ns "cljs.pprint", :name "parse-lb-options", :lang :clj, :filename "cljs/pprint.cljc", :arglist-strs ["[opts body]"], :row 51} {:end-row 80, :ns "cljs.pprint", :name "pprint-logical-block", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Execute the body as a pretty printing logical block with output to *out* which\n  must be a pretty printing writer. When used from pprint or cl-format, this can be\n  assumed.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Before the body, the caller can optionally specify options: :prefix, :per-line-prefix\n  and :suffix.", :row 58} {:fixed-arities #{3}, :end-row 100, :private true, :ns "cljs.pprint", :name "pll-mod-body", :lang :clj, :filename "cljs/pprint.cljc", :arglist-strs ["[env var-sym body]"], :row 90} {:end-row 111, :ns "cljs.pprint", :name "print-length-loop", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "A version of loop that iterates at most *print-length* times. This is designed\n  for use in pretty-printer dispatch functions.", :row 102} {:fixed-arities #{1}, :end-row 119, :private true, :ns "cljs.pprint", :name "process-directive-table-element", :lang :clj, :filename "cljs/pprint.cljc", :arglist-strs ["[[char params flags bracket-info & generator-fn]]"], :row 113} {:end-row 125, :private true, :ns "cljs.pprint", :name "defdirectives", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[& directives]"], :row 121} {:fixed-arities #{1}, :end-row 141, :ns "cljs.pprint", :name "formatter", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning\noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.", :row 127} {:fixed-arities #{1}, :end-row 155, :ns "cljs.pprint", :name "formatter-out", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.", :row 143} {:end-row 161, :ns "cljs.pprint", :name "with-pprint-dispatch", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[function & body]"], :doc "Execute body with the pretty print dispatch function bound to function.", :row 157} {:fixed-arities #{0}, :end-row 167, :ns "cljs.pprint", :name "pp", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[]"], :doc "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).", :row 163} {:arglist-strs ["[base-writer & body]"], :end-row 25, :filename "cljs/pprint.cljc", :lang :cljs, :macro true, :name "with-pretty-writer", :ns "cljs.pprint", :row 18} {:fixed-arities #{1}, :end-row 31, :ns "cljs.pprint", :name "getf", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[sym]"], :doc "Get the value of the field a named by the argument (which should be a keyword).", :row 28} {:fixed-arities #{2}, :end-row 38, :ns "cljs.pprint", :name "setf", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[sym new-val]"], :doc "Set the value of the field SYM to NEW-VAL", :row 35} {:arglist-strs ["[type-name & fields]"], :end-row 49, :filename "cljs/pprint.cljc", :lang :cljs, :macro true, :name "deftype", :ns "cljs.pprint", :row 40} {:fixed-arities #{2}, :end-row 56, :private true, :ns "cljs.pprint", :name "parse-lb-options", :lang :cljs, :filename "cljs/pprint.cljc", :arglist-strs ["[opts body]"], :row 51} {:end-row 80, :ns "cljs.pprint", :name "pprint-logical-block", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Execute the body as a pretty printing logical block with output to *out* which\n  must be a pretty printing writer. When used from pprint or cl-format, this can be\n  assumed.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Before the body, the caller can optionally specify options: :prefix, :per-line-prefix\n  and :suffix.", :row 58} {:arglist-strs ["[env form]"], :end-row 88, :filename "cljs/pprint.cljc", :fixed-arities #{2}, :lang :cljs, :name "macroexpand", :ns "cljs.pprint", :row 83} {:fixed-arities #{3}, :end-row 100, :private true, :ns "cljs.pprint", :name "pll-mod-body", :lang :cljs, :filename "cljs/pprint.cljc", :arglist-strs ["[env var-sym body]"], :row 90} {:end-row 111, :ns "cljs.pprint", :name "print-length-loop", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "A version of loop that iterates at most *print-length* times. This is designed\n  for use in pretty-printer dispatch functions.", :row 102} {:fixed-arities #{1}, :end-row 119, :private true, :ns "cljs.pprint", :name "process-directive-table-element", :lang :cljs, :filename "cljs/pprint.cljc", :arglist-strs ["[[char params flags bracket-info & generator-fn]]"], :row 113} {:end-row 125, :private true, :ns "cljs.pprint", :name "defdirectives", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[& directives]"], :row 121} {:fixed-arities #{1}, :end-row 141, :ns "cljs.pprint", :name "formatter", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning\noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.", :row 127} {:fixed-arities #{1}, :end-row 155, :ns "cljs.pprint", :name "formatter-out", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.", :row 143} {:end-row 161, :ns "cljs.pprint", :name "with-pprint-dispatch", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[function & body]"], :doc "Execute body with the pretty print dispatch function bound to function.", :row 157} {:fixed-arities #{0}, :end-row 167, :ns "cljs.pprint", :name "pp", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[]"], :doc "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).", :row 163} {:arglist-strs ["[& more]"], :end-row 26, :filename "cljs/pprint.cljs", :name "print", :ns "cljs.pprint", :private true, :row 25} {:arglist-strs ["[& more]"], :end-row 30, :filename "cljs/pprint.cljs", :name "println", :ns "cljs.pprint", :private true, :row 28} {:arglist-strs ["[c]"], :end-row 42, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "print-char", :ns "cljs.pprint", :private true, :row 32} {:arglist-strs ["[& more]"], :end-row 45, :filename "cljs/pprint.cljs", :name "pr", :ns "cljs.pprint", :private true, :row 44} {:arglist-strs ["[& more]"], :end-row 49, :filename "cljs/pprint.cljs", :name "prn", :ns "cljs.pprint", :private true, :row 47} {:arglist-strs ["[n]"], :doc "Returns true if n is an float.", :end-row 61, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "float?", :ns "cljs.pprint", :row 55} {:arglist-strs ["[c]"], :doc "Convert char to int", :end-row 69, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "char-code", :ns "cljs.pprint", :row 63} {:arglist-strs ["[func initial-context lis]"], :end-row 84, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "map-passing-context", :ns "cljs.pprint", :private true, :row 75} {:arglist-strs ["[func initial-context]"], :end-row 92, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "consume", :ns "cljs.pprint", :private true, :row 86} {:arglist-strs ["[func initial-context]"], :end-row 100, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "consume-while", :ns "cljs.pprint", :private true, :row 94} {:arglist-strs ["[m]"], :end-row 107, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "unzip-map", :ns "cljs.pprint", :private true, :row 102} {:arglist-strs ["[m v1]"], :end-row 111, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "tuple-map", :ns "cljs.pprint", :private true, :row 109} {:arglist-strs ["[s c]"], :end-row 122, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "rtrim", :ns "cljs.pprint", :private true, :row 113} {:arglist-strs ["[s c]"], :end-row 132, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "ltrim", :ns "cljs.pprint", :private true, :row 124} {:arglist-strs ["[aseq val]"], :end-row 142, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "prefix-count", :ns "cljs.pprint", :private true, :row 134} {:end-row 146, :filename "cljs/pprint.cljs", :name "IPrettyFlush", :ns "cljs.pprint", :row 145} {:arglist-strs ["[pp]"], :end-row 146, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "-ppflush", :ns "cljs.pprint", :row 146} {:end-row 152, :filename "cljs/pprint.cljs", :name "*default-page-width*", :ns "cljs.pprint", :private true, :row 152} {:arglist-strs ["[this sym]"], :end-row 155, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "get-field", :ns "cljs.pprint", :private true, :row 154} {:arglist-strs ["[this sym new-val]"], :end-row 158, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "set-field", :ns "cljs.pprint", :private true, :row 157} {:arglist-strs ["[this]"], :end-row 161, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-column", :ns "cljs.pprint", :private true, :row 160} {:arglist-strs ["[this]"], :end-row 164, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-line", :ns "cljs.pprint", :private true, :row 163} {:arglist-strs ["[this]"], :end-row 167, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-max-column", :ns "cljs.pprint", :private true, :row 166} {:arglist-strs ["[this new-max]"], :end-row 171, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "set-max-column", :ns "cljs.pprint", :private true, :row 169} {:arglist-strs ["[this]"], :end-row 174, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-writer", :ns "cljs.pprint", :private true, :row 173} {:arglist-strs ["[this c]"], :end-row 183, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "c-write-char", :ns "cljs.pprint", :private true, :row 177} {:arglist-strs ["[writer]" "[writer max-columns]"], :end-row 215, :filename "cljs/pprint.cljs", :fixed-arities #{1 2}, :name "column-writer", :ns "cljs.pprint", :private true, :row 185} {:end-row 225, :filename "cljs/pprint.cljs", :name "get-miser-width", :ns "cljs.pprint", :row 225} {:end-row 235, :filename "cljs/pprint.cljs", :name "logical-block", :ns "cljs.pprint", :private true, :row 231} {:arglist-strs ["[parent section start-col indent done-nl intra-block-nl prefix per-line-prefix suffix logical-block-callback]"], :end-row 235, :filename "cljs/pprint.cljs", :fixed-arities #{10}, :name "->logical-block", :ns "cljs.pprint", :private true, :row 231} {:arglist-strs ["[m]"], :end-row 235, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "map->logical-block", :ns "cljs.pprint", :private true, :row 231} {:arglist-strs ["[parent child]"], :end-row 242, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "ancestor?", :ns "cljs.pprint", :private true, :row 237} {:arglist-strs ["[l]"], :end-row 248, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "buffer-length", :ns "cljs.pprint", :private true, :row 244} {:arglist-strs ["[]"], :end-row 262, :filename "cljs/pprint.cljs", :fixed-arities #{0}, :name "pp-newline", :ns "cljs.pprint", :private true, :row 262} {:end-row 264, :filename "cljs/pprint.cljs", :name "emit-nl", :ns "cljs.pprint", :row 264} {:end-row 266, :filename "cljs/pprint.cljs", :name "write-token", :ns "cljs.pprint", :private true, :row 266} {:arglist-strs ["[this tokens force-trailing-whitespace]"], :end-row 312, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "write-tokens", :ns "cljs.pprint", :private true, :row 302} {:arglist-strs ["[this tokens]"], :end-row 323, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "tokens-fit?", :ns "cljs.pprint", :private true, :row 319} {:arglist-strs ["[this lb section]"], :end-row 327, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "linear-nl?", :ns "cljs.pprint", :private true, :row 325} {:arglist-strs ["[this lb section]"], :end-row 334, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "miser-nl?", :ns "cljs.pprint", :private true, :row 329} {:end-row 336, :filename "cljs/pprint.cljs", :name "emit-nl?", :ns "cljs.pprint", :private true, :row 336} {:arglist-strs ["[buffer]"], :end-row 364, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-section", :ns "cljs.pprint", :private true, :row 359} {:arglist-strs ["[buffer]"], :end-row 372, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-sub-section", :ns "cljs.pprint", :private true, :row 366} {:arglist-strs ["[lb]"], :end-row 381, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "update-nl-state", :ns "cljs.pprint", :private true, :row 374} {:arglist-strs ["[this nl]"], :end-row 392, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "emit-nl", :ns "cljs.pprint", :private true, :row 383} {:arglist-strs ["[tokens]"], :end-row 396, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "split-at-newline", :ns "cljs.pprint", :private true, :row 394} {:arglist-strs ["[this tokens]"], :end-row 422, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "write-token-string", :ns "cljs.pprint", :private true, :row 400} {:arglist-strs ["[this]"], :end-row 430, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "write-line", :ns "cljs.pprint", :private true, :row 424} {:arglist-strs ["[this token]"], :end-row 437, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "add-to-buffer", :ns "cljs.pprint", :private true, :row 434} {:arglist-strs ["[this]"], :end-row 445, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "write-buffered-output", :ns "cljs.pprint", :private true, :row 440} {:arglist-strs ["[this]"], :end-row 450, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "write-white-space", :ns "cljs.pprint", :private true, :row 447} {:arglist-strs ["[this s]"], :end-row 477, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "write-initial-lines", :ns "cljs.pprint", :private true, :row 454} {:arglist-strs ["[this c]"], :end-row 489, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "p-write-char", :ns "cljs.pprint", :private true, :row 479} {:arglist-strs ["[writer max-columns miser-width]"], :end-row 546, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "pretty-writer", :ns "cljs.pprint", :private true, :row 495} {:arglist-strs ["[this prefix per-line-prefix suffix]"], :end-row 570, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "start-block", :ns "cljs.pprint", :private true, :row 552} {:arglist-strs ["[this]"], :end-row 585, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "end-block", :ns "cljs.pprint", :private true, :row 572} {:arglist-strs ["[this type]"], :end-row 590, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "nl", :ns "cljs.pprint", :private true, :row 587} {:arglist-strs ["[this relative-to offset]"], :end-row 602, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "indent", :ns "cljs.pprint", :private true, :row 592} {:arglist-strs ["[this]"], :end-row 605, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-miser-width", :ns "cljs.pprint", :private true, :row 604} {:doc "Bind to true if you want write to use pretty printing", :end-row 618, :filename "cljs/pprint.cljs", :name "*print-pretty*", :ns "cljs.pprint", :row 616} {:doc "The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify.", :end-row 624, :filename "cljs/pprint.cljs", :name "*print-pprint-dispatch*", :ns "cljs.pprint", :row 620} {:doc "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines.", :end-row 631, :filename "cljs/pprint.cljs", :name "*print-right-margin*", :ns "cljs.pprint", :row 626} {:doc "The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting.", :end-row 638, :filename "cljs/pprint.cljs", :name "*print-miser-width*", :ns "cljs.pprint", :row 633} {:doc "Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)", :end-row 644, :filename "cljs/pprint.cljs", :name "*print-lines*", :ns "cljs.pprint", :private true, :row 641} {:doc "Mark circular structures (N.B. This is not yet used)", :end-row 650, :filename "cljs/pprint.cljs", :name "*print-circle*", :ns "cljs.pprint", :private true, :row 647} {:doc "Mark repeated structures rather than repeat them (N.B. This is not yet used)", :end-row 656, :filename "cljs/pprint.cljs", :name "*print-shared*", :ns "cljs.pprint", :private true, :row 653} {:doc "Don't print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions", :end-row 662, :filename "cljs/pprint.cljs", :name "*print-suppress-namespaces*", :ns "cljs.pprint", :row 658} {:doc "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* ", :end-row 671, :filename "cljs/pprint.cljs", :name "*print-radix*", :ns "cljs.pprint", :row 666} {:doc "The base to use for printing integers and rationals.", :end-row 676, :filename "cljs/pprint.cljs", :name "*print-base*", :ns "cljs.pprint", :row 673} {:end-row 683, :filename "cljs/pprint.cljs", :name "*current-level*", :ns "cljs.pprint", :private true, :row 683} {:end-row 685, :filename "cljs/pprint.cljs", :name "*current-length*", :ns "cljs.pprint", :private true, :row 685} {:end-row 691, :filename "cljs/pprint.cljs", :name "format-simple-number", :ns "cljs.pprint", :row 691} {:arglist-strs ["[t m]"], :end-row 716, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "table-ize", :ns "cljs.pprint", :private true, :row 713} {:fixed-arities #{1}, :end-row 720, :private true, :ns "cljs.pprint", :name "pretty-writer?", :filename "cljs/pprint.cljs", :arglist-strs ["[x]"], :doc "Return true iff x is a PrettyWriter", :row 718} {:fixed-arities #{3}, :end-row 725, :private true, :ns "cljs.pprint", :name "make-pretty-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[base-writer right-margin miser-width]"], :doc "Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width", :row 722} {:arglist-strs ["[object]"], :doc "Write an object to *out* subject to the current bindings of the printer control\nvariables. Use the kw-args argument to override individual variables for this call (and\nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that\nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. ", :end-row 749, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "write-out", :ns "cljs.pprint", :row 727} {:arglist-strs ["[object & kw-args]"], :doc "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n", :end-row 812, :filename "cljs/pprint.cljs", :name "write", :ns "cljs.pprint", :row 751} {:arglist-strs ["[object]" "[object writer]"], :end-row 825, :filename "cljs/pprint.cljs", :fixed-arities #{1 2}, :name "pprint", :ns "cljs.pprint", :row 814} {:arglist-strs ["[function]"], :end-row 830, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "set-pprint-dispatch", :ns "cljs.pprint", :row 827} {:arglist-strs ["[arg choices]"], :end-row 839, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "check-enumerated-arg", :ns "cljs.pprint", :private true, :row 836} {:arglist-strs ["[]"], :end-row 842, :filename "cljs/pprint.cljs", :fixed-arities #{0}, :name "level-exceeded", :ns "cljs.pprint", :private true, :row 841} {:arglist-strs ["[kind]"], :doc "Print a conditional newline to a pretty printing stream. kind specifies if the\n  newline is :linear, :miser, :fill, or :mandatory.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Output is sent to *out* which must be a pretty printing writer.", :end-row 853, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-newline", :ns "cljs.pprint", :row 844} {:arglist-strs ["[relative-to n]"], :doc "Create an indent at this point in the pretty printing stream. This defines how\nfollowing lines are indented. relative-to can be either :block or :current depending\nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", :end-row 866, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "pprint-indent", :ns "cljs.pprint", :row 855} {:arglist-strs ["[kind colnum colinc]"], :doc "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative.\n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.", :end-row 884, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "pprint-tab", :ns "cljs.pprint", :row 869} {:end-row 891, :filename "cljs/pprint.cljs", :name "compile-format", :ns "cljs.pprint", :row 891} {:end-row 892, :filename "cljs/pprint.cljs", :name "execute-format", :ns "cljs.pprint", :row 892} {:end-row 893, :filename "cljs/pprint.cljs", :name "init-navigator", :ns "cljs.pprint", :row 893} {:arglist-strs ["[writer format-in & args]"], :doc "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It\nsupports sophisticated formatting of structured data.\n\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\nto a string, format-in is the format control string and the remaining arguments\nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives'\ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\"\n                   (count results) results))\n\nPrints via *print-fn*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \"Common Lisp the\nLanguage, 2nd edition\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\nand in the Common Lisp HyperSpec at\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm", :end-row 931, :filename "cljs/pprint.cljs", :name "cl-format", :ns "cljs.pprint", :row 896} {:end-row 933, :filename "cljs/pprint.cljs", :name "*format-str*", :ns "cljs.pprint", :private true, :row 933} {:arglist-strs ["[message offset]"], :end-row 938, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "format-error", :ns "cljs.pprint", :private true, :row 935} {:end-row 947, :filename "cljs/pprint.cljs", :name "arg-navigator", :ns "cljs.pprint", :private true, :row 946} {:arglist-strs ["[seq rest pos]"], :end-row 947, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "->arg-navigator", :ns "cljs.pprint", :private true, :row 946} {:arglist-strs ["[m]"], :end-row 947, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "map->arg-navigator", :ns "cljs.pprint", :private true, :row 946} {:fixed-arities #{1}, :end-row 954, :private true, :ns "cljs.pprint", :name "init-navigator", :filename "cljs/pprint.cljs", :arglist-strs ["[s]"], :doc "Create a new arg-navigator from the sequence with the position set to 0", :row 949} {:arglist-strs ["[navigator]"], :end-row 961, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "next-arg", :ns "cljs.pprint", :private true, :row 957} {:arglist-strs ["[navigator]"], :end-row 967, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "next-arg-or-nil", :ns "cljs.pprint", :private true, :row 963} {:arglist-strs ["[navigator]"], :end-row 975, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-format-arg", :ns "cljs.pprint", :private true, :row 970} {:end-row 977, :filename "cljs/pprint.cljs", :name "relative-reposition", :ns "cljs.pprint", :row 977} {:arglist-strs ["[navigator position]"], :end-row 982, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "absolute-reposition", :ns "cljs.pprint", :private true, :row 979} {:arglist-strs ["[navigator position]"], :end-row 988, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "relative-reposition", :ns "cljs.pprint", :private true, :row 984} {:end-row 991, :filename "cljs/pprint.cljs", :name "compiled-directive", :ns "cljs.pprint", :private true, :row 990} {:arglist-strs ["[func def params offset]"], :end-row 991, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "->compiled-directive", :ns "cljs.pprint", :private true, :row 990} {:arglist-strs ["[m]"], :end-row 991, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "map->compiled-directive", :ns "cljs.pprint", :private true, :row 990} {:arglist-strs ["[[param [raw-val offset]] navigator]"], :end-row 1015, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "realize-parameter", :ns "cljs.pprint", :private true, :row 1001} {:arglist-strs ["[parameter-map navigator]"], :end-row 1020, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "realize-parameter-list", :ns "cljs.pprint", :private true, :row 1017} {:end-row 1030, :filename "cljs/pprint.cljs", :name "opt-base-str", :ns "cljs.pprint", :row 1030} {:end-row 1033, :filename "cljs/pprint.cljs", :name "special-radix-markers", :ns "cljs.pprint", :private true, :row 1032} {:arglist-strs ["[n]"], :end-row 1043, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "format-simple-number", :ns "cljs.pprint", :private true, :row 1035} {:arglist-strs ["[print-func params arg-navigator offsets]"], :end-row 1061, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "format-ascii", :ns "cljs.pprint", :private true, :row 1045} {:fixed-arities #{1}, :end-row 1076, :private true, :ns "cljs.pprint", :name "integral?", :filename "cljs/pprint.cljs", :arglist-strs ["[x]"], :doc "returns true if a number is actually an integer (that is, has no fractional part)", :row 1068} {:fixed-arities #{2}, :end-row 1086, :private true, :ns "cljs.pprint", :name "remainders", :filename "cljs/pprint.cljs", :arglist-strs ["[base val]"], :doc "Return the list of remainders (essentially the 'digits') of val in the given base", :row 1078} {:fixed-arities #{2}, :end-row 1102, :private true, :ns "cljs.pprint", :name "base-str", :filename "cljs/pprint.cljs", :arglist-strs ["[base val]"], :doc "Return val as a string in the given base", :row 1090} {:end-row 1106, :filename "cljs/pprint.cljs", :name "javascript-base-formats", :ns "cljs.pprint", :private true, :row 1105} {:fixed-arities #{2}, :end-row 1111, :private true, :ns "cljs.pprint", :name "opt-base-str", :filename "cljs/pprint.cljs", :arglist-strs ["[base val]"], :doc "Return val as a string in the given base. No cljs format, so no improved performance.", :row 1108} {:arglist-strs ["[unit lis]"], :end-row 1116, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "group-by*", :ns "cljs.pprint", :private true, :row 1113} {:arglist-strs ["[base params arg-navigator offsets]"], :end-row 1142, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "format-integer", :ns "cljs.pprint", :private true, :row 1118} {:end-row 1152, :filename "cljs/pprint.cljs", :name "english-cardinal-units", :ns "cljs.pprint", :private true, :row 1148} {:end-row 1158, :filename "cljs/pprint.cljs", :name "english-ordinal-units", :ns "cljs.pprint", :private true, :row 1154} {:end-row 1162, :filename "cljs/pprint.cljs", :name "english-cardinal-tens", :ns "cljs.pprint", :private true, :row 1160} {:end-row 1167, :filename "cljs/pprint.cljs", :name "english-ordinal-tens", :ns "cljs.pprint", :private true, :row 1164} {:end-row 1179, :filename "cljs/pprint.cljs", :name "english-scale-numbers", :ns "cljs.pprint", :private true, :row 1173} {:fixed-arities #{1}, :end-row 1197, :private true, :ns "cljs.pprint", :name "format-simple-cardinal", :filename "cljs/pprint.cljs", :arglist-strs ["[num]"], :doc "Convert a number less than 1000 to a cardinal english string", :row 1181} {:fixed-arities #{2}, :end-row 1220, :private true, :ns "cljs.pprint", :name "add-english-scales", :filename "cljs/pprint.cljs", :arglist-strs ["[parts offset]"], :doc "Take a sequence of parts, add scale numbers (e.g., million) and combine into a string\n  offset is a factor of 10^3 to multiply by", :row 1199} {:arglist-strs ["[params navigator offsets]"], :end-row 1237, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-cardinal-english", :ns "cljs.pprint", :private true, :row 1222} {:fixed-arities #{1}, :end-row 1259, :private true, :ns "cljs.pprint", :name "format-simple-ordinal", :filename "cljs/pprint.cljs", :arglist-strs ["[num]"], :doc "Convert a number less than 1000 to a ordinal english string\n  Note this should only be used for the last one in the sequence", :row 1239} {:arglist-strs ["[params navigator offsets]"], :end-row 1291, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-ordinal-english", :ns "cljs.pprint", :private true, :row 1261} {:end-row 1302, :filename "cljs/pprint.cljs", :name "old-roman-table", :ns "cljs.pprint", :private true, :row 1297} {:end-row 1309, :filename "cljs/pprint.cljs", :name "new-roman-table", :ns "cljs.pprint", :private true, :row 1304} {:fixed-arities #{4}, :end-row 1333, :private true, :ns "cljs.pprint", :name "format-roman", :filename "cljs/pprint.cljs", :arglist-strs ["[table params navigator offsets]"], :doc "Format a roman numeral using the specified look-up table", :row 1311} {:arglist-strs ["[params navigator offsets]"], :end-row 1336, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-old-roman", :ns "cljs.pprint", :private true, :row 1335} {:arglist-strs ["[params navigator offsets]"], :end-row 1339, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-new-roman", :ns "cljs.pprint", :private true, :row 1338} {:end-row 1346, :filename "cljs/pprint.cljs", :name "special-chars", :ns "cljs.pprint", :private true, :row 1345} {:arglist-strs ["[params navigator offsets]"], :end-row 1360, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "pretty-character", :ns "cljs.pprint", :private true, :row 1348} {:arglist-strs ["[params navigator offsets]"], :end-row 1368, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "readable-character", :ns "cljs.pprint", :private true, :row 1362} {:arglist-strs ["[params navigator offsets]"], :end-row 1373, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "plain-character", :ns "cljs.pprint", :private true, :row 1370} {:arglist-strs ["[context]"], :end-row 1379, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "abort?", :ns "cljs.pprint", :private true, :row 1377} {:arglist-strs ["[format args base-args]"], :end-row 1393, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "execute-sub-format", :ns "cljs.pprint", :private true, :row 1382} {:fixed-arities #{1}, :end-row 1412, :private true, :ns "cljs.pprint", :name "float-parts-base", :filename "cljs/pprint.cljs", :arglist-strs ["[f]"], :doc "Produce string parts for the mantissa (normalize 1-9) and exponent", :row 1400} {:fixed-arities #{1}, :end-row 1424, :private true, :ns "cljs.pprint", :name "float-parts", :filename "cljs/pprint.cljs", :arglist-strs ["[f]"], :doc "Take care of leading and trailing zeros in decomposed floats", :row 1414} {:fixed-arities #{1}, :end-row 1440, :private true, :ns "cljs.pprint", :name "inc-s", :filename "cljs/pprint.cljs", :arglist-strs ["[s]"], :doc "Assumption: The input string consists of one or more decimal digits,\n  and no other characters. Return a string containing one or more\n  decimal digits containing a decimal number one larger than the input\n  string. The output string will always be the same length as the input\n  string, or one character longer.", :row 1426} {:arglist-strs ["[m e d w]"], :end-row 1486, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "round-str", :ns "cljs.pprint", :private true, :row 1442} {:arglist-strs ["[m e d]"], :end-row 1496, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "expand-fixed", :ns "cljs.pprint", :private true, :row 1488} {:fixed-arities #{2}, :end-row 1504, :private true, :ns "cljs.pprint", :name "insert-decimal", :filename "cljs/pprint.cljs", :arglist-strs ["[m e]"], :doc "Insert the decimal point at the right spot in the number to match an exponent", :row 1498} {:arglist-strs ["[m e d]"], :end-row 1507, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "get-fixed", :ns "cljs.pprint", :private true, :row 1506} {:fixed-arities #{2}, :end-row 1514, :private true, :ns "cljs.pprint", :name "insert-scaled-decimal", :filename "cljs/pprint.cljs", :arglist-strs ["[m k]"], :doc "Insert the decimal point at the right spot in the number to match an exponent", :row 1509} {:arglist-strs ["[x]"], :end-row 1518, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "convert-ratio", :ns "cljs.pprint", :private true, :row 1517} {:arglist-strs ["[params navigator offsets]"], :end-row 1564, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "fixed-float", :ns "cljs.pprint", :private true, :row 1522} {:arglist-strs ["[params navigator offset]"], :end-row 1636, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "exponential-float", :ns "cljs.pprint", :private true, :row 1569} {:arglist-strs ["[params navigator offsets]"], :end-row 1662, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "general-float", :ns "cljs.pprint", :private true, :row 1643} {:arglist-strs ["[params navigator offsets]"], :end-row 1682, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "dollar-float", :ns "cljs.pprint", :private true, :row 1666} {:arglist-strs ["[params arg-navigator offsets]"], :end-row 1701, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "choice-conditional", :ns "cljs.pprint", :private true, :row 1692} {:arglist-strs ["[params arg-navigator offsets]"], :end-row 1712, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "boolean-conditional", :ns "cljs.pprint", :private true, :row 1704} {:arglist-strs ["[params arg-navigator offsets]"], :end-row 1724, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "check-arg-conditional", :ns "cljs.pprint", :private true, :row 1716} {:arglist-strs ["[params navigator offsets]"], :end-row 1754, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "iterate-sublist", :ns "cljs.pprint", :private true, :row 1733} {:arglist-strs ["[params navigator offsets]"], :end-row 1777, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "iterate-list-of-sublists", :ns "cljs.pprint", :private true, :row 1758} {:arglist-strs ["[params navigator offsets]"], :end-row 1801, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "iterate-main-list", :ns "cljs.pprint", :private true, :row 1781} {:arglist-strs ["[params navigator offsets]"], :end-row 1821, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "iterate-main-sublists", :ns "cljs.pprint", :private true, :row 1805} {:end-row 1836, :filename "cljs/pprint.cljs", :name "format-logical-block", :ns "cljs.pprint", :row 1836} {:end-row 1837, :filename "cljs/pprint.cljs", :name "justify-clauses", :ns "cljs.pprint", :row 1837} {:arglist-strs ["[params navigator offsets]"], :end-row 1842, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "logical-block-or-justify", :ns "cljs.pprint", :private true, :row 1839} {:arglist-strs ["[clauses navigator base-navigator]"], :end-row 1861, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "render-clauses", :ns "cljs.pprint", :private true, :row 1848} {:arglist-strs ["[params navigator offsets]"], :end-row 1909, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "justify-clauses", :ns "cljs.pprint", :private true, :row 1864} {:fixed-arities #{1}, :end-row 1938, :private true, :ns "cljs.pprint", :name "downcase-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, converting all characters to lower case", :row 1919} {:fixed-arities #{1}, :end-row 1959, :private true, :ns "cljs.pprint", :name "upcase-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, converting all characters to upper case", :row 1940} {:fixed-arities #{2}, :end-row 1982, :private true, :ns "cljs.pprint", :name "capitalize-string", :filename "cljs/pprint.cljs", :arglist-strs ["[s first?]"], :doc "Capitalizes the words in a string. If first? is false, don't capitalize the\n                                      first character of the string even if it's a letter.", :row 1961} {:fixed-arities #{1}, :end-row 2008, :private true, :ns "cljs.pprint", :name "capitalize-word-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, capitalizing all words", :row 1984} {:fixed-arities #{1}, :end-row 2043, :private true, :ns "cljs.pprint", :name "init-cap-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, capitalizing the first word", :row 2010} {:arglist-strs ["[make-writer params navigator offsets]"], :end-row 2048, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "modify-case", :ns "cljs.pprint", :private true, :row 2045} {:arglist-strs ["[writer]"], :doc "Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be\npreserved across calls, you will want to wrap them with this.\n\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \"~4D~7,vT\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1\n       2      4       8\n       3      9      27\n       4     16      64\n       5     25     125\n       6     36     216\n       7     49     343\n       8     64     512\n       9     81     729\n      10    100    1000", :end-row 2090, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-pretty-writer", :ns "cljs.pprint", :row 2055} {:arglist-strs ["[]"], :doc "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.", :end-row 2103, :filename "cljs/pprint.cljs", :fixed-arities #{0}, :name "fresh-line", :ns "cljs.pprint", :row 2096} {:arglist-strs ["[params navigator offsets]"], :end-row 2114, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "absolute-tabulation", :ns "cljs.pprint", :private true, :row 2105} {:arglist-strs ["[params navigator offsets]"], :end-row 2123, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "relative-tabulation", :ns "cljs.pprint", :private true, :row 2116} {:arglist-strs ["[params navigator offsets]"], :end-row 2147, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-logical-block", :ns "cljs.pprint", :private true, :row 2131} {:arglist-strs ["[params navigator offsets]"], :end-row 2152, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "set-indent", :ns "cljs.pprint", :private true, :row 2149} {:arglist-strs ["[params navigator offsets]"], :end-row 2160, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "conditional-newline", :ns "cljs.pprint", :private true, :row 2155} {:end-row 2450, :filename "cljs/pprint.cljs", :name "param-pattern", :ns "cljs.pprint", :private true, :row 2449} {:end-row 2453, :filename "cljs/pprint.cljs", :name "special-params", :ns "cljs.pprint", :private true, :row 2452} {:arglist-strs ["[[s offset saw-comma]]"], :end-row 2467, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "extract-param", :ns "cljs.pprint", :private true, :row 2455} {:arglist-strs ["[s offset]"], :end-row 2470, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "extract-params", :ns "cljs.pprint", :private true, :row 2469} {:fixed-arities #{1}, :end-row 2482, :private true, :ns "cljs.pprint", :name "translate-param", :filename "cljs/pprint.cljs", :arglist-strs ["[[p offset]]"], :doc "Translate the string representation of a param to the internalized\n                                      representation", :row 2472} {:end-row 2485, :filename "cljs/pprint.cljs", :name "flag-defs", :ns "cljs.pprint", :private true, :row 2484} {:arglist-strs ["[s offset]"], :end-row 2500, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "extract-flags", :ns "cljs.pprint", :private true, :row 2487} {:arglist-strs ["[def flags]"], :end-row 2513, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "check-flags", :ns "cljs.pprint", :private true, :row 2502} {:fixed-arities #{4}, :end-row 2543, :private true, :ns "cljs.pprint", :name "map-params", :filename "cljs/pprint.cljs", :arglist-strs ["[def params flags offset]"], :doc "Takes a directive definition and the list of actual parameters and\na map of flags and returns a map of the parameters and flags with defaults\nfilled in. We check to make sure that there are the right types and number\nof parameters as well.", :row 2515} {:arglist-strs ["[s offset]"], :end-row 2563, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "compile-directive", :ns "cljs.pprint", :private true, :row 2545} {:arglist-strs ["[s offset]"], :end-row 2566, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "compile-raw-string", :ns "cljs.pprint", :private true, :row 2565} {:arglist-strs ["[this]"], :end-row 2568, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "right-bracket", :ns "cljs.pprint", :private true, :row 2568} {:arglist-strs ["[this]"], :end-row 2570, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "separator?", :ns "cljs.pprint", :private true, :row 2570} {:arglist-strs ["[this]"], :end-row 2574, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "else-separator?", :ns "cljs.pprint", :private true, :row 2572} {:end-row 2576, :filename "cljs/pprint.cljs", :name "collect-clauses", :ns "cljs.pprint", :row 2576} {:arglist-strs ["[this remainder]"], :end-row 2585, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "process-bracket", :ns "cljs.pprint", :private true, :row 2578} {:arglist-strs ["[bracket-info offset remainder]"], :end-row 2609, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "process-clause", :ns "cljs.pprint", :private true, :row 2587} {:arglist-strs ["[bracket-info offset remainder]"], :end-row 2658, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "collect-clauses", :ns "cljs.pprint", :private true, :row 2611} {:fixed-arities #{1}, :end-row 2673, :private true, :ns "cljs.pprint", :name "process-nesting", :filename "cljs/pprint.cljs", :arglist-strs ["[format]"], :doc "Take a linearly compiled format and process the bracket directives to give it\n   the appropriate tree structure", :row 2660} {:fixed-arities #{1}, :end-row 2693, :private true, :ns "cljs.pprint", :name "compile-format", :filename "cljs/pprint.cljs", :arglist-strs ["[format-str]"], :doc "Compiles format-str into a compiled format which can be used as an argument\nto cl-format just like a plain format string. Use this function for improved\nperformance when you're using the same format string repeatedly", :row 2675} {:fixed-arities #{1}, :end-row 2706, :private true, :ns "cljs.pprint", :name "needs-pretty", :filename "cljs/pprint.cljs", :arglist-strs ["[format]"], :doc "determine whether a given compiled format has any directives that depend on the\ncolumn number or pretty printing", :row 2695} {:fixed-arities #{3 2}, :end-row 2754, :private true, :ns "cljs.pprint", :name "execute-format", :filename "cljs/pprint.cljs", :arglist-strs ["[stream format args]" "[format args]"], :doc "Executes the format with the arguments.", :row 2720} {:end-row 2758, :filename "cljs/pprint.cljs", :name "cached-compile", :ns "cljs.pprint", :private true, :row 2758} {:fixed-arities #{3}, :end-row 2767, :private true, :ns "cljs.pprint", :name "use-method", :filename "cljs/pprint.cljs", :arglist-strs ["[multifn dispatch-val func]"], :doc "Installs a function as a new method of multimethod associated with dispatch-value. ", :row 2764} {:end-row 2795, :filename "cljs/pprint.cljs", :name "reader-macros", :ns "cljs.pprint", :private true, :row 2789} {:arglist-strs ["[alis]"], :end-row 2802, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-reader-macro", :ns "cljs.pprint", :private true, :row 2797} {:arglist-strs ["[alis]"], :end-row 2822, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-simple-list", :ns "cljs.pprint", :private true, :row 2814} {:arglist-strs ["[alis]"], :end-row 2826, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-list", :ns "cljs.pprint", :private true, :row 2824} {:arglist-strs ["[avec]"], :end-row 2837, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-vector", :ns "cljs.pprint", :private true, :row 2829} {:end-row 2839, :filename "cljs/pprint.cljs", :name "pprint-array", :ns "cljs.pprint", :private true, :row 2839} {:arglist-strs ["[amap]"], :end-row 2861, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-map", :ns "cljs.pprint", :private true, :row 2842} {:arglist-strs ["[obj]"], :end-row 2865, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-simple-default", :ns "cljs.pprint", :private true, :row 2863} {:end-row 2867, :filename "cljs/pprint.cljs", :name "pprint-set", :ns "cljs.pprint", :row 2867} {:end-row 2871, :filename "cljs/pprint.cljs", :name "type-map", :ns "cljs.pprint", :private true, :row 2869} {:fixed-arities #{1}, :end-row 2878, :private true, :ns "cljs.pprint", :name "map-ref-type", :filename "cljs/pprint.cljs", :arglist-strs ["[name]"], :doc "Map ugly type names to something simpler", :row 2873} {:arglist-strs ["[o]"], :end-row 2889, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-ideref", :ns "cljs.pprint", :private true, :row 2880} {:end-row 2891, :filename "cljs/pprint.cljs", :name "pprint-pqueue", :ns "cljs.pprint", :private true, :row 2891} {:arglist-strs ["[obj]"], :end-row 2903, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "type-dispatcher", :ns "cljs.pprint", :private true, :row 2893} {:doc "The pretty print dispatch function for simple data structure format.", :end-row 2907, :filename "cljs/pprint.cljs", :name "simple-dispatch", :ns "cljs.pprint", :row 2905} {:end-row 2922, :filename "cljs/pprint.cljs", :name "pprint-simple-code-list", :ns "cljs.pprint", :row 2922} {:fixed-arities #{1}, :end-row 2935, :private true, :ns "cljs.pprint", :name "brackets", :filename "cljs/pprint.cljs", :arglist-strs ["[form]"], :doc "Figure out which kind of brackets to use", :row 2930} {:fixed-arities #{1}, :end-row 2969, :private true, :ns "cljs.pprint", :name "pprint-ns-reference", :filename "cljs/pprint.cljs", :arglist-strs ["[reference]"], :doc "Pretty print a single reference (import, use, etc.) from a namespace decl", :row 2937} {:fixed-arities #{1}, :end-row 2995, :private true, :ns "cljs.pprint", :name "pprint-ns", :filename "cljs/pprint.cljs", :arglist-strs ["[alis]"], :doc "The pretty print dispatch chunk for the ns macro", :row 2971} {:end-row 3002, :filename "cljs/pprint.cljs", :name "pprint-hold-first", :ns "cljs.pprint", :private true, :row 3002} {:arglist-strs ["[alis has-doc-str?]"], :end-row 3015, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "single-defn", :ns "cljs.pprint", :private true, :row 3009} {:arglist-strs ["[alis has-doc-str?]"], :end-row 3020, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "multi-defn", :ns "cljs.pprint", :private true, :row 3018} {:arglist-strs ["[alis]"], :end-row 3043, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-defn", :ns "cljs.pprint", :private true, :row 3024} {:arglist-strs ["[binding-vec]"], :end-row 3062, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-binding-form", :ns "cljs.pprint", :private true, :row 3049} {:arglist-strs ["[alis]"], :end-row 3072, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-let", :ns "cljs.pprint", :private true, :row 3064} {:end-row 3078, :filename "cljs/pprint.cljs", :name "pprint-if", :ns "cljs.pprint", :private true, :row 3078} {:arglist-strs ["[alis]"], :end-row 3098, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-cond", :ns "cljs.pprint", :private true, :row 3080} {:arglist-strs ["[alis]"], :end-row 3117, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-condp", :ns "cljs.pprint", :private true, :row 3100} {:end-row 3120, :filename "cljs/pprint.cljs", :name "*symbol-map*", :ns "cljs.pprint", :private true, :row 3120} {:arglist-strs ["[alis]"], :end-row 3134, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-anon-func", :ns "cljs.pprint", :private true, :row 3122} {:arglist-strs ["[alis]"], :end-row 3153, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-simple-code-list", :ns "cljs.pprint", :private true, :row 3144} {:arglist-strs ["[amap]"], :end-row 3162, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "two-forms", :ns "cljs.pprint", :private true, :row 3157} {:arglist-strs ["[amap]"], :end-row 3171, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "add-core-ns", :ns "cljs.pprint", :private true, :row 3164} {:end-row 3188, :filename "cljs/pprint.cljs", :name "*code-table*", :ns "cljs.pprint", :private true, :row 3173} {:arglist-strs ["[alis]"], :end-row 3194, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-code-list", :ns "cljs.pprint", :private true, :row 3190} {:arglist-strs ["[sym]"], :end-row 3201, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-code-symbol", :ns "cljs.pprint", :private true, :row 3196} {:doc "The pretty print dispatch function for pretty printing Clojure code.", :end-row 3207, :filename "cljs/pprint.cljs", :name "code-dispatch", :ns "cljs.pprint", :row 3203} {:arglist-strs ["[width s]"], :end-row 3300, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "add-padding", :ns "cljs.pprint", :private true, :row 3298} {:arglist-strs ["[ks rows]" "[rows]"], :doc "Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.", :end-row 3325, :filename "cljs/pprint.cljs", :fixed-arities #{1 2}, :name "print-table", :ns "cljs.pprint", :row 3302}]} {:end-row 12, :filename "cljs/pprint.cljc", :lang :cljs, :name "cljs.pprint", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[base-writer & body]"], :end-row 25, :filename "cljs/pprint.cljc", :lang :clj, :macro true, :name "with-pretty-writer", :ns "cljs.pprint", :row 18} {:fixed-arities #{1}, :end-row 31, :ns "cljs.pprint", :name "getf", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[sym]"], :doc "Get the value of the field a named by the argument (which should be a keyword).", :row 28} {:fixed-arities #{2}, :end-row 38, :ns "cljs.pprint", :name "setf", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[sym new-val]"], :doc "Set the value of the field SYM to NEW-VAL", :row 35} {:arglist-strs ["[type-name & fields]"], :end-row 49, :filename "cljs/pprint.cljc", :lang :clj, :macro true, :name "deftype", :ns "cljs.pprint", :row 40} {:fixed-arities #{2}, :end-row 56, :private true, :ns "cljs.pprint", :name "parse-lb-options", :lang :clj, :filename "cljs/pprint.cljc", :arglist-strs ["[opts body]"], :row 51} {:end-row 80, :ns "cljs.pprint", :name "pprint-logical-block", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Execute the body as a pretty printing logical block with output to *out* which\n  must be a pretty printing writer. When used from pprint or cl-format, this can be\n  assumed.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Before the body, the caller can optionally specify options: :prefix, :per-line-prefix\n  and :suffix.", :row 58} {:fixed-arities #{3}, :end-row 100, :private true, :ns "cljs.pprint", :name "pll-mod-body", :lang :clj, :filename "cljs/pprint.cljc", :arglist-strs ["[env var-sym body]"], :row 90} {:end-row 111, :ns "cljs.pprint", :name "print-length-loop", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "A version of loop that iterates at most *print-length* times. This is designed\n  for use in pretty-printer dispatch functions.", :row 102} {:fixed-arities #{1}, :end-row 119, :private true, :ns "cljs.pprint", :name "process-directive-table-element", :lang :clj, :filename "cljs/pprint.cljc", :arglist-strs ["[[char params flags bracket-info & generator-fn]]"], :row 113} {:end-row 125, :private true, :ns "cljs.pprint", :name "defdirectives", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[& directives]"], :row 121} {:fixed-arities #{1}, :end-row 141, :ns "cljs.pprint", :name "formatter", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning\noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.", :row 127} {:fixed-arities #{1}, :end-row 155, :ns "cljs.pprint", :name "formatter-out", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.", :row 143} {:end-row 161, :ns "cljs.pprint", :name "with-pprint-dispatch", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[function & body]"], :doc "Execute body with the pretty print dispatch function bound to function.", :row 157} {:fixed-arities #{0}, :end-row 167, :ns "cljs.pprint", :name "pp", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[]"], :doc "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).", :row 163} {:arglist-strs ["[base-writer & body]"], :end-row 25, :filename "cljs/pprint.cljc", :lang :cljs, :macro true, :name "with-pretty-writer", :ns "cljs.pprint", :row 18} {:fixed-arities #{1}, :end-row 31, :ns "cljs.pprint", :name "getf", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[sym]"], :doc "Get the value of the field a named by the argument (which should be a keyword).", :row 28} {:fixed-arities #{2}, :end-row 38, :ns "cljs.pprint", :name "setf", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[sym new-val]"], :doc "Set the value of the field SYM to NEW-VAL", :row 35} {:arglist-strs ["[type-name & fields]"], :end-row 49, :filename "cljs/pprint.cljc", :lang :cljs, :macro true, :name "deftype", :ns "cljs.pprint", :row 40} {:fixed-arities #{2}, :end-row 56, :private true, :ns "cljs.pprint", :name "parse-lb-options", :lang :cljs, :filename "cljs/pprint.cljc", :arglist-strs ["[opts body]"], :row 51} {:end-row 80, :ns "cljs.pprint", :name "pprint-logical-block", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Execute the body as a pretty printing logical block with output to *out* which\n  must be a pretty printing writer. When used from pprint or cl-format, this can be\n  assumed.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Before the body, the caller can optionally specify options: :prefix, :per-line-prefix\n  and :suffix.", :row 58} {:arglist-strs ["[env form]"], :end-row 88, :filename "cljs/pprint.cljc", :fixed-arities #{2}, :lang :cljs, :name "macroexpand", :ns "cljs.pprint", :row 83} {:fixed-arities #{3}, :end-row 100, :private true, :ns "cljs.pprint", :name "pll-mod-body", :lang :cljs, :filename "cljs/pprint.cljc", :arglist-strs ["[env var-sym body]"], :row 90} {:end-row 111, :ns "cljs.pprint", :name "print-length-loop", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "A version of loop that iterates at most *print-length* times. This is designed\n  for use in pretty-printer dispatch functions.", :row 102} {:fixed-arities #{1}, :end-row 119, :private true, :ns "cljs.pprint", :name "process-directive-table-element", :lang :cljs, :filename "cljs/pprint.cljc", :arglist-strs ["[[char params flags bracket-info & generator-fn]]"], :row 113} {:end-row 125, :private true, :ns "cljs.pprint", :name "defdirectives", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[& directives]"], :row 121} {:fixed-arities #{1}, :end-row 141, :ns "cljs.pprint", :name "formatter", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning\noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.", :row 127} {:fixed-arities #{1}, :end-row 155, :ns "cljs.pprint", :name "formatter-out", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.", :row 143} {:end-row 161, :ns "cljs.pprint", :name "with-pprint-dispatch", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[function & body]"], :doc "Execute body with the pretty print dispatch function bound to function.", :row 157} {:fixed-arities #{0}, :end-row 167, :ns "cljs.pprint", :name "pp", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[]"], :doc "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).", :row 163} {:arglist-strs ["[& more]"], :end-row 26, :filename "cljs/pprint.cljs", :name "print", :ns "cljs.pprint", :private true, :row 25} {:arglist-strs ["[& more]"], :end-row 30, :filename "cljs/pprint.cljs", :name "println", :ns "cljs.pprint", :private true, :row 28} {:arglist-strs ["[c]"], :end-row 42, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "print-char", :ns "cljs.pprint", :private true, :row 32} {:arglist-strs ["[& more]"], :end-row 45, :filename "cljs/pprint.cljs", :name "pr", :ns "cljs.pprint", :private true, :row 44} {:arglist-strs ["[& more]"], :end-row 49, :filename "cljs/pprint.cljs", :name "prn", :ns "cljs.pprint", :private true, :row 47} {:arglist-strs ["[n]"], :doc "Returns true if n is an float.", :end-row 61, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "float?", :ns "cljs.pprint", :row 55} {:arglist-strs ["[c]"], :doc "Convert char to int", :end-row 69, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "char-code", :ns "cljs.pprint", :row 63} {:arglist-strs ["[func initial-context lis]"], :end-row 84, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "map-passing-context", :ns "cljs.pprint", :private true, :row 75} {:arglist-strs ["[func initial-context]"], :end-row 92, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "consume", :ns "cljs.pprint", :private true, :row 86} {:arglist-strs ["[func initial-context]"], :end-row 100, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "consume-while", :ns "cljs.pprint", :private true, :row 94} {:arglist-strs ["[m]"], :end-row 107, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "unzip-map", :ns "cljs.pprint", :private true, :row 102} {:arglist-strs ["[m v1]"], :end-row 111, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "tuple-map", :ns "cljs.pprint", :private true, :row 109} {:arglist-strs ["[s c]"], :end-row 122, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "rtrim", :ns "cljs.pprint", :private true, :row 113} {:arglist-strs ["[s c]"], :end-row 132, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "ltrim", :ns "cljs.pprint", :private true, :row 124} {:arglist-strs ["[aseq val]"], :end-row 142, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "prefix-count", :ns "cljs.pprint", :private true, :row 134} {:end-row 146, :filename "cljs/pprint.cljs", :name "IPrettyFlush", :ns "cljs.pprint", :row 145} {:arglist-strs ["[pp]"], :end-row 146, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "-ppflush", :ns "cljs.pprint", :row 146} {:end-row 152, :filename "cljs/pprint.cljs", :name "*default-page-width*", :ns "cljs.pprint", :private true, :row 152} {:arglist-strs ["[this sym]"], :end-row 155, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "get-field", :ns "cljs.pprint", :private true, :row 154} {:arglist-strs ["[this sym new-val]"], :end-row 158, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "set-field", :ns "cljs.pprint", :private true, :row 157} {:arglist-strs ["[this]"], :end-row 161, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-column", :ns "cljs.pprint", :private true, :row 160} {:arglist-strs ["[this]"], :end-row 164, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-line", :ns "cljs.pprint", :private true, :row 163} {:arglist-strs ["[this]"], :end-row 167, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-max-column", :ns "cljs.pprint", :private true, :row 166} {:arglist-strs ["[this new-max]"], :end-row 171, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "set-max-column", :ns "cljs.pprint", :private true, :row 169} {:arglist-strs ["[this]"], :end-row 174, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-writer", :ns "cljs.pprint", :private true, :row 173} {:arglist-strs ["[this c]"], :end-row 183, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "c-write-char", :ns "cljs.pprint", :private true, :row 177} {:arglist-strs ["[writer]" "[writer max-columns]"], :end-row 215, :filename "cljs/pprint.cljs", :fixed-arities #{1 2}, :name "column-writer", :ns "cljs.pprint", :private true, :row 185} {:end-row 225, :filename "cljs/pprint.cljs", :name "get-miser-width", :ns "cljs.pprint", :row 225} {:end-row 235, :filename "cljs/pprint.cljs", :name "logical-block", :ns "cljs.pprint", :private true, :row 231} {:arglist-strs ["[parent section start-col indent done-nl intra-block-nl prefix per-line-prefix suffix logical-block-callback]"], :end-row 235, :filename "cljs/pprint.cljs", :fixed-arities #{10}, :name "->logical-block", :ns "cljs.pprint", :private true, :row 231} {:arglist-strs ["[m]"], :end-row 235, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "map->logical-block", :ns "cljs.pprint", :private true, :row 231} {:arglist-strs ["[parent child]"], :end-row 242, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "ancestor?", :ns "cljs.pprint", :private true, :row 237} {:arglist-strs ["[l]"], :end-row 248, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "buffer-length", :ns "cljs.pprint", :private true, :row 244} {:arglist-strs ["[]"], :end-row 262, :filename "cljs/pprint.cljs", :fixed-arities #{0}, :name "pp-newline", :ns "cljs.pprint", :private true, :row 262} {:end-row 264, :filename "cljs/pprint.cljs", :name "emit-nl", :ns "cljs.pprint", :row 264} {:end-row 266, :filename "cljs/pprint.cljs", :name "write-token", :ns "cljs.pprint", :private true, :row 266} {:arglist-strs ["[this tokens force-trailing-whitespace]"], :end-row 312, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "write-tokens", :ns "cljs.pprint", :private true, :row 302} {:arglist-strs ["[this tokens]"], :end-row 323, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "tokens-fit?", :ns "cljs.pprint", :private true, :row 319} {:arglist-strs ["[this lb section]"], :end-row 327, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "linear-nl?", :ns "cljs.pprint", :private true, :row 325} {:arglist-strs ["[this lb section]"], :end-row 334, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "miser-nl?", :ns "cljs.pprint", :private true, :row 329} {:end-row 336, :filename "cljs/pprint.cljs", :name "emit-nl?", :ns "cljs.pprint", :private true, :row 336} {:arglist-strs ["[buffer]"], :end-row 364, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-section", :ns "cljs.pprint", :private true, :row 359} {:arglist-strs ["[buffer]"], :end-row 372, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-sub-section", :ns "cljs.pprint", :private true, :row 366} {:arglist-strs ["[lb]"], :end-row 381, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "update-nl-state", :ns "cljs.pprint", :private true, :row 374} {:arglist-strs ["[this nl]"], :end-row 392, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "emit-nl", :ns "cljs.pprint", :private true, :row 383} {:arglist-strs ["[tokens]"], :end-row 396, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "split-at-newline", :ns "cljs.pprint", :private true, :row 394} {:arglist-strs ["[this tokens]"], :end-row 422, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "write-token-string", :ns "cljs.pprint", :private true, :row 400} {:arglist-strs ["[this]"], :end-row 430, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "write-line", :ns "cljs.pprint", :private true, :row 424} {:arglist-strs ["[this token]"], :end-row 437, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "add-to-buffer", :ns "cljs.pprint", :private true, :row 434} {:arglist-strs ["[this]"], :end-row 445, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "write-buffered-output", :ns "cljs.pprint", :private true, :row 440} {:arglist-strs ["[this]"], :end-row 450, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "write-white-space", :ns "cljs.pprint", :private true, :row 447} {:arglist-strs ["[this s]"], :end-row 477, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "write-initial-lines", :ns "cljs.pprint", :private true, :row 454} {:arglist-strs ["[this c]"], :end-row 489, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "p-write-char", :ns "cljs.pprint", :private true, :row 479} {:arglist-strs ["[writer max-columns miser-width]"], :end-row 546, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "pretty-writer", :ns "cljs.pprint", :private true, :row 495} {:arglist-strs ["[this prefix per-line-prefix suffix]"], :end-row 570, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "start-block", :ns "cljs.pprint", :private true, :row 552} {:arglist-strs ["[this]"], :end-row 585, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "end-block", :ns "cljs.pprint", :private true, :row 572} {:arglist-strs ["[this type]"], :end-row 590, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "nl", :ns "cljs.pprint", :private true, :row 587} {:arglist-strs ["[this relative-to offset]"], :end-row 602, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "indent", :ns "cljs.pprint", :private true, :row 592} {:arglist-strs ["[this]"], :end-row 605, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-miser-width", :ns "cljs.pprint", :private true, :row 604} {:doc "Bind to true if you want write to use pretty printing", :end-row 618, :filename "cljs/pprint.cljs", :name "*print-pretty*", :ns "cljs.pprint", :row 616} {:doc "The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify.", :end-row 624, :filename "cljs/pprint.cljs", :name "*print-pprint-dispatch*", :ns "cljs.pprint", :row 620} {:doc "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines.", :end-row 631, :filename "cljs/pprint.cljs", :name "*print-right-margin*", :ns "cljs.pprint", :row 626} {:doc "The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting.", :end-row 638, :filename "cljs/pprint.cljs", :name "*print-miser-width*", :ns "cljs.pprint", :row 633} {:doc "Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)", :end-row 644, :filename "cljs/pprint.cljs", :name "*print-lines*", :ns "cljs.pprint", :private true, :row 641} {:doc "Mark circular structures (N.B. This is not yet used)", :end-row 650, :filename "cljs/pprint.cljs", :name "*print-circle*", :ns "cljs.pprint", :private true, :row 647} {:doc "Mark repeated structures rather than repeat them (N.B. This is not yet used)", :end-row 656, :filename "cljs/pprint.cljs", :name "*print-shared*", :ns "cljs.pprint", :private true, :row 653} {:doc "Don't print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions", :end-row 662, :filename "cljs/pprint.cljs", :name "*print-suppress-namespaces*", :ns "cljs.pprint", :row 658} {:doc "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* ", :end-row 671, :filename "cljs/pprint.cljs", :name "*print-radix*", :ns "cljs.pprint", :row 666} {:doc "The base to use for printing integers and rationals.", :end-row 676, :filename "cljs/pprint.cljs", :name "*print-base*", :ns "cljs.pprint", :row 673} {:end-row 683, :filename "cljs/pprint.cljs", :name "*current-level*", :ns "cljs.pprint", :private true, :row 683} {:end-row 685, :filename "cljs/pprint.cljs", :name "*current-length*", :ns "cljs.pprint", :private true, :row 685} {:end-row 691, :filename "cljs/pprint.cljs", :name "format-simple-number", :ns "cljs.pprint", :row 691} {:arglist-strs ["[t m]"], :end-row 716, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "table-ize", :ns "cljs.pprint", :private true, :row 713} {:fixed-arities #{1}, :end-row 720, :private true, :ns "cljs.pprint", :name "pretty-writer?", :filename "cljs/pprint.cljs", :arglist-strs ["[x]"], :doc "Return true iff x is a PrettyWriter", :row 718} {:fixed-arities #{3}, :end-row 725, :private true, :ns "cljs.pprint", :name "make-pretty-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[base-writer right-margin miser-width]"], :doc "Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width", :row 722} {:arglist-strs ["[object]"], :doc "Write an object to *out* subject to the current bindings of the printer control\nvariables. Use the kw-args argument to override individual variables for this call (and\nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that\nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. ", :end-row 749, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "write-out", :ns "cljs.pprint", :row 727} {:arglist-strs ["[object & kw-args]"], :doc "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n", :end-row 812, :filename "cljs/pprint.cljs", :name "write", :ns "cljs.pprint", :row 751} {:arglist-strs ["[object]" "[object writer]"], :end-row 825, :filename "cljs/pprint.cljs", :fixed-arities #{1 2}, :name "pprint", :ns "cljs.pprint", :row 814} {:arglist-strs ["[function]"], :end-row 830, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "set-pprint-dispatch", :ns "cljs.pprint", :row 827} {:arglist-strs ["[arg choices]"], :end-row 839, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "check-enumerated-arg", :ns "cljs.pprint", :private true, :row 836} {:arglist-strs ["[]"], :end-row 842, :filename "cljs/pprint.cljs", :fixed-arities #{0}, :name "level-exceeded", :ns "cljs.pprint", :private true, :row 841} {:arglist-strs ["[kind]"], :doc "Print a conditional newline to a pretty printing stream. kind specifies if the\n  newline is :linear, :miser, :fill, or :mandatory.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Output is sent to *out* which must be a pretty printing writer.", :end-row 853, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-newline", :ns "cljs.pprint", :row 844} {:arglist-strs ["[relative-to n]"], :doc "Create an indent at this point in the pretty printing stream. This defines how\nfollowing lines are indented. relative-to can be either :block or :current depending\nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", :end-row 866, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "pprint-indent", :ns "cljs.pprint", :row 855} {:arglist-strs ["[kind colnum colinc]"], :doc "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative.\n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.", :end-row 884, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "pprint-tab", :ns "cljs.pprint", :row 869} {:end-row 891, :filename "cljs/pprint.cljs", :name "compile-format", :ns "cljs.pprint", :row 891} {:end-row 892, :filename "cljs/pprint.cljs", :name "execute-format", :ns "cljs.pprint", :row 892} {:end-row 893, :filename "cljs/pprint.cljs", :name "init-navigator", :ns "cljs.pprint", :row 893} {:arglist-strs ["[writer format-in & args]"], :doc "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It\nsupports sophisticated formatting of structured data.\n\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\nto a string, format-in is the format control string and the remaining arguments\nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives'\ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\"\n                   (count results) results))\n\nPrints via *print-fn*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \"Common Lisp the\nLanguage, 2nd edition\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\nand in the Common Lisp HyperSpec at\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm", :end-row 931, :filename "cljs/pprint.cljs", :name "cl-format", :ns "cljs.pprint", :row 896} {:end-row 933, :filename "cljs/pprint.cljs", :name "*format-str*", :ns "cljs.pprint", :private true, :row 933} {:arglist-strs ["[message offset]"], :end-row 938, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "format-error", :ns "cljs.pprint", :private true, :row 935} {:end-row 947, :filename "cljs/pprint.cljs", :name "arg-navigator", :ns "cljs.pprint", :private true, :row 946} {:arglist-strs ["[seq rest pos]"], :end-row 947, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "->arg-navigator", :ns "cljs.pprint", :private true, :row 946} {:arglist-strs ["[m]"], :end-row 947, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "map->arg-navigator", :ns "cljs.pprint", :private true, :row 946} {:fixed-arities #{1}, :end-row 954, :private true, :ns "cljs.pprint", :name "init-navigator", :filename "cljs/pprint.cljs", :arglist-strs ["[s]"], :doc "Create a new arg-navigator from the sequence with the position set to 0", :row 949} {:arglist-strs ["[navigator]"], :end-row 961, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "next-arg", :ns "cljs.pprint", :private true, :row 957} {:arglist-strs ["[navigator]"], :end-row 967, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "next-arg-or-nil", :ns "cljs.pprint", :private true, :row 963} {:arglist-strs ["[navigator]"], :end-row 975, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-format-arg", :ns "cljs.pprint", :private true, :row 970} {:end-row 977, :filename "cljs/pprint.cljs", :name "relative-reposition", :ns "cljs.pprint", :row 977} {:arglist-strs ["[navigator position]"], :end-row 982, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "absolute-reposition", :ns "cljs.pprint", :private true, :row 979} {:arglist-strs ["[navigator position]"], :end-row 988, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "relative-reposition", :ns "cljs.pprint", :private true, :row 984} {:end-row 991, :filename "cljs/pprint.cljs", :name "compiled-directive", :ns "cljs.pprint", :private true, :row 990} {:arglist-strs ["[func def params offset]"], :end-row 991, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "->compiled-directive", :ns "cljs.pprint", :private true, :row 990} {:arglist-strs ["[m]"], :end-row 991, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "map->compiled-directive", :ns "cljs.pprint", :private true, :row 990} {:arglist-strs ["[[param [raw-val offset]] navigator]"], :end-row 1015, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "realize-parameter", :ns "cljs.pprint", :private true, :row 1001} {:arglist-strs ["[parameter-map navigator]"], :end-row 1020, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "realize-parameter-list", :ns "cljs.pprint", :private true, :row 1017} {:end-row 1030, :filename "cljs/pprint.cljs", :name "opt-base-str", :ns "cljs.pprint", :row 1030} {:end-row 1033, :filename "cljs/pprint.cljs", :name "special-radix-markers", :ns "cljs.pprint", :private true, :row 1032} {:arglist-strs ["[n]"], :end-row 1043, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "format-simple-number", :ns "cljs.pprint", :private true, :row 1035} {:arglist-strs ["[print-func params arg-navigator offsets]"], :end-row 1061, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "format-ascii", :ns "cljs.pprint", :private true, :row 1045} {:fixed-arities #{1}, :end-row 1076, :private true, :ns "cljs.pprint", :name "integral?", :filename "cljs/pprint.cljs", :arglist-strs ["[x]"], :doc "returns true if a number is actually an integer (that is, has no fractional part)", :row 1068} {:fixed-arities #{2}, :end-row 1086, :private true, :ns "cljs.pprint", :name "remainders", :filename "cljs/pprint.cljs", :arglist-strs ["[base val]"], :doc "Return the list of remainders (essentially the 'digits') of val in the given base", :row 1078} {:fixed-arities #{2}, :end-row 1102, :private true, :ns "cljs.pprint", :name "base-str", :filename "cljs/pprint.cljs", :arglist-strs ["[base val]"], :doc "Return val as a string in the given base", :row 1090} {:end-row 1106, :filename "cljs/pprint.cljs", :name "javascript-base-formats", :ns "cljs.pprint", :private true, :row 1105} {:fixed-arities #{2}, :end-row 1111, :private true, :ns "cljs.pprint", :name "opt-base-str", :filename "cljs/pprint.cljs", :arglist-strs ["[base val]"], :doc "Return val as a string in the given base. No cljs format, so no improved performance.", :row 1108} {:arglist-strs ["[unit lis]"], :end-row 1116, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "group-by*", :ns "cljs.pprint", :private true, :row 1113} {:arglist-strs ["[base params arg-navigator offsets]"], :end-row 1142, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "format-integer", :ns "cljs.pprint", :private true, :row 1118} {:end-row 1152, :filename "cljs/pprint.cljs", :name "english-cardinal-units", :ns "cljs.pprint", :private true, :row 1148} {:end-row 1158, :filename "cljs/pprint.cljs", :name "english-ordinal-units", :ns "cljs.pprint", :private true, :row 1154} {:end-row 1162, :filename "cljs/pprint.cljs", :name "english-cardinal-tens", :ns "cljs.pprint", :private true, :row 1160} {:end-row 1167, :filename "cljs/pprint.cljs", :name "english-ordinal-tens", :ns "cljs.pprint", :private true, :row 1164} {:end-row 1179, :filename "cljs/pprint.cljs", :name "english-scale-numbers", :ns "cljs.pprint", :private true, :row 1173} {:fixed-arities #{1}, :end-row 1197, :private true, :ns "cljs.pprint", :name "format-simple-cardinal", :filename "cljs/pprint.cljs", :arglist-strs ["[num]"], :doc "Convert a number less than 1000 to a cardinal english string", :row 1181} {:fixed-arities #{2}, :end-row 1220, :private true, :ns "cljs.pprint", :name "add-english-scales", :filename "cljs/pprint.cljs", :arglist-strs ["[parts offset]"], :doc "Take a sequence of parts, add scale numbers (e.g., million) and combine into a string\n  offset is a factor of 10^3 to multiply by", :row 1199} {:arglist-strs ["[params navigator offsets]"], :end-row 1237, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-cardinal-english", :ns "cljs.pprint", :private true, :row 1222} {:fixed-arities #{1}, :end-row 1259, :private true, :ns "cljs.pprint", :name "format-simple-ordinal", :filename "cljs/pprint.cljs", :arglist-strs ["[num]"], :doc "Convert a number less than 1000 to a ordinal english string\n  Note this should only be used for the last one in the sequence", :row 1239} {:arglist-strs ["[params navigator offsets]"], :end-row 1291, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-ordinal-english", :ns "cljs.pprint", :private true, :row 1261} {:end-row 1302, :filename "cljs/pprint.cljs", :name "old-roman-table", :ns "cljs.pprint", :private true, :row 1297} {:end-row 1309, :filename "cljs/pprint.cljs", :name "new-roman-table", :ns "cljs.pprint", :private true, :row 1304} {:fixed-arities #{4}, :end-row 1333, :private true, :ns "cljs.pprint", :name "format-roman", :filename "cljs/pprint.cljs", :arglist-strs ["[table params navigator offsets]"], :doc "Format a roman numeral using the specified look-up table", :row 1311} {:arglist-strs ["[params navigator offsets]"], :end-row 1336, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-old-roman", :ns "cljs.pprint", :private true, :row 1335} {:arglist-strs ["[params navigator offsets]"], :end-row 1339, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-new-roman", :ns "cljs.pprint", :private true, :row 1338} {:end-row 1346, :filename "cljs/pprint.cljs", :name "special-chars", :ns "cljs.pprint", :private true, :row 1345} {:arglist-strs ["[params navigator offsets]"], :end-row 1360, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "pretty-character", :ns "cljs.pprint", :private true, :row 1348} {:arglist-strs ["[params navigator offsets]"], :end-row 1368, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "readable-character", :ns "cljs.pprint", :private true, :row 1362} {:arglist-strs ["[params navigator offsets]"], :end-row 1373, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "plain-character", :ns "cljs.pprint", :private true, :row 1370} {:arglist-strs ["[context]"], :end-row 1379, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "abort?", :ns "cljs.pprint", :private true, :row 1377} {:arglist-strs ["[format args base-args]"], :end-row 1393, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "execute-sub-format", :ns "cljs.pprint", :private true, :row 1382} {:fixed-arities #{1}, :end-row 1412, :private true, :ns "cljs.pprint", :name "float-parts-base", :filename "cljs/pprint.cljs", :arglist-strs ["[f]"], :doc "Produce string parts for the mantissa (normalize 1-9) and exponent", :row 1400} {:fixed-arities #{1}, :end-row 1424, :private true, :ns "cljs.pprint", :name "float-parts", :filename "cljs/pprint.cljs", :arglist-strs ["[f]"], :doc "Take care of leading and trailing zeros in decomposed floats", :row 1414} {:fixed-arities #{1}, :end-row 1440, :private true, :ns "cljs.pprint", :name "inc-s", :filename "cljs/pprint.cljs", :arglist-strs ["[s]"], :doc "Assumption: The input string consists of one or more decimal digits,\n  and no other characters. Return a string containing one or more\n  decimal digits containing a decimal number one larger than the input\n  string. The output string will always be the same length as the input\n  string, or one character longer.", :row 1426} {:arglist-strs ["[m e d w]"], :end-row 1486, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "round-str", :ns "cljs.pprint", :private true, :row 1442} {:arglist-strs ["[m e d]"], :end-row 1496, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "expand-fixed", :ns "cljs.pprint", :private true, :row 1488} {:fixed-arities #{2}, :end-row 1504, :private true, :ns "cljs.pprint", :name "insert-decimal", :filename "cljs/pprint.cljs", :arglist-strs ["[m e]"], :doc "Insert the decimal point at the right spot in the number to match an exponent", :row 1498} {:arglist-strs ["[m e d]"], :end-row 1507, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "get-fixed", :ns "cljs.pprint", :private true, :row 1506} {:fixed-arities #{2}, :end-row 1514, :private true, :ns "cljs.pprint", :name "insert-scaled-decimal", :filename "cljs/pprint.cljs", :arglist-strs ["[m k]"], :doc "Insert the decimal point at the right spot in the number to match an exponent", :row 1509} {:arglist-strs ["[x]"], :end-row 1518, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "convert-ratio", :ns "cljs.pprint", :private true, :row 1517} {:arglist-strs ["[params navigator offsets]"], :end-row 1564, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "fixed-float", :ns "cljs.pprint", :private true, :row 1522} {:arglist-strs ["[params navigator offset]"], :end-row 1636, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "exponential-float", :ns "cljs.pprint", :private true, :row 1569} {:arglist-strs ["[params navigator offsets]"], :end-row 1662, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "general-float", :ns "cljs.pprint", :private true, :row 1643} {:arglist-strs ["[params navigator offsets]"], :end-row 1682, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "dollar-float", :ns "cljs.pprint", :private true, :row 1666} {:arglist-strs ["[params arg-navigator offsets]"], :end-row 1701, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "choice-conditional", :ns "cljs.pprint", :private true, :row 1692} {:arglist-strs ["[params arg-navigator offsets]"], :end-row 1712, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "boolean-conditional", :ns "cljs.pprint", :private true, :row 1704} {:arglist-strs ["[params arg-navigator offsets]"], :end-row 1724, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "check-arg-conditional", :ns "cljs.pprint", :private true, :row 1716} {:arglist-strs ["[params navigator offsets]"], :end-row 1754, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "iterate-sublist", :ns "cljs.pprint", :private true, :row 1733} {:arglist-strs ["[params navigator offsets]"], :end-row 1777, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "iterate-list-of-sublists", :ns "cljs.pprint", :private true, :row 1758} {:arglist-strs ["[params navigator offsets]"], :end-row 1801, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "iterate-main-list", :ns "cljs.pprint", :private true, :row 1781} {:arglist-strs ["[params navigator offsets]"], :end-row 1821, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "iterate-main-sublists", :ns "cljs.pprint", :private true, :row 1805} {:end-row 1836, :filename "cljs/pprint.cljs", :name "format-logical-block", :ns "cljs.pprint", :row 1836} {:end-row 1837, :filename "cljs/pprint.cljs", :name "justify-clauses", :ns "cljs.pprint", :row 1837} {:arglist-strs ["[params navigator offsets]"], :end-row 1842, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "logical-block-or-justify", :ns "cljs.pprint", :private true, :row 1839} {:arglist-strs ["[clauses navigator base-navigator]"], :end-row 1861, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "render-clauses", :ns "cljs.pprint", :private true, :row 1848} {:arglist-strs ["[params navigator offsets]"], :end-row 1909, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "justify-clauses", :ns "cljs.pprint", :private true, :row 1864} {:fixed-arities #{1}, :end-row 1938, :private true, :ns "cljs.pprint", :name "downcase-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, converting all characters to lower case", :row 1919} {:fixed-arities #{1}, :end-row 1959, :private true, :ns "cljs.pprint", :name "upcase-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, converting all characters to upper case", :row 1940} {:fixed-arities #{2}, :end-row 1982, :private true, :ns "cljs.pprint", :name "capitalize-string", :filename "cljs/pprint.cljs", :arglist-strs ["[s first?]"], :doc "Capitalizes the words in a string. If first? is false, don't capitalize the\n                                      first character of the string even if it's a letter.", :row 1961} {:fixed-arities #{1}, :end-row 2008, :private true, :ns "cljs.pprint", :name "capitalize-word-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, capitalizing all words", :row 1984} {:fixed-arities #{1}, :end-row 2043, :private true, :ns "cljs.pprint", :name "init-cap-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, capitalizing the first word", :row 2010} {:arglist-strs ["[make-writer params navigator offsets]"], :end-row 2048, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "modify-case", :ns "cljs.pprint", :private true, :row 2045} {:arglist-strs ["[writer]"], :doc "Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be\npreserved across calls, you will want to wrap them with this.\n\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \"~4D~7,vT\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1\n       2      4       8\n       3      9      27\n       4     16      64\n       5     25     125\n       6     36     216\n       7     49     343\n       8     64     512\n       9     81     729\n      10    100    1000", :end-row 2090, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-pretty-writer", :ns "cljs.pprint", :row 2055} {:arglist-strs ["[]"], :doc "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.", :end-row 2103, :filename "cljs/pprint.cljs", :fixed-arities #{0}, :name "fresh-line", :ns "cljs.pprint", :row 2096} {:arglist-strs ["[params navigator offsets]"], :end-row 2114, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "absolute-tabulation", :ns "cljs.pprint", :private true, :row 2105} {:arglist-strs ["[params navigator offsets]"], :end-row 2123, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "relative-tabulation", :ns "cljs.pprint", :private true, :row 2116} {:arglist-strs ["[params navigator offsets]"], :end-row 2147, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-logical-block", :ns "cljs.pprint", :private true, :row 2131} {:arglist-strs ["[params navigator offsets]"], :end-row 2152, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "set-indent", :ns "cljs.pprint", :private true, :row 2149} {:arglist-strs ["[params navigator offsets]"], :end-row 2160, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "conditional-newline", :ns "cljs.pprint", :private true, :row 2155} {:end-row 2450, :filename "cljs/pprint.cljs", :name "param-pattern", :ns "cljs.pprint", :private true, :row 2449} {:end-row 2453, :filename "cljs/pprint.cljs", :name "special-params", :ns "cljs.pprint", :private true, :row 2452} {:arglist-strs ["[[s offset saw-comma]]"], :end-row 2467, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "extract-param", :ns "cljs.pprint", :private true, :row 2455} {:arglist-strs ["[s offset]"], :end-row 2470, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "extract-params", :ns "cljs.pprint", :private true, :row 2469} {:fixed-arities #{1}, :end-row 2482, :private true, :ns "cljs.pprint", :name "translate-param", :filename "cljs/pprint.cljs", :arglist-strs ["[[p offset]]"], :doc "Translate the string representation of a param to the internalized\n                                      representation", :row 2472} {:end-row 2485, :filename "cljs/pprint.cljs", :name "flag-defs", :ns "cljs.pprint", :private true, :row 2484} {:arglist-strs ["[s offset]"], :end-row 2500, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "extract-flags", :ns "cljs.pprint", :private true, :row 2487} {:arglist-strs ["[def flags]"], :end-row 2513, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "check-flags", :ns "cljs.pprint", :private true, :row 2502} {:fixed-arities #{4}, :end-row 2543, :private true, :ns "cljs.pprint", :name "map-params", :filename "cljs/pprint.cljs", :arglist-strs ["[def params flags offset]"], :doc "Takes a directive definition and the list of actual parameters and\na map of flags and returns a map of the parameters and flags with defaults\nfilled in. We check to make sure that there are the right types and number\nof parameters as well.", :row 2515} {:arglist-strs ["[s offset]"], :end-row 2563, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "compile-directive", :ns "cljs.pprint", :private true, :row 2545} {:arglist-strs ["[s offset]"], :end-row 2566, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "compile-raw-string", :ns "cljs.pprint", :private true, :row 2565} {:arglist-strs ["[this]"], :end-row 2568, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "right-bracket", :ns "cljs.pprint", :private true, :row 2568} {:arglist-strs ["[this]"], :end-row 2570, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "separator?", :ns "cljs.pprint", :private true, :row 2570} {:arglist-strs ["[this]"], :end-row 2574, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "else-separator?", :ns "cljs.pprint", :private true, :row 2572} {:end-row 2576, :filename "cljs/pprint.cljs", :name "collect-clauses", :ns "cljs.pprint", :row 2576} {:arglist-strs ["[this remainder]"], :end-row 2585, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "process-bracket", :ns "cljs.pprint", :private true, :row 2578} {:arglist-strs ["[bracket-info offset remainder]"], :end-row 2609, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "process-clause", :ns "cljs.pprint", :private true, :row 2587} {:arglist-strs ["[bracket-info offset remainder]"], :end-row 2658, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "collect-clauses", :ns "cljs.pprint", :private true, :row 2611} {:fixed-arities #{1}, :end-row 2673, :private true, :ns "cljs.pprint", :name "process-nesting", :filename "cljs/pprint.cljs", :arglist-strs ["[format]"], :doc "Take a linearly compiled format and process the bracket directives to give it\n   the appropriate tree structure", :row 2660} {:fixed-arities #{1}, :end-row 2693, :private true, :ns "cljs.pprint", :name "compile-format", :filename "cljs/pprint.cljs", :arglist-strs ["[format-str]"], :doc "Compiles format-str into a compiled format which can be used as an argument\nto cl-format just like a plain format string. Use this function for improved\nperformance when you're using the same format string repeatedly", :row 2675} {:fixed-arities #{1}, :end-row 2706, :private true, :ns "cljs.pprint", :name "needs-pretty", :filename "cljs/pprint.cljs", :arglist-strs ["[format]"], :doc "determine whether a given compiled format has any directives that depend on the\ncolumn number or pretty printing", :row 2695} {:fixed-arities #{3 2}, :end-row 2754, :private true, :ns "cljs.pprint", :name "execute-format", :filename "cljs/pprint.cljs", :arglist-strs ["[stream format args]" "[format args]"], :doc "Executes the format with the arguments.", :row 2720} {:end-row 2758, :filename "cljs/pprint.cljs", :name "cached-compile", :ns "cljs.pprint", :private true, :row 2758} {:fixed-arities #{3}, :end-row 2767, :private true, :ns "cljs.pprint", :name "use-method", :filename "cljs/pprint.cljs", :arglist-strs ["[multifn dispatch-val func]"], :doc "Installs a function as a new method of multimethod associated with dispatch-value. ", :row 2764} {:end-row 2795, :filename "cljs/pprint.cljs", :name "reader-macros", :ns "cljs.pprint", :private true, :row 2789} {:arglist-strs ["[alis]"], :end-row 2802, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-reader-macro", :ns "cljs.pprint", :private true, :row 2797} {:arglist-strs ["[alis]"], :end-row 2822, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-simple-list", :ns "cljs.pprint", :private true, :row 2814} {:arglist-strs ["[alis]"], :end-row 2826, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-list", :ns "cljs.pprint", :private true, :row 2824} {:arglist-strs ["[avec]"], :end-row 2837, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-vector", :ns "cljs.pprint", :private true, :row 2829} {:end-row 2839, :filename "cljs/pprint.cljs", :name "pprint-array", :ns "cljs.pprint", :private true, :row 2839} {:arglist-strs ["[amap]"], :end-row 2861, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-map", :ns "cljs.pprint", :private true, :row 2842} {:arglist-strs ["[obj]"], :end-row 2865, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-simple-default", :ns "cljs.pprint", :private true, :row 2863} {:end-row 2867, :filename "cljs/pprint.cljs", :name "pprint-set", :ns "cljs.pprint", :row 2867} {:end-row 2871, :filename "cljs/pprint.cljs", :name "type-map", :ns "cljs.pprint", :private true, :row 2869} {:fixed-arities #{1}, :end-row 2878, :private true, :ns "cljs.pprint", :name "map-ref-type", :filename "cljs/pprint.cljs", :arglist-strs ["[name]"], :doc "Map ugly type names to something simpler", :row 2873} {:arglist-strs ["[o]"], :end-row 2889, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-ideref", :ns "cljs.pprint", :private true, :row 2880} {:end-row 2891, :filename "cljs/pprint.cljs", :name "pprint-pqueue", :ns "cljs.pprint", :private true, :row 2891} {:arglist-strs ["[obj]"], :end-row 2903, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "type-dispatcher", :ns "cljs.pprint", :private true, :row 2893} {:doc "The pretty print dispatch function for simple data structure format.", :end-row 2907, :filename "cljs/pprint.cljs", :name "simple-dispatch", :ns "cljs.pprint", :row 2905} {:end-row 2922, :filename "cljs/pprint.cljs", :name "pprint-simple-code-list", :ns "cljs.pprint", :row 2922} {:fixed-arities #{1}, :end-row 2935, :private true, :ns "cljs.pprint", :name "brackets", :filename "cljs/pprint.cljs", :arglist-strs ["[form]"], :doc "Figure out which kind of brackets to use", :row 2930} {:fixed-arities #{1}, :end-row 2969, :private true, :ns "cljs.pprint", :name "pprint-ns-reference", :filename "cljs/pprint.cljs", :arglist-strs ["[reference]"], :doc "Pretty print a single reference (import, use, etc.) from a namespace decl", :row 2937} {:fixed-arities #{1}, :end-row 2995, :private true, :ns "cljs.pprint", :name "pprint-ns", :filename "cljs/pprint.cljs", :arglist-strs ["[alis]"], :doc "The pretty print dispatch chunk for the ns macro", :row 2971} {:end-row 3002, :filename "cljs/pprint.cljs", :name "pprint-hold-first", :ns "cljs.pprint", :private true, :row 3002} {:arglist-strs ["[alis has-doc-str?]"], :end-row 3015, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "single-defn", :ns "cljs.pprint", :private true, :row 3009} {:arglist-strs ["[alis has-doc-str?]"], :end-row 3020, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "multi-defn", :ns "cljs.pprint", :private true, :row 3018} {:arglist-strs ["[alis]"], :end-row 3043, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-defn", :ns "cljs.pprint", :private true, :row 3024} {:arglist-strs ["[binding-vec]"], :end-row 3062, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-binding-form", :ns "cljs.pprint", :private true, :row 3049} {:arglist-strs ["[alis]"], :end-row 3072, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-let", :ns "cljs.pprint", :private true, :row 3064} {:end-row 3078, :filename "cljs/pprint.cljs", :name "pprint-if", :ns "cljs.pprint", :private true, :row 3078} {:arglist-strs ["[alis]"], :end-row 3098, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-cond", :ns "cljs.pprint", :private true, :row 3080} {:arglist-strs ["[alis]"], :end-row 3117, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-condp", :ns "cljs.pprint", :private true, :row 3100} {:end-row 3120, :filename "cljs/pprint.cljs", :name "*symbol-map*", :ns "cljs.pprint", :private true, :row 3120} {:arglist-strs ["[alis]"], :end-row 3134, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-anon-func", :ns "cljs.pprint", :private true, :row 3122} {:arglist-strs ["[alis]"], :end-row 3153, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-simple-code-list", :ns "cljs.pprint", :private true, :row 3144} {:arglist-strs ["[amap]"], :end-row 3162, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "two-forms", :ns "cljs.pprint", :private true, :row 3157} {:arglist-strs ["[amap]"], :end-row 3171, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "add-core-ns", :ns "cljs.pprint", :private true, :row 3164} {:end-row 3188, :filename "cljs/pprint.cljs", :name "*code-table*", :ns "cljs.pprint", :private true, :row 3173} {:arglist-strs ["[alis]"], :end-row 3194, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-code-list", :ns "cljs.pprint", :private true, :row 3190} {:arglist-strs ["[sym]"], :end-row 3201, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-code-symbol", :ns "cljs.pprint", :private true, :row 3196} {:doc "The pretty print dispatch function for pretty printing Clojure code.", :end-row 3207, :filename "cljs/pprint.cljs", :name "code-dispatch", :ns "cljs.pprint", :row 3203} {:arglist-strs ["[width s]"], :end-row 3300, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "add-padding", :ns "cljs.pprint", :private true, :row 3298} {:arglist-strs ["[ks rows]" "[rows]"], :doc "Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.", :end-row 3325, :filename "cljs/pprint.cljs", :fixed-arities #{1 2}, :name "print-table", :ns "cljs.pprint", :row 3302}]} {:end-row 14, :filename "cljs/nodejscli.cljs", :name "cljs.nodejscli", :row 12, :ns nil, :var-definitions nil} {:author "Paula Gearon", :doc "ClojureScript wrapper functions for math operations", :end-row 3, :filename "cljs/math.cljs", :name "cljs.math", :row 1, :ns nil, :var-definitions [{:doc "Constant for Euler's number e, the base for natural logarithms.\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/E", :end-row 10, :filename "cljs/math.cljs", :name "E", :ns "cljs.math", :row 5} {:doc "Constant for pi, the ratio of the circumference of a circle to its diameter.\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/PI", :end-row 17, :filename "cljs/math.cljs", :name "PI", :ns "cljs.math", :row 12} {:doc "Constant used to convert an angular value in degrees to the equivalent in radians", :end-row 23, :filename "cljs/math.cljs", :name "DEGREES-TO-RADIANS", :ns "cljs.math", :private true, :row 19} {:doc "Constant used to convert an angular value in radians to the equivalent in degrees", :end-row 29, :filename "cljs/math.cljs", :name "RADIANS-TO-DEGREES", :ns "cljs.math", :private true, :row 25} {:end-row 31, :filename "cljs/math.cljs", :name "TWO-TO-THE-52", :ns "cljs.math", :private true, :row 31} {:end-row 33, :filename "cljs/math.cljs", :name "SIGNIFICAND-WIDTH32", :ns "cljs.math", :private true, :row 33} {:end-row 35, :filename "cljs/math.cljs", :name "EXP-BIAS", :ns "cljs.math", :private true, :row 35} {:end-row 37, :filename "cljs/math.cljs", :name "EXP-BITMASK32", :ns "cljs.math", :private true, :row 37} {:end-row 39, :filename "cljs/math.cljs", :name "EXP-MAX", :ns "cljs.math", :private true, :row 39} {:end-row 41, :filename "cljs/math.cljs", :name "EXP-MIN", :ns "cljs.math", :private true, :row 41} {:fixed-arities #{0}, :end-row 54, :private true, :ns "cljs.math", :name "get-little-endian", :filename "cljs/math.cljs", :arglist-strs ["[]"], :doc "Tests the platform for endianness. Returns true when little-endian, false otherwise.", :row 47} {:end-row 56, :filename "cljs/math.cljs", :name "little-endian?", :ns "cljs.math", :private true, :row 56} {:doc "offset of hi integers in 64-bit values", :end-row 59, :filename "cljs/math.cljs", :name "HI", :ns "cljs.math", :private true, :row 59} {:doc "offset of hi integers in 64-bit values", :end-row 61, :filename "cljs/math.cljs", :name "LO", :ns "cljs.math", :private true, :row 61} {:end-row 63, :filename "cljs/math.cljs", :name "INT32-MASK", :ns "cljs.math", :private true, :row 63} {:end-row 65, :filename "cljs/math.cljs", :name "INT32-NON-SIGN-BIT", :ns "cljs.math", :private true, :row 65} {:end-row 67, :filename "cljs/math.cljs", :name "INT32-NON-SIGN-BITS", :ns "cljs.math", :private true, :row 67} {:fixed-arities #{2}, :end-row 78, :private true, :ns "cljs.math", :name "u<", :filename "cljs/math.cljs", :arglist-strs ["[a b]"], :doc "unsigned less-than comparator for 32-bit values", :row 69} {:arglist-strs ["[a]"], :doc "Returns the sine of an angle.\n  If a is ##NaN, ##-Inf, ##Inf => ##NaN\n  If a is zero => zero with the same sign as a\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sin", :end-row 86, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "sin", :ns "cljs.math", :row 80} {:arglist-strs ["[a]"], :doc "Returns the cosine of an angle.\n  If a is ##NaN, ##-Inf, ##Inf => ##NaN\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cos", :end-row 93, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "cos", :ns "cljs.math", :row 88} {:arglist-strs ["[a]"], :doc "Returns the tangent of an angle.\n  If a is ##NaN, ##-Inf, ##Inf => ##NaN\n  If a is zero => zero with the same sign as a\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tan", :end-row 101, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "tan", :ns "cljs.math", :row 95} {:arglist-strs ["[a]"], :doc "Returns the arc sine of an angle, in the range -pi/2 to pi/2.\n  If a is ##NaN or |a|>1 => ##NaN\n  If a is zero => zero with the same sign as a\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/asin", :end-row 109, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "asin", :ns "cljs.math", :row 103} {:arglist-strs ["[a]"], :doc "Returns the arc cosine of a, in the range 0.0 to pi.\n  If a is ##NaN or |a|>1 => ##NaN\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/acos", :end-row 116, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "acos", :ns "cljs.math", :row 111} {:arglist-strs ["[a]"], :doc "Returns the arc tangent of a, in the range of -pi/2 to pi/2.\n  If a is ##NaN => ##NaN\n  If a is zero => zero with the same sign as a\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan", :end-row 124, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "atan", :ns "cljs.math", :row 118} {:arglist-strs ["[deg]"], :doc "Converts an angle in degrees to an approximate equivalent angle in radians.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#toRadians-double-", :end-row 131, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "to-radians", :ns "cljs.math", :row 126} {:arglist-strs ["[r]"], :doc "Converts an angle in radians to an approximate equivalent angle in degrees.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#toDegrees-double-", :end-row 138, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "to-degrees", :ns "cljs.math", :row 133} {:arglist-strs ["[a]"], :doc "Returns Euler's number e raised to the power of a.\n  If a is ##NaN => ##NaN\n  If a is ##Inf => ##Inf\n  If a is ##-Inf => +0.0\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/exp", :end-row 147, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "exp", :ns "cljs.math", :row 140} {:arglist-strs ["[a]"], :doc "Returns the natural logarithm (base e) of a.\n  If a is ##NaN or negative => ##NaN\n  If a is ##Inf => ##Inf\n  If a is zero => ##-Inf\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log", :end-row 156, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "log", :ns "cljs.math", :row 149} {:arglist-strs ["[a]"], :doc "Returns the logarithm (base 10) of a.\n  If a is ##NaN or negative => ##NaN\n  If a is ##Inf => ##Inf\n  If a is zero => ##-Inf\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log10", :end-row 165, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "log10", :ns "cljs.math", :row 158} {:arglist-strs ["[a]"], :doc "Returns the positive square root of a.\n  If a is ##NaN or negative => ##NaN\n  If a is ##Inf => ##Inf\n  If a is zero => a\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sqrt", :end-row 174, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "sqrt", :ns "cljs.math", :row 167} {:arglist-strs ["[a]"], :doc "Returns the cube root of a.\n  If a is ##NaN => ##NaN\n  If a is ##Inf or ##-Inf => a\n  If a is zero => zero with sign matching a\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cbrt", :end-row 183, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "cbrt", :ns "cljs.math", :row 176} {:fixed-arities #{1}, :end-row 203, :private true, :ns "cljs.math", :name "fabs", :filename "cljs/math.cljs", :arglist-strs ["[x]"], :doc "Internal function to convert doubles to absolute values.\n  This duplicates the C implementations in Java, in case there is are corner-case differences.", :row 185} {:end-row 218, :filename "cljs/math.cljs", :name "Zero", :ns "cljs.math", :private true, :row 205} {:end-row 220, :filename "cljs/math.cljs", :name "xpos", :ns "cljs.math", :private true, :row 220} {:end-row 221, :filename "cljs/math.cljs", :name "ypos", :ns "cljs.math", :private true, :row 221} {:end-row 222, :filename "cljs/math.cljs", :name "HI-x", :ns "cljs.math", :private true, :row 222} {:end-row 223, :filename "cljs/math.cljs", :name "LO-x", :ns "cljs.math", :private true, :row 223} {:end-row 224, :filename "cljs/math.cljs", :name "HI-y", :ns "cljs.math", :private true, :row 224} {:end-row 225, :filename "cljs/math.cljs", :name "LO-y", :ns "cljs.math", :private true, :row 225} {:fixed-arities #{2}, :end-row 239, :private true, :ns "cljs.math", :name "ilogb", :filename "cljs/math.cljs", :arglist-strs ["[hx lx]"], :doc "internal function for ilogb(x)", :row 227} {:fixed-arities #{3}, :end-row 250, :private true, :ns "cljs.math", :name "setup-hl", :filename "cljs/math.cljs", :arglist-strs ["[i h l]"], :doc "internal function to setup and align integer words", :row 241} {:fixed-arities #{2}, :end-row 333, :private true, :ns "cljs.math", :name "IEEE-fmod", :filename "cljs/math.cljs", :arglist-strs ["[x y]"], :doc "Return x mod y in exact arithmetic. Method: shift and subtract.\n  Reimplements __ieee754_fmod from the JDK.\n  Ported from: https://github.com/openjdk/jdk/blob/master/src/java.base/share/native/libfdlibm/e_fmod.c\n  bit-shift-left and bit-shift-right convert numbers to signed 32-bit\n  Fortunately the values that are shifted are expected to be 32 bit signed.", :row 252} {:arglist-strs ["[dividend divisor]"], :doc "Returns the remainder per IEEE 754 such that\n    remainder = dividend - divisor * n\n   where n is the integer closest to the exact value of dividend / divisor.\n   If two integers are equally close, then n is the even one.\n   If the remainder is zero, sign will match dividend.\n   If dividend or divisor is ##NaN, or dividend is ##Inf or ##-Inf, or divisor is zero => ##NaN\n   If dividend is finite and divisor is infinite => dividend\n\n   Method: based on fmod return x-[x/p]chopped*p exactlp.\n   Ported from: https://github.com/openjdk/jdk/blob/master/src/java.base/share/native/libfdlibm/e_remainder.c\n   See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#IEEEremainder-double-double-", :end-row 411, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "IEEE-remainder", :ns "cljs.math", :row 335} {:arglist-strs ["[a]"], :doc "Returns the smallest double greater than or equal to a, and equal to a\n  mathematical integer.\n  If a is ##NaN or ##Inf or ##-Inf or already equal to an integer => a\n  Note that if a is `nil` then an exception will be thrown. This matches Clojure, rather than js/Math.ceil\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/ceil", :end-row 423, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "ceil", :ns "cljs.math", :row 413} {:arglist-strs ["[a]"], :doc "Returns the largest double less than or equal to a, and equal to a\n  mathematical integer.\n  If a is ##NaN or ##Inf or ##-Inf or already equal to an integer => a\n  If a is less than zero but greater than -1.0 => -0.0\n  Note that if a is `nil` then an exception will be thrown. This matches Clojure, rather than js/Math.floor\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/floor", :end-row 436, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "floor", :ns "cljs.math", :row 425} {:arglist-strs ["[magnitude sign]"], :doc "Returns a double with the magnitude of the first argument and the sign of\n  the second.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#copySign-double-double-", :end-row 463, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "copy-sign", :ns "cljs.math", :row 438} {:arglist-strs ["[a]"], :doc "Returns the double closest to a and equal to a mathematical integer.\n  If two values are equally close, return the even one.\n  If a is ##NaN or ##Inf or ##-Inf or zero => a\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#rint-double-", :end-row 476, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "rint", :ns "cljs.math", :row 465} {:arglist-strs ["[y x]"], :doc "Returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta).\n  Computes the phase theta by computing an arc tangent of y/x in the range of -pi to pi.\n  For more details on special cases, see:\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan", :end-row 484, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "atan2", :ns "cljs.math", :row 478} {:arglist-strs ["[a b]"], :doc "Returns the value of a raised to the power of b.\n  For more details on special cases, see:\n  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/pow", :end-row 491, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "pow", :ns "cljs.math", :row 486} {:arglist-strs ["[a]"], :doc "Returns the closest long to a. If equally close to two values, return the one\n  closer to ##Inf.\n  If a is ##NaN => 0\n  If a is ##-Inf => js/Number.MIN_SAFE_INTEGER\n  If a is ##Inf => js/Number.MAX_SAFE_INTEGER\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/round", :end-row 506, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "round", :ns "cljs.math", :row 493} {:arglist-strs ["[]"], :doc "Returns a positive double between 0.0 and 1.0, chosen pseudorandomly with\n  approximately random distribution. Not cryptographically secure. The seed is chosen internally\n  and cannot be selected.\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/random", :end-row 514, :filename "cljs/math.cljs", :fixed-arities #{0}, :name "random", :ns "cljs.math", :row 508} {:arglist-strs ["[x y]"], :doc "Returns the sum of x and y, throws an exception on overflow. ", :end-row 523, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "add-exact", :ns "cljs.math", :row 516} {:arglist-strs ["[x y]"], :doc "Returns the difference of x and y, throws ArithmeticException on overflow. ", :end-row 532, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "subtract-exact", :ns "cljs.math", :row 525} {:arglist-strs ["[x y]"], :doc "Returns the product of x and y, throws ArithmeticException on overflow. ", :end-row 541, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "multiply-exact", :ns "cljs.math", :row 534} {:arglist-strs ["[a]"], :doc "Returns a incremented by 1, throws ArithmeticException on overflow.", :end-row 549, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "increment-exact", :ns "cljs.math", :row 543} {:arglist-strs ["[a]"], :doc "Returns a decremented by 1, throws ArithmeticException on overflow. ", :end-row 557, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "decrement-exact", :ns "cljs.math", :row 551} {:arglist-strs ["[a]"], :doc "Returns the negation of a, throws ArithmeticException on overflow. ", :end-row 565, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "negate-exact", :ns "cljs.math", :row 559} {:arglist-strs ["[a b]"], :end-row 569, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "xor", :ns "cljs.math", :private true, :row 567} {:arglist-strs ["[x y]"], :doc "Integer division that rounds to negative infinity (as opposed to zero).\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#floorDiv-long-long-", :end-row 582, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "floor-div", :ns "cljs.math", :row 571} {:arglist-strs ["[x y]"], :doc "Integer modulus x - (floorDiv(x, y) * y). Sign matches y and is in the\n  range -|y| < r < |y|.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#floorMod-long-long-", :end-row 597, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "floor-mod", :ns "cljs.math", :row 584} {:arglist-strs ["[d]"], :doc "Returns the exponent of d.\n  If d is ##NaN, ##Inf, ##-Inf => max_Float64_exponent + 1\n  If d is zero or subnormal => min_Float64_exponent - 1\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#getExponent-double-", :end-row 614, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "get-exponent", :ns "cljs.math", :row 599} {:fixed-arities #{2}, :end-row 626, :private true, :ns "cljs.math", :name "hi-lo->double", :filename "cljs/math.cljs", :arglist-strs ["[h l]"], :doc "Converts a pair of 32 bit integers into an IEEE-754 64 bit floating point number.\n  h is the high 32 bits, l is the low 32 bits.", :row 616} {:fixed-arities #{1}, :end-row 634, :private true, :ns "cljs.math", :name "power-of-two", :filename "cljs/math.cljs", :arglist-strs ["[n]"], :doc "returns a floating point power of two in the normal range", :row 628} {:arglist-strs ["[d]"], :doc "Returns the size of an ulp (unit in last place) for d.\n  If d is ##NaN => ##NaN\n  If d is ##Inf or ##-Inf => ##Inf\n  If d is zero => Number/MIN_VALUE\n  If d is +/- Number/MAX_VALUE => 2^971\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#ulp-double-", :end-row 659, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "ulp", :ns "cljs.math", :row 636} {:arglist-strs ["[d]"], :doc "Returns the signum function of d - zero for zero, 1.0 if >0, -1.0 if <0.\n  If d is ##NaN => ##NaN\n  If d is ##Inf or ##-Inf => sign of d\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#signum-double-", :end-row 670, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "signum", :ns "cljs.math", :row 661} {:arglist-strs ["[x]"], :doc "Returns the hyperbolic sine of x, (e^x - e^-x)/2.\n  If x is ##NaN => ##NaN\n  If x is ##Inf or ##-Inf or zero => x\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sinh", :end-row 678, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "sinh", :ns "cljs.math", :row 672} {:arglist-strs ["[x]"], :doc "Returns the hyperbolic cosine of x, (e^x + e^-x)/2.\n  If x is ##NaN => ##NaN\n  If x is ##Inf or ##-Inf => ##Inf\n  If x is zero => 1.0\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/cosh", :end-row 687, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "cosh", :ns "cljs.math", :row 680} {:arglist-strs ["[x]"], :doc "Returns the hyperbolic tangent of x, sinh(x)/cosh(x).\n  If x is ##NaN => ##NaN\n  If x is zero => zero, with same sign\n  If x is ##Inf => +1.0\n  If x is ##-Inf => -1.0\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/tanh", :end-row 697, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "tanh", :ns "cljs.math", :row 689} {:arglist-strs ["[x y]"], :doc "Returns sqrt(x^2 + y^2) without intermediate underflow or overflow.\n  If x or y is ##Inf or ##-Inf => ##Inf\n  If x or y is ##NaN and neither is ##Inf or ##-Inf => ##NaN\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/hypot", :end-row 705, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "hypot", :ns "cljs.math", :row 699} {:arglist-strs ["[x]"], :doc "Returns e^x - 1. Near 0, expm1(x)+1 is more accurate to e^x than exp(x).\n  If x is ##NaN => ##NaN\n  If x is ##Inf => #Inf\n  If x is ##-Inf => -1.0\n  If x is zero => x\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/expm1", :end-row 715, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "expm1", :ns "cljs.math", :row 707} {:arglist-strs ["[x]"], :doc "Returns ln(1+x). For small values of x, log1p(x) is more accurate than\n  log(1.0+x).\n  If x is ##NaN or ##-Inf or < -1 => ##NaN\n  If x is -1 => ##-Inf\n  If x is ##Inf => ##Inf\n  See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/log1p", :end-row 725, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "log1p", :ns "cljs.math", :row 717} {:fixed-arities #{4}, :end-row 740, :private true, :ns "cljs.math", :name "add64", :filename "cljs/math.cljs", :arglist-strs ["[hx lx hy ly]"], :doc "Takes the high and low words for 2 different 64 bit integers, and adds them.\n  This handles overflow from the low-order words into the high order words.", :row 727} {:arglist-strs ["[start direction]"], :doc "Returns the adjacent floating point number to start in the direction of\n  the second argument. If the arguments are equal, the second is returned.\n  If either arg is #NaN => #NaN\n  If both arguments are signed zeros => direction\n  If start is +-Number/MIN_VALUE and direction would cause a smaller magnitude\n    => zero with sign matching start\n  If start is ##Inf or ##-Inf and direction would cause a smaller magnitude\n    => Number/MAX_VALUE with same sign as start\n  If start is equal to +=Number/MAX_VALUE and direction would cause a larger magnitude\n    => ##Inf or ##-Inf with sign matching start\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextAfter-double-double-", :end-row 788, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "next-after", :ns "cljs.math", :row 742} {:arglist-strs ["[d]"], :doc "Returns the adjacent double of d in the direction of ##Inf.\n  If d is ##NaN => ##NaN\n  If d is ##Inf => ##Inf\n  If d is zero => Number/MIN_VALUE\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextUp-double-", :end-row 814, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "next-up", :ns "cljs.math", :row 790} {:arglist-strs ["[d]"], :doc "Returns the adjacent double of d in the direction of ##-Inf.\n  If d is ##NaN => ##NaN\n  If d is ##Inf => Number/MAX_VALUE\n  If d is zero => -Number/MIN_VALUE\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextDown-double-", :end-row 839, :filename "cljs/math.cljs", :fixed-arities #{1}, :name "next-down", :ns "cljs.math", :row 816} {:end-row 841, :filename "cljs/math.cljs", :name "MAX_SCALE", :ns "cljs.math", :private true, :row 841} {:end-row 843, :filename "cljs/math.cljs", :name "two-to-the-double-scale-up", :ns "cljs.math", :private true, :row 843} {:end-row 845, :filename "cljs/math.cljs", :name "two-to-the-double-scale-down", :ns "cljs.math", :private true, :row 845} {:arglist-strs ["[d scaleFactor]"], :doc "Returns d * 2^scaleFactor, scaling by a factor of 2. If the exponent\n  is between min_Float64_exponent and max_Float64_exponent.\n  scaleFactor is an integer\n  If d is ##NaN => ##NaN\n  If d is ##Inf or ##-Inf => ##Inf or ##-Inf respectively\n  If d is zero => zero of same sign as d\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextDown-double-", :end-row 869, :filename "cljs/math.cljs", :fixed-arities #{2}, :name "scalb", :ns "cljs.math", :row 847}]} {:end-row 19, :filename "cljs/pprint.cljs", :name "cljs.pprint", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[base-writer & body]"], :end-row 25, :filename "cljs/pprint.cljc", :lang :clj, :macro true, :name "with-pretty-writer", :ns "cljs.pprint", :row 18} {:fixed-arities #{1}, :end-row 31, :ns "cljs.pprint", :name "getf", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[sym]"], :doc "Get the value of the field a named by the argument (which should be a keyword).", :row 28} {:fixed-arities #{2}, :end-row 38, :ns "cljs.pprint", :name "setf", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[sym new-val]"], :doc "Set the value of the field SYM to NEW-VAL", :row 35} {:arglist-strs ["[type-name & fields]"], :end-row 49, :filename "cljs/pprint.cljc", :lang :clj, :macro true, :name "deftype", :ns "cljs.pprint", :row 40} {:fixed-arities #{2}, :end-row 56, :private true, :ns "cljs.pprint", :name "parse-lb-options", :lang :clj, :filename "cljs/pprint.cljc", :arglist-strs ["[opts body]"], :row 51} {:end-row 80, :ns "cljs.pprint", :name "pprint-logical-block", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Execute the body as a pretty printing logical block with output to *out* which\n  must be a pretty printing writer. When used from pprint or cl-format, this can be\n  assumed.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Before the body, the caller can optionally specify options: :prefix, :per-line-prefix\n  and :suffix.", :row 58} {:fixed-arities #{3}, :end-row 100, :private true, :ns "cljs.pprint", :name "pll-mod-body", :lang :clj, :filename "cljs/pprint.cljc", :arglist-strs ["[env var-sym body]"], :row 90} {:end-row 111, :ns "cljs.pprint", :name "print-length-loop", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "A version of loop that iterates at most *print-length* times. This is designed\n  for use in pretty-printer dispatch functions.", :row 102} {:fixed-arities #{1}, :end-row 119, :private true, :ns "cljs.pprint", :name "process-directive-table-element", :lang :clj, :filename "cljs/pprint.cljc", :arglist-strs ["[[char params flags bracket-info & generator-fn]]"], :row 113} {:end-row 125, :private true, :ns "cljs.pprint", :name "defdirectives", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[& directives]"], :row 121} {:fixed-arities #{1}, :end-row 141, :ns "cljs.pprint", :name "formatter", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning\noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.", :row 127} {:fixed-arities #{1}, :end-row 155, :ns "cljs.pprint", :name "formatter-out", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.", :row 143} {:end-row 161, :ns "cljs.pprint", :name "with-pprint-dispatch", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[function & body]"], :doc "Execute body with the pretty print dispatch function bound to function.", :row 157} {:fixed-arities #{0}, :end-row 167, :ns "cljs.pprint", :name "pp", :lang :clj, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[]"], :doc "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).", :row 163} {:arglist-strs ["[base-writer & body]"], :end-row 25, :filename "cljs/pprint.cljc", :lang :cljs, :macro true, :name "with-pretty-writer", :ns "cljs.pprint", :row 18} {:fixed-arities #{1}, :end-row 31, :ns "cljs.pprint", :name "getf", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[sym]"], :doc "Get the value of the field a named by the argument (which should be a keyword).", :row 28} {:fixed-arities #{2}, :end-row 38, :ns "cljs.pprint", :name "setf", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[sym new-val]"], :doc "Set the value of the field SYM to NEW-VAL", :row 35} {:arglist-strs ["[type-name & fields]"], :end-row 49, :filename "cljs/pprint.cljc", :lang :cljs, :macro true, :name "deftype", :ns "cljs.pprint", :row 40} {:fixed-arities #{2}, :end-row 56, :private true, :ns "cljs.pprint", :name "parse-lb-options", :lang :cljs, :filename "cljs/pprint.cljc", :arglist-strs ["[opts body]"], :row 51} {:end-row 80, :ns "cljs.pprint", :name "pprint-logical-block", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Execute the body as a pretty printing logical block with output to *out* which\n  must be a pretty printing writer. When used from pprint or cl-format, this can be\n  assumed.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Before the body, the caller can optionally specify options: :prefix, :per-line-prefix\n  and :suffix.", :row 58} {:arglist-strs ["[env form]"], :end-row 88, :filename "cljs/pprint.cljc", :fixed-arities #{2}, :lang :cljs, :name "macroexpand", :ns "cljs.pprint", :row 83} {:fixed-arities #{3}, :end-row 100, :private true, :ns "cljs.pprint", :name "pll-mod-body", :lang :cljs, :filename "cljs/pprint.cljc", :arglist-strs ["[env var-sym body]"], :row 90} {:end-row 111, :ns "cljs.pprint", :name "print-length-loop", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "A version of loop that iterates at most *print-length* times. This is designed\n  for use in pretty-printer dispatch functions.", :row 102} {:fixed-arities #{1}, :end-row 119, :private true, :ns "cljs.pprint", :name "process-directive-table-element", :lang :cljs, :filename "cljs/pprint.cljc", :arglist-strs ["[[char params flags bracket-info & generator-fn]]"], :row 113} {:end-row 125, :private true, :ns "cljs.pprint", :name "defdirectives", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[& directives]"], :row 121} {:fixed-arities #{1}, :end-row 141, :ns "cljs.pprint", :name "formatter", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning\noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.", :row 127} {:fixed-arities #{1}, :end-row 155, :ns "cljs.pprint", :name "formatter-out", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.", :row 143} {:end-row 161, :ns "cljs.pprint", :name "with-pprint-dispatch", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[function & body]"], :doc "Execute body with the pretty print dispatch function bound to function.", :row 157} {:fixed-arities #{0}, :end-row 167, :ns "cljs.pprint", :name "pp", :lang :cljs, :filename "cljs/pprint.cljc", :macro true, :arglist-strs ["[]"], :doc "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).", :row 163} {:arglist-strs ["[& more]"], :end-row 26, :filename "cljs/pprint.cljs", :name "print", :ns "cljs.pprint", :private true, :row 25} {:arglist-strs ["[& more]"], :end-row 30, :filename "cljs/pprint.cljs", :name "println", :ns "cljs.pprint", :private true, :row 28} {:arglist-strs ["[c]"], :end-row 42, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "print-char", :ns "cljs.pprint", :private true, :row 32} {:arglist-strs ["[& more]"], :end-row 45, :filename "cljs/pprint.cljs", :name "pr", :ns "cljs.pprint", :private true, :row 44} {:arglist-strs ["[& more]"], :end-row 49, :filename "cljs/pprint.cljs", :name "prn", :ns "cljs.pprint", :private true, :row 47} {:arglist-strs ["[n]"], :doc "Returns true if n is an float.", :end-row 61, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "float?", :ns "cljs.pprint", :row 55} {:arglist-strs ["[c]"], :doc "Convert char to int", :end-row 69, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "char-code", :ns "cljs.pprint", :row 63} {:arglist-strs ["[func initial-context lis]"], :end-row 84, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "map-passing-context", :ns "cljs.pprint", :private true, :row 75} {:arglist-strs ["[func initial-context]"], :end-row 92, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "consume", :ns "cljs.pprint", :private true, :row 86} {:arglist-strs ["[func initial-context]"], :end-row 100, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "consume-while", :ns "cljs.pprint", :private true, :row 94} {:arglist-strs ["[m]"], :end-row 107, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "unzip-map", :ns "cljs.pprint", :private true, :row 102} {:arglist-strs ["[m v1]"], :end-row 111, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "tuple-map", :ns "cljs.pprint", :private true, :row 109} {:arglist-strs ["[s c]"], :end-row 122, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "rtrim", :ns "cljs.pprint", :private true, :row 113} {:arglist-strs ["[s c]"], :end-row 132, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "ltrim", :ns "cljs.pprint", :private true, :row 124} {:arglist-strs ["[aseq val]"], :end-row 142, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "prefix-count", :ns "cljs.pprint", :private true, :row 134} {:end-row 146, :filename "cljs/pprint.cljs", :name "IPrettyFlush", :ns "cljs.pprint", :row 145} {:arglist-strs ["[pp]"], :end-row 146, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "-ppflush", :ns "cljs.pprint", :row 146} {:end-row 152, :filename "cljs/pprint.cljs", :name "*default-page-width*", :ns "cljs.pprint", :private true, :row 152} {:arglist-strs ["[this sym]"], :end-row 155, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "get-field", :ns "cljs.pprint", :private true, :row 154} {:arglist-strs ["[this sym new-val]"], :end-row 158, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "set-field", :ns "cljs.pprint", :private true, :row 157} {:arglist-strs ["[this]"], :end-row 161, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-column", :ns "cljs.pprint", :private true, :row 160} {:arglist-strs ["[this]"], :end-row 164, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-line", :ns "cljs.pprint", :private true, :row 163} {:arglist-strs ["[this]"], :end-row 167, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-max-column", :ns "cljs.pprint", :private true, :row 166} {:arglist-strs ["[this new-max]"], :end-row 171, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "set-max-column", :ns "cljs.pprint", :private true, :row 169} {:arglist-strs ["[this]"], :end-row 174, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-writer", :ns "cljs.pprint", :private true, :row 173} {:arglist-strs ["[this c]"], :end-row 183, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "c-write-char", :ns "cljs.pprint", :private true, :row 177} {:arglist-strs ["[writer]" "[writer max-columns]"], :end-row 215, :filename "cljs/pprint.cljs", :fixed-arities #{1 2}, :name "column-writer", :ns "cljs.pprint", :private true, :row 185} {:end-row 225, :filename "cljs/pprint.cljs", :name "get-miser-width", :ns "cljs.pprint", :row 225} {:end-row 235, :filename "cljs/pprint.cljs", :name "logical-block", :ns "cljs.pprint", :private true, :row 231} {:arglist-strs ["[parent section start-col indent done-nl intra-block-nl prefix per-line-prefix suffix logical-block-callback]"], :end-row 235, :filename "cljs/pprint.cljs", :fixed-arities #{10}, :name "->logical-block", :ns "cljs.pprint", :private true, :row 231} {:arglist-strs ["[m]"], :end-row 235, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "map->logical-block", :ns "cljs.pprint", :private true, :row 231} {:arglist-strs ["[parent child]"], :end-row 242, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "ancestor?", :ns "cljs.pprint", :private true, :row 237} {:arglist-strs ["[l]"], :end-row 248, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "buffer-length", :ns "cljs.pprint", :private true, :row 244} {:arglist-strs ["[]"], :end-row 262, :filename "cljs/pprint.cljs", :fixed-arities #{0}, :name "pp-newline", :ns "cljs.pprint", :private true, :row 262} {:end-row 264, :filename "cljs/pprint.cljs", :name "emit-nl", :ns "cljs.pprint", :row 264} {:end-row 266, :filename "cljs/pprint.cljs", :name "write-token", :ns "cljs.pprint", :private true, :row 266} {:arglist-strs ["[this tokens force-trailing-whitespace]"], :end-row 312, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "write-tokens", :ns "cljs.pprint", :private true, :row 302} {:arglist-strs ["[this tokens]"], :end-row 323, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "tokens-fit?", :ns "cljs.pprint", :private true, :row 319} {:arglist-strs ["[this lb section]"], :end-row 327, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "linear-nl?", :ns "cljs.pprint", :private true, :row 325} {:arglist-strs ["[this lb section]"], :end-row 334, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "miser-nl?", :ns "cljs.pprint", :private true, :row 329} {:end-row 336, :filename "cljs/pprint.cljs", :name "emit-nl?", :ns "cljs.pprint", :private true, :row 336} {:arglist-strs ["[buffer]"], :end-row 364, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-section", :ns "cljs.pprint", :private true, :row 359} {:arglist-strs ["[buffer]"], :end-row 372, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-sub-section", :ns "cljs.pprint", :private true, :row 366} {:arglist-strs ["[lb]"], :end-row 381, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "update-nl-state", :ns "cljs.pprint", :private true, :row 374} {:arglist-strs ["[this nl]"], :end-row 392, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "emit-nl", :ns "cljs.pprint", :private true, :row 383} {:arglist-strs ["[tokens]"], :end-row 396, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "split-at-newline", :ns "cljs.pprint", :private true, :row 394} {:arglist-strs ["[this tokens]"], :end-row 422, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "write-token-string", :ns "cljs.pprint", :private true, :row 400} {:arglist-strs ["[this]"], :end-row 430, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "write-line", :ns "cljs.pprint", :private true, :row 424} {:arglist-strs ["[this token]"], :end-row 437, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "add-to-buffer", :ns "cljs.pprint", :private true, :row 434} {:arglist-strs ["[this]"], :end-row 445, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "write-buffered-output", :ns "cljs.pprint", :private true, :row 440} {:arglist-strs ["[this]"], :end-row 450, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "write-white-space", :ns "cljs.pprint", :private true, :row 447} {:arglist-strs ["[this s]"], :end-row 477, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "write-initial-lines", :ns "cljs.pprint", :private true, :row 454} {:arglist-strs ["[this c]"], :end-row 489, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "p-write-char", :ns "cljs.pprint", :private true, :row 479} {:arglist-strs ["[writer max-columns miser-width]"], :end-row 546, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "pretty-writer", :ns "cljs.pprint", :private true, :row 495} {:arglist-strs ["[this prefix per-line-prefix suffix]"], :end-row 570, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "start-block", :ns "cljs.pprint", :private true, :row 552} {:arglist-strs ["[this]"], :end-row 585, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "end-block", :ns "cljs.pprint", :private true, :row 572} {:arglist-strs ["[this type]"], :end-row 590, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "nl", :ns "cljs.pprint", :private true, :row 587} {:arglist-strs ["[this relative-to offset]"], :end-row 602, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "indent", :ns "cljs.pprint", :private true, :row 592} {:arglist-strs ["[this]"], :end-row 605, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-miser-width", :ns "cljs.pprint", :private true, :row 604} {:doc "Bind to true if you want write to use pretty printing", :end-row 618, :filename "cljs/pprint.cljs", :name "*print-pretty*", :ns "cljs.pprint", :row 616} {:doc "The pretty print dispatch function. Use with-pprint-dispatch or\nset-pprint-dispatch to modify.", :end-row 624, :filename "cljs/pprint.cljs", :name "*print-pprint-dispatch*", :ns "cljs.pprint", :row 620} {:doc "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all\nnon-mandatory newlines.", :end-row 631, :filename "cljs/pprint.cljs", :name "*print-right-margin*", :ns "cljs.pprint", :row 626} {:doc "The column at which to enter miser style. Depending on the dispatch table,\nmiser style add newlines in more places to try to keep lines short allowing for further\nlevels of nesting.", :end-row 638, :filename "cljs/pprint.cljs", :name "*print-miser-width*", :ns "cljs.pprint", :row 633} {:doc "Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)", :end-row 644, :filename "cljs/pprint.cljs", :name "*print-lines*", :ns "cljs.pprint", :private true, :row 641} {:doc "Mark circular structures (N.B. This is not yet used)", :end-row 650, :filename "cljs/pprint.cljs", :name "*print-circle*", :ns "cljs.pprint", :private true, :row 647} {:doc "Mark repeated structures rather than repeat them (N.B. This is not yet used)", :end-row 656, :filename "cljs/pprint.cljs", :name "*print-shared*", :ns "cljs.pprint", :private true, :row 653} {:doc "Don't print namespaces with symbols. This is particularly useful when\npretty printing the results of macro expansions", :end-row 662, :filename "cljs/pprint.cljs", :name "*print-suppress-namespaces*", :ns "cljs.pprint", :row 658} {:doc "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8,\nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the\nradix specifier is in the form #XXr where XX is the decimal value of *print-base* ", :end-row 671, :filename "cljs/pprint.cljs", :name "*print-radix*", :ns "cljs.pprint", :row 666} {:doc "The base to use for printing integers and rationals.", :end-row 676, :filename "cljs/pprint.cljs", :name "*print-base*", :ns "cljs.pprint", :row 673} {:end-row 683, :filename "cljs/pprint.cljs", :name "*current-level*", :ns "cljs.pprint", :private true, :row 683} {:end-row 685, :filename "cljs/pprint.cljs", :name "*current-length*", :ns "cljs.pprint", :private true, :row 685} {:end-row 691, :filename "cljs/pprint.cljs", :name "format-simple-number", :ns "cljs.pprint", :row 691} {:arglist-strs ["[t m]"], :end-row 716, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "table-ize", :ns "cljs.pprint", :private true, :row 713} {:fixed-arities #{1}, :end-row 720, :private true, :ns "cljs.pprint", :name "pretty-writer?", :filename "cljs/pprint.cljs", :arglist-strs ["[x]"], :doc "Return true iff x is a PrettyWriter", :row 718} {:fixed-arities #{3}, :end-row 725, :private true, :ns "cljs.pprint", :name "make-pretty-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[base-writer right-margin miser-width]"], :doc "Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width", :row 722} {:arglist-strs ["[object]"], :doc "Write an object to *out* subject to the current bindings of the printer control\nvariables. Use the kw-args argument to override individual variables for this call (and\nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that\nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. ", :end-row 749, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "write-out", :ns "cljs.pprint", :row 727} {:arglist-strs ["[object & kw-args]"], :doc "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any\nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n", :end-row 812, :filename "cljs/pprint.cljs", :name "write", :ns "cljs.pprint", :row 751} {:arglist-strs ["[object]" "[object writer]"], :end-row 825, :filename "cljs/pprint.cljs", :fixed-arities #{1 2}, :name "pprint", :ns "cljs.pprint", :row 814} {:arglist-strs ["[function]"], :end-row 830, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "set-pprint-dispatch", :ns "cljs.pprint", :row 827} {:arglist-strs ["[arg choices]"], :end-row 839, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "check-enumerated-arg", :ns "cljs.pprint", :private true, :row 836} {:arglist-strs ["[]"], :end-row 842, :filename "cljs/pprint.cljs", :fixed-arities #{0}, :name "level-exceeded", :ns "cljs.pprint", :private true, :row 841} {:arglist-strs ["[kind]"], :doc "Print a conditional newline to a pretty printing stream. kind specifies if the\n  newline is :linear, :miser, :fill, or :mandatory.\n\n  This function is intended for use when writing custom dispatch functions.\n\n  Output is sent to *out* which must be a pretty printing writer.", :end-row 853, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-newline", :ns "cljs.pprint", :row 844} {:arglist-strs ["[relative-to n]"], :doc "Create an indent at this point in the pretty printing stream. This defines how\nfollowing lines are indented. relative-to can be either :block or :current depending\nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", :end-row 866, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "pprint-indent", :ns "cljs.pprint", :row 855} {:arglist-strs ["[kind colnum colinc]"], :doc "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative.\n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.", :end-row 884, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "pprint-tab", :ns "cljs.pprint", :row 869} {:end-row 891, :filename "cljs/pprint.cljs", :name "compile-format", :ns "cljs.pprint", :row 891} {:end-row 892, :filename "cljs/pprint.cljs", :name "execute-format", :ns "cljs.pprint", :row 892} {:end-row 893, :filename "cljs/pprint.cljs", :name "init-navigator", :ns "cljs.pprint", :row 893} {:arglist-strs ["[writer format-in & args]"], :doc "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It\nsupports sophisticated formatting of structured data.\n\nWriter satisfies IWriter, true to output via *print-fn* or nil to output\nto a string, format-in is the format control string and the remaining arguments\nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives'\ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format\nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\"\n                   (count results) results))\n\nPrints via *print-fn*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \"Common Lisp the\nLanguage, 2nd edition\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000)\nand in the Common Lisp HyperSpec at\nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm", :end-row 931, :filename "cljs/pprint.cljs", :name "cl-format", :ns "cljs.pprint", :row 896} {:end-row 933, :filename "cljs/pprint.cljs", :name "*format-str*", :ns "cljs.pprint", :private true, :row 933} {:arglist-strs ["[message offset]"], :end-row 938, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "format-error", :ns "cljs.pprint", :private true, :row 935} {:end-row 947, :filename "cljs/pprint.cljs", :name "arg-navigator", :ns "cljs.pprint", :private true, :row 946} {:arglist-strs ["[seq rest pos]"], :end-row 947, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "->arg-navigator", :ns "cljs.pprint", :private true, :row 946} {:arglist-strs ["[m]"], :end-row 947, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "map->arg-navigator", :ns "cljs.pprint", :private true, :row 946} {:fixed-arities #{1}, :end-row 954, :private true, :ns "cljs.pprint", :name "init-navigator", :filename "cljs/pprint.cljs", :arglist-strs ["[s]"], :doc "Create a new arg-navigator from the sequence with the position set to 0", :row 949} {:arglist-strs ["[navigator]"], :end-row 961, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "next-arg", :ns "cljs.pprint", :private true, :row 957} {:arglist-strs ["[navigator]"], :end-row 967, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "next-arg-or-nil", :ns "cljs.pprint", :private true, :row 963} {:arglist-strs ["[navigator]"], :end-row 975, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-format-arg", :ns "cljs.pprint", :private true, :row 970} {:end-row 977, :filename "cljs/pprint.cljs", :name "relative-reposition", :ns "cljs.pprint", :row 977} {:arglist-strs ["[navigator position]"], :end-row 982, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "absolute-reposition", :ns "cljs.pprint", :private true, :row 979} {:arglist-strs ["[navigator position]"], :end-row 988, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "relative-reposition", :ns "cljs.pprint", :private true, :row 984} {:end-row 991, :filename "cljs/pprint.cljs", :name "compiled-directive", :ns "cljs.pprint", :private true, :row 990} {:arglist-strs ["[func def params offset]"], :end-row 991, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "->compiled-directive", :ns "cljs.pprint", :private true, :row 990} {:arglist-strs ["[m]"], :end-row 991, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "map->compiled-directive", :ns "cljs.pprint", :private true, :row 990} {:arglist-strs ["[[param [raw-val offset]] navigator]"], :end-row 1015, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "realize-parameter", :ns "cljs.pprint", :private true, :row 1001} {:arglist-strs ["[parameter-map navigator]"], :end-row 1020, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "realize-parameter-list", :ns "cljs.pprint", :private true, :row 1017} {:end-row 1030, :filename "cljs/pprint.cljs", :name "opt-base-str", :ns "cljs.pprint", :row 1030} {:end-row 1033, :filename "cljs/pprint.cljs", :name "special-radix-markers", :ns "cljs.pprint", :private true, :row 1032} {:arglist-strs ["[n]"], :end-row 1043, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "format-simple-number", :ns "cljs.pprint", :private true, :row 1035} {:arglist-strs ["[print-func params arg-navigator offsets]"], :end-row 1061, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "format-ascii", :ns "cljs.pprint", :private true, :row 1045} {:fixed-arities #{1}, :end-row 1076, :private true, :ns "cljs.pprint", :name "integral?", :filename "cljs/pprint.cljs", :arglist-strs ["[x]"], :doc "returns true if a number is actually an integer (that is, has no fractional part)", :row 1068} {:fixed-arities #{2}, :end-row 1086, :private true, :ns "cljs.pprint", :name "remainders", :filename "cljs/pprint.cljs", :arglist-strs ["[base val]"], :doc "Return the list of remainders (essentially the 'digits') of val in the given base", :row 1078} {:fixed-arities #{2}, :end-row 1102, :private true, :ns "cljs.pprint", :name "base-str", :filename "cljs/pprint.cljs", :arglist-strs ["[base val]"], :doc "Return val as a string in the given base", :row 1090} {:end-row 1106, :filename "cljs/pprint.cljs", :name "javascript-base-formats", :ns "cljs.pprint", :private true, :row 1105} {:fixed-arities #{2}, :end-row 1111, :private true, :ns "cljs.pprint", :name "opt-base-str", :filename "cljs/pprint.cljs", :arglist-strs ["[base val]"], :doc "Return val as a string in the given base. No cljs format, so no improved performance.", :row 1108} {:arglist-strs ["[unit lis]"], :end-row 1116, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "group-by*", :ns "cljs.pprint", :private true, :row 1113} {:arglist-strs ["[base params arg-navigator offsets]"], :end-row 1142, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "format-integer", :ns "cljs.pprint", :private true, :row 1118} {:end-row 1152, :filename "cljs/pprint.cljs", :name "english-cardinal-units", :ns "cljs.pprint", :private true, :row 1148} {:end-row 1158, :filename "cljs/pprint.cljs", :name "english-ordinal-units", :ns "cljs.pprint", :private true, :row 1154} {:end-row 1162, :filename "cljs/pprint.cljs", :name "english-cardinal-tens", :ns "cljs.pprint", :private true, :row 1160} {:end-row 1167, :filename "cljs/pprint.cljs", :name "english-ordinal-tens", :ns "cljs.pprint", :private true, :row 1164} {:end-row 1179, :filename "cljs/pprint.cljs", :name "english-scale-numbers", :ns "cljs.pprint", :private true, :row 1173} {:fixed-arities #{1}, :end-row 1197, :private true, :ns "cljs.pprint", :name "format-simple-cardinal", :filename "cljs/pprint.cljs", :arglist-strs ["[num]"], :doc "Convert a number less than 1000 to a cardinal english string", :row 1181} {:fixed-arities #{2}, :end-row 1220, :private true, :ns "cljs.pprint", :name "add-english-scales", :filename "cljs/pprint.cljs", :arglist-strs ["[parts offset]"], :doc "Take a sequence of parts, add scale numbers (e.g., million) and combine into a string\n  offset is a factor of 10^3 to multiply by", :row 1199} {:arglist-strs ["[params navigator offsets]"], :end-row 1237, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-cardinal-english", :ns "cljs.pprint", :private true, :row 1222} {:fixed-arities #{1}, :end-row 1259, :private true, :ns "cljs.pprint", :name "format-simple-ordinal", :filename "cljs/pprint.cljs", :arglist-strs ["[num]"], :doc "Convert a number less than 1000 to a ordinal english string\n  Note this should only be used for the last one in the sequence", :row 1239} {:arglist-strs ["[params navigator offsets]"], :end-row 1291, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-ordinal-english", :ns "cljs.pprint", :private true, :row 1261} {:end-row 1302, :filename "cljs/pprint.cljs", :name "old-roman-table", :ns "cljs.pprint", :private true, :row 1297} {:end-row 1309, :filename "cljs/pprint.cljs", :name "new-roman-table", :ns "cljs.pprint", :private true, :row 1304} {:fixed-arities #{4}, :end-row 1333, :private true, :ns "cljs.pprint", :name "format-roman", :filename "cljs/pprint.cljs", :arglist-strs ["[table params navigator offsets]"], :doc "Format a roman numeral using the specified look-up table", :row 1311} {:arglist-strs ["[params navigator offsets]"], :end-row 1336, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-old-roman", :ns "cljs.pprint", :private true, :row 1335} {:arglist-strs ["[params navigator offsets]"], :end-row 1339, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-new-roman", :ns "cljs.pprint", :private true, :row 1338} {:end-row 1346, :filename "cljs/pprint.cljs", :name "special-chars", :ns "cljs.pprint", :private true, :row 1345} {:arglist-strs ["[params navigator offsets]"], :end-row 1360, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "pretty-character", :ns "cljs.pprint", :private true, :row 1348} {:arglist-strs ["[params navigator offsets]"], :end-row 1368, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "readable-character", :ns "cljs.pprint", :private true, :row 1362} {:arglist-strs ["[params navigator offsets]"], :end-row 1373, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "plain-character", :ns "cljs.pprint", :private true, :row 1370} {:arglist-strs ["[context]"], :end-row 1379, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "abort?", :ns "cljs.pprint", :private true, :row 1377} {:arglist-strs ["[format args base-args]"], :end-row 1393, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "execute-sub-format", :ns "cljs.pprint", :private true, :row 1382} {:fixed-arities #{1}, :end-row 1412, :private true, :ns "cljs.pprint", :name "float-parts-base", :filename "cljs/pprint.cljs", :arglist-strs ["[f]"], :doc "Produce string parts for the mantissa (normalize 1-9) and exponent", :row 1400} {:fixed-arities #{1}, :end-row 1424, :private true, :ns "cljs.pprint", :name "float-parts", :filename "cljs/pprint.cljs", :arglist-strs ["[f]"], :doc "Take care of leading and trailing zeros in decomposed floats", :row 1414} {:fixed-arities #{1}, :end-row 1440, :private true, :ns "cljs.pprint", :name "inc-s", :filename "cljs/pprint.cljs", :arglist-strs ["[s]"], :doc "Assumption: The input string consists of one or more decimal digits,\n  and no other characters. Return a string containing one or more\n  decimal digits containing a decimal number one larger than the input\n  string. The output string will always be the same length as the input\n  string, or one character longer.", :row 1426} {:arglist-strs ["[m e d w]"], :end-row 1486, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "round-str", :ns "cljs.pprint", :private true, :row 1442} {:arglist-strs ["[m e d]"], :end-row 1496, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "expand-fixed", :ns "cljs.pprint", :private true, :row 1488} {:fixed-arities #{2}, :end-row 1504, :private true, :ns "cljs.pprint", :name "insert-decimal", :filename "cljs/pprint.cljs", :arglist-strs ["[m e]"], :doc "Insert the decimal point at the right spot in the number to match an exponent", :row 1498} {:arglist-strs ["[m e d]"], :end-row 1507, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "get-fixed", :ns "cljs.pprint", :private true, :row 1506} {:fixed-arities #{2}, :end-row 1514, :private true, :ns "cljs.pprint", :name "insert-scaled-decimal", :filename "cljs/pprint.cljs", :arglist-strs ["[m k]"], :doc "Insert the decimal point at the right spot in the number to match an exponent", :row 1509} {:arglist-strs ["[x]"], :end-row 1518, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "convert-ratio", :ns "cljs.pprint", :private true, :row 1517} {:arglist-strs ["[params navigator offsets]"], :end-row 1564, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "fixed-float", :ns "cljs.pprint", :private true, :row 1522} {:arglist-strs ["[params navigator offset]"], :end-row 1636, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "exponential-float", :ns "cljs.pprint", :private true, :row 1569} {:arglist-strs ["[params navigator offsets]"], :end-row 1662, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "general-float", :ns "cljs.pprint", :private true, :row 1643} {:arglist-strs ["[params navigator offsets]"], :end-row 1682, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "dollar-float", :ns "cljs.pprint", :private true, :row 1666} {:arglist-strs ["[params arg-navigator offsets]"], :end-row 1701, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "choice-conditional", :ns "cljs.pprint", :private true, :row 1692} {:arglist-strs ["[params arg-navigator offsets]"], :end-row 1712, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "boolean-conditional", :ns "cljs.pprint", :private true, :row 1704} {:arglist-strs ["[params arg-navigator offsets]"], :end-row 1724, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "check-arg-conditional", :ns "cljs.pprint", :private true, :row 1716} {:arglist-strs ["[params navigator offsets]"], :end-row 1754, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "iterate-sublist", :ns "cljs.pprint", :private true, :row 1733} {:arglist-strs ["[params navigator offsets]"], :end-row 1777, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "iterate-list-of-sublists", :ns "cljs.pprint", :private true, :row 1758} {:arglist-strs ["[params navigator offsets]"], :end-row 1801, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "iterate-main-list", :ns "cljs.pprint", :private true, :row 1781} {:arglist-strs ["[params navigator offsets]"], :end-row 1821, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "iterate-main-sublists", :ns "cljs.pprint", :private true, :row 1805} {:end-row 1836, :filename "cljs/pprint.cljs", :name "format-logical-block", :ns "cljs.pprint", :row 1836} {:end-row 1837, :filename "cljs/pprint.cljs", :name "justify-clauses", :ns "cljs.pprint", :row 1837} {:arglist-strs ["[params navigator offsets]"], :end-row 1842, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "logical-block-or-justify", :ns "cljs.pprint", :private true, :row 1839} {:arglist-strs ["[clauses navigator base-navigator]"], :end-row 1861, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "render-clauses", :ns "cljs.pprint", :private true, :row 1848} {:arglist-strs ["[params navigator offsets]"], :end-row 1909, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "justify-clauses", :ns "cljs.pprint", :private true, :row 1864} {:fixed-arities #{1}, :end-row 1938, :private true, :ns "cljs.pprint", :name "downcase-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, converting all characters to lower case", :row 1919} {:fixed-arities #{1}, :end-row 1959, :private true, :ns "cljs.pprint", :name "upcase-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, converting all characters to upper case", :row 1940} {:fixed-arities #{2}, :end-row 1982, :private true, :ns "cljs.pprint", :name "capitalize-string", :filename "cljs/pprint.cljs", :arglist-strs ["[s first?]"], :doc "Capitalizes the words in a string. If first? is false, don't capitalize the\n                                      first character of the string even if it's a letter.", :row 1961} {:fixed-arities #{1}, :end-row 2008, :private true, :ns "cljs.pprint", :name "capitalize-word-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, capitalizing all words", :row 1984} {:fixed-arities #{1}, :end-row 2043, :private true, :ns "cljs.pprint", :name "init-cap-writer", :filename "cljs/pprint.cljs", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, capitalizing the first word", :row 2010} {:arglist-strs ["[make-writer params navigator offsets]"], :end-row 2048, :filename "cljs/pprint.cljs", :fixed-arities #{4}, :name "modify-case", :ns "cljs.pprint", :private true, :row 2045} {:arglist-strs ["[writer]"], :doc "Returns the IWriter passed in wrapped in a pretty writer proxy, unless it's\nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be\npreserved across calls, you will want to wrap them with this.\n\nFor example, when you want to generate column-aware output with multiple calls to cl-format,\ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \"~4D~7,vT\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1\n       2      4       8\n       3      9      27\n       4     16      64\n       5     25     125\n       6     36     216\n       7     49     343\n       8     64     512\n       9     81     729\n      10    100    1000", :end-row 2090, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "get-pretty-writer", :ns "cljs.pprint", :row 2055} {:arglist-strs ["[]"], :doc "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.", :end-row 2103, :filename "cljs/pprint.cljs", :fixed-arities #{0}, :name "fresh-line", :ns "cljs.pprint", :row 2096} {:arglist-strs ["[params navigator offsets]"], :end-row 2114, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "absolute-tabulation", :ns "cljs.pprint", :private true, :row 2105} {:arglist-strs ["[params navigator offsets]"], :end-row 2123, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "relative-tabulation", :ns "cljs.pprint", :private true, :row 2116} {:arglist-strs ["[params navigator offsets]"], :end-row 2147, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "format-logical-block", :ns "cljs.pprint", :private true, :row 2131} {:arglist-strs ["[params navigator offsets]"], :end-row 2152, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "set-indent", :ns "cljs.pprint", :private true, :row 2149} {:arglist-strs ["[params navigator offsets]"], :end-row 2160, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "conditional-newline", :ns "cljs.pprint", :private true, :row 2155} {:end-row 2450, :filename "cljs/pprint.cljs", :name "param-pattern", :ns "cljs.pprint", :private true, :row 2449} {:end-row 2453, :filename "cljs/pprint.cljs", :name "special-params", :ns "cljs.pprint", :private true, :row 2452} {:arglist-strs ["[[s offset saw-comma]]"], :end-row 2467, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "extract-param", :ns "cljs.pprint", :private true, :row 2455} {:arglist-strs ["[s offset]"], :end-row 2470, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "extract-params", :ns "cljs.pprint", :private true, :row 2469} {:fixed-arities #{1}, :end-row 2482, :private true, :ns "cljs.pprint", :name "translate-param", :filename "cljs/pprint.cljs", :arglist-strs ["[[p offset]]"], :doc "Translate the string representation of a param to the internalized\n                                      representation", :row 2472} {:end-row 2485, :filename "cljs/pprint.cljs", :name "flag-defs", :ns "cljs.pprint", :private true, :row 2484} {:arglist-strs ["[s offset]"], :end-row 2500, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "extract-flags", :ns "cljs.pprint", :private true, :row 2487} {:arglist-strs ["[def flags]"], :end-row 2513, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "check-flags", :ns "cljs.pprint", :private true, :row 2502} {:fixed-arities #{4}, :end-row 2543, :private true, :ns "cljs.pprint", :name "map-params", :filename "cljs/pprint.cljs", :arglist-strs ["[def params flags offset]"], :doc "Takes a directive definition and the list of actual parameters and\na map of flags and returns a map of the parameters and flags with defaults\nfilled in. We check to make sure that there are the right types and number\nof parameters as well.", :row 2515} {:arglist-strs ["[s offset]"], :end-row 2563, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "compile-directive", :ns "cljs.pprint", :private true, :row 2545} {:arglist-strs ["[s offset]"], :end-row 2566, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "compile-raw-string", :ns "cljs.pprint", :private true, :row 2565} {:arglist-strs ["[this]"], :end-row 2568, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "right-bracket", :ns "cljs.pprint", :private true, :row 2568} {:arglist-strs ["[this]"], :end-row 2570, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "separator?", :ns "cljs.pprint", :private true, :row 2570} {:arglist-strs ["[this]"], :end-row 2574, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "else-separator?", :ns "cljs.pprint", :private true, :row 2572} {:end-row 2576, :filename "cljs/pprint.cljs", :name "collect-clauses", :ns "cljs.pprint", :row 2576} {:arglist-strs ["[this remainder]"], :end-row 2585, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "process-bracket", :ns "cljs.pprint", :private true, :row 2578} {:arglist-strs ["[bracket-info offset remainder]"], :end-row 2609, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "process-clause", :ns "cljs.pprint", :private true, :row 2587} {:arglist-strs ["[bracket-info offset remainder]"], :end-row 2658, :filename "cljs/pprint.cljs", :fixed-arities #{3}, :name "collect-clauses", :ns "cljs.pprint", :private true, :row 2611} {:fixed-arities #{1}, :end-row 2673, :private true, :ns "cljs.pprint", :name "process-nesting", :filename "cljs/pprint.cljs", :arglist-strs ["[format]"], :doc "Take a linearly compiled format and process the bracket directives to give it\n   the appropriate tree structure", :row 2660} {:fixed-arities #{1}, :end-row 2693, :private true, :ns "cljs.pprint", :name "compile-format", :filename "cljs/pprint.cljs", :arglist-strs ["[format-str]"], :doc "Compiles format-str into a compiled format which can be used as an argument\nto cl-format just like a plain format string. Use this function for improved\nperformance when you're using the same format string repeatedly", :row 2675} {:fixed-arities #{1}, :end-row 2706, :private true, :ns "cljs.pprint", :name "needs-pretty", :filename "cljs/pprint.cljs", :arglist-strs ["[format]"], :doc "determine whether a given compiled format has any directives that depend on the\ncolumn number or pretty printing", :row 2695} {:fixed-arities #{3 2}, :end-row 2754, :private true, :ns "cljs.pprint", :name "execute-format", :filename "cljs/pprint.cljs", :arglist-strs ["[stream format args]" "[format args]"], :doc "Executes the format with the arguments.", :row 2720} {:end-row 2758, :filename "cljs/pprint.cljs", :name "cached-compile", :ns "cljs.pprint", :private true, :row 2758} {:fixed-arities #{3}, :end-row 2767, :private true, :ns "cljs.pprint", :name "use-method", :filename "cljs/pprint.cljs", :arglist-strs ["[multifn dispatch-val func]"], :doc "Installs a function as a new method of multimethod associated with dispatch-value. ", :row 2764} {:end-row 2795, :filename "cljs/pprint.cljs", :name "reader-macros", :ns "cljs.pprint", :private true, :row 2789} {:arglist-strs ["[alis]"], :end-row 2802, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-reader-macro", :ns "cljs.pprint", :private true, :row 2797} {:arglist-strs ["[alis]"], :end-row 2822, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-simple-list", :ns "cljs.pprint", :private true, :row 2814} {:arglist-strs ["[alis]"], :end-row 2826, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-list", :ns "cljs.pprint", :private true, :row 2824} {:arglist-strs ["[avec]"], :end-row 2837, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-vector", :ns "cljs.pprint", :private true, :row 2829} {:end-row 2839, :filename "cljs/pprint.cljs", :name "pprint-array", :ns "cljs.pprint", :private true, :row 2839} {:arglist-strs ["[amap]"], :end-row 2861, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-map", :ns "cljs.pprint", :private true, :row 2842} {:arglist-strs ["[obj]"], :end-row 2865, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-simple-default", :ns "cljs.pprint", :private true, :row 2863} {:end-row 2867, :filename "cljs/pprint.cljs", :name "pprint-set", :ns "cljs.pprint", :row 2867} {:end-row 2871, :filename "cljs/pprint.cljs", :name "type-map", :ns "cljs.pprint", :private true, :row 2869} {:fixed-arities #{1}, :end-row 2878, :private true, :ns "cljs.pprint", :name "map-ref-type", :filename "cljs/pprint.cljs", :arglist-strs ["[name]"], :doc "Map ugly type names to something simpler", :row 2873} {:arglist-strs ["[o]"], :end-row 2889, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-ideref", :ns "cljs.pprint", :private true, :row 2880} {:end-row 2891, :filename "cljs/pprint.cljs", :name "pprint-pqueue", :ns "cljs.pprint", :private true, :row 2891} {:arglist-strs ["[obj]"], :end-row 2903, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "type-dispatcher", :ns "cljs.pprint", :private true, :row 2893} {:doc "The pretty print dispatch function for simple data structure format.", :end-row 2907, :filename "cljs/pprint.cljs", :name "simple-dispatch", :ns "cljs.pprint", :row 2905} {:end-row 2922, :filename "cljs/pprint.cljs", :name "pprint-simple-code-list", :ns "cljs.pprint", :row 2922} {:fixed-arities #{1}, :end-row 2935, :private true, :ns "cljs.pprint", :name "brackets", :filename "cljs/pprint.cljs", :arglist-strs ["[form]"], :doc "Figure out which kind of brackets to use", :row 2930} {:fixed-arities #{1}, :end-row 2969, :private true, :ns "cljs.pprint", :name "pprint-ns-reference", :filename "cljs/pprint.cljs", :arglist-strs ["[reference]"], :doc "Pretty print a single reference (import, use, etc.) from a namespace decl", :row 2937} {:fixed-arities #{1}, :end-row 2995, :private true, :ns "cljs.pprint", :name "pprint-ns", :filename "cljs/pprint.cljs", :arglist-strs ["[alis]"], :doc "The pretty print dispatch chunk for the ns macro", :row 2971} {:end-row 3002, :filename "cljs/pprint.cljs", :name "pprint-hold-first", :ns "cljs.pprint", :private true, :row 3002} {:arglist-strs ["[alis has-doc-str?]"], :end-row 3015, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "single-defn", :ns "cljs.pprint", :private true, :row 3009} {:arglist-strs ["[alis has-doc-str?]"], :end-row 3020, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "multi-defn", :ns "cljs.pprint", :private true, :row 3018} {:arglist-strs ["[alis]"], :end-row 3043, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-defn", :ns "cljs.pprint", :private true, :row 3024} {:arglist-strs ["[binding-vec]"], :end-row 3062, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-binding-form", :ns "cljs.pprint", :private true, :row 3049} {:arglist-strs ["[alis]"], :end-row 3072, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-let", :ns "cljs.pprint", :private true, :row 3064} {:end-row 3078, :filename "cljs/pprint.cljs", :name "pprint-if", :ns "cljs.pprint", :private true, :row 3078} {:arglist-strs ["[alis]"], :end-row 3098, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-cond", :ns "cljs.pprint", :private true, :row 3080} {:arglist-strs ["[alis]"], :end-row 3117, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-condp", :ns "cljs.pprint", :private true, :row 3100} {:end-row 3120, :filename "cljs/pprint.cljs", :name "*symbol-map*", :ns "cljs.pprint", :private true, :row 3120} {:arglist-strs ["[alis]"], :end-row 3134, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-anon-func", :ns "cljs.pprint", :private true, :row 3122} {:arglist-strs ["[alis]"], :end-row 3153, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-simple-code-list", :ns "cljs.pprint", :private true, :row 3144} {:arglist-strs ["[amap]"], :end-row 3162, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "two-forms", :ns "cljs.pprint", :private true, :row 3157} {:arglist-strs ["[amap]"], :end-row 3171, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "add-core-ns", :ns "cljs.pprint", :private true, :row 3164} {:end-row 3188, :filename "cljs/pprint.cljs", :name "*code-table*", :ns "cljs.pprint", :private true, :row 3173} {:arglist-strs ["[alis]"], :end-row 3194, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-code-list", :ns "cljs.pprint", :private true, :row 3190} {:arglist-strs ["[sym]"], :end-row 3201, :filename "cljs/pprint.cljs", :fixed-arities #{1}, :name "pprint-code-symbol", :ns "cljs.pprint", :private true, :row 3196} {:doc "The pretty print dispatch function for pretty printing Clojure code.", :end-row 3207, :filename "cljs/pprint.cljs", :name "code-dispatch", :ns "cljs.pprint", :row 3203} {:arglist-strs ["[width s]"], :end-row 3300, :filename "cljs/pprint.cljs", :fixed-arities #{2}, :name "add-padding", :ns "cljs.pprint", :private true, :row 3298} {:arglist-strs ["[ks rows]" "[rows]"], :doc "Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.", :end-row 3325, :filename "cljs/pprint.cljs", :fixed-arities #{1 2}, :name "print-table", :ns "cljs.pprint", :row 3302}]} {:end-row 20, :filename "cljs/externs.clj", :name "cljs.externs", :row 9, :ns nil, :var-definitions [{:end-row 22, :filename "cljs/externs.clj", :name "*ignore-var*", :ns "cljs.externs", :row 22} {:end-row 23, :filename "cljs/externs.clj", :name "*source-file*", :ns "cljs.externs", :row 23} {:end-row 24, :filename "cljs/externs.clj", :name "*goog-ns*", :ns "cljs.externs", :row 24} {:arglist-strs ["[props ty]"], :doc "Given a sequential list of properties [foo core baz] representing segments\n  of the namespace, annotate the last symbol with the type information.", :end-row 36, :filename "cljs/externs.clj", :fixed-arities #{2}, :name "annotate", :ns "cljs.externs", :row 29} {:arglist-strs ["[texpr]"], :end-row 44, :filename "cljs/externs.clj", :fixed-arities #{1}, :name "get-tag", :ns "cljs.externs", :row 38} {:arglist-strs ["[xs]"], :end-row 54, :filename "cljs/externs.clj", :fixed-arities #{1}, :name "params->method-params", :ns "cljs.externs", :row 46} {:arglist-strs ["[t]"], :end-row 58, :filename "cljs/externs.clj", :fixed-arities #{1}, :name "generic?", :ns "cljs.externs", :row 56} {:arglist-strs ["[t]"], :end-row 65, :filename "cljs/externs.clj", :fixed-arities #{1}, :name "gtype->cljs-type", :ns "cljs.externs", :row 60} {:arglist-strs ["[node]"], :end-row 98, :filename "cljs/externs.clj", :fixed-arities #{1}, :name "get-var-info", :ns "cljs.externs", :row 67} {:end-row 102, :filename "cljs/externs.clj", :name "parse-extern-node", :ns "cljs.externs", :row 100} {:arglist-strs ["[source-file]"], :doc "Returns a sequential collection of the form:\n\n    [[foo core first]\n     [foo core next]\n     [foo core baz last] ...]\n\n  Where the last symbol is annotated with var info via metadata. This simple\n  structure captures the nested form of Closure namespaces and aids\n  direct indexing.", :end-row 220, :filename "cljs/externs.clj", :fixed-arities #{1}, :name "parse-externs", :ns "cljs.externs", :row 185} {:arglist-strs ["[externs]"], :end-row 227, :filename "cljs/externs.clj", :fixed-arities #{1}, :name "index-externs", :ns "cljs.externs", :row 222} {:arglist-strs ["[]" "[sources]" "[sources defaults]"], :end-row 249, :filename "cljs/externs.clj", :fixed-arities #{0 1 2}, :name "externs-map*", :ns "cljs.externs", :row 229} {:end-row 251, :filename "cljs/externs.clj", :name "externs-map", :ns "cljs.externs", :row 251} {:arglist-strs ["[ns-segs var-segs]"], :end-row 259, :filename "cljs/externs.clj", :fixed-arities #{2}, :name "ns-match?", :ns "cljs.externs", :row 253} {:end-row 261, :filename "cljs/externs.clj", :name "parsed->defs", :ns "cljs.externs", :row 261} {:arglist-strs ["[resource]"], :end-row 296, :filename "cljs/externs.clj", :fixed-arities #{1}, :name "resource->source-file", :ns "cljs.externs", :row 291} {:arglist-strs ["[f]" "[f ns]"], :end-row 309, :filename "cljs/externs.clj", :fixed-arities #{1 2}, :name "analyze-goog-file", :ns "cljs.externs", :row 298}]} {:end-row 13, :filename "cljs/nodejs.cljs", :name "cljs.nodejs", :row 12, :ns nil, :var-definitions [{:end-row 16, :filename "cljs/nodejs.cljs", :name "require", :ns "cljs.nodejs", :row 16} {:end-row 17, :filename "cljs/nodejs.cljs", :name "process", :ns "cljs.nodejs", :row 17} {:arglist-strs ["[]"], :end-row 27, :filename "cljs/nodejs.cljs", :fixed-arities #{0}, :name "enable-util-print!", :ns "cljs.nodejs", :row 19}]} {:end-row 9, :filename "cljs/source_map/base64.cljs", :name "cljs.source-map.base64", :row 9, :ns nil, :var-definitions [{:end-row 11, :filename "cljs/source_map/base64.cljs", :name "chars64", :ns "cljs.source-map.base64", :row 11} {:end-row 12, :filename "cljs/source_map/base64.cljs", :name "char->int", :ns "cljs.source-map.base64", :row 12} {:end-row 13, :filename "cljs/source_map/base64.cljs", :name "int->char", :ns "cljs.source-map.base64", :row 13} {:arglist-strs ["[n]"], :end-row 19, :filename "cljs/source_map/base64.cljs", :fixed-arities #{1}, :name "encode", :ns "cljs.source-map.base64", :row 15} {:arglist-strs ["[c]"], :end-row 25, :filename "cljs/source_map/base64.cljs", :fixed-arities #{1}, :name "decode", :ns "cljs.source-map.base64", :row 21} {:end-row 11, :filename "cljs/source_map/base64.clj", :name "chars64", :ns "cljs.source-map.base64", :row 11} {:end-row 12, :filename "cljs/source_map/base64.clj", :name "char->int", :ns "cljs.source-map.base64", :row 12} {:end-row 13, :filename "cljs/source_map/base64.clj", :name "int->char", :ns "cljs.source-map.base64", :row 13} {:arglist-strs ["[n]"], :end-row 22, :filename "cljs/source_map/base64.clj", :fixed-arities #{1}, :name "encode", :ns "cljs.source-map.base64", :row 15} {:arglist-strs ["[c]"], :end-row 28, :filename "cljs/source_map/base64.clj", :fixed-arities #{1}, :name "decode", :ns "cljs.source-map.base64", :row 24}]} {:end-row 9, :filename "cljs/source_map/base64.clj", :name "cljs.source-map.base64", :row 9, :ns nil, :var-definitions [{:end-row 11, :filename "cljs/source_map/base64.cljs", :name "chars64", :ns "cljs.source-map.base64", :row 11} {:end-row 12, :filename "cljs/source_map/base64.cljs", :name "char->int", :ns "cljs.source-map.base64", :row 12} {:end-row 13, :filename "cljs/source_map/base64.cljs", :name "int->char", :ns "cljs.source-map.base64", :row 13} {:arglist-strs ["[n]"], :end-row 19, :filename "cljs/source_map/base64.cljs", :fixed-arities #{1}, :name "encode", :ns "cljs.source-map.base64", :row 15} {:arglist-strs ["[c]"], :end-row 25, :filename "cljs/source_map/base64.cljs", :fixed-arities #{1}, :name "decode", :ns "cljs.source-map.base64", :row 21} {:end-row 11, :filename "cljs/source_map/base64.clj", :name "chars64", :ns "cljs.source-map.base64", :row 11} {:end-row 12, :filename "cljs/source_map/base64.clj", :name "char->int", :ns "cljs.source-map.base64", :row 12} {:end-row 13, :filename "cljs/source_map/base64.clj", :name "int->char", :ns "cljs.source-map.base64", :row 13} {:arglist-strs ["[n]"], :end-row 22, :filename "cljs/source_map/base64.clj", :fixed-arities #{1}, :name "encode", :ns "cljs.source-map.base64", :row 15} {:arglist-strs ["[c]"], :end-row 28, :filename "cljs/source_map/base64.clj", :fixed-arities #{1}, :name "decode", :ns "cljs.source-map.base64", :row 24}]} {:end-row 11, :filename "cljs/source_map/base64_vlq.clj", :name "cljs.source-map.base64-vlq", :row 9, :ns nil, :var-definitions [{:end-row 13, :filename "cljs/source_map/base64_vlq.clj", :name "vlq-base-shift", :ns "cljs.source-map.base64-vlq", :row 13} {:end-row 14, :filename "cljs/source_map/base64_vlq.clj", :name "vlq-base", :ns "cljs.source-map.base64-vlq", :row 14} {:end-row 15, :filename "cljs/source_map/base64_vlq.clj", :name "vlq-base-mask", :ns "cljs.source-map.base64-vlq", :row 15} {:end-row 16, :filename "cljs/source_map/base64_vlq.clj", :name "vlq-continuation-bit", :ns "cljs.source-map.base64-vlq", :row 16} {:arglist-strs ["[x n]"], :end-row 19, :filename "cljs/source_map/base64_vlq.clj", :fixed-arities #{2}, :name "bit-shift-right-zero-fill", :ns "cljs.source-map.base64-vlq", :row 18} {:arglist-strs ["[v]"], :end-row 24, :filename "cljs/source_map/base64_vlq.clj", :fixed-arities #{1}, :name "to-vlq-signed", :ns "cljs.source-map.base64-vlq", :row 21} {:arglist-strs ["[v]"], :end-row 31, :filename "cljs/source_map/base64_vlq.clj", :fixed-arities #{1}, :name "from-vlq-signed", :ns "cljs.source-map.base64-vlq", :row 26} {:arglist-strs ["[n]"], :end-row 44, :filename "cljs/source_map/base64_vlq.clj", :fixed-arities #{1}, :name "encode-val", :ns "cljs.source-map.base64-vlq", :row 33} {:arglist-strs ["[v]"], :end-row 47, :filename "cljs/source_map/base64_vlq.clj", :fixed-arities #{1}, :name "encode", :ns "cljs.source-map.base64-vlq", :row 46} {:arglist-strs ["[s]"], :end-row 66, :filename "cljs/source_map/base64_vlq.clj", :fixed-arities #{1}, :name "decode", :ns "cljs.source-map.base64-vlq", :row 49} {:end-row 14, :filename "cljs/source_map/base64_vlq.cljs", :name "vlq-base-shift", :ns "cljs.source-map.base64-vlq", :row 14} {:end-row 15, :filename "cljs/source_map/base64_vlq.cljs", :name "vlq-base", :ns "cljs.source-map.base64-vlq", :row 15} {:end-row 16, :filename "cljs/source_map/base64_vlq.cljs", :name "vlq-base-mask", :ns "cljs.source-map.base64-vlq", :row 16} {:end-row 17, :filename "cljs/source_map/base64_vlq.cljs", :name "vlq-continuation-bit", :ns "cljs.source-map.base64-vlq", :row 17} {:arglist-strs ["[v]"], :end-row 22, :filename "cljs/source_map/base64_vlq.cljs", :fixed-arities #{1}, :name "to-vlq-signed", :ns "cljs.source-map.base64-vlq", :row 19} {:arglist-strs ["[v]"], :end-row 29, :filename "cljs/source_map/base64_vlq.cljs", :fixed-arities #{1}, :name "from-vlq-signed", :ns "cljs.source-map.base64-vlq", :row 24} {:arglist-strs ["[n]"], :end-row 42, :filename "cljs/source_map/base64_vlq.cljs", :fixed-arities #{1}, :name "encode-val", :ns "cljs.source-map.base64-vlq", :row 31} {:arglist-strs ["[v]"], :end-row 45, :filename "cljs/source_map/base64_vlq.cljs", :fixed-arities #{1}, :name "encode", :ns "cljs.source-map.base64-vlq", :row 44} {:arglist-strs ["[s]"], :end-row 64, :filename "cljs/source_map/base64_vlq.cljs", :fixed-arities #{1}, :name "decode", :ns "cljs.source-map.base64-vlq", :row 47}]} {:end-row 12, :filename "cljs/source_map/base64_vlq.cljs", :name "cljs.source-map.base64-vlq", :row 9, :ns nil, :var-definitions [{:end-row 13, :filename "cljs/source_map/base64_vlq.clj", :name "vlq-base-shift", :ns "cljs.source-map.base64-vlq", :row 13} {:end-row 14, :filename "cljs/source_map/base64_vlq.clj", :name "vlq-base", :ns "cljs.source-map.base64-vlq", :row 14} {:end-row 15, :filename "cljs/source_map/base64_vlq.clj", :name "vlq-base-mask", :ns "cljs.source-map.base64-vlq", :row 15} {:end-row 16, :filename "cljs/source_map/base64_vlq.clj", :name "vlq-continuation-bit", :ns "cljs.source-map.base64-vlq", :row 16} {:arglist-strs ["[x n]"], :end-row 19, :filename "cljs/source_map/base64_vlq.clj", :fixed-arities #{2}, :name "bit-shift-right-zero-fill", :ns "cljs.source-map.base64-vlq", :row 18} {:arglist-strs ["[v]"], :end-row 24, :filename "cljs/source_map/base64_vlq.clj", :fixed-arities #{1}, :name "to-vlq-signed", :ns "cljs.source-map.base64-vlq", :row 21} {:arglist-strs ["[v]"], :end-row 31, :filename "cljs/source_map/base64_vlq.clj", :fixed-arities #{1}, :name "from-vlq-signed", :ns "cljs.source-map.base64-vlq", :row 26} {:arglist-strs ["[n]"], :end-row 44, :filename "cljs/source_map/base64_vlq.clj", :fixed-arities #{1}, :name "encode-val", :ns "cljs.source-map.base64-vlq", :row 33} {:arglist-strs ["[v]"], :end-row 47, :filename "cljs/source_map/base64_vlq.clj", :fixed-arities #{1}, :name "encode", :ns "cljs.source-map.base64-vlq", :row 46} {:arglist-strs ["[s]"], :end-row 66, :filename "cljs/source_map/base64_vlq.clj", :fixed-arities #{1}, :name "decode", :ns "cljs.source-map.base64-vlq", :row 49} {:end-row 14, :filename "cljs/source_map/base64_vlq.cljs", :name "vlq-base-shift", :ns "cljs.source-map.base64-vlq", :row 14} {:end-row 15, :filename "cljs/source_map/base64_vlq.cljs", :name "vlq-base", :ns "cljs.source-map.base64-vlq", :row 15} {:end-row 16, :filename "cljs/source_map/base64_vlq.cljs", :name "vlq-base-mask", :ns "cljs.source-map.base64-vlq", :row 16} {:end-row 17, :filename "cljs/source_map/base64_vlq.cljs", :name "vlq-continuation-bit", :ns "cljs.source-map.base64-vlq", :row 17} {:arglist-strs ["[v]"], :end-row 22, :filename "cljs/source_map/base64_vlq.cljs", :fixed-arities #{1}, :name "to-vlq-signed", :ns "cljs.source-map.base64-vlq", :row 19} {:arglist-strs ["[v]"], :end-row 29, :filename "cljs/source_map/base64_vlq.cljs", :fixed-arities #{1}, :name "from-vlq-signed", :ns "cljs.source-map.base64-vlq", :row 24} {:arglist-strs ["[n]"], :end-row 42, :filename "cljs/source_map/base64_vlq.cljs", :fixed-arities #{1}, :name "encode-val", :ns "cljs.source-map.base64-vlq", :row 31} {:arglist-strs ["[v]"], :end-row 45, :filename "cljs/source_map/base64_vlq.cljs", :fixed-arities #{1}, :name "encode", :ns "cljs.source-map.base64-vlq", :row 44} {:arglist-strs ["[s]"], :end-row 64, :filename "cljs/source_map/base64_vlq.cljs", :fixed-arities #{1}, :name "decode", :ns "cljs.source-map.base64-vlq", :row 47}]} {:end-row 10, :filename "cljs/compiler/macros.clj", :name "cljs.compiler.macros", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[env & body]"], :end-row 16, :filename "cljs/compiler/macros.clj", :macro true, :name "emit-wrap", :ns "cljs.compiler.macros", :row 12}]} {:doc "This is intended to be a stable api for those who need programmatic access\n  to the compiler.", :end-row 16, :filename "cljs/compiler/api.clj", :name "cljs.compiler.api", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[s]"], :doc "Munge a symbol or string. Preserves the original type.", :end-row 24, :filename "cljs/compiler/api.clj", :fixed-arities #{1}, :name "munge", :ns "cljs.compiler.api", :row 21} {:arglist-strs ["[ast]" "[state ast]"], :doc "Given an AST node generated by the analyzer emit JavaScript as a string.", :end-row 33, :filename "cljs/compiler/api.clj", :fixed-arities #{1 2}, :name "emit", :ns "cljs.compiler.api", :row 26} {:arglist-strs ["[]" "[opts]" "[opts body]" "[state opts body]"], :doc "Ensure that core.cljs has been loaded.", :end-row 47, :filename "cljs/compiler/api.clj", :fixed-arities #{0 1 3 2}, :name "with-core-cljs", :ns "cljs.compiler.api", :row 35} {:arglist-strs ["[src dest]" "[src dest opts]" "[state src dest opts]"], :doc "Return true if the src file requires compilation.", :end-row 57, :filename "cljs/compiler/api.clj", :fixed-arities #{4 3 2}, :name "requires-compilation?", :ns "cljs.compiler.api", :row 49} {:arglist-strs ["[src]" "[src dest]" "[src dest opts]" "[state src dest opts]"], :doc "Compiles src to a file of the same name, but with a .js extension,\n   in the src file's directory.\n\n   With dest argument, write file to provided location. If the dest\n   argument is a file outside the source tree, missing parent\n   directories will be created. The src file will only be compiled if\n   the dest file has an older modification time.\n\n   Both src and dest may be either a String or a File.\n\n   Returns a map containing {:ns .. :provides .. :requires .. :file ..}.\n   If the file was not compiled returns only {:file ...}", :end-row 81, :filename "cljs/compiler/api.clj", :fixed-arities #{1 4 3 2}, :name "compile-file", :ns "cljs.compiler.api", :row 59} {:arglist-strs ["[dir]"], :doc "Return a sequence of all .cljs and .cljc files in the given directory.", :end-row 86, :filename "cljs/compiler/api.clj", :fixed-arities #{1}, :name "cljs-files-in", :ns "cljs.compiler.api", :row 83} {:arglist-strs ["[src-dir]" "[src-dir target-dir]" "[src-dir target-dir opts]" "[state src-dir target-dir opts]"], :doc "Looks recursively in src-dir for .cljs files and compiles them to\n   .js files. If target-dir is provided, output will go into this\n   directory mirroring the source directory structure. Returns a list\n   of maps containing information about each file which was compiled\n   in dependency order.", :end-row 101, :filename "cljs/compiler/api.clj", :fixed-arities #{1 4 3 2}, :name "compile-root", :ns "cljs.compiler.api", :row 88}]} {:author "Bronsa", :doc "A clojure reader in clojure", :end-row 28, :filename "cljs/vendor/clojure/tools/reader.clj", :name "cljs.vendor.clojure.tools.reader", :row 9, :ns nil, :var-definitions [{:end-row 40, :filename "cljs/vendor/clojure/tools/reader.clj", :name "read*", :ns "cljs.vendor.clojure.tools.reader", :row 34} {:end-row 40, :filename "cljs/vendor/clojure/tools/reader.clj", :name "macros", :ns "cljs.vendor.clojure.tools.reader", :row 34} {:end-row 40, :filename "cljs/vendor/clojure/tools/reader.clj", :name "dispatch-macros", :ns "cljs.vendor.clojure.tools.reader", :row 34} {:end-row 40, :filename "cljs/vendor/clojure/tools/reader.clj", :name "*read-eval*", :ns "cljs.vendor.clojure.tools.reader", :row 34} {:end-row 40, :filename "cljs/vendor/clojure/tools/reader.clj", :name "*data-readers*", :ns "cljs.vendor.clojure.tools.reader", :row 34} {:end-row 40, :filename "cljs/vendor/clojure/tools/reader.clj", :name "*default-data-reader-fn*", :ns "cljs.vendor.clojure.tools.reader", :row 34} {:end-row 40, :filename "cljs/vendor/clojure/tools/reader.clj", :name "*suppress-read*", :ns "cljs.vendor.clojure.tools.reader", :row 34} {:end-row 40, :filename "cljs/vendor/clojure/tools/reader.clj", :name "default-data-readers", :ns "cljs.vendor.clojure.tools.reader", :row 34} {:arglist-strs ["[x]"], :end-row 45, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "ns-name*", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 42} {:arglist-strs ["[ch]"], :end-row 50, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "macro-terminating?", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 47} {:fixed-arities #{3}, :end-row 64, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "read-token", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[rdr kind initch]"], :doc "Read in a single logical token from the reader", :row 52} {:end-row 66, :filename "cljs/vendor/clojure/tools/reader.clj", :name "read-tagged", :ns "cljs.vendor.clojure.tools.reader", :row 66} {:arglist-strs ["[rdr _ opts pending-forms]"], :end-row 74, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-dispatch", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 68} {:arglist-strs ["[rdr ch opts pending-forms]"], :end-row 78, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-unmatched-delimiter", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 76} {:arglist-strs ["[rdr ch opts pending-forms]"], :end-row 99, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-regex", :ns "cljs.vendor.clojure.tools.reader", :row 84} {:arglist-strs ["[token offset length base]" "[rdr initch base length exact?]"], :end-row 133, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4 5}, :name "read-unicode-char", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 101} {:end-row 135, :filename "cljs/vendor/clojure/tools/reader.clj", :name "upper-limit", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 135} {:end-row 136, :filename "cljs/vendor/clojure/tools/reader.clj", :name "lower-limit", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 136} {:fixed-arities #{4}, :end-row 177, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "read-char*", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[rdr backslash opts pending-forms]"], :doc "Read in a character literal", :row 138} {:arglist-strs ["[rdr]"], :end-row 181, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "starting-line-col-info", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 179} {:arglist-strs ["[rdr]"], :end-row 185, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "ending-line-col-info", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 183} {:end-row 187, :filename "cljs/vendor/clojure/tools/reader.clj", :name "READ_EOF", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 187} {:end-row 188, :filename "cljs/vendor/clojure/tools/reader.clj", :name "READ_FINISHED", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 188} {:end-row 190, :filename "cljs/vendor/clojure/tools/reader.clj", :name "*read-delim*", :ns "cljs.vendor.clojure.tools.reader", :row 190} {:fixed-arities #{5}, :end-row 203, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "read-delimited", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[kind delim rdr opts pending-forms]"], :doc "Reads and returns a collection ended with delim", :row 191} {:fixed-arities #{4}, :end-row 221, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "read-list", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[rdr _ opts pending-forms]"], :doc "Read in a list, including its location if the reader is an indexing reader", :row 205} {:fixed-arities #{4}, :end-row 237, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "read-vector", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[rdr _ opts pending-forms]"], :doc "Read in a vector, including its location if the reader is an indexing reader", :row 223} {:fixed-arities #{4}, :end-row 259, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "read-map", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[rdr _ opts pending-forms]"], :doc "Read in a map, including its location if the reader is an indexing reader", :row 239} {:arglist-strs ["[rdr initch]"], :end-row 270, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{2}, :name "read-number", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 261} {:arglist-strs ["[sb rdr]"], :end-row 291, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{2}, :name "escape-char", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 272} {:arglist-strs ["[reader _ opts pending-forms]"], :end-row 302, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-string*", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 293} {:arglist-strs ["[rdr initch]"], :end-row 327, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{2}, :name "read-symbol", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 304} {:doc "Map from ns alias to ns, if non-nil, it will be used to resolve read-time\n   ns aliases instead of (ns-aliases *ns*).\n\n   Defaults to nil", :end-row 334, :filename "cljs/vendor/clojure/tools/reader.clj", :name "*alias-map*", :ns "cljs.vendor.clojure.tools.reader", :row 329} {:arglist-strs ["[sym]"], :end-row 338, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "resolve-alias", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 336} {:arglist-strs ["[sym]"], :end-row 342, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "resolve-ns", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 340} {:arglist-strs ["[reader initch opts pending-forms]"], :end-row 362, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-keyword", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 344} {:fixed-arities #{1}, :end-row 368, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "wrapping-reader", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[sym]"], :doc "Returns a function which wraps a reader in a call to sym", :row 364} {:fixed-arities #{4}, :end-row 386, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "read-meta", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[rdr _ opts pending-forms]"], :doc "Read metadata and return the following object with the metadata applied", :row 370} {:arglist-strs ["[rdr _ opts pending-forms]"], :end-row 404, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-set", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 388} {:fixed-arities #{4}, :end-row 410, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "read-discard", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[rdr _ opts pending-forms]"], :doc "Read and discard the first object from rdr", :row 406} {:arglist-strs ["[rdr _ opts pending-forms]"], :end-row 419, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-symbolic-value", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 412} {:end-row 421, :filename "cljs/vendor/clojure/tools/reader.clj", :name "RESERVED_FEATURES", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 421} {:arglist-strs ["[rdr feature opts]"], :end-row 427, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{3}, :name "has-feature?", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 423} {:arglist-strs ["[form rdr first-line]"], :end-row 433, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{3}, :name "check-eof-error", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 430} {:arglist-strs ["[rdr form]"], :end-row 438, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{2}, :name "check-reserved-features", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 435} {:arglist-strs ["[form rdr first-line]"], :end-row 445, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{3}, :name "check-invalid-read-cond", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 440} {:fixed-arities #{4}, :end-row 454, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "read-suppress", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[first-line rdr opts pending-forms]"], :doc "Read next form and suppress. Return nil or READ_FINISHED.", :row 447} {:end-row 456, :filename "cljs/vendor/clojure/tools/reader.clj", :name "NO_MATCH", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 456} {:fixed-arities #{4}, :end-row 475, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "match-feature", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[first-line rdr opts pending-forms]"], :doc "Read next feature. If matched, read next form and return.\n   Otherwise, read and skip next form, returning READ_FINISHED or nil.", :row 458} {:arglist-strs ["[rdr splicing opts pending-forms]"], :end-row 504, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-cond-delimited", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 477} {:arglist-strs ["[rdr _ opts pending-forms]"], :end-row 524, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-cond", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 506} {:end-row 526, :filename "cljs/vendor/clojure/tools/reader.clj", :name "arg-env", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 526} {:fixed-arities #{1}, :end-row 532, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "garg", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[n]"], :doc "Get a symbol for an anonymous ?argument?", :row 528} {:arglist-strs ["[rdr _ opts pending-forms]"], :end-row 553, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-fn", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 534} {:fixed-arities #{1}, :end-row 564, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "register-arg", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[n]"], :doc "Registers an argument to the arg-env", :row 555} {:end-row 566, :filename "cljs/vendor/clojure/tools/reader.clj", :name "read-symbol", :ns "cljs.vendor.clojure.tools.reader", :row 566} {:arglist-strs ["[rdr pct opts pending-forms]"], :end-row 587, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-arg", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 568} {:fixed-arities #{4}, :end-row 594, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "read-eval", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[rdr _ opts pending-forms]"], :doc "Evaluate a reader literal", :row 589} {:end-row 596, :filename "cljs/vendor/clojure/tools/reader.clj", :name "gensym-env", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 596} {:arglist-strs ["[rdr comma opts pending-forms]"], :end-row 603, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-unquote", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 598} {:end-row 605, :filename "cljs/vendor/clojure/tools/reader.clj", :name "syntax-quote*", :ns "cljs.vendor.clojure.tools.reader", :row 605} {:arglist-strs ["[form]"], :end-row 608, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "unquote-splicing?", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 606} {:arglist-strs ["[form]"], :end-row 612, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "unquote?", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 610} {:fixed-arities #{1}, :end-row 626, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "expand-list", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[s]"], :doc "Expand a list by resolving its syntax quotes and unquotes", :row 614} {:fixed-arities #{1}, :end-row 637, :private true, :ns "cljs.vendor.clojure.tools.reader", :name "flatten-map", :filename "cljs/vendor/clojure/tools/reader.clj", :arglist-strs ["[form]"], :doc "Flatten a map into a seq of alternate keys and values", :row 628} {:arglist-strs ["[sym]"], :end-row 647, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "register-gensym", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 639} {:arglist-strs ["[s]"], :doc "Resolve a symbol s into its fully qualified namespace version", :end-row 668, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "resolve-symbol", :ns "cljs.vendor.clojure.tools.reader", :row 649} {:arglist-strs ["[form ret]"], :end-row 674, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{2}, :name "add-meta", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 670} {:arglist-strs ["[type coll]"], :end-row 685, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{2}, :name "syntax-quote-coll", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 676} {:arglist-strs ["[coll]"], :doc "Decide which map type to use, array-map if less than 16 elements", :end-row 692, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "map-func", :ns "cljs.vendor.clojure.tools.reader", :row 687} {:arglist-strs ["[form]"], :end-row 745, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "syntax-quote*", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 694} {:arglist-strs ["[rdr backquote opts pending-forms]"], :end-row 751, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-syntax-quote", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 747} {:arglist-strs ["[rdr _ opts pending-forms]"], :end-row 786, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-namespaced-map", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 753} {:arglist-strs ["[ch]"], :end-row 807, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "macros", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 788} {:arglist-strs ["[ch]"], :end-row 823, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1}, :name "dispatch-macros", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 809} {:arglist-strs ["[rdr class-name opts pending-forms]"], :end-row 856, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-ctor", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 825} {:arglist-strs ["[rdr initch opts pending-forms]"], :end-row 871, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{4}, :name "read-tagged", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 858} {:doc "Defaults to true.\n\n   ***WARNING***\n   This setting implies that the full power of the reader is in play,\n   including syntax that can cause code to execute. It should never be\n   used with untrusted sources. See also: cljs.vendor.clojure.tools.reader.edn/read.\n\n   When set to logical false in the thread-local binding,\n   the eval reader (#=) and *record/type literal syntax* are disabled in read/load.\n   Example (will fail): (binding [*read-eval* false] (read-string \"#=(* 2 21)\"))\n\n   When set to :unknown all reads will fail in contexts where *read-eval*\n   has not been explicitly bound to either true or false. This setting\n   can be a useful diagnostic tool to ensure that all of your reads\n   occur in considered contexts.", :end-row 893, :filename "cljs/vendor/clojure/tools/reader.clj", :name "*read-eval*", :ns "cljs.vendor.clojure.tools.reader", :row 877} {:doc "Map from reader tag symbols to data reader Vars.\n   Reader tags without namespace qualifiers are reserved for Clojure.\n   Default reader tags are defined in cljs.vendor.clojure.tools.reader/default-data-readers\n   and may be overridden by binding this Var.", :end-row 900, :filename "cljs/vendor/clojure/tools/reader.clj", :name "*data-readers*", :ns "cljs.vendor.clojure.tools.reader", :row 895} {:doc "When no data reader is found for a tag and *default-data-reader-fn*\n   is non-nil, it will be called with two arguments, the tag and the value.\n   If *default-data-reader-fn* is nil (the default value), an exception\n   will be thrown for the unknown tag.", :end-row 907, :filename "cljs/vendor/clojure/tools/reader.clj", :name "*default-data-reader-fn*", :ns "cljs.vendor.clojure.tools.reader", :row 902} {:end-row 909, :filename "cljs/vendor/clojure/tools/reader.clj", :name "*suppress-read*", :ns "cljs.vendor.clojure.tools.reader", :row 909} {:doc "Default map of data reader functions provided by Clojure.\n   May be overridden by binding *data-readers*", :end-row 915, :filename "cljs/vendor/clojure/tools/reader.clj", :name "default-data-readers", :ns "cljs.vendor.clojure.tools.reader", :row 911} {:arglist-strs ["[reader eof-error? sentinel opts pending-forms]" "[reader eof-error? sentinel return-on opts pending-forms]"], :end-row 959, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{6 5}, :name "read*", :ns "cljs.vendor.clojure.tools.reader", :private true, :row 917} {:arglist-strs ["[]" "[reader]" "[{eof :eof :as opts :or {eof :eofthrow}} reader]" "[reader eof-error? sentinel]"], :doc "Reads the first object from an IPushbackReader or a java.io.PushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true.\n   Otherwise returns sentinel. If no stream is provided, *in* will be used.\n\n   Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n   ***WARNING***\n   Note that read can execute code (controlled by *read-eval*),\n   and as such should be used only with trusted sources.\n\n   To read data structures only, use cljs.vendor.clojure.tools.reader.edn/read\n\n   Note that the function signature of cljs.vendor.clojure.tools.reader/read and\n   cljs.vendor.clojure.tools.reader.edn/read is not the same for eof-handling", :end-row 993, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{0 1 3 2}, :name "read", :ns "cljs.vendor.clojure.tools.reader", :row 961} {:arglist-strs ["[s]" "[opts s]"], :doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   ***WARNING***\n   Note that read-string can execute code (controlled by *read-eval*),\n   and as such should be used only with trusted sources.\n\n   To read data structures only, use cljs.vendor.clojure.tools.reader.edn/read-string\n\n   Note that the function signature of cljs.vendor.clojure.tools.reader/read-string and\n   cljs.vendor.clojure.tools.reader.edn/read-string is not the same for eof-handling", :end-row 1011, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{1 2}, :name "read-string", :ns "cljs.vendor.clojure.tools.reader", :row 995} {:fixed-arities #{1}, :end-row 1017, :ns "cljs.vendor.clojure.tools.reader", :name "syntax-quote", :filename "cljs/vendor/clojure/tools/reader.clj", :macro true, :arglist-strs ["[form]"], :doc "Macro equivalent to the syntax-quote reader macro (`).", :row 1013} {:arglist-strs ["[]" "[stream]" "[stream eof-error? eof-value]" "[opts stream]"], :doc "Like read, and taking the same args. reader must be a SourceLoggingPushbackReader.\n  Returns a vector containing the object read and the (whitespace-trimmed) string read.", :end-row 1031, :filename "cljs/vendor/clojure/tools/reader.clj", :fixed-arities #{0 1 3 2}, :name "read+string", :ns "cljs.vendor.clojure.tools.reader", :row 1019}]} {:author "Bronsa", :doc "An EDN reader in clojure", :end-row 21, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :name "cljs.vendor.clojure.tools.reader.edn", :row 9, :ns nil, :var-definitions [{:end-row 27, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :name "read", :ns "cljs.vendor.clojure.tools.reader.edn", :row 27} {:end-row 27, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :name "macros", :ns "cljs.vendor.clojure.tools.reader.edn", :row 27} {:end-row 27, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :name "dispatch-macros", :ns "cljs.vendor.clojure.tools.reader.edn", :row 27} {:arglist-strs ["[ch]"], :end-row 33, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{1}, :name "macro-terminating?", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 29} {:arglist-strs ["[ch]"], :end-row 38, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{1}, :name "not-constituent?", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 35} {:arglist-strs ["[rdr kind initch]" "[rdr kind initch validate-leading?]"], :end-row 63, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{4 3}, :name "read-token", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 40} {:end-row 67, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :name "read-tagged", :ns "cljs.vendor.clojure.tools.reader.edn", :row 67} {:arglist-strs ["[rdr _ opts]"], :end-row 75, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-dispatch", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 69} {:arglist-strs ["[rdr ch opts]"], :end-row 79, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-unmatched-delimiter", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 77} {:arglist-strs ["[token offset length base]" "[rdr initch base length exact?]"], :end-row 118, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{4 5}, :name "read-unicode-char", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 86} {:end-row 120, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :name "upper-limit", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 120} {:end-row 121, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :name "lower-limit", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 121} {:arglist-strs ["[rdr backslash opts]"], :end-row 162, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-char*", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 123} {:arglist-strs ["[rdr]"], :end-row 166, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{1}, :name "starting-line-col-info", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 164} {:arglist-strs ["[kind delim rdr opts]"], :end-row 183, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{4}, :name "read-delimited", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 168} {:arglist-strs ["[rdr _ opts]"], :end-row 190, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-list", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 185} {:arglist-strs ["[rdr _ opts]"], :end-row 194, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-vector", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 192} {:arglist-strs ["[rdr _ opts]"], :end-row 203, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-map", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 196} {:arglist-strs ["[rdr initch opts]"], :end-row 214, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-number", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 205} {:arglist-strs ["[sb rdr]"], :end-row 236, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{2}, :name "escape-char", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 217} {:arglist-strs ["[rdr _ opts]"], :end-row 247, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-string*", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 238} {:arglist-strs ["[rdr initch]"], :end-row 262, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{2}, :name "read-symbol", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 249} {:arglist-strs ["[reader initch opts]"], :end-row 277, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-keyword", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 264} {:arglist-strs ["[sym]"], :end-row 282, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{1}, :name "wrapping-reader", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 279} {:arglist-strs ["[rdr _ opts]"], :end-row 293, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-meta", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 284} {:arglist-strs ["[rdr _ opts]"], :end-row 297, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-set", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 295} {:arglist-strs ["[rdr _ opts]"], :end-row 302, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-discard", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 299} {:arglist-strs ["[rdr _ opts]"], :end-row 317, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-namespaced-map", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 304} {:arglist-strs ["[rdr _ opts]"], :end-row 326, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-symbolic-value", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 319} {:arglist-strs ["[ch]"], :end-row 342, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{1}, :name "macros", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 328} {:arglist-strs ["[ch]"], :end-row 353, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{1}, :name "dispatch-macros", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 344} {:arglist-strs ["[rdr initch opts]"], :end-row 365, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{3}, :name "read-tagged", :ns "cljs.vendor.clojure.tools.reader.edn", :private true, :row 355} {:arglist-strs ["[]" "[reader]" "[{:keys [eof] :as opts} reader]" "[reader eof-error? eof opts]"], :doc "Reads the first object from an IPushbackReader or a java.io.PushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   cljs.vendor.clojure.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.", :end-row 427, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{0 1 4 2}, :name "read", :ns "cljs.vendor.clojure.tools.reader.edn", :row 371} {:arglist-strs ["[s]" "[opts s]"], :doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per cljs.vendor.clojure.tools.reader.edn/read", :end-row 440, :filename "cljs/vendor/clojure/tools/reader/edn.clj", :fixed-arities #{1 2}, :name "read-string", :ns "cljs.vendor.clojure.tools.reader.edn", :row 429}]} {:end-row 11, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :name "cljs.vendor.clojure.tools.reader.impl.errors", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[rdr ex-type]"], :end-row 22, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "location-details", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :private true, :row 13} {:arglist-strs ["[rdr ex-type & msg]"], :end-row 34, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :name "throw-ex", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :private true, :row 24} {:arglist-strs ["[rdr & msgs]"], :doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :end-row 40, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :name "reader-error", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 36} {:arglist-strs ["[rdr & msgs]"], :doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :end-row 46, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :name "eof-error", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 42} {:arglist-strs ["[rdr & msgs]"], :doc "Throws an ExceptionInfo with the given message.\n   If rdr is an IndexingReader, additional information about column and line number is provided", :end-row 52, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :name "illegal-arg-error", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 48} {:arglist-strs ["[rdr kind line column]" "[rdr kind line column n]"], :end-row 65, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{4 5}, :name "throw-eof-delimited", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 54} {:arglist-strs ["[rdr line col elements]"], :end-row 75, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{4}, :name "throw-odd-map", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 67} {:arglist-strs ["[rdr token]"], :end-row 82, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-invalid-number", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 77} {:arglist-strs ["[rdr token]"], :end-row 87, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-invalid-unicode-literal", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 84} {:arglist-strs ["[rdr ch]"], :end-row 94, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-invalid-unicode-escape", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 89} {:arglist-strs ["[rdr kind token]"], :end-row 97, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{3}, :name "throw-invalid", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 96} {:arglist-strs ["[rdr kind]"], :end-row 100, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-eof-at-start", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 99} {:arglist-strs ["[rdr kind ch]"], :end-row 103, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{3}, :name "throw-bad-char", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 102} {:arglist-strs ["[rdr]"], :end-row 106, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{1}, :name "throw-eof-at-dispatch", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 105} {:arglist-strs ["[rdr ch]"], :end-row 109, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-unmatch-delimiter", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 108} {:arglist-strs ["[rdr kind & start]"], :end-row 113, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :name "throw-eof-reading", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 111} {:arglist-strs ["[rdr token]"], :end-row 118, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-invalid-unicode-char", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 115} {:arglist-strs ["[rdr ch token]"], :end-row 123, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{3}, :name "throw-invalid-unicode-digit-in-token", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 120} {:arglist-strs ["[rdr ch]"], :end-row 128, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-invalid-unicode-digit", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 125} {:arglist-strs ["[rdr actual expected]"], :end-row 138, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{3}, :name "throw-invalid-unicode-len", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 130} {:arglist-strs ["[rdr token]"], :end-row 141, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-invalid-character-literal", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 140} {:arglist-strs ["[rdr token]"], :end-row 148, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-invalid-octal-len", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 143} {:arglist-strs ["[rdr]"], :end-row 151, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{1}, :name "throw-bad-octal-number", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 150} {:arglist-strs ["[rdr token]"], :end-row 158, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-unsupported-character", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 153} {:arglist-strs ["[rdr]"], :end-row 161, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{1}, :name "throw-eof-in-character", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 160} {:arglist-strs ["[rdr ch]"], :end-row 164, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-bad-escape-char", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 163} {:arglist-strs ["[rdr]"], :end-row 167, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{1}, :name "throw-single-colon", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 166} {:arglist-strs ["[rdr x]"], :end-row 174, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-bad-metadata", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 169} {:arglist-strs ["[rdr target]"], :end-row 182, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-bad-metadata-target", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 176} {:arglist-strs ["[rdr feature]"], :end-row 189, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-feature-not-keyword", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 184} {:arglist-strs ["[rdr ns-name]"], :end-row 192, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-ns-map-no-map", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 191} {:arglist-strs ["[rdr ns-name]"], :end-row 195, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-bad-ns", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 194} {:arglist-strs ["[rdr tag]"], :end-row 202, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-bad-reader-tag", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 197} {:arglist-strs ["[rdr tag]"], :end-row 209, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-unknown-reader-tag", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 204} {:arglist-strs ["[rdr line]"], :end-row 214, :filename "cljs/vendor/clojure/tools/reader/impl/errors.clj", :fixed-arities #{2}, :name "throw-eof-error", :ns "cljs.vendor.clojure.tools.reader.impl.errors", :row 211}]} {:end-row 16, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :name "cljs.vendor.clojure.tools.reader.impl.commons", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[reader initch]"], :doc "Checks whether the reader is at the start of a number literal", :end-row 27, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :fixed-arities #{2}, :name "number-literal?", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :row 22} {:arglist-strs ["[pred rdr]"], :doc "Read until first character that doesn't match pred, returning\n   char.", :end-row 36, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :fixed-arities #{2}, :name "read-past", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :row 29} {:arglist-strs ["[reader]"], :doc "Advances the reader to the end of a line. Returns the reader", :end-row 44, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :fixed-arities #{1}, :name "skip-line", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :row 38} {:end-row 46, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :name "int-pattern", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :row 46} {:end-row 47, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :name "ratio-pattern", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :row 47} {:end-row 48, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :name "float-pattern", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :row 48} {:arglist-strs ["[m]"], :end-row 69, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :fixed-arities #{1}, :name "match-int", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :private true, :row 50} {:arglist-strs ["[m]"], :end-row 79, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :fixed-arities #{1}, :name "match-ratio", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :private true, :row 71} {:arglist-strs ["[s m]"], :end-row 85, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :fixed-arities #{2}, :name "match-float", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :private true, :row 81} {:arglist-strs ["[s]"], :end-row 96, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :fixed-arities #{1}, :name "match-number", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :row 87} {:arglist-strs ["[token]"], :doc "Parses a string into a vector of the namespace and symbol", :end-row 118, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :fixed-arities #{1}, :name "parse-symbol", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :row 98} {:arglist-strs ["[rdr & _]"], :end-row 126, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :name "read-comment", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :row 124} {:arglist-strs ["[msg]"], :end-row 131, :filename "cljs/vendor/clojure/tools/reader/impl/commons.clj", :fixed-arities #{1}, :name "throwing-reader", :ns "cljs.vendor.clojure.tools.reader.impl.commons", :row 128}]} {:end-row 9, :filename "cljs/vendor/clojure/tools/reader/impl/inspect.clj", :name "cljs.vendor.clojure.tools.reader.impl.inspect", :row 9, :ns nil, :var-definitions [{:end-row 11, :filename "cljs/vendor/clojure/tools/reader/impl/inspect.clj", :name "inspect*", :ns "cljs.vendor.clojure.tools.reader.impl.inspect", :row 11} {:arglist-strs ["[truncate col start end]"], :end-row 19, :filename "cljs/vendor/clojure/tools/reader/impl/inspect.clj", :fixed-arities #{4}, :name "inspect*-col", :ns "cljs.vendor.clojure.tools.reader.impl.inspect", :private true, :row 13} {:arglist-strs ["[_ x]"], :end-row 35, :filename "cljs/vendor/clojure/tools/reader/impl/inspect.clj", :fixed-arities #{2}, :name "dispatch-inspect", :ns "cljs.vendor.clojure.tools.reader.impl.inspect", :private true, :row 21} {:end-row 37, :filename "cljs/vendor/clojure/tools/reader/impl/inspect.clj", :name "inspect*", :ns "cljs.vendor.clojure.tools.reader.impl.inspect", :row 37} {:arglist-strs ["[x]" "[truncate x]"], :doc "Return a string description of the value supplied.\n   May be the a string version of the value itself (e.g. \"true\")\n   or it may be a description (e.g. \"an instance of Foo\").\n   If truncate is true then return a very terse version of\n   the inspection.", :end-row 91, :filename "cljs/vendor/clojure/tools/reader/impl/inspect.clj", :fixed-arities #{1 2}, :name "inspect", :ns "cljs.vendor.clojure.tools.reader.impl.inspect", :row 84}]} {:end-row 10, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :name "cljs.vendor.clojure.tools.reader.impl.utils", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[x]"], :end-row 14, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{1}, :name "char", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 12} {:end-row 24, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :name "<=clojure-1-7-alpha5", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 16} {:arglist-strs ["[cond & then]"], :end-row 28, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :macro true, :name "compile-when", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 26} {:arglist-strs ["[ex]"], :end-row 31, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{1}, :name "ex-info?", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 30} {:end-row 34, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :name "TaggedLiteral", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 34} {:arglist-strs ["[tag form]"], :end-row 34, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{2}, :name "->TaggedLiteral", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 34} {:arglist-strs ["[m]"], :end-row 34, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{1}, :name "map->TaggedLiteral", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 34} {:arglist-strs ["[value]"], :doc "Return true if the value is the data representation of a tagged literal", :end-row 39, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{1}, :name "tagged-literal?", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 36} {:arglist-strs ["[tag form]"], :doc "Construct a data representation of a tagged literal from a\n       tag symbol and a form.", :end-row 45, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{2}, :name "tagged-literal", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 41} {:end-row 56, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :name "ReaderConditional", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 56} {:arglist-strs ["[splicing? form]"], :end-row 56, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{2}, :name "->ReaderConditional", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 56} {:arglist-strs ["[m]"], :end-row 56, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{1}, :name "map->ReaderConditional", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 56} {:arglist-strs ["[value]"], :doc "Return true if the value is the data representation of a reader conditional", :end-row 63, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{1}, :name "reader-conditional?", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 60} {:arglist-strs ["[form splicing?]"], :doc "Construct a data representation of a reader conditional.\n       If true, splicing? indicates read-cond-splicing.", :end-row 69, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{2}, :name "reader-conditional", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 65} {:arglist-strs ["[ch]"], :doc "Checks whether a given character is whitespace", :end-row 81, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{1}, :name "whitespace?", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 76} {:arglist-strs ["[ch]"], :doc "Checks whether a given character is numeric", :end-row 87, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{1}, :name "numeric?", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 83} {:arglist-strs ["[c]"], :doc "Checks whether the character is a newline", :end-row 93, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{1}, :name "newline?", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 89} {:arglist-strs ["[f]"], :doc "Resolves syntactical sugar in metadata", :end-row 102, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{1}, :name "desugar-meta", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 95} {:arglist-strs ["[]"], :doc "Returns an anonymous unbound Var", :end-row 107, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{0}, :name "make-var", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 104} {:arglist-strs ["[ns keys]"], :end-row 124, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{2}, :name "namespace-keys", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 109} {:arglist-strs ["[[a b]]"], :end-row 127, :filename "cljs/vendor/clojure/tools/reader/impl/utils.clj", :fixed-arities #{1}, :name "second'", :ns "cljs.vendor.clojure.tools.reader.impl.utils", :row 126}]} {:author "Bronsa", :doc "Protocols and default Reader types implementation", :end-row 15, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "cljs.vendor.clojure.tools.reader.reader-types", :row 9, :ns nil, :var-definitions [{:fixed-arities #{2}, :end-row 18, :private true, :ns "cljs.vendor.clojure.tools.reader.reader-types", :name "update!", :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :macro true, :arglist-strs ["[what f]"], :row 17} {:end-row 28, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "Reader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 24} {:arglist-strs ["[reader]"], :doc "Returns the next char from the Reader, nil if the end of stream has been reached", :end-row 26, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1}, :name "read-char", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 25} {:arglist-strs ["[reader]"], :doc "Returns the next char from the Reader without removing it from the reader stream", :end-row 28, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1}, :name "peek-char", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 27} {:end-row 32, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "IPushbackReader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 30} {:arglist-strs ["[reader ch]"], :doc "Pushes back a single character on to the stream", :end-row 32, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{2}, :name "unread", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 31} {:end-row 40, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "IndexingReader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 34} {:arglist-strs ["[reader]"], :doc "Returns the line number of the next character to be read from the stream", :end-row 36, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1}, :name "get-line-number", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 35} {:arglist-strs ["[reader]"], :doc "Returns the column number of the next character to be read from the stream", :end-row 38, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1}, :name "get-column-number", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 37} {:arglist-strs ["[reader]"], :doc "Returns the file name the reader is reading from, or nil", :end-row 40, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1}, :name "get-file-name", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 39} {:end-row 56, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "StringReader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 46} {:arglist-strs ["[s s-len s-pos]"], :end-row 56, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{3}, :name "->StringReader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 46} {:end-row 77, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "InputStreamReader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 58} {:arglist-strs ["[is buf]"], :end-row 77, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{2}, :name "->InputStreamReader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 58} {:end-row 103, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "PushbackReader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 79} {:arglist-strs ["[rdr buf buf-len buf-pos]"], :end-row 103, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{4}, :name "->PushbackReader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 79} {:end-row 169, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "IndexingPushbackReader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 105} {:arglist-strs ["[rdr line column line-start? prev prev-column file-name normalize?]"], :end-row 169, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{8}, :name "->IndexingPushbackReader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 105} {:end-row 198, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "ReaderCoercer", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 197} {:arglist-strs ["[rdr]"], :end-row 198, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1}, :name "to-rdr", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 198} {:end-row 200, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "string-reader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 200} {:end-row 200, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "push-back-reader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 200} {:end-row 216, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "PushbackReaderCoercer", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 215} {:arglist-strs ["[rdr buf-len]"], :end-row 216, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{2}, :name "to-pbr", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 216} {:arglist-strs ["[obj m]"], :doc "Returns an object of the same type and value as `obj`, with its\n  metadata merged over `m`.", :end-row 241, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{2}, :name "merge-meta", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 236} {:fixed-arities #{1}, :end-row 248, :private true, :ns "cljs.vendor.clojure.tools.reader.reader-types", :name "peek-source-log", :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :arglist-strs ["[source-log-frames]"], :doc "Returns a string containing the contents of the top most source\n  logging frame.", :row 243} {:fixed-arities #{2}, :end-row 254, :private true, :ns "cljs.vendor.clojure.tools.reader.reader-types", :name "log-source-char", :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :arglist-strs ["[source-log-frames char]"], :doc "Logs `char` to all currently active source logging frames.", :row 250} {:fixed-arities #{1}, :end-row 261, :private true, :ns "cljs.vendor.clojure.tools.reader.reader-types", :name "drop-last-logged-char", :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :arglist-strs ["[source-log-frames]"], :doc "Removes the last logged character from all currently active source\n  logging frames. Called when pushing a character back.", :row 256} {:end-row 314, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :name "SourceLoggingPushbackReader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 263} {:arglist-strs ["[rdr line column line-start? prev prev-column file-name source-log-frames normalize?]"], :end-row 314, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{9}, :name "->SourceLoggingPushbackReader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 263} {:arglist-strs ["[reader f]"], :end-row 325, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{2}, :name "log-source*", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 316} {:arglist-strs ["[rdr]"], :doc "Returns true if the reader satisfies IndexingReader", :end-row 340, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1}, :name "indexing-reader?", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 332} {:arglist-strs ["[s]"], :doc "Creates a StringReader from a given string", :end-row 345, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1}, :name "string-reader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 342} {:arglist-strs ["[rdr]" "[rdr buf-len]"], :doc "Creates a PushbackReader from a given reader or string", :end-row 350, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1 2}, :name "push-back-reader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 347} {:arglist-strs ["[s]" "[s buf-len]"], :doc "Creates a PushbackReader from a given string", :end-row 357, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1 2}, :name "string-push-back-reader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 352} {:arglist-strs ["[is]"], :doc "Creates an InputStreamReader from an InputStream", :end-row 362, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1}, :name "input-stream-reader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 359} {:arglist-strs ["[is]" "[is buf-len]"], :doc "Creates a PushbackReader from a given InputStream", :end-row 369, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1 2}, :name "input-stream-push-back-reader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 364} {:arglist-strs ["[s-or-rdr]" "[s-or-rdr buf-len]" "[s-or-rdr buf-len file-name]"], :doc "Creates an IndexingPushbackReader from a given string or PushbackReader", :end-row 379, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1 3 2}, :name "indexing-push-back-reader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 371} {:arglist-strs ["[s-or-rdr]" "[s-or-rdr buf-len]" "[s-or-rdr buf-len file-name]"], :doc "Creates a SourceLoggingPushbackReader from a given string or PushbackReader", :end-row 399, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1 3 2}, :name "source-logging-push-back-reader", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 381} {:arglist-strs ["[]" "[rdr]"], :doc "Reads a line from the reader or from *in* if no reader is specified", :end-row 412, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{0 1}, :name "read-line", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 401} {:arglist-strs ["[rdr]"], :end-row 416, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1}, :name "source-logging-reader?", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 414} {:arglist-strs ["[reader & body]"], :doc "If reader is a SourceLoggingPushbackReader, execute body in a source\n  logging context. Otherwise, execute body, returning the result.", :end-row 425, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :macro true, :name "log-source", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 418} {:arglist-strs ["[rdr]"], :doc "Returns true if rdr is an IndexingReader and the current char starts a new line", :end-row 431, :filename "cljs/vendor/clojure/tools/reader/reader_types.clj", :fixed-arities #{1}, :name "line-start?", :ns "cljs.vendor.clojure.tools.reader.reader-types", :row 427}]} {:end-row 13, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :name "cljs.vendor.clojure.tools.reader.default-data-readers", :row 11, :ns nil, :var-definitions [{:fixed-arities #{1}, :end-row 22, :private true, :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :name "fail", :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :macro true, :arglist-strs ["[msg]"], :row 20} {:fixed-arities #{1 2}, :end-row 26, :private true, :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :name "verify", :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :macro true, :arglist-strs ["[test msg]" "[test]"], :row 24} {:arglist-strs ["[num div]"], :end-row 30, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :fixed-arities #{2}, :name "divisible?", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :private true, :row 28} {:arglist-strs ["[num div]"], :end-row 34, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :fixed-arities #{2}, :name "indivisible?", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :private true, :row 32} {:arglist-strs ["[s]"], :end-row 41, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :fixed-arities #{1}, :name "parse-int", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :private true, :row 40} {:arglist-strs ["[s width]"], :end-row 49, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :fixed-arities #{2}, :name "zero-fill-right", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :private true, :row 43} {:doc "Parse a string containing an RFC3339-like like timestamp.\n\nThe function new-instant is called with the following arguments.\n\n                min  max           default\n                ---  ------------  -------\n  years          0           9999      N/A (s must provide years)\n  months         1             12        1\n  days           1             31        1 (actual max days depends\n  hours          0             23        0  on month and year)\n  minutes        0             59        0\n  seconds        0             60        0 (though 60 is only valid\n  nanoseconds    0      999999999        0  when minutes is 59)\n  offset-sign   -1              1        0\n  offset-hours   0             23        0\n  offset-minutes 0             59        0\n\nThese are all integers and will be non-nil. (The listed defaults\nwill be passed if the corresponding field is not present in s.)\n\nGrammar (of s):\n\n  date-fullyear   = 4DIGIT\n  date-month      = 2DIGIT  ; 01-12\n  date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on\n                            ; month/year\n  time-hour       = 2DIGIT  ; 00-23\n  time-minute     = 2DIGIT  ; 00-59\n  time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second\n                            ; rules\n  time-secfrac    = '.' 1*DIGIT\n  time-numoffset  = ('+' / '-') time-hour ':' time-minute\n  time-offset     = 'Z' / time-numoffset\n\n  time-part       = time-hour [ ':' time-minute [ ':' time-second\n                    [time-secfrac] [time-offset] ] ]\n\n  timestamp       = date-year [ '-' date-month [ '-' date-mday\n                    [ 'T' time-part ] ] ]\n\nUnlike RFC3339:\n\n  - we only parse the timestamp format\n  - timestamp can elide trailing components\n  - time-offset is optional (defaults to +00:00)\n\nThough time-offset is syntactically optional, a missing time-offset\nwill be treated as if the time-offset zero (+00:00) had been\nspecified.\n", :end-row 121, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :name "parse-timestamp", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :row 51} {:arglist-strs ["[year]"], :end-row 131, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :fixed-arities #{1}, :name "leap-year?", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :private true, :row 127} {:end-row 137, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :name "days-in-month", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :private true, :row 133} {:arglist-strs ["[new-instance]"], :doc "Return a function which constructs and instant by calling constructor\nafter first validating that those arguments are in range and otherwise\nplausible. The resulting function will throw an exception if called\nwith invalid arguments.", :end-row 157, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :fixed-arities #{1}, :name "validated", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :row 139} {:end-row 170, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :name "thread-local-utc-date-format", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :private true, :row 163} {:fixed-arities #{2}, :end-row 178, :private true, :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :name "print-date", :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :arglist-strs ["[d w]"], :doc "Print a java.util.Date as RFC3339 timestamp, always in UTC.", :row 172} {:fixed-arities #{2}, :end-row 198, :private true, :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :name "print-calendar", :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :arglist-strs ["[c w]"], :doc "Print a java.util.Calendar as RFC3339 timestamp, preserving timezone.", :row 188} {:end-row 215, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :name "thread-local-utc-timestamp-format", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :private true, :row 209} {:fixed-arities #{2}, :end-row 226, :private true, :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :name "print-timestamp", :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :arglist-strs ["[ts w]"], :doc "Print a java.sql.Timestamp as RFC3339 timestamp, always in UTC.", :row 217} {:fixed-arities #{10}, :end-row 251, :private true, :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :name "construct-calendar", :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :arglist-strs ["[years months days hours minutes seconds nanoseconds offset-sign offset-hours offset-minutes]"], :doc "Construct a java.util.Calendar, preserving the timezone\noffset, but truncating the subsecond fraction to milliseconds.", :row 240} {:fixed-arities #{10}, :end-row 260, :private true, :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :name "construct-date", :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :arglist-strs ["[years months days hours minutes seconds nanoseconds offset-sign offset-hours offset-minutes]"], :doc "Construct a java.util.Date, which expresses the original instant as\nmilliseconds since the epoch, UTC.", :row 253} {:fixed-arities #{10}, :end-row 272, :private true, :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :name "construct-timestamp", :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :arglist-strs ["[years months days hours minutes seconds nanoseconds offset-sign offset-hours offset-minutes]"], :doc "Construct a java.sql.Timestamp, which has nanosecond precision.", :row 262} {:doc "To read an instant as a java.util.Date, bind *data-readers* to a map with\nthis var as the value for the 'inst key. The timezone offset will be used\nto convert into UTC.", :end-row 278, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :name "read-instant-date", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :row 274} {:doc "To read an instant as a java.util.Calendar, bind *data-readers* to a map with\nthis var as the value for the 'inst key.  Calendar preserves the timezone\noffset.", :end-row 284, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :name "read-instant-calendar", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :row 280} {:doc "To read an instant as a java.sql.Timestamp, bind *data-readers* to a\nmap with this var as the value for the 'inst key. Timestamp preserves\nfractional seconds with nanosecond precision. The timezone offset will\nbe used to convert into UTC.", :end-row 291, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :name "read-instant-timestamp", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :row 286} {:arglist-strs ["[form]"], :end-row 297, :filename "cljs/vendor/clojure/tools/reader/default_data_readers.clj", :fixed-arities #{1}, :name "default-uuid-reader", :ns "cljs.vendor.clojure.tools.reader.default-data-readers", :row 295}]} {:author "Stuart Sierra", :doc "JavaScript Object Notation (JSON) parser/generator.\n  See http://www.json.org/", :end-row 16, :filename "cljs/vendor/clojure/data/json.clj", :name "cljs.vendor.clojure.data.json", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[x]"], :end-row 28, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{1}, :name "default-write-key-fn", :ns "cljs.vendor.clojure.data.json", :private true, :row 22} {:arglist-strs ["[k v]"], :end-row 30, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{2}, :name "default-value-fn", :ns "cljs.vendor.clojure.data.json", :private true, :row 30} {:end-row 32, :filename "cljs/vendor/clojure/data/json.clj", :name "-read", :ns "cljs.vendor.clojure.data.json", :row 32} {:fixed-arities #{1}, :end-row 35, :private true, :ns "cljs.vendor.clojure.data.json", :name "codepoint", :filename "cljs/vendor/clojure/data/json.clj", :macro true, :arglist-strs ["[c]"], :row 34} {:arglist-strs ["[[test result]]"], :end-row 45, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{1}, :name "codepoint-clause", :ns "cljs.vendor.clojure.data.json", :private true, :row 37} {:arglist-strs ["[e & clauses]"], :end-row 51, :filename "cljs/vendor/clojure/data/json.clj", :macro true, :name "codepoint-case", :ns "cljs.vendor.clojure.data.json", :private true, :row 47} {:arglist-strs ["[stream]"], :end-row 64, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{1}, :name "read-hex-char", :ns "cljs.vendor.clojure.data.json", :private true, :row 53} {:arglist-strs ["[stream]"], :end-row 79, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{1}, :name "read-escaped-char", :ns "cljs.vendor.clojure.data.json", :private true, :row 66} {:arglist-strs ["[stream already-read]"], :end-row 92, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{2}, :name "slow-read-string", :ns "cljs.vendor.clojure.data.json", :private true, :row 81} {:arglist-strs ["[stream]"], :end-row 116, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{1}, :name "read-quoted-string", :ns "cljs.vendor.clojure.data.json", :private true, :row 94} {:arglist-strs ["[string]"], :end-row 123, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{1}, :name "read-integer", :ns "cljs.vendor.clojure.data.json", :private true, :row 118} {:arglist-strs ["[string bigdec?]"], :end-row 128, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{2}, :name "read-decimal", :ns "cljs.vendor.clojure.data.json", :private true, :row 125} {:arglist-strs ["[stream bigdec?]"], :end-row 251, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{2}, :name "read-number", :ns "cljs.vendor.clojure.data.json", :private true, :row 130} {:arglist-strs ["[stream]"], :end-row 259, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{1}, :name "next-token", :ns "cljs.vendor.clojure.data.json", :private true, :row 253} {:arglist-strs ["[]"], :end-row 262, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{0}, :name "invalid-array-exception", :ns "cljs.vendor.clojure.data.json", :row 261} {:arglist-strs ["[stream options]"], :end-row 271, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{2}, :name "read-array*", :ns "cljs.vendor.clojure.data.json", :private true, :row 264} {:arglist-strs ["[stream options]"], :end-row 282, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{2}, :name "read-array", :ns "cljs.vendor.clojure.data.json", :private true, :row 273} {:arglist-strs ["[stream]"], :end-row 293, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{1}, :name "read-key", :ns "cljs.vendor.clojure.data.json", :private true, :row 284} {:arglist-strs ["[stream options]"], :end-row 317, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{2}, :name "read-object", :ns "cljs.vendor.clojure.data.json", :private true, :row 295} {:arglist-strs ["[stream eof-error? eof-value options]"], :end-row 364, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{4}, :name "-read", :ns "cljs.vendor.clojure.data.json", :private true, :row 319} {:end-row 368, :filename "cljs/vendor/clojure/data/json.clj", :name "default-read-options", :ns "cljs.vendor.clojure.data.json", :row 366} {:arglist-strs ["[reader & {:as options}]"], :doc "Reads a single item of JSON data from a java.io.Reader. Options are\n  key-value pairs, valid options are:\n\n     :eof-error? boolean\n\n        If true (default) will throw exception if the stream is empty.\n\n     :eof-value Object\n\n        Object to return if the stream is empty and eof-error? is\n        false. Default is nil.\n\n     :bigdec boolean\n\n        If true use BigDecimal for decimal numbers instead of Double.\n        Default is false.\n\n     :key-fn function\n\n        Single-argument function called on JSON property names; return\n        value will replace the property names in the output. Default\n        is clojure.core/identity, use clojure.core/keyword to get\n        keyword properties.\n\n     :value-fn function\n\n        Function to transform values in maps (\"objects\" in JSON) in\n        the output. For each JSON property, value-fn is called with\n        two arguments: the property name (transformed by key-fn) and\n        the value. The return value of value-fn will replace the value\n        in the output. If value-fn returns itself, the property will\n        be omitted from the output. The default value-fn returns the\n        value unchanged. This option does not apply to non-map\n        collections.", :end-row 409, :filename "cljs/vendor/clojure/data/json.clj", :name "read", :ns "cljs.vendor.clojure.data.json", :row 369} {:arglist-strs ["[string & {:as options}]"], :doc "Reads one JSON value from input String. Options are the same as for\n  read.", :end-row 419, :filename "cljs/vendor/clojure/data/json.clj", :name "read-str", :ns "cljs.vendor.clojure.data.json", :row 411} {:end-row 426, :filename "cljs/vendor/clojure/data/json.clj", :name "JSONWriter", :ns "cljs.vendor.clojure.data.json", :row 424} {:arglist-strs ["[object out options]"], :doc "Print object to Appendable out as JSON", :end-row 426, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "-write", :ns "cljs.vendor.clojure.data.json", :row 425} {:arglist-strs ["[out cp]"], :end-row 438, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{2}, :name "->hex-string", :ns "cljs.vendor.clojure.data.json", :private true, :row 428} {:end-row 455, :filename "cljs/vendor/clojure/data/json.clj", :name "codepoint-decoder", :ns "cljs.vendor.clojure.data.json", :row 440} {:arglist-strs ["[s out options]"], :end-row 480, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-string", :ns "cljs.vendor.clojure.data.json", :private true, :row 457} {:arglist-strs ["[out options]"], :end-row 488, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{2}, :name "write-indent", :ns "cljs.vendor.clojure.data.json", :private true, :row 482} {:arglist-strs ["[m out options]"], :end-row 524, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-object", :ns "cljs.vendor.clojure.data.json", :private true, :row 490} {:arglist-strs ["[s out options]"], :end-row 545, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-array", :ns "cljs.vendor.clojure.data.json", :private true, :row 526} {:arglist-strs ["[x out options]"], :end-row 548, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-bignum", :ns "cljs.vendor.clojure.data.json", :private true, :row 547} {:arglist-strs ["[x out options]"], :end-row 556, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-float", :ns "cljs.vendor.clojure.data.json", :private true, :row 550} {:arglist-strs ["[x out options]"], :end-row 564, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-double", :ns "cljs.vendor.clojure.data.json", :private true, :row 558} {:arglist-strs ["[x out options]"], :end-row 567, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-plain", :ns "cljs.vendor.clojure.data.json", :private true, :row 566} {:arglist-strs ["[x out options]"], :end-row 572, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-uuid", :ns "cljs.vendor.clojure.data.json", :private true, :row 569} {:arglist-strs ["[x out options]"], :end-row 578, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-instant", :ns "cljs.vendor.clojure.data.json", :private true, :row 574} {:arglist-strs ["[x out options]"], :end-row 581, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-date", :ns "cljs.vendor.clojure.data.json", :private true, :row 580} {:arglist-strs ["[d]"], :end-row 584, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{1}, :name "default-sql-date->instant-fn", :ns "cljs.vendor.clojure.data.json", :private true, :row 583} {:arglist-strs ["[x out options]"], :end-row 588, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-sql-date", :ns "cljs.vendor.clojure.data.json", :private true, :row 586} {:arglist-strs ["[x out options]"], :end-row 591, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-null", :ns "cljs.vendor.clojure.data.json", :private true, :row 590} {:arglist-strs ["[x out options]"], :end-row 594, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-named", :ns "cljs.vendor.clojure.data.json", :private true, :row 593} {:arglist-strs ["[x out options]"], :end-row 599, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-generic", :ns "cljs.vendor.clojure.data.json", :private true, :row 596} {:arglist-strs ["[x out options]"], :end-row 602, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-ratio", :ns "cljs.vendor.clojure.data.json", :private true, :row 601} {:end-row 645, :filename "cljs/vendor/clojure/data/json.clj", :name "default-write-options", :ns "cljs.vendor.clojure.data.json", :row 637} {:arglist-strs ["[x writer & {:as options}]"], :doc "Write JSON-formatted output to a java.io.Writer. Options are\n   key-value pairs, valid options are:\n\n    :escape-unicode boolean\n\n       If true (default) non-ASCII characters are escaped as \\uXXXX\n\n    :escape-js-separators boolean\n\n       If true (default) the Unicode characters U+2028 and U+2029 will\n       be escaped as \\u2028 and \\u2029 even if :escape-unicode is\n       false. (These two characters are valid in pure JSON but are not\n       valid in JavaScript strings.)\n\n    :escape-slash boolean\n\n       If true (default) the slash / is escaped as \\/\n\n    :sql-date-converter function\n\n       Single-argument function used to convert a java.sql.Date to\n       a java.time.Instant. As java.sql.Date does not have a\n       time-component (which is required by java.time.Instant), it needs\n       to be computed. The default implementation, `default-sql-date->instant-fn`\n       uses\n       ```\n          (.toInstant (.atStartOfDay (.toLocalDate sql-date) (java.time.ZoneId/systemDefault)))\n       ```\n\n    :date-formatter\n\n        A java.time.DateTimeFormatter instance, defaults to DateTimeFormatter/ISO_INSTANT\n\n    :key-fn function\n\n        Single-argument function called on map keys; return value will\n        replace the property names in the output. Must return a\n        string. Default calls clojure.core/name on symbols and\n        keywords and clojure.core/str on everything else.\n\n    :value-fn function\n\n        Function to transform values in maps before writing. For each\n        key-value pair in an input map, called with two arguments: the\n        key (BEFORE transformation by key-fn) and the value. The\n        return value of value-fn will replace the value in the output.\n        If the return value is a number, boolean, string, or nil it\n        will be included literally in the output. If the return value\n        is a non-map collection, it will be processed recursively. If\n        the return value is a map, it will be processed recursively,\n        calling value-fn again on its key-value pairs. If value-fn\n        returns itself, the key-value pair will be omitted from the\n        output. This option does not apply to non-map collections.", :end-row 701, :filename "cljs/vendor/clojure/data/json.clj", :name "write", :ns "cljs.vendor.clojure.data.json", :row 646} {:arglist-strs ["[x & {:as options}]"], :doc "Converts x to a JSON-formatted string. Options are the same as\n  write.", :end-row 709, :filename "cljs/vendor/clojure/data/json.clj", :name "write-str", :ns "cljs.vendor.clojure.data.json", :row 703} {:arglist-strs ["[s]"], :end-row 716, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{1}, :name "pprint-array", :ns "cljs.vendor.clojure.data.json", :private true, :row 715} {:arglist-strs ["[m options]"], :end-row 721, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{2}, :name "pprint-object", :ns "cljs.vendor.clojure.data.json", :private true, :row 718} {:arglist-strs ["[x options]"], :end-row 727, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{2}, :name "pprint-generic", :ns "cljs.vendor.clojure.data.json", :private true, :row 723} {:arglist-strs ["[x options]"], :end-row 734, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{2}, :name "pprint-dispatch", :ns "cljs.vendor.clojure.data.json", :private true, :row 729} {:arglist-strs ["[x & {:as options}]"], :doc "Pretty-prints JSON representation of x to *out*. Options are the\n  same as for write except :value-fn, which is not supported.", :end-row 742, :filename "cljs/vendor/clojure/data/json.clj", :name "pprint", :ns "cljs.vendor.clojure.data.json", :row 736} {:arglist-strs ["[input]" "[input keywordize?]" "[input keywordize? eof-error? eof-value]"], :doc "DEPRECATED; replaced by read-str.\n\n  Reads one JSON value from input String or Reader. If keywordize? is\n  true (default), object keys will be converted to keywords. If\n  eof-error? is true (default), empty input will throw an\n  EOFException; if false EOF will return eof-value.", :end-row 769, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{1 4 2}, :name "read-json", :ns "cljs.vendor.clojure.data.json", :row 746} {:arglist-strs ["[x out escape-unicode?]"], :doc "DEPRECATED; replaced by 'write'.\n\n  Print object to PrintWriter out as JSON", :end-row 776, :filename "cljs/vendor/clojure/data/json.clj", :fixed-arities #{3}, :name "write-json", :ns "cljs.vendor.clojure.data.json", :row 771} {:arglist-strs ["[x & options]"], :doc "DEPRECATED; replaced by 'write-str'.\n\n  Converts x to a JSON-formatted string.\n\n  Valid options are:\n    :escape-unicode false\n        to turn of \\uXXXX escapes of Unicode characters.", :end-row 787, :filename "cljs/vendor/clojure/data/json.clj", :name "json-str", :ns "cljs.vendor.clojure.data.json", :row 778} {:arglist-strs ["[x & options]"], :doc "DEPRECATED; replaced by 'write' to *out*.\n\n  Write JSON-formatted output to *out*.\n\n  Valid options are:\n    :escape-unicode false\n        to turn off \\uXXXX escapes of Unicode characters.", :end-row 798, :filename "cljs/vendor/clojure/data/json.clj", :name "print-json", :ns "cljs.vendor.clojure.data.json", :row 789} {:arglist-strs ["[x & options]"], :doc "DEPRECATED; replaced by 'pprint'.\n\n  Pretty-prints JSON representation of x to *out*.\n\n  Valid options are:\n    :escape-unicode false\n        to turn off \\uXXXX escapes of Unicode characters.", :end-row 809, :filename "cljs/vendor/clojure/data/json.clj", :name "pprint-json", :ns "cljs.vendor.clojure.data.json", :row 800}]} {:end-row 11, :filename "cljs/vendor/bridge.clj", :name "cljs.vendor.bridge", :row 9, :ns nil, :var-definitions nil} {:doc "An implementation of the transit-format for Clojure built\n   on top of the transit-java library.", :end-row 24, :filename "cljs/vendor/cognitect/transit.clj", :name "cljs.vendor.cognitect.transit", :row 15, :ns nil, :var-definitions [{:end-row 27, :filename "cljs/vendor/cognitect/transit.clj", :name "HandlerMapProvider", :ns "cljs.vendor.cognitect.transit", :row 26} {:arglist-strs ["[this]"], :end-row 27, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "handler-map", :ns "cljs.vendor.cognitect.transit", :row 27} {:end-row 31, :filename "cljs/vendor/cognitect/transit.clj", :name "HandlerMapContainer", :ns "cljs.vendor.cognitect.transit", :row 29} {:arglist-strs ["[m]"], :end-row 31, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "->HandlerMapContainer", :ns "cljs.vendor.cognitect.transit", :row 29} {:fixed-arities #{1}, :end-row 44, :private true, :ns "cljs.vendor.cognitect.transit", :name "transit-format", :filename "cljs/vendor/cognitect/transit.clj", :arglist-strs ["[kw]"], :doc "Converts a keyword to a TransitFactory$Format value.", :row 37} {:arglist-strs ["[tag rep]"], :doc "Creates a TaggedValue object.", :end-row 48, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{2}, :name "tagged-value", :ns "cljs.vendor.cognitect.transit", :row 46} {:arglist-strs ["[kw-or-sym]"], :doc "Convert a keyword or symbol to a string in\n   namespace/name format.", :end-row 56, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "nsed-name", :ns "cljs.vendor.cognitect.transit", :row 50} {:arglist-strs ["[f]"], :end-row 60, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "fn-or-val", :ns "cljs.vendor.cognitect.transit", :private true, :row 58} {:arglist-strs ["[tag-fn rep-fn]" "[tag-fn rep-fn str-rep-fn]" "[tag-fn rep-fn str-rep-fn verbose-handler-fn]"], :doc "Creates a transit WriteHandler whose tag, rep,\n   stringRep, and verboseWriteHandler methods\n   invoke the provided fns.\n\n   If a non-fn is passed as an argument, implemented\n   handler method returns the value unaltered.", :end-row 82, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{4 3 2}, :name "write-handler", :ns "cljs.vendor.cognitect.transit", :row 62} {:end-row 84, :filename "cljs/vendor/cognitect/transit.clj", :name "WithMeta", :ns "cljs.vendor.cognitect.transit", :row 84} {:arglist-strs ["[value meta]"], :end-row 84, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{2}, :name "->WithMeta", :ns "cljs.vendor.cognitect.transit", :row 84} {:doc "Returns a map of default WriteHandlers for\n   Clojure types. Java types are handled\n   by the default WriteHandlers provided by the\n   transit-java library.", :end-row 135, :filename "cljs/vendor/cognitect/transit.clj", :name "default-write-handlers", :ns "cljs.vendor.cognitect.transit", :row 86} {:end-row 137, :filename "cljs/vendor/cognitect/transit.clj", :name "Writer", :ns "cljs.vendor.cognitect.transit", :row 137} {:arglist-strs ["[w]"], :end-row 137, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "->Writer", :ns "cljs.vendor.cognitect.transit", :row 137} {:arglist-strs ["[out type]" "[out type {:keys [handlers default-handler transform]}]"], :doc "Creates a writer over the provided destination `out` using\n   the specified format, one of: :msgpack, :json or :json-verbose.\n\n   An optional opts map may be passed. Supported options are:\n\n   :handlers - a map of types to WriteHandler instances, they are merged\n   with the default-handlers and then with the default handlers\n   provided by transit-java.\n\n   :default-handler - a default WriteHandler to use if NO handler is\n   found for a type. If no default is specified, an error will be\n   thrown for an unknown type.\n\n   :transform - a function of one argument that will transform values before\n   they are written.", :end-row 166, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{3 2}, :name "writer", :ns "cljs.vendor.cognitect.transit", :row 139} {:arglist-strs ["[writer o]"], :doc "Writes a value to a transit writer.", :end-row 171, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{2}, :name "write", :ns "cljs.vendor.cognitect.transit", :row 168} {:arglist-strs ["[from-rep]"], :doc "Creates a transit ReadHandler whose fromRep\n   method invokes the provided fn.", :end-row 181, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "read-handler", :ns "cljs.vendor.cognitect.transit", :row 176} {:arglist-strs ["[from-rep map-reader]"], :doc "Creates a Transit MapReadHandler whose fromRep\n   and mapReader methods invoke the provided fns.", :end-row 189, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{2}, :name "read-map-handler", :ns "cljs.vendor.cognitect.transit", :row 183} {:arglist-strs ["[from-rep array-reader]"], :doc "Creates a Transit ArrayReadHandler whose fromRep\n   and arrayReader methods invoke the provided fns.", :end-row 197, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{2}, :name "read-array-handler", :ns "cljs.vendor.cognitect.transit", :row 191} {:doc "Returns a map of default ReadHandlers for\n   Clojure types. Java types are handled\n   by the default ReadHandlers provided by the\n   transit-java library.", :end-row 266, :filename "cljs/vendor/cognitect/transit.clj", :name "default-read-handlers", :ns "cljs.vendor.cognitect.transit", :row 200} {:arglist-strs ["[]"], :doc "Creates a MapBuilder that makes Clojure-\n   compatible maps.", :end-row 276, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{0}, :name "map-builder", :ns "cljs.vendor.cognitect.transit", :row 268} {:arglist-strs ["[]"], :doc "Creates an ArrayBuilder that makes Clojure-\n   compatible lists.", :end-row 286, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{0}, :name "list-builder", :ns "cljs.vendor.cognitect.transit", :row 278} {:end-row 288, :filename "cljs/vendor/cognitect/transit.clj", :name "Reader", :ns "cljs.vendor.cognitect.transit", :row 288} {:arglist-strs ["[r]"], :end-row 288, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "->Reader", :ns "cljs.vendor.cognitect.transit", :row 288} {:arglist-strs ["[in type]" "[in type {:keys [handlers default-handler]}]"], :doc "Creates a reader over the provided source `in` using\n   the specified format, one of: :msgpack, :json or :json-verbose.\n\n   An optional opts map may be passed. Supported options are:\n\n   :handlers - a map of tags to ReadHandler instances, they are merged\n   with the Clojure default-read-handlers and then with the default ReadHandlers\n   provided by transit-java.\n\n   :default-handler - an instance of DefaultReadHandler, used to process\n   transit encoded values for which there is no other ReadHandler; if\n   :default-handler is not specified, non-readable values are returned\n   as TaggedValues.", :end-row 317, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{3 2}, :name "reader", :ns "cljs.vendor.cognitect.transit", :row 290} {:arglist-strs ["[reader]"], :doc "Reads a value from a reader. Throws a RuntimeException when\n   the reader's InputStream is empty.", :end-row 323, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "read", :ns "cljs.vendor.cognitect.transit", :row 319} {:arglist-strs ["[type]"], :doc "Creates a WriteHandler for a record type", :end-row 332, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "record-write-handler", :ns "cljs.vendor.cognitect.transit", :row 325} {:arglist-strs ["[& types]"], :doc "Creates a map of record types to WriteHandlers", :end-row 339, :filename "cljs/vendor/cognitect/transit.clj", :name "record-write-handlers", :ns "cljs.vendor.cognitect.transit", :row 334} {:arglist-strs ["[type]"], :doc "Creates a ReadHandler for a record type", :end-row 349, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "record-read-handler", :ns "cljs.vendor.cognitect.transit", :row 341} {:arglist-strs ["[& types]"], :doc "Creates a map of record type tags to ReadHandlers", :end-row 356, :filename "cljs/vendor/cognitect/transit.clj", :name "record-read-handlers", :ns "cljs.vendor.cognitect.transit", :row 351} {:arglist-strs ["[custom-handlers]"], :doc "Returns a HandlerMapContainer containing a ReadHandlerMap\n  containing all the default handlers for Clojure and Java and any\n  custom handlers that you supply, letting you store the return value\n  and pass it to multiple invocations of reader.  This can be more\n  efficient than repeatedly handing the same raw map of tags -> custom\n  handlers to reader.", :end-row 367, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "read-handler-map", :ns "cljs.vendor.cognitect.transit", :row 358} {:arglist-strs ["[custom-handlers]"], :doc "Returns a HandlerMapContainer containing a WriteHandlerMap\n  containing all the default handlers for Clojure and Java and any\n  custom handlers that you supply, letting you store the return value\n  and pass it to multiple invocations of writer.  This can be more\n  efficient than repeatedly handing the same raw map of types -> custom\n  handlers to writer.", :end-row 378, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "write-handler-map", :ns "cljs.vendor.cognitect.transit", :row 369} {:arglist-strs ["[x]"], :doc "For :transform. Will write any metadata present on the value.", :end-row 387, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "write-meta", :ns "cljs.vendor.cognitect.transit", :row 380} {:end-row 395, :filename "cljs/vendor/cognitect/transit.clj", :name "out", :ns "cljs.vendor.cognitect.transit", :row 395} {:end-row 397, :filename "cljs/vendor/cognitect/transit.clj", :name "w", :ns "cljs.vendor.cognitect.transit", :row 397} {:end-row 398, :filename "cljs/vendor/cognitect/transit.clj", :name "w", :ns "cljs.vendor.cognitect.transit", :row 398} {:end-row 399, :filename "cljs/vendor/cognitect/transit.clj", :name "w", :ns "cljs.vendor.cognitect.transit", :row 399} {:end-row 400, :filename "cljs/vendor/cognitect/transit.clj", :name "w", :ns "cljs.vendor.cognitect.transit", :row 400} {:end-row 401, :filename "cljs/vendor/cognitect/transit.clj", :name "w", :ns "cljs.vendor.cognitect.transit", :row 401} {:end-row 421, :filename "cljs/vendor/cognitect/transit.clj", :name "in", :ns "cljs.vendor.cognitect.transit", :row 421} {:end-row 423, :filename "cljs/vendor/cognitect/transit.clj", :name "r", :ns "cljs.vendor.cognitect.transit", :row 423} {:end-row 425, :filename "cljs/vendor/cognitect/transit.clj", :name "r", :ns "cljs.vendor.cognitect.transit", :row 425} {:end-row 427, :filename "cljs/vendor/cognitect/transit.clj", :name "x", :ns "cljs.vendor.cognitect.transit", :row 427} {:end-row 434, :filename "cljs/vendor/cognitect/transit.clj", :name "Point", :ns "cljs.vendor.cognitect.transit", :row 434} {:arglist-strs ["[x y]"], :end-row 434, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{2}, :name "->Point", :ns "cljs.vendor.cognitect.transit", :row 434} {:arglist-strs ["[m]"], :end-row 434, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "map->Point", :ns "cljs.vendor.cognitect.transit", :row 434} {:end-row 436, :filename "cljs/vendor/cognitect/transit.clj", :name "Circle", :ns "cljs.vendor.cognitect.transit", :row 436} {:arglist-strs ["[c r]"], :end-row 436, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{2}, :name "->Circle", :ns "cljs.vendor.cognitect.transit", :row 436} {:arglist-strs ["[m]"], :end-row 436, :filename "cljs/vendor/cognitect/transit.clj", :fixed-arities #{1}, :name "map->Circle", :ns "cljs.vendor.cognitect.transit", :row 436} {:end-row 442, :filename "cljs/vendor/cognitect/transit.clj", :name "ext-write-handlers", :ns "cljs.vendor.cognitect.transit", :row 438} {:end-row 448, :filename "cljs/vendor/cognitect/transit.clj", :name "ext-read-handlers", :ns "cljs.vendor.cognitect.transit", :row 444} {:end-row 451, :filename "cljs/vendor/cognitect/transit.clj", :name "ext-write-handlers", :ns "cljs.vendor.cognitect.transit", :row 450} {:end-row 454, :filename "cljs/vendor/cognitect/transit.clj", :name "ext-read-handlers", :ns "cljs.vendor.cognitect.transit", :row 453} {:end-row 456, :filename "cljs/vendor/cognitect/transit.clj", :name "out", :ns "cljs.vendor.cognitect.transit", :row 456} {:end-row 457, :filename "cljs/vendor/cognitect/transit.clj", :name "w", :ns "cljs.vendor.cognitect.transit", :row 457} {:end-row 462, :filename "cljs/vendor/cognitect/transit.clj", :name "in", :ns "cljs.vendor.cognitect.transit", :row 462} {:end-row 463, :filename "cljs/vendor/cognitect/transit.clj", :name "r", :ns "cljs.vendor.cognitect.transit", :row 463} {:end-row 468, :filename "cljs/vendor/cognitect/transit.clj", :name "custom-write-handler-map", :ns "cljs.vendor.cognitect.transit", :row 468} {:end-row 469, :filename "cljs/vendor/cognitect/transit.clj", :name "custom-read-handler-map", :ns "cljs.vendor.cognitect.transit", :row 469} {:end-row 471, :filename "cljs/vendor/cognitect/transit.clj", :name "out", :ns "cljs.vendor.cognitect.transit", :row 471} {:end-row 472, :filename "cljs/vendor/cognitect/transit.clj", :name "w", :ns "cljs.vendor.cognitect.transit", :row 472} {:end-row 476, :filename "cljs/vendor/cognitect/transit.clj", :name "in", :ns "cljs.vendor.cognitect.transit", :row 476} {:end-row 477, :filename "cljs/vendor/cognitect/transit.clj", :name "r", :ns "cljs.vendor.cognitect.transit", :row 477}]} {:end-row 48, :filename "cljs/closure.clj", :name "cljs.closure", :row 9, :ns nil, :var-definitions [{:end-row 58, :filename "cljs/closure.clj", :name "GITLIBS-CACHE-DIR", :ns "cljs.closure", :private true, :row 52} {:fixed-arities #{0}, :end-row 63, :private true, :ns "cljs.closure", :name "gitlibs-cache-dir", :filename "cljs/closure.clj", :arglist-strs ["[]"], :doc "Returns the gitlibs cache dir, a string.", :row 60} {:fixed-arities #{1}, :end-row 70, :private true, :ns "cljs.closure", :name "gitlibs-src?", :filename "cljs/closure.clj", :arglist-strs ["[file]"], :doc "Returns true if the file comes from the gitlibs cache.", :row 65} {:end-row 72, :filename "cljs/closure.clj", :name "name-chars", :ns "cljs.closure", :row 72} {:arglist-strs ["[]"], :end-row 75, :filename "cljs/closure.clj", :fixed-arities #{0}, :name "random-char", :ns "cljs.closure", :row 74} {:arglist-strs ["[length]"], :end-row 78, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "random-string", :ns "cljs.closure", :row 77} {:fixed-arities #{3 2}, :end-row 104, :private true, :ns "cljs.closure", :name "sym->var", :filename "cljs/closure.clj", :arglist-strs ["[sym kw]" "[sym kw ex-data]"], :doc "Converts a namespaced symbol to a var, loading the requisite namespace if\n  needed. For use with a function defined under a keyword in opts. The kw and\n  ex-data arguments are used to form exceptions.", :row 80} {:fixed-arities #{2}, :end-row 111, :private true, :ns "cljs.closure", :name "opts-fn", :filename "cljs/closure.clj", :arglist-strs ["[kw opts]"], :doc "Extracts a function from opts, by default expecting a function value, but\n  converting from a namespaced symbol if needed.", :row 106} {:end-row 116, :filename "cljs/closure.clj", :name "js-source-file", :ns "cljs.closure", :row 116} {:end-row 142, :filename "cljs/closure.clj", :name "check-level", :ns "cljs.closure", :row 139} {:end-row 197, :filename "cljs/closure.clj", :name "warning-types", :ns "cljs.closure", :row 144} {:doc "Set of all known compiler options.", :end-row 213, :filename "cljs/closure.clj", :name "known-opts", :ns "cljs.closure", :row 199} {:end-row 221, :filename "cljs/closure.clj", :name "string->charset", :ns "cljs.closure", :row 215} {:arglist-strs ["[charset]"], :end-row 234, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "to-charset", :ns "cljs.closure", :row 223} {:end-row 239, :filename "cljs/closure.clj", :name "lang-level", :ns "cljs.closure", :row 236} {:arglist-strs ["[key]"], :end-row 242, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "expand-lang-key", :ns "cljs.closure", :row 241} {:arglist-strs ["[key]"], :end-row 255, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "lang-key->lang-mode", :ns "cljs.closure", :row 244} {:arglist-strs ["[opts compiler-options]"], :doc "TODO: Add any other options that we would like to support.", :end-row 323, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "set-options", :ns "cljs.closure", :row 257} {:arglist-strs ["[opts]"], :doc "Create a CompilerOptions object and set options from opts map.", :end-row 361, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "make-options", :ns "cljs.closure", :row 325} {:arglist-strs ["[{:keys [externs use-only-custom-externs target ups-externs infer-externs] :as opts}]"], :doc "Externs are JavaScript files which contain empty definitions of\n  functions which will be provided by the environment. Any function in\n  an extern file will not be renamed during optimization.\n\n  Options may contain an :externs key with a list of file paths to\n  load. The :use-only-custom-externs flag may be used to indicate that\n  the default externs should be excluded.", :end-row 402, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "load-externs", :ns "cljs.closure", :row 363} {:arglist-strs ["[]"], :end-row 407, :filename "cljs/closure.clj", :fixed-arities #{0}, :name "make-closure-compiler", :ns "cljs.closure", :row 404} {:arglist-strs ["[result]"], :end-row 418, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "report-failure", :ns "cljs.closure", :row 409} {:end-row 427, :filename "cljs/closure.clj", :name "ISourceMap", :ns "cljs.closure", :row 425} {:arglist-strs ["[this]"], :doc "Return the CLJS source url", :end-row 426, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "-source-url", :ns "cljs.closure", :row 426} {:arglist-strs ["[this]"], :doc "Return the CLJS compiler generated JS source mapping", :end-row 427, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "-source-map", :ns "cljs.closure", :row 427} {:end-row 497, :filename "cljs/closure.clj", :name "JavaScriptFile", :ns "cljs.closure", :row 481} {:arglist-strs ["[foreign url source-url provides requires lines source-map]"], :end-row 497, :filename "cljs/closure.clj", :fixed-arities #{7}, :name "->JavaScriptFile", :ns "cljs.closure", :row 481} {:arglist-strs ["[m]"], :end-row 497, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "map->JavaScriptFile", :ns "cljs.closure", :row 481} {:arglist-strs ["[foreign url provides requires]" "[foreign url source-url provides requires lines source-map]"], :end-row 504, :filename "cljs/closure.clj", :fixed-arities #{7 4}, :name "javascript-file", :ns "cljs.closure", :row 499} {:arglist-strs ["[m]"], :end-row 531, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "map->javascript-file", :ns "cljs.closure", :row 506} {:arglist-strs ["[f]"], :doc "Read a JavaScript file returning a map of file information.", :end-row 538, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "read-js", :ns "cljs.closure", :row 533} {:end-row 545, :filename "cljs/closure.clj", :name "Inputs", :ns "cljs.closure", :row 544} {:arglist-strs ["[this]"], :doc "Returns the file paths to the source inputs", :end-row 545, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "-paths", :ns "cljs.closure", :row 545} {:end-row 555, :filename "cljs/closure.clj", :name "Compilable", :ns "cljs.closure", :row 553} {:arglist-strs ["[this opts]"], :doc "Returns one or more IJavaScripts.", :end-row 554, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "-compile", :ns "cljs.closure", :row 554} {:arglist-strs ["[this opts]"], :doc "Returns one or more IJavascripts, without compiling them.", :end-row 555, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "-find-sources", :ns "cljs.closure", :row 555} {:arglist-strs ["[paths]"], :doc "Takes a coll of inputs as strings or files and returns a\n  single Inputs and Compilable object.", :end-row 571, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "compilable-input-paths", :ns "cljs.closure", :row 557} {:arglist-strs ["[forms]" "[forms opts]"], :doc "Compile a sequence of forms to a JavaScript source string.", :end-row 585, :filename "cljs/closure.clj", :fixed-arities #{1 2}, :name "compile-form-seq", :ns "cljs.closure", :row 573} {:arglist-strs ["[m]"], :doc "Given a map with at least a :file key, return a map with\n   {:file .. :provides .. :requires ..}.\n\n   Compiled files are cached so they will only be read once.", :end-row 600, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "compiled-file", :ns "cljs.closure", :row 587} {:arglist-strs ["[compilable opts]"], :doc "Given a Compilable, compile it and return an IJavaScript.", :end-row 605, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "compile", :ns "cljs.closure", :row 602} {:end-row 608, :filename "cljs/closure.clj", :name "USER-HOME-WRITABLE", :ns "cljs.closure", :private true, :row 607} {:arglist-strs ["[opts]"], :end-row 614, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "aot-cache?", :ns "cljs.closure", :private true, :row 610} {:arglist-strs ["[cache-path cacheable source-file opts]"], :end-row 628, :filename "cljs/closure.clj", :fixed-arities #{4}, :name "copy-from-cache", :ns "cljs.closure", :private true, :row 616} {:arglist-strs ["[compilable opts]"], :doc "Given a Compilable, find sources and return a sequence of IJavaScript.", :end-row 633, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "find-sources", :ns "cljs.closure", :row 630} {:arglist-strs ["[file {:keys [output-file] :as opts}]"], :doc "Compile a single cljs file. If no output-file is specified, returns\n  a string of compiled JavaScript. With an output-file option, the\n  compiled JavaScript will written to this location and the function\n  returns a JavaScriptFile. In either case the return value satisfies\n  IJavaScript.", :end-row 661, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "compile-file", :ns "cljs.closure", :row 635} {:arglist-strs ["[src-dir opts]"], :doc "Recursively compile all cljs files under the given source\n  directory. Return a list of JavaScriptFiles.", :end-row 669, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "compile-dir", :ns "cljs.closure", :row 663} {:arglist-strs ["[url]"], :doc "Given the URL of a file within a jar, return the path of the file\n  from the root of the jar.", :end-row 675, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "path-from-jarfile", :ns "cljs.closure", :row 671} {:arglist-strs ["[url out-dir]" "[url out-dir opts]"], :doc "Copy a file contained within a jar to disk. Return the created file.", :end-row 692, :filename "cljs/closure.clj", :fixed-arities #{3 2}, :name "jar-file-to-disk", :ns "cljs.closure", :row 677} {:arglist-strs ["[jar-file {:keys [output-file] :as opts}]"], :doc "Compile a file from a jar if necessary. Returns IJavaScript.", :end-row 720, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "compile-from-jar", :ns "cljs.closure", :row 694} {:arglist-strs ["[this opts]"], :end-row 723, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "find-jar-sources", :ns "cljs.closure", :row 722} {:arglist-strs ["[opts requires]"], :doc "Given a sequence of Closure namespace strings, return the list of\n  all dependencies. The returned list includes all Google and\n  third-party library dependencies.\n\n  Third-party libraries are configured using the :libs option where\n  the value is a list of directories containing third-party\n  libraries.", :end-row 818, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "js-dependencies", :ns "cljs.closure", :row 798} {:arglist-strs ["[compiled]"], :doc "If a compiled entity is the cljs.js namespace, explicitly\n  add the cljs.core macros namespace dependency to it.", :end-row 844, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "add-core-macros-if-cljs-js", :ns "cljs.closure", :row 836} {:arglist-strs ["[opts {:keys [relative-path uri]}]"], :doc "Return an IJavaScript for this file. Compiled output will be\n   written to the working directory.", :end-row 852, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "get-compiled-cljs", :ns "cljs.closure", :row 846} {:arglist-strs ["[ns]"], :doc "Given a namespace return the corresponding source with either a .cljs or\n  .cljc extension.", :end-row 867, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "cljs-source-for-namespace", :ns "cljs.closure", :row 854} {:arglist-strs ["[ns compiler-env]"], :doc "Given a namespace and compilation environment return the relative path and\n  uri of the corresponding source regardless of the source language extension:\n  .cljs, .cljc, .js", :end-row 899, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "source-for-namespace", :ns "cljs.closure", :row 869} {:arglist-strs ["[opts requires]"], :doc "Given a list of all required namespaces, return a list of\n  IJavaScripts which are the cljs dependencies. The returned list will\n  not only include the explicitly required files but any transitive\n  dependencies as well. JavaScript files will be compiled to the\n  working directory if they do not already exist.\n\n  Only load dependencies from the classpath.", :end-row 926, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "cljs-dependencies", :ns "cljs.closure", :row 901} {:arglist-strs ["[requires]"], :doc "Given set of cljs namespace symbols, find IJavaScript objects for the namespaces.", :end-row 957, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "find-cljs-dependencies", :ns "cljs.closure", :row 937} {:fixed-arities #{1}, :end-row 963, :private true, :ns "cljs.closure", :name "constants-filename", :filename "cljs/closure.clj", :arglist-strs ["[opts]"], :doc "Returns the filename of the constants table.", :row 959} {:fixed-arities #{1}, :end-row 969, :private true, :ns "cljs.closure", :name "constants-javascript-file", :filename "cljs/closure.clj", :arglist-strs ["[opts]"], :doc "Returns the constants table as a JavaScriptFile.", :row 965} {:arglist-strs ["[opts & inputs]"], :doc "DEPRECATED: Given one or more IJavaScript objects in dependency order, produce\n  a new sequence of IJavaScript objects which includes the input list\n  plus all dependencies in dependency order.", :end-row 998, :filename "cljs/closure.clj", :name "add-dependencies", :ns "cljs.closure", :row 971} {:fixed-arities #{1}, :end-row 1017, :private true, :ns "cljs.closure", :name "module-entries", :filename "cljs/closure.clj", :arglist-strs ["[compile-opts]"], :doc "Return the module entries of `compile-opts` as a set.", :row 1010} {:arglist-strs ["[inputs]" "[inputs compile-opts]"], :doc "Given list of IJavaScript objects, produce a new sequence of IJavaScript objects\n  of all dependencies of inputs.", :end-row 1030, :filename "cljs/closure.clj", :fixed-arities #{1 2}, :name "add-dependency-sources", :ns "cljs.closure", :row 1019} {:arglist-strs ["[inputs]"], :end-row 1039, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "check-unprovided", :ns "cljs.closure", :row 1032} {:arglist-strs ["[deque input-set compiled opts failed]"], :end-row 1065, :filename "cljs/closure.clj", :fixed-arities #{5}, :name "compile-task", :ns "cljs.closure", :row 1041} {:arglist-strs ["[inputs compiler-stats opts]"], :end-row 1085, :filename "cljs/closure.clj", :fixed-arities #{3}, :name "parallel-compile-sources", :ns "cljs.closure", :row 1067} {:arglist-strs ["[inputs opts]" "[inputs compiler-stats opts]"], :doc "Takes dependency ordered list of IJavaScript compatible maps from parse-ns\n  and compiles them.", :end-row 1105, :filename "cljs/closure.clj", :fixed-arities #{3 2}, :name "compile-sources", :ns "cljs.closure", :row 1087} {:arglist-strs ["[inputs]"], :end-row 1109, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "remove-goog-base", :ns "cljs.closure", :row 1107} {:arglist-strs ["[inputs]"], :end-row 1114, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "add-goog-base", :ns "cljs.closure", :row 1111} {:arglist-strs ["[inputs opts]"], :doc "Given list of IJavaScript objects, add foreign-deps, constants-table\n   IJavaScript objects to the list.", :end-row 1132, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "add-js-sources", :ns "cljs.closure", :row 1116} {:arglist-strs ["[inputs opts]"], :doc "Add :preloads to a given set of inputs (IJavaScript). Returns a new\n  list of inputs where the preloaded namespaces and their deps come immediately after\n  cljs.core or the constants table depending on the optimization setting. Any\n  files needing copying or compilation will be compiled and/or copied to the\n  appropiate location.", :end-row 1164, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "add-preloads", :ns "cljs.closure", :row 1134} {:arglist-strs ["[paths]"], :end-row 1175, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "preamble-from-paths", :ns "cljs.closure", :row 1171} {:arglist-strs ["[{:keys [target preamble hashbang]}]"], :end-row 1180, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "make-preamble", :ns "cljs.closure", :row 1177} {:end-row 1185, :filename "cljs/closure.clj", :name "javascript-name", :ns "cljs.closure", :row 1185} {:arglist-strs ["[provides]"], :doc "Given a vector of provides, builds required goog.provide statements", :end-row 1200, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "build-provides", :ns "cljs.closure", :row 1197} {:arglist-strs ["[modules]" "[modules opts]"], :doc "Ensure that compiler :modules map has :cljs-base module with defined\n  :output-to. If :output-to not provided will default to :output-dir location\n  and the name of the file will be \"cljs_base.js.\"", :end-row 1221, :filename "cljs/closure.clj", :fixed-arities #{1 2}, :name "ensure-cljs-base-module", :ns "cljs.closure", :row 1208} {:fixed-arities #{2}, :end-row 1240, :private true, :ns "cljs.closure", :name "const-expr-form", :filename "cljs/closure.clj", :arglist-strs ["[compiler-state sym]"], :doc "Returns the :const-expr form for `sym` from `compiler-state`.", :row 1236} {:arglist-strs ["[inputs {:keys [modules] :as opts}]"], :doc "Special compilation pass for cljs.loader namespace. cljs.loader must be\n  compiled last after all inputs. This is because all inputs must be known and\n  they must already be sorted in dependency order.", :end-row 1266, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "compile-loader", :ns "cljs.closure", :row 1242} {:arglist-strs ["[sources opts]"], :doc "Given a list of IJavaScript sources in dependency order and compiler options\n   return a dependency sorted list of module name / description tuples. The\n   module descriptions will be augmented with a :closure-module entry holding\n   the Closure JSChunk. Each module description will also be augmented with\n   a :foreign-deps vector containing foreign IJavaScript sources in dependency\n   order.", :end-row 1335, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "build-modules", :ns "cljs.closure", :row 1268} {:arglist-strs ["[sm-json sources name opts]"], :doc "Given a JSON parsed Google Closure JavaScript to JavaScript source map,\n   the entire list of original IJavaScript sources output a merged JavaScript\n   to ClojureScript source map file with the given file name. opts should\n   supply :preamble-line-count and :foreign-deps-line-count if they are\n   relevant.", :end-row 1419, :filename "cljs/closure.clj", :fixed-arities #{4}, :name "emit-optimized-source-map", :ns "cljs.closure", :row 1363} {:arglist-strs ["[result opts]"], :end-row 1431, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "write-variable-maps", :ns "cljs.closure", :row 1421} {:arglist-strs ["[opts & sources]"], :doc "Use the Closure Compiler to optimize one or more Closure JSChunks. Returns\n   a dependency sorted list of module name and description tuples.", :end-row 1482, :filename "cljs/closure.clj", :name "optimize-modules", :ns "cljs.closure", :row 1433} {:arglist-strs ["[sources]"], :end-row 1491, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "->js-source-files", :ns "cljs.closure", :row 1484} {:arglist-strs ["[opts & sources]"], :doc "Use the Closure Compiler to optimize one or more JavaScript files.", :end-row 1529, :filename "cljs/closure.clj", :name "optimize", :ns "cljs.closure", :row 1493} {:arglist-strs ["[base input]"], :doc "Generate a string which is the path to the input IJavaScript relative\n  to the specified base file.", :end-row 1586, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "path-relative-to", :ns "cljs.closure", :row 1575} {:arglist-strs ["[opts input]"], :doc "Return a goog.addDependency string for an input.", :end-row 1606, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "add-dep-string", :ns "cljs.closure", :row 1588} {:arglist-strs ["[opts sources]"], :doc "Return a deps file string for a sequence of inputs.", :end-row 1611, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "deps-file", :ns "cljs.closure", :row 1608} {:arglist-strs ["[js {:keys [elide-strict] :as opts}]"], :end-row 1621, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "elide-strict", :ns "cljs.closure", :row 1619} {:arglist-strs ["[content out-file]"], :end-row 1633, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "fingerprint-out-file", :ns "cljs.closure", :row 1623} {:arglist-strs ["[{:keys [output-to fingerprint] :as opts} js]"], :end-row 1652, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "output-one-file", :ns "cljs.closure", :row 1635} {:arglist-strs ["[opts sources]"], :end-row 1655, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "output-deps-file", :ns "cljs.closure", :row 1654} {:end-row 1657, :filename "cljs/closure.clj", :name "foreign-deps-str", :ns "cljs.closure", :row 1657} {:end-row 1657, :filename "cljs/closure.clj", :name "add-header", :ns "cljs.closure", :row 1657} {:end-row 1657, :filename "cljs/closure.clj", :name "add-source-map-link", :ns "cljs.closure", :row 1657} {:arglist-strs ["[syms]" "[syms mode]"], :end-row 1667, :filename "cljs/closure.clj", :fixed-arities #{1 2}, :name "preloads", :ns "cljs.closure", :row 1659} {:arglist-strs ["[opts]"], :end-row 1670, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "bundle?", :ns "cljs.closure", :row 1669} {:arglist-strs ["[dep]"], :end-row 1673, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "export-dep", :ns "cljs.closure", :row 1672} {:arglist-strs ["[node-requires]"], :doc "Returns the JavaScript code to support runtime require of bundled modules.", :end-row 1683, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "npm-deps-js", :ns "cljs.closure", :row 1675} {:arglist-strs ["[opts]"], :doc "Output an entry point. In the non-modules case, opts is simply compiler\n  options. When emitting a module entry point, opts must contain :module-name.", :end-row 1765, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "output-main-file", :ns "cljs.closure", :row 1685} {:arglist-strs ["[modules fingerprint-info]"], :end-row 1776, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "fingerprinted-modules", :ns "cljs.closure", :row 1767} {:arglist-strs ["[opts js-sources modules]"], :doc "Given compiler options, original IJavaScript sources and a sequence of\n   module name and module description tuples output module sources to disk.\n   Modules description must define :output-to and supply :source entry with\n   the JavaScript source to write to disk.", :end-row 1859, :filename "cljs/closure.clj", :fixed-arities #{3}, :name "output-modules", :ns "cljs.closure", :row 1778} {:arglist-strs ["[{:keys [lib-path url provides] :as ijs}]"], :end-row 1868, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "lib-rel-path", :ns "cljs.closure", :row 1861} {:arglist-strs ["[js]" "[js opts]"], :doc "Given a IJavaScript which points to a .js file either in memory, in a jar file,\n  or is a foreign lib, return the path relative to the output directory.", :end-row 1890, :filename "cljs/closure.clj", :fixed-arities #{1 2}, :name "rel-output-path", :ns "cljs.closure", :row 1870} {:arglist-strs ["[js-modules opts]"], :end-row 1899, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "get-source-files", :ns "cljs.closure", :row 1892} {:arglist-strs ["[opts]"], :end-row 1907, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "make-convert-js-module-options", :ns "cljs.closure", :row 1901} {:arglist-strs ["[module-type]"], :end-row 1916, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "module-type->keyword", :ns "cljs.closure", :row 1909} {:arglist-strs ["[closure-compiler inputs-by-name opts {:keys [file-min file provides requires] :as ijs}]"], :end-row 1954, :filename "cljs/closure.clj", :fixed-arities #{4}, :name "add-converted-source", :ns "cljs.closure", :row 1918} {:fixed-arities #{1}, :end-row 1973, :private true, :ns "cljs.closure", :name "package-json-entries", :filename "cljs/closure.clj", :arglist-strs ["[opts]"], :doc "Takes options and returns a sequence with the desired order of package.json\n   entries for the given :package-json-resolution mode. If no mode is provided,\n   defaults to :webpack (if no target is set) and :nodejs (if the target is\n   :nodejs).", :row 1956} {:arglist-strs ["[]"], :end-row 1992, :filename "cljs/closure.clj", :fixed-arities #{0}, :name "sorting-dependency-options", :ns "cljs.closure", :private true, :row 1985} {:arglist-strs ["[js-modules opts]"], :doc "Takes a list JavaScript modules as an IJavaScript and rewrites them into a Google\n  Closure-compatible form. Returns list IJavaScript with the converted module\n  code set as source.", :end-row 2021, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "convert-js-modules", :ns "cljs.closure", :row 1994} {:doc "Takes an IJavaScript with the source code set as source, transforms the\n  source code and returns an IJavascript with the new code set as source.", :end-row 2027, :filename "cljs/closure.clj", :name "js-transforms", :ns "cljs.closure", :row 2023} {:arglist-strs ["[url]"], :end-row 2041, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "url->nio-path", :ns "cljs.closure", :row 2033} {:arglist-strs ["[source]"], :end-row 2049, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "add-goog-load", :ns "cljs.closure", :row 2043} {:arglist-strs ["[]"], :end-row 2054, :filename "cljs/closure.clj", :fixed-arities #{0}, :name "es5-warnings", :ns "cljs.closure", :row 2051} {:arglist-strs ["[]"], :end-row 2066, :filename "cljs/closure.clj", :fixed-arities #{0}, :name "transpile-options", :ns "cljs.closure", :row 2056} {:arglist-strs ["[rsc opts]" "[path source opts]"], :doc "Transpile a single JavaScript file to JavaScript. Used to lower Closure\n  Library files written in more recent versions of the JavaScript standard.", :end-row 2080, :filename "cljs/closure.clj", :fixed-arities #{3 2}, :name "closure-transpile", :ns "cljs.closure", :row 2068} {:arglist-strs ["[{:keys [language-out] :or {language-out :es3} :as opts} rsc {:keys [module lang] :as js}]"], :end-row 2093, :filename "cljs/closure.clj", :fixed-arities #{3}, :name "transpile", :ns "cljs.closure", :row 2083} {:arglist-strs ["[out-file]"], :end-row 2097, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "requires-transpile?", :ns "cljs.closure", :row 2095} {:arglist-strs ["[opts {:keys [module lang]}]"], :end-row 2112, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "transpile?", :ns "cljs.closure", :row 2111} {:arglist-strs ["[{:keys [optimizations] :as opts} js]"], :doc "Write or copy a JavaScript file to output directory. Only write if the file\n   does not already exist. Return IJavaScript for the file on disk at the new\n   location.", :end-row 2151, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "write-javascript", :ns "cljs.closure", :row 2114} {:arglist-strs ["[js]"], :doc "Returns true if IJavaScript instance needs to be written/copied to output\n  directory. True when in memory, in a JAR, or if foreign library.", :end-row 2164, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "write-js?", :ns "cljs.closure", :row 2153} {:arglist-strs ["[opts js]"], :doc "Ensure that the given IJavaScript exists on disk in the output directory.\n   Return updated IJavaScript with the new location if necessary.", :end-row 2189, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "source-on-disk", :ns "cljs.closure", :row 2166} {:arglist-strs ["[{:keys [modules] :as opts} & sources]"], :doc "Ensure that all JavaScript source files are on disk (not in jars),\n   write the goog deps file including only the libraries that are being\n   used and write the deps file for the current project.\n\n   The deps file for the current project will include third-party\n   libraries.", :end-row 2242, :filename "cljs/closure.clj", :name "output-unoptimized", :ns "cljs.closure", :row 2202} {:arglist-strs ["[]" "[classloader]"], :doc "returns a merged map containing all upstream dependencies defined\n  by libraries on the classpath.", :end-row 2257, :filename "cljs/closure.clj", :fixed-arities #{0 1}, :name "get-upstream-deps*", :ns "cljs.closure", :row 2244} {:end-row 2259, :filename "cljs/closure.clj", :name "get-upstream-deps", :ns "cljs.closure", :row 2259} {:arglist-strs ["[opts js]"], :end-row 2262, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "add-header", :ns "cljs.closure", :row 2261} {:arglist-strs ["[opts sources]"], :end-row 2272, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "foreign-deps-str", :ns "cljs.closure", :row 2264} {:arglist-strs ["[{:keys [output-wrapper] :as opts} js]"], :end-row 2280, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "add-wrapper", :ns "cljs.closure", :row 2274} {:arglist-strs ["[{:keys [source-map output-to] :as opts} js]"], :end-row 2287, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "add-source-map-link", :ns "cljs.closure", :row 2282} {:arglist-strs ["[path]"], :end-row 2290, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "absolute-path?", :ns "cljs.closure", :row 2289} {:arglist-strs ["[path]"], :end-row 2293, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "absolute-parent", :ns "cljs.closure", :row 2292} {:arglist-strs ["[path-1 path-2]"], :doc "Checks that path-1 and path-2 are siblings in the same logical directory.", :end-row 2299, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "in-same-dir?", :ns "cljs.closure", :row 2295} {:arglist-strs ["[dir path]"], :doc "Checks that path names a file or directory that is the dir or a subdirectory there of.", :end-row 2306, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "same-or-subdirectory-of?", :ns "cljs.closure", :row 2301} {:arglist-strs ["[{:keys [output-to] :as opts}]"], :end-row 2314, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "check-output-to", :ns "cljs.closure", :row 2308} {:arglist-strs ["[{:keys [output-dir] :as opts}]"], :end-row 2321, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "check-output-dir", :ns "cljs.closure", :row 2316} {:arglist-strs ["[{:keys [output-to source-map output-dir optimizations] :as opts}]"], :doc "When :source-map is specified in opts, ", :end-row 2354, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "check-source-map", :ns "cljs.closure", :row 2323} {:arglist-strs ["[{:keys [source-map-path] :as opts}]"], :end-row 2366, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "check-source-map-path", :ns "cljs.closure", :row 2356} {:arglist-strs ["[{:keys [output-wrapper optimizations]}]"], :end-row 2370, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "check-output-wrapper", :ns "cljs.closure", :row 2368} {:arglist-strs ["[{:keys [nodejs-rt optimizations] :as opts}]"], :end-row 2376, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "check-node-target", :ns "cljs.closure", :row 2372} {:arglist-strs ["[{:keys [main] :as opts}]"], :end-row 2384, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "check-main", :ns "cljs.closure", :row 2378} {:arglist-strs ["[{:keys [preloads optimizations] :as opts}]"], :end-row 2391, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "check-preloads", :ns "cljs.closure", :row 2386} {:arglist-strs ["[{:keys [cache-analysis cache-analysis-format] :as opts}]"], :end-row 2398, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "check-cache-analysis-format", :ns "cljs.closure", :row 2393} {:arglist-strs ["[{:keys [npm-deps]}]"], :end-row 2411, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "check-npm-deps", :ns "cljs.closure", :row 2400} {:arglist-strs ["[js]"], :end-row 2415, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "foreign-source?", :ns "cljs.closure", :row 2413} {:arglist-strs ["[libs]"], :doc "EXPERIMENTAL. Given a set of libs expand any entries which only name\n   directories into a sequence of lib entries for all JS files recursively\n   found in that directory. All other options will be shared with the original\n   entry. The computed :provides assumes the specified directory is on the\n   classpath.", :end-row 2449, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "expand-libs", :ns "cljs.closure", :row 2417} {:end-row 2451, :filename "cljs/closure.clj", :name "index-node-modules", :ns "cljs.closure", :row 2451} {:arglist-strs ["[]" "[{:keys [npm-deps]}]"], :end-row 2468, :filename "cljs/closure.clj", :fixed-arities #{0 1}, :name "compute-upstream-npm-deps", :ns "cljs.closure", :row 2453} {:arglist-strs ["[opts]"], :end-row 2472, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "ensure-module-opts", :ns "cljs.closure", :row 2470} {:arglist-strs ["[{:keys [target process-shim] :as opts}]"], :end-row 2478, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "shim-process?", :ns "cljs.closure", :row 2474} {:arglist-strs ["[defines]"], :end-row 2484, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "normalize-closure-defines", :ns "cljs.closure", :row 2480} {:arglist-strs ["[fns]"], :end-row 2506, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "resolve-warning-handlers", :ns "cljs.closure", :row 2486} {:arglist-strs ["[{:keys [optimizations output-dir] :or {optimizations :none output-dir \"out\"} :as opts}]"], :end-row 2614, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "add-implicit-options", :ns "cljs.closure", :row 2508} {:arglist-strs ["[proc]"], :end-row 2617, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "alive?", :ns "cljs.closure", :private true, :row 2616} {:arglist-strs ["[proc in out]"], :end-row 2632, :filename "cljs/closure.clj", :fixed-arities #{3}, :name "pipe", :ns "cljs.closure", :private true, :row 2619} {:arglist-strs ["[{:keys [deps-cmd npm-deps verbose] :or {deps-cmd \"npm\"} :as opts}]"], :end-row 2668, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "maybe-install-node-deps!", :ns "cljs.closure", :row 2634} {:arglist-strs ["[entry]" "[{:keys [file]} {:keys [target] :as opts}]"], :doc "EXPERIMENTAL: return the foreign libs entries as computed by running\n   the module-deps package on the supplied JavaScript entry point. Assumes\n   that the `@cljs-oss/module-deps` NPM package is either locally or globally\n   installed.", :end-row 2721, :filename "cljs/closure.clj", :fixed-arities #{1 2}, :name "node-module-deps", :ns "cljs.closure", :row 2670} {:arglist-strs ["[entries]" "[entries opts]"], :doc "EXPERIMENTAL: return the foreign libs entries as computed by running\n   the module-deps package on the supplied JavaScript entry points. Assumes\n   that the `@cljs-oss/module-deps` NPM package is either locally or globally\n   installed.", :end-row 2733, :filename "cljs/closure.clj", :fixed-arities #{1 2}, :name "node-inputs", :ns "cljs.closure", :row 2723} {:arglist-strs ["[modules]" "[modules opts]"], :end-row 2764, :filename "cljs/closure.clj", :fixed-arities #{1 2}, :name "index-node-modules", :ns "cljs.closure", :row 2735} {:fixed-arities #{2}, :end-row 2867, :private true, :ns "cljs.closure", :name "node-file-seq->libs-spec*", :filename "cljs/closure.clj", :arglist-strs ["[module-fseq opts]"], :doc "Given a sequence of non-nested node_module paths where the extension ends in\n  `.js/.json`, return lib-spec maps for each path containing at least :file,\n   :module-type, and :provides.", :row 2766} {:end-row 2869, :filename "cljs/closure.clj", :name "node-file-seq->libs-spec", :ns "cljs.closure", :row 2869} {:arglist-strs ["[]" "[opts]"], :end-row 2878, :filename "cljs/closure.clj", :fixed-arities #{0 1}, :name "index-node-modules-dir", :ns "cljs.closure", :row 2871} {:arglist-strs ["[{:keys [preprocess] :as js-module} opts]"], :doc "Given js-module map, apply preprocessing defined by :preprocess value in the map.", :end-row 2901, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "preprocess-js", :ns "cljs.closure", :row 2880} {:arglist-strs ["[file-str]"], :end-row 2904, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "to-absolute-path", :ns "cljs.closure", :private true, :row 2903} {:arglist-strs ["[opts]"], :doc "Given the current compiler options, converts JavaScript modules to Google\n  Closure modules and writes them to disk. Adds mapping from original module\n  namespace to new module namespace to compiler env. Returns modified compiler\n  options where new modules are passed with :libs option.", :end-row 2975, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "process-js-modules", :ns "cljs.closure", :row 2906} {:arglist-strs ["[compiler]"], :end-row 2979, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "load-data-readers!", :ns "cljs.closure", :row 2977} {:arglist-strs ["[opts]"], :end-row 2984, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "add-externs-sources", :ns "cljs.closure", :row 2981} {:arglist-strs ["[{:keys [npm-deps target] :as opts} js-sources compiler-env]"], :doc "Given all Cljs sources (build inputs and dependencies in classpath)\n\n  - index all the node modules\n  - process the JS modules (preprocess + convert to Closure JS)\n  - save js-dependency-index for compilation", :end-row 3041, :filename "cljs/closure.clj", :fixed-arities #{3}, :name "handle-js-modules", :ns "cljs.closure", :row 2986} {:arglist-strs ["[{:keys [target target-fn] :as opts}]"], :end-row 3053, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "output-bootstrap", :ns "cljs.closure", :row 3043} {:arglist-strs ["[inputs opts]"], :doc "Compile inputs and all of their transitive dependencies including JS modules,\n   libs, and foreign libs. Duplicates the pipeline of build.", :end-row 3069, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "compile-inputs", :ns "cljs.closure", :row 3055} {:arglist-strs ["[ns opts]"], :doc "Compiles a namespace and all of its transitive dependencies.\n   See compile-inputs.", :end-row 3075, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "compile-ns", :ns "cljs.closure", :row 3071} {:arglist-strs ["[opts]"], :end-row 3087, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "validate-opts", :ns "cljs.closure", :row 3077} {:arglist-strs ["[opts]"], :end-row 3102, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "run-bundle-cmd", :ns "cljs.closure", :row 3089} {:arglist-strs ["[opts]" "[source opts]" "[source opts compiler-env]"], :doc "Given compiler options, produce runnable JavaScript. An optional source\n   parameter may be provided.", :end-row 3267, :filename "cljs/closure.clj", :fixed-arities #{1 3 2}, :name "build", :ns "cljs.closure", :row 3104} {:arglist-strs ["[ns-sym output-dir]"], :end-row 3290, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "target-file-for-cljs-ns", :ns "cljs.closure", :row 3286} {:arglist-strs ["[ns-sym output-dir]"], :end-row 3296, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "mark-cljs-ns-for-recompile!", :ns "cljs.closure", :row 3292} {:arglist-strs ["[state namespaces]"], :end-row 3304, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "cljs-dependents-for-macro-namespaces", :ns "cljs.closure", :row 3298} {:arglist-strs ["[source opts]" "[source opts compiler-env]" "[source opts compiler-env quit]"], :doc "Given a source directory, produce runnable JavaScript. Watch the source\n   directory for changes rebuilding when necessary. Takes the same arguments as\n   cljs.closure/build in addition to some watch-specific options:\n    - :watch-fn, a function of no arguments to run after a successful build. May\n                 be a function value or a namespaced symbol identifying a function,\n                 in which case the associated namespace willl be loaded and the\n                 symbol resolved.\n    - :watch-error-fn, a function receiving the exception of a failed build. May\n                       be a function value or a namespaced symbol, loaded as\n                       with :watch-fn.", :end-row 3405, :filename "cljs/closure.clj", :fixed-arities #{4 3 2}, :name "watch", :ns "cljs.closure", :row 3306} {:arglist-strs ["[opts]"], :end-row 3425, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "output-directory", :ns "cljs.closure", :row 3424} {:arglist-strs ["[f]"], :end-row 3428, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "parse-js-ns", :ns "cljs.closure", :row 3427} {:arglist-strs ["[src]" "[src opts]"], :end-row 3439, :filename "cljs/closure.clj", :fixed-arities #{1 2}, :name "src-file->target-file", :ns "cljs.closure", :row 3430} {:arglist-strs ["[src]" "[src {:keys [wrap all-provides macros-ns] :as options}]"], :end-row 3461, :filename "cljs/closure.clj", :fixed-arities #{1 2}, :name "src-file->goog-require", :ns "cljs.closure", :row 3441} {:arglist-strs ["[opts]"], :end-row 3479, :filename "cljs/closure.clj", :fixed-arities #{1}, :name "compile-client-js", :ns "cljs.closure", :row 3465} {:arglist-strs ["[opts file-path]"], :end-row 3487, :filename "cljs/closure.clj", :fixed-arities #{2}, :name "create-client-js-file", :ns "cljs.closure", :row 3481} {:arglist-strs ["[]"], :end-row 3513, :filename "cljs/closure.clj", :fixed-arities #{0}, :name "aot-cache-core", :ns "cljs.closure", :row 3491}]} {:end-row 10, :filename "cljs/reader.clj", :name "cljs.reader", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[default-readers]"], :end-row 18, :filename "cljs/reader.clj", :fixed-arities #{1}, :macro true, :name "add-data-readers", :ns "cljs.reader", :row 12} {:arglist-strs ["[s width]"], :end-row 24, :filename "cljs/reader.cljs", :fixed-arities #{2}, :name "zero-fill-right-and-truncate", :ns "cljs.reader", :private true, :row 16} {:arglist-strs ["[num div]"], :end-row 28, :filename "cljs/reader.cljs", :fixed-arities #{2}, :name "divisible?", :ns "cljs.reader", :private true, :row 26} {:arglist-strs ["[num div]"], :end-row 32, :filename "cljs/reader.cljs", :fixed-arities #{2}, :name "indivisible?", :ns "cljs.reader", :private true, :row 30} {:arglist-strs ["[year]"], :end-row 38, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "leap-year?", :ns "cljs.reader", :private true, :row 34} {:end-row 44, :filename "cljs/reader.cljs", :name "days-in-month", :ns "cljs.reader", :private true, :row 40} {:end-row 46, :filename "cljs/reader.cljs", :name "timestamp-regex", :ns "cljs.reader", :private true, :row 46} {:arglist-strs ["[s]"], :end-row 51, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "parse-int", :ns "cljs.reader", :private true, :row 48} {:arglist-strs ["[low n high msg]"], :end-row 56, :filename "cljs/reader.cljs", :fixed-arities #{4}, :name "check", :ns "cljs.reader", :private true, :row 53} {:arglist-strs ["[s]"], :end-row 81, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "parse-and-validate-timestamp", :ns "cljs.reader", :row 58} {:arglist-strs ["[ts]"], :end-row 90, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "parse-timestamp", :ns "cljs.reader", :row 83} {:arglist-strs ["[s]"], :end-row 96, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "read-date", :ns "cljs.reader", :private true, :row 92} {:arglist-strs ["[elems]"], :end-row 102, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "read-queue", :ns "cljs.reader", :private true, :row 98} {:arglist-strs ["[form]"], :end-row 123, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "read-js", :ns "cljs.reader", :private true, :row 104} {:arglist-strs ["[uuid]"], :end-row 129, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "read-uuid", :ns "cljs.reader", :private true, :row 125} {:end-row 132, :filename "cljs/reader.cljs", :name "*default-data-reader-fn*", :ns "cljs.reader", :row 131} {:end-row 140, :filename "cljs/reader.cljs", :name "*tag-table*", :ns "cljs.reader", :row 134} {:arglist-strs ["[reader]" "[{:keys [eof] :as opts} reader]" "[reader eof-error? eof opts]"], :doc "Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   cljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.", :end-row 172, :filename "cljs/reader.cljs", :fixed-arities #{1 4 2}, :name "read", :ns "cljs.reader", :row 142} {:arglist-strs ["[s]" "[opts s]"], :doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per cljs.tools.reader.edn/read", :end-row 190, :filename "cljs/reader.cljs", :fixed-arities #{1 2}, :name "read-string", :ns "cljs.reader", :row 174} {:arglist-strs ["[tag f]"], :end-row 196, :filename "cljs/reader.cljs", :fixed-arities #{2}, :name "register-tag-parser!", :ns "cljs.reader", :row 192} {:arglist-strs ["[tag]"], :end-row 202, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "deregister-tag-parser!", :ns "cljs.reader", :row 198} {:arglist-strs ["[f]"], :end-row 208, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "register-default-tag-parser!", :ns "cljs.reader", :row 204} {:arglist-strs ["[]"], :end-row 214, :filename "cljs/reader.cljs", :fixed-arities #{0}, :name "deregister-default-tag-parser!", :ns "cljs.reader", :row 210}]} {:end-row 14, :filename "cljs/source_map.clj", :name "cljs.source-map", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[sources]"], :doc "Take a seq of source file names and return a map from\n   file number to integer index.", :end-row 48, :filename "cljs/source_map.clj", :fixed-arities #{1}, :name "indexed-sources", :ns "cljs.source-map", :row 42} {:arglist-strs ["[sources]"], :doc "Take a seq of source file names and return a comparator\n   that can be used to construct a sorted map.", :end-row 55, :filename "cljs/source_map.clj", :fixed-arities #{1}, :name "source-compare", :ns "cljs.source-map", :row 50} {:arglist-strs ["[seg source-map]"], :doc "Take a source map segment represented as a vector\n   and return a map.", :end-row 70, :filename "cljs/source_map.clj", :fixed-arities #{2}, :name "seg->map", :ns "cljs.source-map", :row 60} {:arglist-strs ["[seg relseg]"], :doc "Combine a source map segment vector and a relative\n   source map segment vector and combine them to get\n   an absolute segment posititon information as a vector.", :end-row 86, :filename "cljs/source_map.clj", :fixed-arities #{2}, :name "seg-combine", :ns "cljs.source-map", :row 72} {:arglist-strs ["[result segmap gline]"], :doc "Helper for decode-reverse. Take a source map and update it\n  based on a segment map.", :end-row 104, :filename "cljs/source_map.clj", :fixed-arities #{3}, :name "update-reverse-result", :ns "cljs.source-map", :row 88} {:arglist-strs ["[source-map]" "[mappings source-map]"], :doc "Convert a v3 source map JSON object into a nested sorted map\n   organized as file, line, and column. Note this source map\n   maps from *original* source location to generated source location.", :end-row 134, :filename "cljs/source_map.clj", :fixed-arities #{1 2}, :name "decode-reverse", :ns "cljs.source-map", :row 106} {:arglist-strs ["[result segmap gline]"], :doc "Helper for decode. Take a source map and update it based on a\n  segment map.", :end-row 149, :filename "cljs/source_map.clj", :fixed-arities #{3}, :name "update-result", :ns "cljs.source-map", :row 136} {:arglist-strs ["[source-map]" "[mappings source-map]"], :doc "Convert a v3 source map JSON object into a nested sorted map\n   organized as file, line, and column. Note this source map\n   maps from *generated* source location to original source\n   location.", :end-row 176, :filename "cljs/source_map.clj", :fixed-arities #{1 2}, :name "decode", :ns "cljs.source-map", :row 151} {:arglist-strs ["[lines]"], :doc "Take a nested sorted map encoding line and column information\n   for a file and return a vector of vectors of encoded segments.\n   Each vector represents a line, and the internal vectors are segments\n   representing the contents of the line.", :end-row 202, :filename "cljs/source_map.clj", :fixed-arities #{1}, :name "lines->segs", :ns "cljs.source-map", :row 181} {:arglist-strs ["[path {:keys [output-dir source-map-path source-map relpaths] :as opts}]"], :doc "Relativize a path using :source-map-path if provided or the parent directory\n   otherwise.", :end-row 221, :filename "cljs/source_map.clj", :fixed-arities #{2}, :name "relativize-path", :ns "cljs.source-map", :row 204} {:arglist-strs ["[m opts]"], :doc "Take an internal source map representation represented as nested\n   sorted maps of file, line, column and return a v3 representation.", :end-row 286, :filename "cljs/source_map.clj", :fixed-arities #{2}, :name "encode*", :ns "cljs.source-map", :row 223} {:arglist-strs ["[m opts]"], :doc "Take an internal source map representation represented as nested\n   sorted maps of file, line, column and return a source map v3 JSON\n   string.", :end-row 299, :filename "cljs/source_map.clj", :fixed-arities #{2}, :name "encode", :ns "cljs.source-map", :row 288} {:arglist-strs ["[cljs-map js-map]"], :doc "Merge an internal source map representation of a single\n   ClojureScript file mapping original to generated with a\n   second source map mapping original JS to generated JS.\n   The is to support source maps that work through multiple\n   compilation steps like Google Closure optimization passes.", :end-row 326, :filename "cljs/source_map.clj", :fixed-arities #{2}, :name "merge-source-maps", :ns "cljs.source-map", :row 304} {:arglist-strs ["[reverse-map]"], :doc "Given a ClojureScript to JavaScript source map, invert it. Useful when\n   mapping JavaScript stack traces when environment support is unavailable.", :end-row 344, :filename "cljs/source_map.clj", :fixed-arities #{1}, :name "invert-reverse-map", :ns "cljs.source-map", :row 331} {:end-row 362, :filename "cljs/source_map.clj", :name "raw-source-map", :ns "cljs.source-map", :row 361} {:arglist-strs ["[sources]"], :doc "Take a seq of source file names and return a map from\n   file number to integer index. For reverse source maps.", :end-row 40, :filename "cljs/source_map.cljs", :fixed-arities #{1}, :name "indexed-sources", :ns "cljs.source-map", :row 34} {:arglist-strs ["[sources]"], :doc "Take a seq of source file names and return a comparator\n   that can be used to construct a sorted map. For reverse\n   source maps.", :end-row 48, :filename "cljs/source_map.cljs", :fixed-arities #{1}, :name "source-compare", :ns "cljs.source-map", :row 42} {:arglist-strs ["[seg source-map]"], :doc "Take a source map segment represented as a vector\n   and return a map.", :end-row 63, :filename "cljs/source_map.cljs", :fixed-arities #{2}, :name "seg->map", :ns "cljs.source-map", :row 53} {:arglist-strs ["[seg relseg]"], :doc "Combine a source map segment vector and a relative\n   source map segment vector and combine them to get\n   an absolute segment posititon information as a vector.", :end-row 79, :filename "cljs/source_map.cljs", :fixed-arities #{2}, :name "seg-combine", :ns "cljs.source-map", :row 65} {:arglist-strs ["[result segmap gline]"], :doc "Helper for decode-reverse. Take a reverse source map and\n  update it with a segment map.", :end-row 97, :filename "cljs/source_map.cljs", :fixed-arities #{3}, :name "update-reverse-result", :ns "cljs.source-map", :row 81} {:arglist-strs ["[source-map]" "[mappings source-map]"], :doc "Convert a v3 source map JSON object into a reverse source map\n  mapping original ClojureScript source locations to the generated\n  JavaScript.", :end-row 128, :filename "cljs/source_map.cljs", :fixed-arities #{1 2}, :name "decode-reverse", :ns "cljs.source-map", :row 99} {:arglist-strs ["[result segmap gline]"], :doc "Helper for decode. Take a source map and update it based on a\n  segment map.", :end-row 143, :filename "cljs/source_map.cljs", :fixed-arities #{3}, :name "update-result", :ns "cljs.source-map", :row 130} {:arglist-strs ["[source-map]" "[mappings source-map]"], :doc "Convert a v3 source map JSON object into a source map mapping\n  generated JavaScript source locations to the original\n  ClojureScript.", :end-row 170, :filename "cljs/source_map.cljs", :fixed-arities #{1 2}, :name "decode", :ns "cljs.source-map", :row 145} {:arglist-strs ["[lines]"], :doc "Take a nested sorted map encoding line and column information\n   for a file and return a vector of vectors of encoded segments.\n   Each vector represents a line, and the internal vectors are segments\n   representing the contents of the line.", :end-row 196, :filename "cljs/source_map.cljs", :fixed-arities #{1}, :name "lines->segs", :ns "cljs.source-map", :row 175} {:arglist-strs ["[m opts]"], :doc "Take an internal source map representation represented as nested\n   sorted maps of file, line, column and return a source map v3 JSON\n   string.", :end-row 253, :filename "cljs/source_map.cljs", :fixed-arities #{2}, :name "encode", :ns "cljs.source-map", :row 198} {:arglist-strs ["[cljs-map js-map]"], :doc "Merge an internal source map representation of a single\n   ClojureScript file mapping original to generated with a\n   second source map mapping original JS to generated JS.\n   The is to support source maps that work through multiple\n   compilation steps like Google Closure optimization passes.", :end-row 280, :filename "cljs/source_map.cljs", :fixed-arities #{2}, :name "merge-source-maps", :ns "cljs.source-map", :row 258} {:arglist-strs ["[reverse-map]"], :doc "Given a ClojureScript to JavaScript source map, invert it. Useful when\n   mapping JavaScript stack traces when environment support is unavailable.", :end-row 298, :filename "cljs/source_map.cljs", :fixed-arities #{1}, :name "invert-reverse-map", :ns "cljs.source-map", :row 285}]} {:end-row 24, :filename "cljs/js.cljs", :name "cljs.js", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[& args]"], :end-row 31, :filename "cljs/js.cljs", :name "debug-prn", :ns "cljs.js", :private true, :row 28} {:arglist-strs ["[ns-sym]"], :doc "Given a namespace as a symbol return the relative path sans extension", :end-row 36, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "ns->relpath", :ns "cljs.js", :row 33} {:arglist-strs ["[file]"], :end-row 42, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "file->ns", :ns "cljs.js", :row 38} {:arglist-strs ["[ns-name]"], :end-row 49, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "drop-macros-suffix", :ns "cljs.js", :private true, :row 44} {:arglist-strs ["[sym]"], :end-row 53, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "elide-macros-suffix", :ns "cljs.js", :private true, :row 51} {:arglist-strs ["[sym]"], :end-row 59, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "resolve-symbol", :ns "cljs.js", :private true, :row 55} {:arglist-strs ["[eof rdr]"], :end-row 63, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "read", :ns "cljs.js", :private true, :row 61} {:arglist-strs ["[x]"], :end-row 66, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "atom?", :ns "cljs.js", :private true, :row 65} {:arglist-strs ["[x]"], :end-row 69, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "valid-name?", :ns "cljs.js", :private true, :row 68} {:arglist-strs ["[x]"], :end-row 72, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "valid-opts?", :ns "cljs.js", :private true, :row 71} {:doc "Each runtime environment provides a different way to load a library.\n  Whatever function *load-fn* is bound to will be passed two arguments - a\n  map and a callback function: The map will have the following keys:\n\n  :name   - the name of the library (a symbol)\n  :macros - modifier signaling a macros namespace load\n  :path   - munged relative library path (a string)\n\n  It is up to the implementor to correctly resolve the corresponding .cljs,\n  .cljc, or .js resource (the order must be respected). If :macros is true\n  resolution should only consider .clj or .cljc resources (the order must be\n  respected). Upon resolution the callback should be invoked with a map\n  containing the following keys:\n\n  :lang       - the language, :clj or :js\n  :source     - the source of the library (a string)\n  :file       - optional, the file path, it will be added to AST's :file keyword\n                (but not in :meta)\n  :cache      - optional, if a :clj namespace has been precompiled to :js, can\n                give an analysis cache for faster loads.\n  :source-map - optional, if a :clj namespace has been precompiled to :js, can\n                give a V3 source map JSON\n\n  If the resource could not be resolved, the callback should be invoked with\n  nil.", :end-row 103, :filename "cljs/js.cljs", :name "*load-fn*", :ns "cljs.js", :row 74} {:doc "Each runtime environment provides various ways to eval JavaScript\n  source. Whatever function *eval-fn* is bound to will be passed a map\n  containing the following keys:\n\n  :source - the source of the library (string)\n  :name   - used to unique identify the script (symbol)\n  :cache  - if the source was originally ClojureScript, will be given the\n            analysis cache.\n\n  The result of evaluation should be the return value.", :end-row 119, :filename "cljs/js.cljs", :name "*eval-fn*", :ns "cljs.js", :row 105} {:arglist-strs ["[{:keys [source] :as resource}]"], :doc "A default JavaScript evaluation function.", :end-row 124, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "js-eval", :ns "cljs.js", :row 121} {:arglist-strs ["[ex]"], :end-row 127, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "wrap-error", :ns "cljs.js", :private true, :row 126} {:arglist-strs ["[]" "[init]"], :doc "Construct an empty compiler state. Required to invoke analyze, compile,\n   eval and eval-str.", :end-row 139, :filename "cljs/js.cljs", :fixed-arities #{0 1}, :name "empty-state", :ns "cljs.js", :row 129} {:arglist-strs ["[state ns cache]"], :end-row 142, :filename "cljs/js.cljs", :fixed-arities #{3}, :name "load-analysis-cache!", :ns "cljs.js", :row 141} {:arglist-strs ["[state ns sm-json]"], :end-row 146, :filename "cljs/js.cljs", :fixed-arities #{3}, :name "load-source-map!", :ns "cljs.js", :row 144} {:arglist-strs ["[]"], :end-row 152, :filename "cljs/js.cljs", :fixed-arities #{0}, :name "sm-data", :ns "cljs.js", :private true, :row 148} {:arglist-strs ["[s pre]"], :end-row 155, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "prefix", :ns "cljs.js", :private true, :row 154} {:arglist-strs ["[state name source sb sm-data {:keys [output-dir asset-path source-map-timestamp] :as opts}]"], :end-row 185, :filename "cljs/js.cljs", :fixed-arities #{6}, :name "append-source-map", :ns "cljs.js", :private true, :row 157} {:arglist-strs ["[compiler cljs-ns]"], :end-row 192, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "alias-map", :ns "cljs.js", :private true, :row 187} {:end-row 197, :filename "cljs/js.cljs", :name "eval-str*", :ns "cljs.js", :row 197} {:end-row 199, :filename "cljs/js.cljs", :name "*loaded*", :ns "cljs.js", :row 199} {:fixed-arities #{4}, :end-row 218, :private true, :ns "cljs.js", :name "run-async!", :filename "cljs/js.cljs", :arglist-strs ["[proc coll break? cb]"], :doc "Like cljs.core/run!, but for an async procedure, and with the\n  ability to break prior to processing the entire collection.\n\n  Chains successive calls to the supplied procedure for items in\n  the collection. The procedure should accept an item from the\n  collection and a callback of one argument. If the break? predicate,\n  when applied to the procedure callback value, yields a truthy\n  result, terminates early calling the supplied cb with the callback\n  value. Otherwise, when complete, calls cb with nil.", :row 201} {:end-row 223, :filename "cljs/js.cljs", :name "require", :ns "cljs.js", :row 220} {:arglist-strs ["[bound-vars names opts cb]"], :end-row 231, :filename "cljs/js.cljs", :fixed-arities #{4}, :name "process-deps", :ns "cljs.js", :private true, :row 225} {:arglist-strs ["[bound-vars cache opts cb]"], :end-row 240, :filename "cljs/js.cljs", :fixed-arities #{4}, :name "process-macros-deps", :ns "cljs.js", :private true, :row 233} {:arglist-strs ["[bound-vars cache opts cb]"], :end-row 247, :filename "cljs/js.cljs", :fixed-arities #{4}, :name "process-libs-deps", :ns "cljs.js", :private true, :row 242} {:arglist-strs ["[st name file opts]"], :end-row 257, :filename "cljs/js.cljs", :fixed-arities #{4}, :name "pre-file-side-effects", :ns "cljs.js", :private true, :row 249} {:arglist-strs ["[file opts]"], :end-row 266, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "post-file-side-effects", :ns "cljs.js", :private true, :row 259} {:arglist-strs ["[name cb]" "[name opts cb]" "[bound-vars name opts cb]" "[bound-vars name reload opts cb]"], :end-row 353, :filename "cljs/js.cljs", :fixed-arities #{4 3 2 5}, :name "require", :ns "cljs.js", :row 268} {:arglist-strs ["[compiler in from to]"], :end-row 379, :filename "cljs/js.cljs", :fixed-arities #{4}, :name "patch-alias-map", :ns "cljs.js", :private true, :row 355} {:arglist-strs ["[deps opts]"], :end-row 382, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "self-require?", :ns "cljs.js", :private true, :row 381} {:arglist-strs ["[bound-vars ana-env lib deps cb]" "[bound-vars ana-env lib deps reload opts cb]"], :end-row 430, :filename "cljs/js.cljs", :fixed-arities #{7 5}, :name "load-deps", :ns "cljs.js", :private true, :row 384} {:end-row 432, :filename "cljs/js.cljs", :name "analyze-str*", :ns "cljs.js", :row 432} {:arglist-strs ["[bound-vars ana-env lib deps cb]" "[bound-vars ana-env lib deps opts cb]"], :end-row 489, :filename "cljs/js.cljs", :fixed-arities #{6 5}, :name "analyze-deps", :ns "cljs.js", :private true, :row 434} {:arglist-strs ["[bound-vars k macros lib reload reloads opts cb]"], :end-row 522, :filename "cljs/js.cljs", :fixed-arities #{8}, :name "load-macros", :ns "cljs.js", :private true, :row 491} {:arglist-strs ["[ast smap]" "[ast smap macros?]"], :end-row 551, :filename "cljs/js.cljs", :fixed-arities #{3 2}, :name "rewrite-ns-ast", :ns "cljs.js", :private true, :row 524} {:arglist-strs ["[{:keys [requires name] :as ast} cenv]"], :end-row 564, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "check-macro-autoload-inferring-missing", :ns "cljs.js", :private true, :row 553} {:arglist-strs ["[bound-vars ana-env ast opts cb]" "[load bound-vars ana-env {:keys [op] :as ast} opts cb]"], :end-row 640, :filename "cljs/js.cljs", :fixed-arities #{6 5}, :name "ns-side-effects", :ns "cljs.js", :private true, :row 566} {:arglist-strs ["[bound-vars sb deps ns-name emit-nil-result?]"], :end-row 651, :filename "cljs/js.cljs", :fixed-arities #{5}, :name "node-side-effects", :ns "cljs.js", :private true, :row 642} {:arglist-strs ["[bound-vars sb deps ns-name emit-nil-result?]"], :end-row 662, :filename "cljs/js.cljs", :fixed-arities #{5}, :name "global-exports-side-effects", :ns "cljs.js", :private true, :row 653} {:fixed-arities #{1}, :end-row 669, :private true, :ns "cljs.js", :name "trampoline-safe", :filename "cljs/js.cljs", :arglist-strs ["[f]"], :doc "Returns a new function that calls f but discards any return value,\n  returning nil instead, thus avoiding any inadvertent trampoline continuation\n  if a function happens to be returned.", :row 664} {:arglist-strs ["[bound-vars source name opts cb]"], :end-row 722, :filename "cljs/js.cljs", :fixed-arities #{5}, :name "analyze-str*", :ns "cljs.js", :private true, :row 671} {:arglist-strs ["[state source cb]" "[state source name cb]" "[state source name opts cb]"], :doc "Analyze ClojureScript source. The compiler state will be populated with\n   the results of analyzes. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false).\n                          Defaults to false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:statement`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value, the actual value is not meaningful. If unsuccessful the\n     map will contain a key :error with an ex-info instance describing the cause\n     of failure.", :end-row 785, :filename "cljs/js.cljs", :fixed-arities #{4 3 5}, :name "analyze-str", :ns "cljs.js", :row 724} {:end-row 790, :filename "cljs/js.cljs", :name "clear-fns!", :ns "cljs.js", :row 790} {:arglist-strs ["[bound-vars form opts cb]"], :end-row 848, :filename "cljs/js.cljs", :fixed-arities #{4}, :name "eval*", :ns "cljs.js", :private true, :row 792} {:arglist-strs ["[state form cb]" "[state form opts cb]"], :doc "Evaluate a single ClojureScript form. The parameters:\n\n   state (atom)\n     the compiler state\n\n   form (s-expr)\n     the ClojureScript source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:statement`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the result of evalution. If unsuccessful the map will\n     contain a key :error with an ex-info instance describing the cause of\n     failure.", :end-row 902, :filename "cljs/js.cljs", :fixed-arities #{4 3}, :name "eval", :ns "cljs.js", :row 850} {:arglist-strs ["[bound-vars source name opts cb]"], :end-row 972, :filename "cljs/js.cljs", :fixed-arities #{5}, :name "compile-str*", :ns "cljs.js", :private true, :row 907} {:arglist-strs ["[state source cb]" "[state source name cb]" "[state source name opts cb]"], :doc "Compile ClojureScript source into JavaScript. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source - used as key in :source-maps\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:statement`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the compilation result (string). If unsuccessful the map\n     will contain a key :error with an ex-info instance describing the cause\n     of failure.", :end-row 1034, :filename "cljs/js.cljs", :fixed-arities #{4 3 5}, :name "compile-str", :ns "cljs.js", :row 974} {:arglist-strs ["[bound-vars source name opts cb]"], :end-row 1138, :filename "cljs/js.cljs", :fixed-arities #{5}, :name "eval-str*", :ns "cljs.js", :private true, :row 1039} {:arglist-strs ["[state source cb]" "[state source name cb]" "[state source name opts cb]"], :doc "Evalute ClojureScript source given as a string. The parameters:\n\n  state (atom)\n    the compiler state\n\n  source (string)\n    the ClojureScript source\n\n  name (symbol or string)\n    optional, the name of the source - used as key in :source-maps\n\n  opts (map)\n    compilation options.\n\n    :eval             - eval function to invoke, see *eval-fn*\n    :load             - library resolution function, see *load-fn*\n    :source-map       - set to true to generate inline source map information\n    :cache-source     - optional, a function to run side-effects with the\n                        compilation result prior to actual evalution. This function\n                        takes two arguments, the first is the eval map, the source\n                        will be under :source. The second argument is a callback of\n                        one argument. If an error occurs an :error key should be\n                        supplied.\n    :def-emits-var    - sets whether def (and derived) forms return either a Var\n                        (if set to true) or the def init value (if false). Default\n                        is false.\n    :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                        to aget/aset. Logs for incorrect values if :warn, throws if\n                        :error. Defaults to false.\n    :static-fns       - employ static dispatch to specific function arities in\n                        emitted JavaScript, as opposed to making use of the\n                        `call` construct. Defaults to false.\n    :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                        unknown functions, but instead direct invokes via\n                        `f(a0,a1...)`. Defaults to `false`.\n    :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                        at the moment.\n    :ns               - optional, the namespace in which to evaluate the source.\n    :verbose          - optional, emit details from compiler activity. Defaults to\n                        false.\n    :context          - optional, sets the context for the source. Possible values\n                     are `:expr`, `:statement` and `:return`. Defaults to\n                      `:statement`.\n\n  cb (function)\n    callback, will be invoked with a map. If succesful the map will contain\n    a :value key with the result of evaluation and :ns the current namespace.\n    If unsuccessful will contain a :error key with an ex-info instance describing\n    the cause of failure.", :end-row 1205, :filename "cljs/js.cljs", :fixed-arities #{4 3 5}, :name "eval-str", :ns "cljs.js", :row 1140} {:end-row 1213, :filename "cljs/js.cljs", :name "fn-index", :ns "cljs.js", :private true, :row 1213} {:end-row 1214, :filename "cljs/js.cljs", :name "fn-refs", :ns "cljs.js", :private true, :row 1214} {:fixed-arities #{0}, :end-row 1219, :private true, :ns "cljs.js", :name "clear-fns!", :filename "cljs/js.cljs", :arglist-strs ["[]"], :doc "Clears saved functions.", :row 1216} {:fixed-arities #{1}, :end-row 1226, :private true, :ns "cljs.js", :name "put-fn", :filename "cljs/js.cljs", :arglist-strs ["[f]"], :doc "Saves a function, returning a numeric representation.", :row 1221} {:fixed-arities #{1}, :end-row 1231, :private true, :ns "cljs.js", :name "get-fn", :filename "cljs/js.cljs", :arglist-strs ["[n]"], :doc "Gets a function, given its numeric representation.", :row 1228} {:arglist-strs ["[f]"], :end-row 1234, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "emit-fn", :ns "cljs.js", :private true, :row 1233} {:arglist-strs ["[form]" "[form ns]"], :end-row 1258, :filename "cljs/js.cljs", :fixed-arities #{1 2}, :name "eval-impl", :ns "cljs.js", :private true, :row 1244} {:end-row 1266, :filename "cljs/js.cljs", :name "vm", :ns "cljs.js", :row 1266} {:end-row 1267, :filename "cljs/js.cljs", :name "fs", :ns "cljs.js", :row 1267} {:end-row 1268, :filename "cljs/js.cljs", :name "st", :ns "cljs.js", :row 1268} {:arglist-strs ["[{:keys [name source]}]"], :end-row 1273, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "node-eval", :ns "cljs.js", :row 1272} {:end-row 1278, :filename "cljs/js.cljs", :name "libs", :ns "cljs.js", :row 1275} {:arglist-strs ["[{:keys [name macros]} cb]"], :end-row 1289, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "node-load", :ns "cljs.js", :row 1280} {:arglist-strs ["[env ast opts]"], :end-row 1292, :filename "cljs/js.cljs", :fixed-arities #{3}, :name "elide-env", :ns "cljs.js", :row 1291} {:arglist-strs ["[state & body]"], :end-row 18, :filename "cljs/js.clj", :macro true, :name "with-state", :ns "cljs.js", :row 15} {:arglist-strs ["[]"], :end-row 24, :filename "cljs/js.clj", :fixed-arities #{0}, :macro true, :name "dump-core", :ns "cljs.js", :row 20}]} {:end-row 15, :filename "cljs/repl/reflect.clj", :name "cljs.repl.reflect", :row 9, :ns nil, :var-definitions [{:fixed-arities #{2}, :end-row 29, :private true, :ns "cljs.repl.reflect", :name "dissoc-unless", :filename "cljs/repl/reflect.clj", :arglist-strs ["[m key-set]"], :doc "Dissoc all keys from map that do not appear in key-set.\n\n    (dissoc-unless {:foo 1 :bar 2} #{:foo})\n    => {:foo 1}", :row 17} {:arglist-strs ["[sym]"], :end-row 38, :filename "cljs/repl/reflect.clj", :fixed-arities #{1}, :name "get-meta", :ns "cljs.repl.reflect", :private true, :row 31} {:arglist-strs ["[form]"], :doc "Fully expands a cljs macro form.", :end-row 46, :filename "cljs/repl/reflect.clj", :fixed-arities #{1}, :name "macroexpand", :ns "cljs.repl.reflect", :row 40} {:arglist-strs ["[encoded & [encoding]]"], :end-row 49, :filename "cljs/repl/reflect.clj", :name "url-decode", :ns "cljs.repl.reflect", :private true, :row 48} {:end-row 51, :filename "cljs/repl/reflect.clj", :name "read-url-string", :ns "cljs.repl.reflect", :row 51} {:arglist-strs ["[path]"], :doc "Parses the query parameter of a path of the form \"/reflect?var=foo\"\n  into the vector [\"var\" \"foo\"].", :end-row 59, :filename "cljs/repl/reflect.clj", :fixed-arities #{1}, :name "parse-param", :ns "cljs.repl.reflect", :row 53} {:fixed-arities #{2}, :end-row 67, :private true, :ns "cljs.repl.reflect", :name "compile-and-return", :filename "cljs/repl/reflect.clj", :arglist-strs ["[conn form]"], :doc "Compiles a form to javascript and returns it on conn.", :row 61} {:end-row 69, :filename "cljs/repl/reflect.clj", :name "handle-reflect-query", :ns "cljs.repl.reflect", :row 69}]} {:end-row 25, :filename "cljs/repl/browser.clj", :name "cljs.repl.browser", :row 9, :ns nil, :var-definitions [{:end-row 27, :filename "cljs/repl/browser.clj", :name "browser-state", :ns "cljs.repl.browser", :row 27} {:end-row 28, :filename "cljs/repl/browser.clj", :name "ordering", :ns "cljs.repl.browser", :row 28} {:end-row 29, :filename "cljs/repl/browser.clj", :name "es", :ns "cljs.repl.browser", :row 29} {:end-row 30, :filename "cljs/repl/browser.clj", :name "outs", :ns "cljs.repl.browser", :row 30} {:arglist-strs ["[]"], :end-row 34, :filename "cljs/repl/browser.clj", :fixed-arities #{0}, :name "thread-name", :ns "cljs.repl.browser", :row 32} {:end-row 63, :filename "cljs/repl/browser.clj", :name "ext->mime-type", :ns "cljs.repl.browser", :row 36} {:end-row 87, :filename "cljs/repl/browser.clj", :name "mime-type->encoding", :ns "cljs.repl.browser", :row 65} {:fixed-arities #{1}, :end-row 93, :private true, :ns "cljs.repl.browser", :name "set-return-value-fn", :filename "cljs/repl/browser.clj", :arglist-strs ["[f]"], :doc "Save the return value function which will be called when the next\n  return value is received.", :row 89} {:arglist-strs ["[form return-value-fn]" "[conn form return-value-fn]"], :doc "Given a form and a return value function, send the form to the\n  browser for evaluation. The return value function will be called\n  when the return value is received.", :end-row 107, :filename "cljs/repl/browser.clj", :fixed-arities #{3 2}, :name "send-for-eval", :ns "cljs.repl.browser", :row 95} {:fixed-arities #{1}, :end-row 113, :private true, :ns "cljs.repl.browser", :name "return-value", :filename "cljs/repl/browser.clj", :arglist-strs ["[val]"], :doc "Called by the server when a return value is received.", :row 109} {:arglist-strs ["[]"], :end-row 116, :filename "cljs/repl/browser.clj", :fixed-arities #{0}, :name "repl-client-js", :ns "cljs.repl.browser", :row 115} {:arglist-strs ["[{:keys [path] :as request} conn opts]"], :end-row 132, :filename "cljs/repl/browser.clj", :fixed-arities #{3}, :name "send-repl-client-page", :ns "cljs.repl.browser", :row 118} {:arglist-strs ["[output-to]"], :end-row 170, :filename "cljs/repl/browser.clj", :fixed-arities #{1}, :name "default-index", :ns "cljs.repl.browser", :row 134} {:arglist-strs ["[ext->mime-type path default]"], :end-row 179, :filename "cljs/repl/browser.clj", :fixed-arities #{3}, :name "path->mime-type", :ns "cljs.repl.browser", :private true, :row 172} {:arglist-strs ["[{path :path :as request} conn {:keys [static-dir output-dir host port gzip?] :or {output-dir \"out\"} :as opts}]"], :end-row 237, :filename "cljs/repl/browser.clj", :fixed-arities #{3}, :name "send-static", :ns "cljs.repl.browser", :row 181} {:end-row 249, :filename "cljs/repl/browser.clj", :name "handle-post", :ns "cljs.repl.browser", :row 249} {:arglist-strs ["[{:keys [expecting fns]} order f]"], :end-row 273, :filename "cljs/repl/browser.clj", :fixed-arities #{3}, :name "add-in-order", :ns "cljs.repl.browser", :row 271} {:arglist-strs ["[{:keys [expecting fns]}]"], :end-row 281, :filename "cljs/repl/browser.clj", :fixed-arities #{1}, :name "run-in-order", :ns "cljs.repl.browser", :row 275} {:arglist-strs ["[order f]"], :doc "Elements to be printed in the REPL will arrive out of order. Ensure\n  that they are printed in the correct order.", :end-row 288, :filename "cljs/repl/browser.clj", :fixed-arities #{2}, :name "constrain-order", :ns "cljs.repl.browser", :row 283} {:arglist-strs ["[form]"], :doc "Given a string of JavaScript, evaluate it in the browser and return a map representing the\n   result of the evaluation. The map will contain the keys :type and :value. :type can be\n   :success, :exception, or :error. :success means that the JavaScript was evaluated without\n   exception and :value will contain the return value of the evaluation. :exception means that\n   there was an exception in the browser while evaluating the JavaScript and :value will\n   contain the error message. :error means that some other error has occured.", :end-row 320, :filename "cljs/repl/browser.clj", :fixed-arities #{1}, :name "browser-eval", :ns "cljs.repl.browser", :row 304} {:arglist-strs ["[repl-env provides url]"], :doc "Accepts a REPL environment, a list of namespaces, and a URL for a\n  JavaScript file which contains the implementation for the list of\n  namespaces. Will load the JavaScript file into the REPL environment\n  if any of the namespaces have not already been loaded from the\n  ClojureScript REPL.", :end-row 329, :filename "cljs/repl/browser.clj", :fixed-arities #{3}, :name "load-javascript", :ns "cljs.repl.browser", :row 322} {:arglist-strs ["[{:keys [host port output-dir] :as opts}]"], :end-row 339, :filename "cljs/repl/browser.clj", :fixed-arities #{1}, :name "serve", :ns "cljs.repl.browser", :row 331} {:end-row 344, :filename "cljs/repl/browser.clj", :name "lock", :ns "cljs.repl.browser", :row 344} {:arglist-strs ["[url]"], :end-row 347, :filename "cljs/repl/browser.clj", :fixed-arities #{1}, :name "waiting-to-connect-message", :ns "cljs.repl.browser", :private true, :row 346} {:arglist-strs ["[base-url]"], :end-row 361, :filename "cljs/repl/browser.clj", :fixed-arities #{1}, :name "maybe-browse-url", :ns "cljs.repl.browser", :private true, :row 349} {:arglist-strs ["[{:keys [working-dir launch-browser server-state] :as repl-env} {:keys [output-dir] :as opts}]"], :end-row 394, :filename "cljs/repl/browser.clj", :fixed-arities #{2}, :name "setup", :ns "cljs.repl.browser", :row 363} {:end-row 450, :filename "cljs/repl/browser.clj", :name "BrowserEnv", :ns "cljs.repl.browser", :row 396} {:arglist-strs ["[]"], :end-row 450, :filename "cljs/repl/browser.clj", :fixed-arities #{0}, :name "->BrowserEnv", :ns "cljs.repl.browser", :row 396} {:arglist-strs ["[m]"], :end-row 450, :filename "cljs/repl/browser.clj", :fixed-arities #{1}, :name "map->BrowserEnv", :ns "cljs.repl.browser", :row 396} {:arglist-strs ["[{:keys [output-dir host port] :or {host \"localhost\" port 9000} :as opts}]"], :end-row 471, :filename "cljs/repl/browser.clj", :fixed-arities #{1}, :name "repl-env*", :ns "cljs.repl.browser", :row 452} {:arglist-strs ["[& {:as opts}]"], :doc "Create a browser-connected REPL environment.\n\n  Options:\n\n  port:           The port on which the REPL server will run. Defaults to 9000.\n  launch-browser: A Boolean indicating whether a browser should be automatically\n                  launched connecting back to the terminal REPL. Defaults to true.\n  working-dir:    The directory where the compiled REPL client JavaScript will\n                  be stored. Defaults to \".repl\" with a ClojureScript version\n                  suffix, eg. \".repl-0.0-2138\".\n  static-dir:     List of directories to search for static content. Defaults to\n                  [\".\" \"out/\"].\n  src:            The source directory containing user-defined cljs files. Used to\n                  support reflection. Defaults to \"src/\".\n  ", :end-row 490, :filename "cljs/repl/browser.clj", :name "repl-env", :ns "cljs.repl.browser", :row 473} {:arglist-strs ["[& args]"], :end-row 493, :filename "cljs/repl/browser.clj", :name "-main", :ns "cljs.repl.browser", :row 492} {:end-row 499, :filename "cljs/repl/browser.clj", :name "env", :ns "cljs.repl.browser", :row 499}]} {:end-row 10, :filename "cljs/repl/bootstrap.clj", :name "cljs.repl.bootstrap", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[repl-env env]"], :doc "Install a version of goog.require that supports namespace reloading.\n   IMPORTANT: must be invoked *after* loading cljs.core.", :end-row 53, :filename "cljs/repl/bootstrap.clj", :fixed-arities #{2}, :name "install-repl-goog-require", :ns "cljs.repl.bootstrap", :row 12}]} {:end-row 24, :filename "cljs/repl/node.clj", :name "cljs.repl.node", :row 9, :ns nil, :var-definitions [{:end-row 26, :filename "cljs/repl/node.clj", :name "lock", :ns "cljs.repl.node", :row 26} {:end-row 27, :filename "cljs/repl/node.clj", :name "results", :ns "cljs.repl.node", :row 27} {:end-row 28, :filename "cljs/repl/node.clj", :name "outs", :ns "cljs.repl.node", :row 28} {:end-row 29, :filename "cljs/repl/node.clj", :name "errs", :ns "cljs.repl.node", :row 29} {:arglist-strs ["[]"], :end-row 33, :filename "cljs/repl/node.clj", :fixed-arities #{0}, :name "thread-name", :ns "cljs.repl.node", :row 31} {:arglist-strs ["[host port]"], :end-row 39, :filename "cljs/repl/node.clj", :fixed-arities #{2}, :name "create-socket", :ns "cljs.repl.node", :row 35} {:arglist-strs ["[s]"], :end-row 44, :filename "cljs/repl/node.clj", :fixed-arities #{1}, :name "close-socket", :ns "cljs.repl.node", :row 41} {:arglist-strs ["[out js]"], :end-row 49, :filename "cljs/repl/node.clj", :fixed-arities #{2}, :name "write", :ns "cljs.repl.node", :row 46} {:arglist-strs ["[in]"], :end-row 59, :filename "cljs/repl/node.clj", :fixed-arities #{1}, :name "read-response", :ns "cljs.repl.node", :row 51} {:arglist-strs ["[repl-env js]"], :doc "Evaluate a JavaScript string in the Node REPL process.", :end-row 75, :filename "cljs/repl/node.clj", :fixed-arities #{2}, :name "node-eval", :ns "cljs.repl.node", :row 61} {:arglist-strs ["[repl-env provides url]"], :doc "Load a Closure JavaScript file into the Node REPL process.", :end-row 81, :filename "cljs/repl/node.clj", :fixed-arities #{3}, :name "load-javascript", :ns "cljs.repl.node", :row 77} {:arglist-strs ["[v]"], :end-row 84, :filename "cljs/repl/node.clj", :fixed-arities #{1}, :name "seq->js-array", :ns "cljs.repl.node", :row 83} {:arglist-strs ["[v]"], :end-row 87, :filename "cljs/repl/node.clj", :fixed-arities #{1}, :name "platform-path", :ns "cljs.repl.node", :row 86} {:arglist-strs ["[proc]"], :end-row 90, :filename "cljs/repl/node.clj", :fixed-arities #{1}, :name "alive?", :ns "cljs.repl.node", :private true, :row 89} {:arglist-strs ["[proc in]"], :end-row 111, :filename "cljs/repl/node.clj", :fixed-arities #{2}, :name "event-loop", :ns "cljs.repl.node", :private true, :row 92} {:arglist-strs ["[opts repl-env input-src]"], :end-row 123, :filename "cljs/repl/node.clj", :fixed-arities #{3}, :name "build-process", :ns "cljs.repl.node", :private true, :row 113} {:arglist-strs ["[repl-env]" "[{:keys [host port socket state] :as repl-env} opts]"], :end-row 204, :filename "cljs/repl/node.clj", :fixed-arities #{1 2}, :name "setup", :ns "cljs.repl.node", :row 125} {:end-row 233, :filename "cljs/repl/node.clj", :name "NodeEnv", :ns "cljs.repl.node", :row 206} {:arglist-strs ["[host port path socket proc state]"], :end-row 233, :filename "cljs/repl/node.clj", :fixed-arities #{6}, :name "->NodeEnv", :ns "cljs.repl.node", :row 206} {:arglist-strs ["[m]"], :end-row 233, :filename "cljs/repl/node.clj", :fixed-arities #{1}, :name "map->NodeEnv", :ns "cljs.repl.node", :row 206} {:arglist-strs ["[options]"], :end-row 244, :filename "cljs/repl/node.clj", :fixed-arities #{1}, :name "repl-env*", :ns "cljs.repl.node", :row 235} {:arglist-strs ["[& {:as options}]"], :doc "Construct a Node.js evalution environment. Can supply :host, :port\n  and :path (a vector used as the NODE_PATH).", :end-row 250, :filename "cljs/repl/node.clj", :name "repl-env", :ns "cljs.repl.node", :row 246} {:arglist-strs ["[& args]"], :end-row 253, :filename "cljs/repl/node.clj", :name "-main", :ns "cljs.repl.node", :row 252}]} {:end-row 17, :filename "cljs/repl/server.clj", :name "cljs.repl.server", :row 9, :ns nil, :var-definitions [{:end-row 19, :filename "cljs/repl/server.clj", :name "state", :ns "cljs.repl.server", :row 19} {:end-row 20, :filename "cljs/repl/server.clj", :name "connq", :ns "cljs.repl.server", :row 20} {:end-row 21, :filename "cljs/repl/server.clj", :name "promiseq", :ns "cljs.repl.server", :row 21} {:end-row 22, :filename "cljs/repl/server.clj", :name "lock", :ns "cljs.repl.server", :row 22} {:arglist-strs ["[]"], :doc "Promise to return a connection when one is available. If no connection is\n   available put the promise into a FIFO queue to get the next available\n   connection.", :end-row 35, :filename "cljs/repl/server.clj", :fixed-arities #{0}, :name "connection", :ns "cljs.repl.server", :row 24} {:arglist-strs ["[conn]"], :doc "Given a new available connection, poll the promise queue for and deliver\n   the connection. Otherwise put the connection into a FIFO queue.", :end-row 44, :filename "cljs/repl/server.clj", :fixed-arities #{1}, :name "set-connection", :ns "cljs.repl.server", :row 37} {:end-row 46, :filename "cljs/repl/server.clj", :name "handlers", :ns "cljs.repl.server", :row 46} {:arglist-strs ["[method pred handler]" "[method {:as m}]"], :doc "Registers a handler to be dispatched based on a request method and a\n  predicate.\n\n  pred should be a function that accepts an options map, a connection,\n  and a request map and returns a boolean value based on whether or not\n  that request should be dispatched to the related handler.", :end-row 60, :filename "cljs/repl/server.clj", :fixed-arities #{3 2}, :name "dispatch-on", :ns "cljs.repl.server", :row 48} {:arglist-strs ["[file]"], :end-row 73, :filename "cljs/repl/server.clj", :fixed-arities #{1}, :name "parse-file-parts", :ns "cljs.repl.server", :row 62} {:arglist-strs ["[header-lines]"], :doc "Parse the headers of an HTTP POST request.", :end-row 84, :filename "cljs/repl/server.clj", :fixed-arities #{1}, :name "parse-headers", :ns "cljs.repl.server", :row 76} {:arglist-strs ["[rdr]"], :end-row 92, :filename "cljs/repl/server.clj", :fixed-arities #{1}, :name "read-headers", :ns "cljs.repl.server", :row 86} {:arglist-strs ["[line rdr]"], :end-row 106, :filename "cljs/repl/server.clj", :fixed-arities #{2}, :name "read-post", :ns "cljs.repl.server", :row 94} {:arglist-strs ["[line rdr]"], :end-row 116, :filename "cljs/repl/server.clj", :fixed-arities #{2}, :name "read-get", :ns "cljs.repl.server", :row 108} {:arglist-strs ["[rdr]"], :end-row 124, :filename "cljs/repl/server.clj", :fixed-arities #{1}, :name "read-request", :ns "cljs.repl.server", :row 118} {:arglist-strs ["[status]"], :end-row 130, :filename "cljs/repl/server.clj", :fixed-arities #{1}, :name "status-line", :ns "cljs.repl.server", :private true, :row 126} {:arglist-strs ["[bytes]"], :end-row 142, :filename "cljs/repl/server.clj", :fixed-arities #{1}, :name "gzip", :ns "cljs.repl.server", :row 132} {:arglist-strs ["[conn status form]" "[conn status form content-type]" "[conn status form content-type encoding]" "[conn status form content-type encoding gzip?]"], :doc "Use the passed connection to send a form to the browser. Send a\n  proper HTTP response.", :end-row 171, :filename "cljs/repl/server.clj", :fixed-arities #{4 6 3 5}, :name "send-and-close", :ns "cljs.repl.server", :row 144} {:arglist-strs ["[conn path]"], :end-row 180, :filename "cljs/repl/server.clj", :fixed-arities #{2}, :name "send-404", :ns "cljs.repl.server", :row 173} {:arglist-strs ["[request conn opts]"], :end-row 200, :filename "cljs/repl/server.clj", :fixed-arities #{3}, :name "dispatch-request", :ns "cljs.repl.server", :private true, :row 182} {:arglist-strs ["[opts conn]"], :end-row 207, :filename "cljs/repl/server.clj", :fixed-arities #{2}, :name "handle-connection", :ns "cljs.repl.server", :private true, :row 202} {:arglist-strs ["[opts server-socket]"], :end-row 217, :filename "cljs/repl/server.clj", :fixed-arities #{2}, :name "server-loop", :ns "cljs.repl.server", :private true, :row 209} {:arglist-strs ["[opts]"], :doc "Start the server on the specified port.", :end-row 227, :filename "cljs/repl/server.clj", :fixed-arities #{1}, :name "start", :ns "cljs.repl.server", :row 219} {:arglist-strs ["[]"], :end-row 232, :filename "cljs/repl/server.clj", :fixed-arities #{0}, :name "stop", :ns "cljs.repl.server", :row 229}]} {:end-row 46, :filename "cljs/analyzer.cljc", :lang :clj, :name "cljs.analyzer", :row 9, :ns nil, :var-definitions [{:end-row 51, :filename "cljs/analyzer.cljc", :lang :clj, :name "*unchecked-if*", :ns "cljs.analyzer", :row 51} {:end-row 52, :filename "cljs/analyzer.cljc", :lang :clj, :name "*unchecked-arrays*", :ns "cljs.analyzer", :row 52} {:end-row 55, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-ns*", :ns "cljs.analyzer", :row 55} {:end-row 56, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-file*", :ns "cljs.analyzer", :row 56} {:end-row 57, :filename "cljs/analyzer.cljc", :lang :clj, :name "*checked-arrays*", :ns "cljs.analyzer", :row 57} {:end-row 58, :filename "cljs/analyzer.cljc", :lang :clj, :name "*check-alias-dupes*", :ns "cljs.analyzer", :row 58} {:end-row 59, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-static-fns*", :ns "cljs.analyzer", :row 59} {:end-row 60, :filename "cljs/analyzer.cljc", :lang :clj, :name "*fn-invoke-direct*", :ns "cljs.analyzer", :row 60} {:end-row 61, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-macros-path*", :ns "cljs.analyzer", :row 61} {:end-row 62, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-macros-is-classpath*", :ns "cljs.analyzer", :row 62} {:end-row 63, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-dep-set*", :ns "cljs.analyzer", :row 63} {:end-row 64, :filename "cljs/analyzer.cljc", :lang :clj, :name "*analyze-deps*", :ns "cljs.analyzer", :row 64} {:end-row 65, :filename "cljs/analyzer.cljc", :lang :clj, :name "*load-tests*", :ns "cljs.analyzer", :row 65} {:end-row 66, :filename "cljs/analyzer.cljc", :lang :clj, :name "*load-macros*", :ns "cljs.analyzer", :row 66} {:end-row 67, :filename "cljs/analyzer.cljc", :lang :clj, :name "*reload-macros*", :ns "cljs.analyzer", :row 67} {:end-row 68, :filename "cljs/analyzer.cljc", :lang :clj, :name "*macro-infer*", :ns "cljs.analyzer", :row 68} {:end-row 69, :filename "cljs/analyzer.cljc", :lang :clj, :name "*passes*", :ns "cljs.analyzer", :row 69} {:end-row 70, :filename "cljs/analyzer.cljc", :lang :clj, :name "*file-defs*", :ns "cljs.analyzer", :row 70} {:end-row 71, :filename "cljs/analyzer.cljc", :lang :clj, :name "*private-var-access-nowarn*", :ns "cljs.analyzer", :row 71} {:doc "The namespace of the constants table as a symbol.", :end-row 75, :filename "cljs/analyzer.cljc", :lang :clj, :name "constants-ns-sym", :ns "cljs.analyzer", :row 73} {:end-row 89, :filename "cljs/analyzer.cljc", :lang :clj, :name "transit-read-opts", :ns "cljs.analyzer", :row 78} {:end-row 109, :filename "cljs/analyzer.cljc", :lang :clj, :name "transit-write-opts", :ns "cljs.analyzer", :row 92} {:end-row 122, :filename "cljs/analyzer.cljc", :lang :clj, :name "transit", :ns "cljs.analyzer", :row 112} {:end-row 125, :filename "cljs/analyzer.cljc", :lang :clj, :name "*verbose*", :ns "cljs.analyzer", :row 125} {:end-row 127, :filename "cljs/analyzer.cljc", :lang :clj, :name "-cljs-macros-loaded", :ns "cljs.analyzer", :row 127} {:end-row 168, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-warnings*", :ns "cljs.analyzer", :row 129} {:arglist-strs ["[]"], :end-row 171, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :clj, :name "unchecked-arrays?", :ns "cljs.analyzer", :row 170} {:arglist-strs ["[]"], :end-row 174, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :clj, :name "compiler-options", :ns "cljs.analyzer", :row 173} {:arglist-strs ["[]"], :end-row 177, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :clj, :name "get-externs", :ns "cljs.analyzer", :row 176} {:fixed-arities #{0}, :end-row 185, :ns "cljs.analyzer", :name "checked-arrays", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :doc "Returns false-y, :warn, or :error based on configuration and the\n   current value of *unchecked-arrays*.", :row 179} {:end-row 200, :filename "cljs/analyzer.cljc", :lang :clj, :name "js-reserved", :ns "cljs.analyzer", :row 187} {:end-row 203, :filename "cljs/analyzer.cljc", :lang :clj, :name "es5-allowed", :ns "cljs.analyzer", :row 202} {:end-row 205, :filename "cljs/analyzer.cljc", :lang :clj, :name "SENTINEL", :ns "cljs.analyzer", :row 205} {:arglist-strs ["[m k0 k1]" "[m k0 k1 k2]" "[m k0 k1 k2 k3]"], :end-row 226, :filename "cljs/analyzer.cljc", :fixed-arities #{4 3 5}, :lang :clj, :name "gets", :ns "cljs.analyzer", :row 208} {:end-row 254, :filename "cljs/analyzer.cljc", :lang :clj, :name "message", :ns "cljs.analyzer", :row 254} {:end-row 254, :filename "cljs/analyzer.cljc", :lang :clj, :name "namespaces", :ns "cljs.analyzer", :row 254} {:arglist-strs ["[x]"], :end-row 259, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "ast?", :ns "cljs.analyzer", :row 256} {:end-row 261, :filename "cljs/analyzer.cljc", :lang :clj, :name "error-message", :ns "cljs.analyzer", :row 261} {:arglist-strs ["[warning-type env extra]"], :end-row 485, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "default-warning-handler", :ns "cljs.analyzer", :row 479} {:end-row 488, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-warning-handlers*", :ns "cljs.analyzer", :row 487} {:arglist-strs ["[handlers & body]"], :end-row 493, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "with-warning-handlers", :ns "cljs.analyzer", :row 491} {:fixed-arities #{2}, :end-row 499, :private true, :ns "cljs.analyzer", :name "repeat-char", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[c n]"], :row 495} {:fixed-arities #{2}, :end-row 508, :private true, :ns "cljs.analyzer", :name "hex-format", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[s pad]"], :row 501} {:arglist-strs ["[value]"], :end-row 528, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "gen-constant-id", :ns "cljs.analyzer", :row 510} {:fixed-arities #{1 2}, :end-row 548, :private true, :ns "cljs.analyzer", :name "register-constant!", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[val]" "[env val]"], :row 530} {:end-row 551, :filename "cljs/analyzer.cljc", :lang :clj, :name "default-namespaces", :ns "cljs.analyzer", :row 550} {:end-row 570, :filename "cljs/analyzer.cljc", :lang :clj, :name "namespaces", :ns "cljs.analyzer", :row 558} {:arglist-strs ["[key]" "[cenv key]"], :end-row 579, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :clj, :name "get-namespace", :ns "cljs.analyzer", :row 572} {:arglist-strs ["[& body]"], :end-row 585, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "no-warn", :ns "cljs.analyzer", :row 582} {:arglist-strs ["[& body]"], :end-row 591, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "all-warn", :ns "cljs.analyzer", :row 588} {:arglist-strs ["[x env]"], :end-row 594, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "get-line", :ns "cljs.analyzer", :row 593} {:arglist-strs ["[x env]"], :end-row 597, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "get-col", :ns "cljs.analyzer", :row 596} {:fixed-arities #{1 2}, :end-row 616, :ns "cljs.analyzer", :name "intern-macros", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]" "[ns reload]"], :doc "Given a Clojure namespace intern all macros into the ambient ClojureScript\n   analysis environment.", :row 599} {:end-row 619, :filename "cljs/analyzer.cljc", :lang :clj, :name "load-mutex", :ns "cljs.analyzer", :row 619} {:fixed-arities #{2}, :end-row 646, :private true, :ns "cljs.analyzer", :name "load-data-reader-file", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[mappings url]"], :row 622} {:fixed-arities #{0 1}, :end-row 656, :ns "cljs.analyzer", :name "get-data-readers*", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]" "[classloader]"], :doc "returns a merged map containing all data readers defined by libraries\n      on the classpath.", :row 649} {:end-row 659, :filename "cljs/analyzer.cljc", :lang :clj, :name "get-data-readers", :ns "cljs.analyzer", :row 659} {:arglist-strs ["[]"], :end-row 675, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :clj, :name "load-data-readers*", :ns "cljs.analyzer", :row 662} {:end-row 678, :filename "cljs/analyzer.cljc", :lang :clj, :name "load-data-readers", :ns "cljs.analyzer", :row 678} {:arglist-strs ["[]"], :end-row 689, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :clj, :name "load-core", :ns "cljs.analyzer", :row 681} {:arglist-strs ["[path & body]"], :end-row 698, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "with-core-macros", :ns "cljs.analyzer", :row 692} {:arglist-strs ["[path & body]"], :end-row 708, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "with-core-macros-file", :ns "cljs.analyzer", :row 701} {:fixed-arities #{0}, :end-row 722, :ns "cljs.analyzer", :name "empty-env", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :doc "Construct an empty analysis environment. Required to analyze forms.", :row 710} {:fixed-arities #{1}, :end-row 728, :private true, :ns "cljs.analyzer", :name "source-info->error-data", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[{:keys [file line column]}]"], :row 724} {:arglist-strs ["[env]" "[name env]"], :end-row 741, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :clj, :name "source-info", :ns "cljs.analyzer", :row 730} {:arglist-strs ["[env s]"], :end-row 748, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "message", :ns "cljs.analyzer", :row 743} {:arglist-strs ["[warning-type env extra]"], :end-row 752, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "warning", :ns "cljs.analyzer", :row 750} {:fixed-arities #{1}, :end-row 757, :private true, :ns "cljs.analyzer", :name "accumulating-warning-handler", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[warn-acc]"], :row 754} {:fixed-arities #{1}, :end-row 760, :private true, :ns "cljs.analyzer", :name "replay-accumulated-warnings", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[warn-acc]"], :row 759} {:fixed-arities #{3 2}, :end-row 769, :private true, :ns "cljs.analyzer", :name "error-data", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env phase]" "[env phase symbol]"], :row 762} {:fixed-arities #{3}, :end-row 774, :private true, :ns "cljs.analyzer", :name "compile-syntax-error", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env msg symbol]"], :row 771} {:arglist-strs ["[env msg]" "[env msg cause]"], :end-row 782, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "error", :ns "cljs.analyzer", :row 776} {:arglist-strs ["[ex]"], :end-row 787, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "analysis-error?", :ns "cljs.analyzer", :row 784} {:arglist-strs ["[ex]"], :end-row 792, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "has-error-data?", :ns "cljs.analyzer", :row 789} {:arglist-strs ["[env & body]"], :end-row 802, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "wrapping-errors", :ns "cljs.analyzer", :row 795} {:end-row 805, :filename "cljs/analyzer.cljc", :lang :clj, :name "implicit-nses", :ns "cljs.analyzer", :row 805} {:arglist-strs ["[env prefix suffix]"], :end-row 810, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "implicit-import?", :ns "cljs.analyzer", :row 807} {:end-row 812, :filename "cljs/analyzer.cljc", :lang :clj, :name "get-expander", :ns "cljs.analyzer", :row 812} {:arglist-strs ["[env prefix suffix]"], :end-row 819, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "confirm-var-exist-warning", :ns "cljs.analyzer", :row 814} {:fixed-arities #{1}, :end-row 827, :ns "cljs.analyzer", :name "lib&sublib", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[lib]"], :doc "If a library name has the form foo$bar, return a vector of the library and\n   the sublibrary property.", :row 821} {:fixed-arities #{2}, :end-row 837, :ns "cljs.analyzer", :name "loaded-js-ns?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env prefix]"], :doc "Check if a JavaScript namespace has been loaded. JavaScript vars are\n  not currently checked.", :row 829} {:fixed-arities #{2}, :end-row 848, :private true, :ns "cljs.analyzer", :name "internal-js-module-exists?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[js-module-index module]"], :row 839} {:end-row 850, :filename "cljs/analyzer.cljc", :lang :clj, :name "js-module-exists?*", :ns "cljs.analyzer", :row 850} {:arglist-strs ["[module]"], :end-row 854, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "js-module-exists?", :ns "cljs.analyzer", :row 852} {:arglist-strs ["[module]"], :end-row 867, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "node-module-dep?", :ns "cljs.analyzer", :row 856} {:arglist-strs ["[module]"], :end-row 874, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "dep-has-global-exports?", :ns "cljs.analyzer", :row 869} {:arglist-strs ["[module]"], :end-row 886, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "goog-module-dep?", :ns "cljs.analyzer", :row 876} {:arglist-strs ["[env prefix suffix]" "[env prefix suffix missing-fn]"], :end-row 906, :filename "cljs/analyzer.cljc", :fixed-arities #{4 3}, :lang :clj, :name "confirm-var-exists", :ns "cljs.analyzer", :row 888} {:arglist-strs ["[]"], :end-row 912, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :clj, :name "confirm-var-exists-throw", :ns "cljs.analyzer", :row 908} {:arglist-strs ["[env name]" "[env name not-found]"], :end-row 919, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "resolve-ns-alias", :ns "cljs.analyzer", :row 914} {:arglist-strs ["[env name]" "[env name not-found]"], :end-row 926, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "resolve-macro-ns-alias", :ns "cljs.analyzer", :row 921} {:fixed-arities #{2}, :end-row 941, :ns "cljs.analyzer", :name "confirm-ns", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env ns-sym]"], :doc "Given env, an analysis environment, and ns-sym, a symbol identifying a\n   namespace, confirm that the namespace exists. Warn if not found.", :row 928} {:fixed-arities #{2}, :end-row 952, :ns "cljs.analyzer", :name "core-name?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Is sym visible from core in the current compilation namespace?", :row 943} {:fixed-arities #{2}, :end-row 963, :ns "cljs.analyzer", :name "public-name?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns sym]"], :doc "Is sym public?", :row 954} {:arglist-strs ["[x]"], :end-row 968, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "js-tag?", :ns "cljs.analyzer", :row 965} {:arglist-strs ["[x]"], :end-row 977, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "normalize-js-tag", :ns "cljs.analyzer", :row 970} {:fixed-arities #{1}, :end-row 985, :ns "cljs.analyzer", :name "->type-set", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[t]"], :doc "Ensures that a type tag is a set.", :row 979} {:arglist-strs ["[t]"], :end-row 999, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "canonicalize-type", :ns "cljs.analyzer", :row 987} {:fixed-arities #{0 1 2}, :end-row 1012, :ns "cljs.analyzer", :name "add-types", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]" "[t1]" "[t1 t2]" "[t1 t2 & ts]"], :doc "Produces a union of types.", :row 1001} {:end-row 1021, :filename "cljs/analyzer.cljc", :lang :clj, :name "alias->type", :ns "cljs.analyzer", :row 1014} {:arglist-strs ["[pre externs]" "[pre externs top]"], :end-row 1047, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "has-extern?*", :ns "cljs.analyzer", :row 1023} {:arglist-strs ["[pre]" "[pre externs]"], :end-row 1058, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :clj, :name "has-extern?", :ns "cljs.analyzer", :row 1049} {:arglist-strs ["[pre]" "[pre tag-type]" "[pre tag-type externs]" "[pre tag-type externs top]"], :end-row 1073, :filename "cljs/analyzer.cljc", :fixed-arities #{1 4 3 2}, :lang :clj, :name "js-tag", :ns "cljs.analyzer", :row 1060} {:arglist-strs ["[sym]"], :end-row 1080, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "dotted-symbol?", :ns "cljs.analyzer", :row 1075} {:arglist-strs ["[name]"], :end-row 1084, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "munge-node-lib", :ns "cljs.analyzer", :row 1082} {:arglist-strs ["[name]" "[ns name]"], :end-row 1090, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :clj, :name "munge-goog-module-lib", :ns "cljs.analyzer", :row 1086} {:arglist-strs ["[name]"], :end-row 1094, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "munge-global-export", :ns "cljs.analyzer", :row 1092} {:fixed-arities #{2}, :end-row 1109, :ns "cljs.analyzer", :name "resolve-alias", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns sym]"], :doc "Takes a namespace and an unqualified symbol and potentially returns a new\n  symbol to be used in lieu of the original.", :row 1096} {:arglist-strs ["[ns]"], :end-row 1116, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "ns->module-type", :ns "cljs.analyzer", :row 1111} {:end-row 1118, :filename "cljs/analyzer.cljc", :lang :clj, :name "resolve*", :ns "cljs.analyzer", :row 1118} {:arglist-strs ["[sym current-ns]"], :end-row 1131, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "extern-pre", :ns "cljs.analyzer", :row 1126} {:arglist-strs ["[]" "[opts]"], :end-row 1138, :filename "cljs/analyzer.cljc", :fixed-arities #{0 1}, :lang :clj, :name "node-like?", :ns "cljs.analyzer", :row 1133} {:doc "Specially-treated symbols for which we don't trigger :private-var-access warnings.", :end-row 1175, :filename "cljs/analyzer.cljc", :lang :clj, :name "private-var-access-exceptions", :ns "cljs.analyzer", :private true, :row 1170} {:arglist-strs ["[ns env]"], :end-row 1194, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "required?", :ns "cljs.analyzer", :row 1192} {:fixed-arities #{2}, :end-row 1204, :ns "cljs.analyzer", :name "invokeable-ns?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns env]"], :doc "Returns true if ns is a required namespace and a JavaScript module that\n   might be invokeable as a function.", :row 1196} {:arglist-strs ["[ns current-ns env]"], :end-row 1222, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "resolve-invokeable-ns", :ns "cljs.analyzer", :row 1206} {:fixed-arities #{2}, :end-row 1231, :ns "cljs.analyzer", :name "resolve-import", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env import]"], :doc "goog.modules are deterministically assigned to a property of the namespace,\n   we cannot expect the reference will be globally available, so we resolve to\n   namespace local reference.", :row 1224} {:arglist-strs ["[sym lb]"], :end-row 1241, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "handle-symbol-local", :ns "cljs.analyzer", :row 1238} {:fixed-arities #{4 3 2}, :end-row 1359, :ns "cljs.analyzer", :name "resolve-var", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]" "[env sym confirm]" "[env sym confirm default?]"], :doc "Resolve a var. Accepts a side-effecting confirm fn for producing\n   warnings about unresolved vars.", :row 1243} {:fixed-arities #{2}, :end-row 1367, :ns "cljs.analyzer", :name "resolve-existing-var", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Given env, an analysis environment, and sym, a symbol, resolve an existing var.\n   Emits a warning if no such var exists.", :row 1361} {:fixed-arities #{2}, :end-row 1377, :ns "cljs.analyzer", :name "confirm-bindings", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env names]"], :doc "Given env, an analysis environment env, and names, a list of symbols, confirm\n   that all correspond to declared dynamic vars.", :row 1369} {:fixed-arities #{2}, :end-row 1412, :ns "cljs.analyzer", :name "resolve-macro-var", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Given env, an analysis environment, and sym, a symbol, resolve a macro.", :row 1379} {:end-row 1414, :filename "cljs/analyzer.cljc", :lang :clj, :name "analyze", :ns "cljs.analyzer", :row 1414} {:end-row 1414, :filename "cljs/analyzer.cljc", :lang :clj, :name "analyze-symbol", :ns "cljs.analyzer", :row 1414} {:end-row 1414, :filename "cljs/analyzer.cljc", :lang :clj, :name "analyze-seq", :ns "cljs.analyzer", :row 1414} {:end-row 1419, :filename "cljs/analyzer.cljc", :lang :clj, :name "specials", :ns "cljs.analyzer", :row 1418} {:end-row 1421, :filename "cljs/analyzer.cljc", :lang :clj, :name "*recur-frames*", :ns "cljs.analyzer", :row 1421} {:end-row 1422, :filename "cljs/analyzer.cljc", :lang :clj, :name "*loop-lets*", :ns "cljs.analyzer", :row 1422} {:end-row 1423, :filename "cljs/analyzer.cljc", :lang :clj, :name "*allow-redef*", :ns "cljs.analyzer", :row 1423} {:end-row 1424, :filename "cljs/analyzer.cljc", :lang :clj, :name "*allow-ns*", :ns "cljs.analyzer", :row 1424} {:arglist-strs ["[& body]"], :end-row 1428, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "disallowing-recur", :ns "cljs.analyzer", :row 1427} {:arglist-strs ["[& body]"], :end-row 1432, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "allowing-redef", :ns "cljs.analyzer", :row 1431} {:arglist-strs ["[& body]"], :end-row 1436, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "disallowing-ns*", :ns "cljs.analyzer", :row 1435} {:arglist-strs ["[env sym]"], :end-row 1442, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-keyword", :ns "cljs.analyzer", :row 1439} {:arglist-strs ["[ast]"], :end-row 1449, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "get-tag", :ns "cljs.analyzer", :row 1444} {:arglist-strs ["[fn-ast params]"], :end-row 1460, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "find-matching-method", :ns "cljs.analyzer", :row 1451} {:arglist-strs ["[env t]"], :end-row 1475, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "type?", :ns "cljs.analyzer", :row 1462} {:end-row 1477, :filename "cljs/analyzer.cljc", :lang :clj, :name "infer-tag", :ns "cljs.analyzer", :row 1477} {:arglist-strs ["[{:keys [op] :as ast}]"], :end-row 1483, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "unwrap-quote", :ns "cljs.analyzer", :row 1479} {:arglist-strs ["[env ast]"], :end-row 1515, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "infer-if", :ns "cljs.analyzer", :row 1485} {:arglist-strs ["[ast]"], :end-row 1518, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "js-var?", :ns "cljs.analyzer", :row 1517} {:arglist-strs ["[fn-ast]"], :end-row 1521, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "js-var-fn?", :ns "cljs.analyzer", :row 1520} {:arglist-strs ["[{:keys [info] :as fn-ast}]"], :end-row 1534, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "fn-ast->tag", :ns "cljs.analyzer", :row 1523} {:arglist-strs ["[env {fn-ast :fn :keys [args] :as ast}]"], :end-row 1543, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "infer-invoke", :ns "cljs.analyzer", :row 1536} {:fixed-arities #{2}, :end-row 1573, :ns "cljs.analyzer", :name "infer-tag", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env ast]"], :doc "Given env, an analysis environment, and e, an AST node, return the inferred\n   type of the node", :row 1545} {:end-row 1575, :filename "cljs/analyzer.cljc", :lang :clj, :name "parse", :ns "cljs.analyzer", :row 1575} {:arglist-strs ["[var]" "[var expr-env]"], :end-row 1600, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :clj, :name "var-meta", :ns "cljs.analyzer", :row 1577} {:arglist-strs ["[env sym]"], :end-row 1613, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "var-ast", :ns "cljs.analyzer", :row 1602} {:end-row 1690, :filename "cljs/analyzer.cljc", :lang :clj, :name "predicate->tag", :ns "cljs.analyzer", :private true, :row 1628} {:fixed-arities #{2}, :end-row 1705, :private true, :ns "cljs.analyzer", :name "simple-predicate-induced-tag", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Look for a predicate-induced tag when the test expression is a simple\n   application of a predicate to a local, as in (string? x).", :row 1692} {:end-row 1707, :filename "cljs/analyzer.cljc", :lang :clj, :name "specials", :ns "cljs.analyzer", :row 1707} {:fixed-arities #{2}, :end-row 1727, :private true, :ns "cljs.analyzer", :name "type-check-induced-tag", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Look for a type-check-induced tag when the test expression is the use of\n  instance? on a local, as in (instance? UUID x) or implements? on a local, as\n  in (implements? ICounted x).", :row 1709} {:fixed-arities #{2}, :end-row 1739, :private true, :ns "cljs.analyzer", :name "truth-induced-tag", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Refine a tag to exclude clj-nil if the test is a local.", :row 1729} {:fixed-arities #{2}, :end-row 1750, :private true, :ns "cljs.analyzer", :name "set-test-induced-tags", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Looks at the test and sets any tags which are induced by virtue\n  of the test being truthy. For example in (if (string? x) x :bar)\n  the local x in the then branch must be of string type.", :row 1741} {:arglist-strs ["[x]"], :end-row 1887, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "valid-proto", :ns "cljs.analyzer", :row 1886} {:arglist-strs ["[env ast opts]"], :end-row 1890, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "elide-env", :ns "cljs.analyzer", :row 1889} {:arglist-strs ["[new-env]"], :end-row 1894, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "replace-env-pass", :ns "cljs.analyzer", :row 1892} {:arglist-strs ["[ast]"], :end-row 1902, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "ast-children", :ns "cljs.analyzer", :row 1896} {:arglist-strs ["[{:keys [op] :as ast}]"], :end-row 1908, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "constant-value?", :ns "cljs.analyzer", :row 1904} {:arglist-strs ["[{:keys [op] :as e}]"], :end-row 1917, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "const-expr->constant-value", :ns "cljs.analyzer", :row 1910} {:fixed-arities #{1}, :end-row 1923, :private true, :ns "cljs.analyzer", :name "earmuffed?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym]"], :row 1919} {:fixed-arities #{1}, :end-row 1929, :private true, :ns "cljs.analyzer", :name "core-ns?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns-sym]"], :row 1925} {:arglist-strs ["[env]"], :end-row 2143, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "analyze-fn-method-param", :ns "cljs.analyzer", :row 2117} {:arglist-strs ["[env form recur-frames]"], :end-row 2147, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "analyze-fn-method-body", :ns "cljs.analyzer", :row 2145} {:fixed-arities #{5}, :end-row 2183, :private true, :ns "cljs.analyzer", :name "analyze-fn-method", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env locals form type analyze-body?]"], :row 2149} {:end-row 2185, :filename "cljs/analyzer.cljc", :lang :clj, :name "analyze-wrap-meta", :ns "cljs.analyzer", :row 2185} {:arglist-strs ["[env locals name]"], :end-row 2203, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "fn-name-var", :ns "cljs.analyzer", :row 2187} {:arglist-strs ["[menv locals type meths]"], :end-row 2206, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze-fn-methods-pass2*", :ns "cljs.analyzer", :row 2205} {:arglist-strs ["[menv locals type meths]"], :end-row 2209, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze-fn-methods-pass2", :ns "cljs.analyzer", :row 2208} {:arglist-strs ["[env exprs]"], :end-row 2349, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-do-statements*", :ns "cljs.analyzer", :row 2348} {:arglist-strs ["[env exprs]"], :end-row 2352, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-do-statements", :ns "cljs.analyzer", :row 2351} {:arglist-strs ["[env init loop-lets]"], :end-row 2379, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "analyze-let-binding-init", :ns "cljs.analyzer", :row 2377} {:arglist-strs ["[name init-expr]"], :end-row 2386, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "get-let-tag", :ns "cljs.analyzer", :row 2381} {:arglist-strs ["[encl-env bindings op]"], :end-row 2432, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "analyze-let-bindings*", :ns "cljs.analyzer", :row 2388} {:arglist-strs ["[encl-env bindings op]"], :end-row 2435, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "analyze-let-bindings", :ns "cljs.analyzer", :row 2434} {:arglist-strs ["[env context exprs]"], :end-row 2438, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "analyze-let-body*", :ns "cljs.analyzer", :row 2437} {:arglist-strs ["[env context exprs recur-frames loop-lets]"], :end-row 2443, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :clj, :name "analyze-let-body", :ns "cljs.analyzer", :row 2440} {:arglist-strs ["[encl-env [_ bindings & exprs :as form] is-loop widened-tags]"], :end-row 2495, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze-let", :ns "cljs.analyzer", :row 2445} {:arglist-strs ["[env form]"], :end-row 2545, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-const", :ns "cljs.analyzer", :row 2536} {:end-row 2565, :filename "cljs/analyzer.cljc", :lang :clj, :name "js-prim-ctor->tag", :ns "cljs.analyzer", :row 2559} {:fixed-arities #{1}, :end-row 2570, :ns "cljs.analyzer", :name "prim-ctor?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[t]"], :doc "Test whether a tag is a constructor for a JS primitive", :row 2567} {:end-row 2672, :filename "cljs/analyzer.cljc", :lang :clj, :name "analyze-file", :ns "cljs.analyzer", :row 2672} {:fixed-arities #{1}, :end-row 2693, :ns "cljs.analyzer", :name "locate-src", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Given a namespace return the corresponding ClojureScript (.cljs or .cljc)\n     resource on the classpath or file from the root of the build.", :row 2675} {:arglist-strs ["[dep]"], :end-row 2701, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "foreign-dep?", :ns "cljs.analyzer", :row 2695} {:fixed-arities #{4 3}, :end-row 2740, :ns "cljs.analyzer", :name "analyze-deps", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[lib deps env]" "[lib deps env opts]"], :doc "Given a lib, a namespace, deps, its dependencies, env, an analysis environment\n   and opts, compiler options - analyze all of the dependencies. Required to\n   correctly analyze usage of other namespaces.", :row 2703} {:arglist-strs ["[lib sym cenv]"], :end-row 2748, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "missing-use?", :ns "cljs.analyzer", :row 2742} {:arglist-strs ["[sym cenv]"], :end-row 2753, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "missing-rename?", :ns "cljs.analyzer", :row 2750} {:arglist-strs ["[lib sym]"], :end-row 2759, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "missing-use-macro?", :ns "cljs.analyzer", :row 2755} {:arglist-strs ["[sym]"], :end-row 2765, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "missing-rename-macro?", :ns "cljs.analyzer", :row 2761} {:arglist-strs ["[uses env]"], :end-row 2771, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "missing-uses", :ns "cljs.analyzer", :row 2768} {:arglist-strs ["[renames env]"], :end-row 2776, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "missing-renames", :ns "cljs.analyzer", :row 2774} {:arglist-strs ["[use-macros env]"], :end-row 2781, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "missing-use-macros", :ns "cljs.analyzer", :row 2779} {:arglist-strs ["[use-macros env]"], :end-row 2786, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "inferred-use-macros", :ns "cljs.analyzer", :row 2784} {:arglist-strs ["[rename-macros env]"], :end-row 2790, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "inferred-rename-macros", :ns "cljs.analyzer", :row 2789} {:arglist-strs ["[uses env]"], :end-row 2798, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "check-uses", :ns "cljs.analyzer", :row 2792} {:arglist-strs ["[use-macros env]" "[use-macros missing-uses env]"], :end-row 2811, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "check-use-macros", :ns "cljs.analyzer", :row 2800} {:arglist-strs ["[{:keys [name uses use-macros] :as ast} env]"], :end-row 2829, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "check-use-macros-inferring-missing", :ns "cljs.analyzer", :row 2813} {:arglist-strs ["[{:keys [name renames] :as ast} env]"], :end-row 2848, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "check-rename-macros-inferring-missing", :ns "cljs.analyzer", :row 2831} {:arglist-strs ["[spec msg]"], :end-row 2851, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "parse-ns-error-msg", :ns "cljs.analyzer", :row 2850} {:arglist-strs ["[env macros? spec]"], :end-row 2881, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "basic-validate-ns-spec", :ns "cljs.analyzer", :row 2853} {:arglist-strs ["[env args]"], :end-row 2921, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "parse-ns-excludes", :ns "cljs.analyzer", :row 2883} {:arglist-strs ["[env [lib & filters :as spec]]"], :end-row 2955, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "use->require", :ns "cljs.analyzer", :row 2923} {:arglist-strs ["[env macros? deps aliases spec]"], :end-row 3011, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :clj, :name "parse-require-spec", :ns "cljs.analyzer", :row 2957} {:arglist-strs ["[env deps spec]"], :end-row 3031, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "parse-import-spec", :ns "cljs.analyzer", :row 3013} {:end-row 3033, :filename "cljs/analyzer.cljc", :lang :clj, :name "parse-ns", :ns "cljs.analyzer", :row 3033} {:fixed-arities #{1}, :end-row 3048, :ns "cljs.analyzer", :name "macro-autoload-ns?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[form]"], :doc "Given a spec form check whether the spec namespace requires a macro file\n   of the same name. If so return true.", :row 3035} {:fixed-arities #{1}, :end-row 3057, :ns "cljs.analyzer", :name "clj-ns->cljs-ns", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym]"], :doc "Given a symbol that starts with clojure as the first segment return the\n   same symbol with the first segment replaced with cljs", :row 3050} {:fixed-arities #{1}, :end-row 3067, :ns "cljs.analyzer", :name "aliasable-clj-ns?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym]"], :doc "Predicate for testing with a symbol represents an aliasable clojure namespace.", :row 3060} {:arglist-strs ["[[k & specs :as form]]"], :end-row 3082, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "process-rewrite-form", :ns "cljs.analyzer", :row 3070} {:fixed-arities #{1}, :end-row 3089, :ns "cljs.analyzer", :name "rewrite-cljs-aliases", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[args]"], :doc "Alias non-existing clojure.* namespaces to existing cljs.* namespaces if\n      possible.", :row 3085} {:arglist-strs ["[specs]"], :end-row 3097, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "canonicalize-specs", :ns "cljs.analyzer", :row 3091} {:arglist-strs ["[specs]"], :end-row 3104, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "canonicalize-import-specs", :ns "cljs.analyzer", :row 3099} {:fixed-arities #{1}, :end-row 3155, :ns "cljs.analyzer", :name "desugar-ns-specs", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[args]"], :doc "Given an original set of ns specs desugar :include-macros and :refer-macros\n   usage into only primitive spec forms - :use, :require, :use-macros,\n   :require-macros. If a library includes a macro file of with the same name\n   as the namespace will also be desugared.", :row 3106} {:arglist-strs ["[env ns segments]"], :end-row 3166, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "find-def-clash", :ns "cljs.analyzer", :row 3157} {:arglist-strs ["[name]"], :end-row 3173, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "macro-ns-name", :ns "cljs.analyzer", :row 3168} {:fixed-arities #{3}, :end-row 3189, :private true, :ns "cljs.analyzer", :name "check-duplicate-aliases", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env old new]"], :row 3175} {:fixed-arities #{3}, :end-row 3205, :private true, :ns "cljs.analyzer", :name "merge-ns-info", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[old new env]"], :row 3191} {:arglist-strs ["[op env [_ tsym fields pmasks body :as form]]"], :end-row 3434, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "parse-type", :ns "cljs.analyzer", :row 3399} {:fixed-arities #{1}, :end-row 3446, :private true, :ns "cljs.analyzer", :name "property-symbol?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[%1]"], :row 3446} {:fixed-arities #{1}, :end-row 3457, :private true, :ns "cljs.analyzer", :name "classify-dot-form", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[[target member args]]"], :row 3448} {:end-row 3459, :filename "cljs/analyzer.cljc", :lang :clj, :name "build-dot-form", :ns "cljs.analyzer", :row 3459} {:fixed-arities #{3}, :end-row 3480, :private true, :ns "cljs.analyzer", :name "build-method-call", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[target meth args]"], :doc "Builds the intermediate method call map used to reason about the parsed form during\n  compilation.", :row 3474} {:arglist-strs ["[env target field member+ form]"], :end-row 3572, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :clj, :name "analyze-dot", :ns "cljs.analyzer", :row 3511} {:arglist-strs ["[form]"], :end-row 3583, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "get-js-tag", :ns "cljs.analyzer", :row 3578} {:arglist-strs ["[env s]"], :end-row 3595, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "js-star-interp", :ns "cljs.analyzer", :row 3585} {:arglist-strs ["[s]"], :end-row 3605, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "js-star-seg", :ns "cljs.analyzer", :row 3597} {:end-row 3607, :filename "cljs/analyzer.cljc", :lang :clj, :name "NUMERIC_SET", :ns "cljs.analyzer", :row 3607} {:arglist-strs ["[t]"], :end-row 3629, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "numeric-type?", :ns "cljs.analyzer", :row 3609} {:end-row 3632, :filename "cljs/analyzer.cljc", :lang :clj, :name "array-types", :ns "cljs.analyzer", :row 3631} {:arglist-strs ["[t]"], :end-row 3650, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "array-type?", :ns "cljs.analyzer", :row 3634} {:fixed-arities #{3}, :end-row 3660, :private true, :ns "cljs.analyzer", :name "analyze-js-star-args", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[js-op env args]"], :row 3652} {:arglist-strs ["[env jsform args form]"], :end-row 3689, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze-js-star*", :ns "cljs.analyzer", :row 3662} {:arglist-strs ["[env jsform args form]"], :end-row 3692, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze-js-star", :ns "cljs.analyzer", :row 3691} {:fixed-arities #{1}, :end-row 3718, :private true, :ns "cljs.analyzer", :name "unsorted-map?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :row 3716} {:fixed-arities #{1}, :end-row 3726, :ns "cljs.analyzer", :name "analyzed", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :doc "Mark a form as being analyzed. Assumes x satisfies IMeta. Useful to suppress\n  warnings that will have been caught by a first compiler pass.", :row 3720} {:fixed-arities #{1}, :end-row 3735, :ns "cljs.analyzer", :name "analyzed?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :doc "Returns boolean if the form has already been marked as analyzed.", :row 3728} {:fixed-arities #{1}, :end-row 3740, :private true, :ns "cljs.analyzer", :name "all-values?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[exprs]"], :row 3737} {:fixed-arities #{2}, :end-row 3746, :private true, :ns "cljs.analyzer", :name "valid-arity?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[argc method-params]"], :row 3742} {:fixed-arities #{1}, :end-row 3752, :private true, :ns "cljs.analyzer", :name "record-tag?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[tag]"], :row 3748} {:fixed-arities #{1}, :end-row 3758, :private true, :ns "cljs.analyzer", :name "record-basis", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[tag]"], :row 3754} {:fixed-arities #{2}, :end-row 3763, :private true, :ns "cljs.analyzer", :name "record-with-field?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[tag field]"], :row 3760} {:fixed-arities #{4}, :end-row 3768, :private true, :ns "cljs.analyzer", :name "invalid-arity?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[argc method-params variadic max-fixed-arity]"], :row 3765} {:arglist-strs ["[env [f & args :as form]]"], :end-row 3832, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "parse-invoke*", :ns "cljs.analyzer", :row 3770} {:arglist-strs ["[env form]"], :end-row 3836, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "parse-invoke", :ns "cljs.analyzer", :row 3834} {:arglist-strs ["[{:keys [op] :as expr}]"], :end-row 3862, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "desugar-dotted-expr", :ns "cljs.analyzer", :row 3838} {:fixed-arities #{2}, :end-row 3913, :ns "cljs.analyzer", :name "analyze-symbol", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Finds the var associated with sym", :row 3865} {:arglist-strs ["[env sym]"], :end-row 3919, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "excluded?", :ns "cljs.analyzer", :row 3915} {:arglist-strs ["[env sym]"], :end-row 3925, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "used?", :ns "cljs.analyzer", :row 3921} {:arglist-strs ["[env nstr]"], :end-row 3940, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "get-expander-ns", :ns "cljs.analyzer", :row 3927} {:arglist-strs ["[sym env]"], :end-row 3965, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "get-expander*", :ns "cljs.analyzer", :row 3942} {:fixed-arities #{2}, :end-row 3975, :ns "cljs.analyzer", :name "get-expander", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym env]"], :doc "Given a sym, a symbol identifying a macro, and env, an analysis environment\n   return the corresponding Clojure macroexpander.", :row 3967} {:fixed-arities #{1}, :end-row 3985, :private true, :ns "cljs.analyzer", :name "var->sym", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[var]"], :row 3983} {:fixed-arities #{3}, :end-row 3997, :private true, :ns "cljs.analyzer", :name "do-macroexpand-check", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env form mac-var]"], :row 3987} {:arglist-strs ["[env form]"], :end-row 4068, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "macroexpand-1*", :ns "cljs.analyzer", :row 4010} {:fixed-arities #{2}, :end-row 4074, :ns "cljs.analyzer", :name "macroexpand-1", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env form]"], :doc "Given a env, an analysis environment, and form, a ClojureScript form,\n   macroexpand the form once.", :row 4070} {:end-row 4076, :filename "cljs/analyzer.cljc", :lang :clj, :name "analyze-list", :ns "cljs.analyzer", :row 4076} {:arglist-strs ["[op env form name opts]"], :end-row 4081, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :clj, :name "analyze-seq*", :ns "cljs.analyzer", :row 4078} {:arglist-strs ["[op env form name opts]"], :end-row 4085, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :clj, :name "analyze-seq*-wrap", :ns "cljs.analyzer", :row 4083} {:arglist-strs ["[env form name]" "[env form name opts]"], :end-row 4110, :filename "cljs/analyzer.cljc", :fixed-arities #{4 3}, :lang :clj, :name "analyze-seq", :ns "cljs.analyzer", :row 4087} {:arglist-strs ["[env form]"], :end-row 4120, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-map", :ns "cljs.analyzer", :row 4112} {:arglist-strs ["[env form]"], :end-row 4128, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-list", :ns "cljs.analyzer", :row 4124} {:arglist-strs ["[env form]"], :end-row 4134, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-vector", :ns "cljs.analyzer", :row 4130} {:arglist-strs ["[env form]"], :end-row 4140, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-set", :ns "cljs.analyzer", :row 4136} {:arglist-strs ["[env form]"], :end-row 4164, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-js-value", :ns "cljs.analyzer", :row 4142} {:arglist-strs ["[x]"], :end-row 4172, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "record-ns+name", :ns "cljs.analyzer", :row 4166} {:arglist-strs ["[env x]"], :end-row 4184, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-record", :ns "cljs.analyzer", :row 4174} {:arglist-strs ["[m]"], :end-row 4187, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "elide-reader-meta", :ns "cljs.analyzer", :row 4186} {:arglist-strs ["[m]"], :end-row 4190, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "elide-analyzer-meta", :ns "cljs.analyzer", :row 4189} {:arglist-strs ["[m]"], :end-row 4193, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "elide-irrelevant-meta", :ns "cljs.analyzer", :row 4192} {:arglist-strs ["[expr]"], :end-row 4204, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "analyze-wrap-meta", :ns "cljs.analyzer", :row 4195} {:arglist-strs ["[env {:keys [tag] :as ast} _]"], :end-row 4217, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "infer-type", :ns "cljs.analyzer", :row 4206} {:fixed-arities #{2}, :end-row 4220, :private true, :ns "cljs.analyzer", :name "repl-self-require?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env deps]"], :row 4219} {:arglist-strs ["[env {:keys [op] :as ast} opts]"], :end-row 4263, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "ns-side-effects", :ns "cljs.analyzer", :row 4223} {:end-row 4277, :filename "cljs/analyzer.cljc", :lang :clj, :name "invoke-arg-type-validators", :ns "cljs.analyzer", :row 4267} {:arglist-strs ["[env {:keys [op] :as ast} opts]"], :end-row 4290, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "check-invoke-arg-types", :ns "cljs.analyzer", :row 4279} {:arglist-strs ["[env form name opts]"], :end-row 4313, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze-form", :ns "cljs.analyzer", :row 4293} {:end-row 4339, :filename "cljs/analyzer.cljc", :lang :clj, :name "default-passes", :ns "cljs.analyzer", :row 4337} {:arglist-strs ["[env form name opts]"], :end-row 4350, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze*", :ns "cljs.analyzer", :row 4341} {:fixed-arities #{4 3 2}, :end-row 4369, :ns "cljs.analyzer", :name "analyze", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env form]" "[env form name]" "[env form name opts]"], :doc "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n  (one of :statement, :expr, :return), :ns (a symbol naming the\n  compilation ns)}, and form, returns an expression object (a map\n  containing at least :form, :op and :env keys). If expr has any (immediately)\n  nested exprs, must have a :children entry. This must be a vector of keywords naming\n  the immediately nested fields mapped to an expr or vector of exprs. This will\n  facilitate code walking without knowing the details of the op set.", :row 4352} {:fixed-arities #{2}, :end-row 4384, :ns "cljs.analyzer", :name "add-consts", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[compiler-state constants-map]"], :doc "Given a compiler state and a map from fully qualified symbols to constant\n  EDN values, update the compiler state marking these vars as const to support\n  direct substitution of these vars in source.", :row 4371} {:fixed-arities #{1}, :end-row 4392, :private true, :ns "cljs.analyzer", :name "source-path", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :doc "Returns a path suitable for providing to tools.reader as a 'filename'.", :row 4387} {:arglist-strs ["[sym]"], :end-row 4400, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "resolve-symbol", :ns "cljs.analyzer", :row 4394} {:fixed-arities #{1}, :end-row 4407, :ns "cljs.analyzer", :name "get-aliases", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Get all alias maps for a namespace.", :row 4402} {:fixed-arities #{0}, :end-row 4416, :ns "cljs.analyzer", :name "get-bridged-alias-map", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :doc "Returns clojure.tools.reader/*alias-map* for bridging", :row 4410} {:fixed-arities #{1 2}, :end-row 4445, :ns "cljs.analyzer", :name "forms-seq*", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[rdr]" "[rdr filename]"], :doc "Seq of Clojure/ClojureScript forms from rdr, a java.io.Reader. Optionally\n     accepts a filename argument which will be used in any emitted errors.", :row 4419} {:fixed-arities #{1 3 2}, :end-row 4476, :ns "cljs.analyzer", :name "forms-seq", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[f]" "[f filename]" "[f filename return-reader?]"], :doc "DEPRECATED: Seq of Clojure/ClojureScript forms from [f], which can be anything\n     for which `clojure.java.io/reader` can produce a `java.io.Reader`. Optionally\n     accepts a [filename] argument, which the reader will use in any emitted errors.", :row 4448} {:arglist-strs ["[src]"], :end-row 4487, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "gen-user-ns", :ns "cljs.analyzer", :row 4479} {:fixed-arities #{1 3 2}, :end-row 4592, :ns "cljs.analyzer", :name "parse-ns", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[src]" "[src opts]" "[src dest opts]"], :doc "Helper for parsing only the essential namespace information from a\n      ClojureScript source file and returning a cljs.closure/IJavaScript compatible\n      map _not_ a namespace AST node.\n\n      By default does not load macros or perform any analysis of dependencies. If\n      opts parameter provided :analyze-deps and :load-macros keys their values will\n      be used for *analyze-deps* and *load-macros* bindings respectively. This\n      function does _not_ side-effect the ambient compilation environment unless\n      requested via opts where :restore is false.", :row 4490} {:fixed-arities #{0 1}, :end-row 4598, :private true, :ns "cljs.analyzer", :name "cache-analysis-ext", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]" "[format]"], :row 4595} {:arglist-strs ["[opts]"], :end-row 4604, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "build-affecting-options", :ns "cljs.analyzer", :row 4601} {:arglist-strs ["[path opts]"], :end-row 4609, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "build-affecting-options-sha", :ns "cljs.analyzer", :row 4607} {:arglist-strs ["[path]" "[path opts]"], :end-row 4618, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :clj, :name "cache-base-path", :ns "cljs.analyzer", :row 4612} {:arglist-strs ["[rsrc ext]" "[rsrc ext opts]"], :end-row 4640, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "cacheable-files", :ns "cljs.analyzer", :row 4621} {:fixed-arities #{1 4 3 2 5}, :end-row 4668, :ns "cljs.analyzer", :name "cache-file", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[src]" "[src output-dir]" "[src ns-info output-dir]" "[src ns-info output-dir mode]" "[src ns-info output-dir mode opts]"], :doc "Given a ClojureScript source file returns the read/write path to the analysis\n      cache file. Defaults to the read path which is usually also the write path.", :row 4643} {:fixed-arities #{1 4 3 2}, :end-row 4700, :ns "cljs.analyzer", :name "requires-analysis?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[src]" "[src output-dir]" "[src cache output-dir]" "[src cache output-dir opts]"], :doc "Given a src, a resource, and output-dir, a compilation output directory\n      return true or false depending on whether src needs to be (re-)analyzed.\n      Can optionally pass cache, the analysis cache file.", :row 4671} {:fixed-arities #{0}, :end-row 4708, :private true, :ns "cljs.analyzer", :name "get-spec-vars", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :row 4703} {:fixed-arities #{1}, :end-row 4739, :ns "cljs.analyzer", :name "dump-specs", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Dumps registered speced vars for a given namespace into the compiler\n  environment.", :row 4719} {:fixed-arities #{1}, :end-row 4754, :ns "cljs.analyzer", :name "register-specs", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[cached-ns]"], :doc "Registers speced vars found in a namespace analysis cache.", :row 4741} {:arglist-strs ["[ns cache-file]" "[ns cache-file src]"], :end-row 4773, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "write-analysis-cache", :ns "cljs.analyzer", :row 4757} {:arglist-strs ["[cache-file src]" "[cache-file src opts]"], :end-row 4802, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "read-analysis-cache", :ns "cljs.analyzer", :row 4776} {:arglist-strs ["[forms]" "[forms opts]" "[forms opts return-last?]"], :end-row 4829, :filename "cljs/analyzer.cljc", :fixed-arities #{1 3 2}, :lang :clj, :name "analyze-form-seq", :ns "cljs.analyzer", :row 4804} {:fixed-arities #{1}, :end-row 4835, :ns "cljs.analyzer", :name "ensure-defs", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Ensures that a non-nil defs map exists in the compiler state for a given\n  ns. (A non-nil defs map signifies that the namespace has been analyzed.)", :row 4831} {:fixed-arities #{1 3 2}, :end-row 4902, :ns "cljs.analyzer", :name "analyze-file", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[f]" "[f opts]" "[f skip-cache opts]"], :doc "Given a java.io.File, java.net.URL or a string identifying a resource on the\n      classpath attempt to analyze it.\n\n      This function side-effects the ambient compilation environment\n      `cljs.env/*compiler*` to aggregate analysis information. opts argument is\n      compiler options, if :cache-analysis true will cache analysis to\n      \":output-dir/some/ns/foo.cljs.cache.edn\". This function does not return a\n      meaningful value.", :row 4838} {:end-row 55, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-ns*", :ns "cljs.analyzer", :row 55} {:end-row 56, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-file*", :ns "cljs.analyzer", :row 56} {:end-row 57, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*checked-arrays*", :ns "cljs.analyzer", :row 57} {:end-row 58, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*check-alias-dupes*", :ns "cljs.analyzer", :row 58} {:end-row 59, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-static-fns*", :ns "cljs.analyzer", :row 59} {:end-row 60, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*fn-invoke-direct*", :ns "cljs.analyzer", :row 60} {:end-row 61, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-macros-path*", :ns "cljs.analyzer", :row 61} {:end-row 62, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-macros-is-classpath*", :ns "cljs.analyzer", :row 62} {:end-row 63, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-dep-set*", :ns "cljs.analyzer", :row 63} {:end-row 64, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*analyze-deps*", :ns "cljs.analyzer", :row 64} {:end-row 65, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*load-tests*", :ns "cljs.analyzer", :row 65} {:end-row 66, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*load-macros*", :ns "cljs.analyzer", :row 66} {:end-row 67, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*reload-macros*", :ns "cljs.analyzer", :row 67} {:end-row 68, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*macro-infer*", :ns "cljs.analyzer", :row 68} {:end-row 69, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*passes*", :ns "cljs.analyzer", :row 69} {:end-row 70, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*file-defs*", :ns "cljs.analyzer", :row 70} {:end-row 71, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*private-var-access-nowarn*", :ns "cljs.analyzer", :row 71} {:doc "The namespace of the constants table as a symbol.", :end-row 75, :filename "cljs/analyzer.cljc", :lang :cljs, :name "constants-ns-sym", :ns "cljs.analyzer", :row 73} {:end-row 125, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*verbose*", :ns "cljs.analyzer", :row 125} {:end-row 127, :filename "cljs/analyzer.cljc", :lang :cljs, :name "-cljs-macros-loaded", :ns "cljs.analyzer", :row 127} {:end-row 168, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-warnings*", :ns "cljs.analyzer", :row 129} {:arglist-strs ["[]"], :end-row 171, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :cljs, :name "unchecked-arrays?", :ns "cljs.analyzer", :row 170} {:arglist-strs ["[]"], :end-row 174, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :cljs, :name "compiler-options", :ns "cljs.analyzer", :row 173} {:arglist-strs ["[]"], :end-row 177, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :cljs, :name "get-externs", :ns "cljs.analyzer", :row 176} {:fixed-arities #{0}, :end-row 185, :ns "cljs.analyzer", :name "checked-arrays", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :doc "Returns false-y, :warn, or :error based on configuration and the\n   current value of *unchecked-arrays*.", :row 179} {:end-row 200, :filename "cljs/analyzer.cljc", :lang :cljs, :name "js-reserved", :ns "cljs.analyzer", :row 187} {:end-row 203, :filename "cljs/analyzer.cljc", :lang :cljs, :name "es5-allowed", :ns "cljs.analyzer", :row 202} {:end-row 206, :filename "cljs/analyzer.cljc", :lang :cljs, :name "SENTINEL", :ns "cljs.analyzer", :row 206} {:arglist-strs ["[m k0 k1]" "[m k0 k1 k2]" "[m k0 k1 k2 k3]"], :end-row 226, :filename "cljs/analyzer.cljc", :fixed-arities #{4 3 5}, :lang :cljs, :name "gets", :ns "cljs.analyzer", :row 208} {:arglist-strs ["[ss]"], :end-row 230, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "munge-path", :ns "cljs.analyzer", :row 229} {:fixed-arities #{1 2}, :end-row 238, :ns "cljs.analyzer", :name "ns->relpath", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]" "[ns ext]"], :doc "Given a namespace as a symbol return the relative path. May optionally\n     provide the file extension, defaults to :cljs.", :row 233} {:arglist-strs ["[x get-deps]" "[x depth state memo-get-deps]"], :end-row 252, :filename "cljs/analyzer.cljc", :fixed-arities #{4 2}, :lang :cljs, :name "topo-sort", :ns "cljs.analyzer", :row 241} {:end-row 254, :filename "cljs/analyzer.cljc", :lang :cljs, :name "message", :ns "cljs.analyzer", :row 254} {:end-row 254, :filename "cljs/analyzer.cljc", :lang :cljs, :name "namespaces", :ns "cljs.analyzer", :row 254} {:arglist-strs ["[x]"], :end-row 259, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "ast?", :ns "cljs.analyzer", :row 256} {:end-row 261, :filename "cljs/analyzer.cljc", :lang :cljs, :name "error-message", :ns "cljs.analyzer", :row 261} {:arglist-strs ["[warning-type env extra]"], :end-row 485, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "default-warning-handler", :ns "cljs.analyzer", :row 479} {:end-row 488, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-warning-handlers*", :ns "cljs.analyzer", :row 487} {:fixed-arities #{2}, :end-row 499, :private true, :ns "cljs.analyzer", :name "repeat-char", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[c n]"], :row 495} {:fixed-arities #{2}, :end-row 508, :private true, :ns "cljs.analyzer", :name "hex-format", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[s pad]"], :row 501} {:arglist-strs ["[value]"], :end-row 528, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "gen-constant-id", :ns "cljs.analyzer", :row 510} {:fixed-arities #{1 2}, :end-row 548, :private true, :ns "cljs.analyzer", :name "register-constant!", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[val]" "[env val]"], :row 530} {:end-row 551, :filename "cljs/analyzer.cljc", :lang :cljs, :name "default-namespaces", :ns "cljs.analyzer", :row 550} {:end-row 570, :filename "cljs/analyzer.cljc", :lang :cljs, :name "namespaces", :ns "cljs.analyzer", :row 558} {:arglist-strs ["[key]" "[cenv key]"], :end-row 579, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "get-namespace", :ns "cljs.analyzer", :row 572} {:arglist-strs ["[x env]"], :end-row 594, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-line", :ns "cljs.analyzer", :row 593} {:arglist-strs ["[x env]"], :end-row 597, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-col", :ns "cljs.analyzer", :row 596} {:fixed-arities #{1 2}, :end-row 616, :ns "cljs.analyzer", :name "intern-macros", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]" "[ns reload]"], :doc "Given a Clojure namespace intern all macros into the ambient ClojureScript\n   analysis environment.", :row 599} {:fixed-arities #{0}, :end-row 722, :ns "cljs.analyzer", :name "empty-env", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :doc "Construct an empty analysis environment. Required to analyze forms.", :row 710} {:fixed-arities #{1}, :end-row 728, :private true, :ns "cljs.analyzer", :name "source-info->error-data", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[{:keys [file line column]}]"], :row 724} {:arglist-strs ["[env]" "[name env]"], :end-row 741, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "source-info", :ns "cljs.analyzer", :row 730} {:arglist-strs ["[env s]"], :end-row 748, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "message", :ns "cljs.analyzer", :row 743} {:arglist-strs ["[warning-type env extra]"], :end-row 752, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "warning", :ns "cljs.analyzer", :row 750} {:fixed-arities #{1}, :end-row 757, :private true, :ns "cljs.analyzer", :name "accumulating-warning-handler", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[warn-acc]"], :row 754} {:fixed-arities #{1}, :end-row 760, :private true, :ns "cljs.analyzer", :name "replay-accumulated-warnings", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[warn-acc]"], :row 759} {:fixed-arities #{3 2}, :end-row 769, :private true, :ns "cljs.analyzer", :name "error-data", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env phase]" "[env phase symbol]"], :row 762} {:fixed-arities #{3}, :end-row 774, :private true, :ns "cljs.analyzer", :name "compile-syntax-error", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env msg symbol]"], :row 771} {:arglist-strs ["[env msg]" "[env msg cause]"], :end-row 782, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "error", :ns "cljs.analyzer", :row 776} {:arglist-strs ["[ex]"], :end-row 787, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "analysis-error?", :ns "cljs.analyzer", :row 784} {:arglist-strs ["[ex]"], :end-row 792, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "has-error-data?", :ns "cljs.analyzer", :row 789} {:end-row 805, :filename "cljs/analyzer.cljc", :lang :cljs, :name "implicit-nses", :ns "cljs.analyzer", :row 805} {:arglist-strs ["[env prefix suffix]"], :end-row 810, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "implicit-import?", :ns "cljs.analyzer", :row 807} {:end-row 812, :filename "cljs/analyzer.cljc", :lang :cljs, :name "get-expander", :ns "cljs.analyzer", :row 812} {:arglist-strs ["[env prefix suffix]"], :end-row 819, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "confirm-var-exist-warning", :ns "cljs.analyzer", :row 814} {:fixed-arities #{1}, :end-row 827, :ns "cljs.analyzer", :name "lib&sublib", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[lib]"], :doc "If a library name has the form foo$bar, return a vector of the library and\n   the sublibrary property.", :row 821} {:fixed-arities #{2}, :end-row 837, :ns "cljs.analyzer", :name "loaded-js-ns?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env prefix]"], :doc "Check if a JavaScript namespace has been loaded. JavaScript vars are\n  not currently checked.", :row 829} {:fixed-arities #{2}, :end-row 848, :private true, :ns "cljs.analyzer", :name "internal-js-module-exists?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[js-module-index module]"], :row 839} {:end-row 850, :filename "cljs/analyzer.cljc", :lang :cljs, :name "js-module-exists?*", :ns "cljs.analyzer", :row 850} {:arglist-strs ["[module]"], :end-row 854, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "js-module-exists?", :ns "cljs.analyzer", :row 852} {:arglist-strs ["[module]"], :end-row 867, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "node-module-dep?", :ns "cljs.analyzer", :row 856} {:arglist-strs ["[module]"], :end-row 874, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "dep-has-global-exports?", :ns "cljs.analyzer", :row 869} {:arglist-strs ["[module]"], :end-row 886, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "goog-module-dep?", :ns "cljs.analyzer", :row 876} {:arglist-strs ["[env prefix suffix]" "[env prefix suffix missing-fn]"], :end-row 906, :filename "cljs/analyzer.cljc", :fixed-arities #{4 3}, :lang :cljs, :name "confirm-var-exists", :ns "cljs.analyzer", :row 888} {:arglist-strs ["[]"], :end-row 912, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :cljs, :name "confirm-var-exists-throw", :ns "cljs.analyzer", :row 908} {:arglist-strs ["[env name]" "[env name not-found]"], :end-row 919, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "resolve-ns-alias", :ns "cljs.analyzer", :row 914} {:arglist-strs ["[env name]" "[env name not-found]"], :end-row 926, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "resolve-macro-ns-alias", :ns "cljs.analyzer", :row 921} {:fixed-arities #{2}, :end-row 941, :ns "cljs.analyzer", :name "confirm-ns", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env ns-sym]"], :doc "Given env, an analysis environment, and ns-sym, a symbol identifying a\n   namespace, confirm that the namespace exists. Warn if not found.", :row 928} {:fixed-arities #{2}, :end-row 952, :ns "cljs.analyzer", :name "core-name?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Is sym visible from core in the current compilation namespace?", :row 943} {:fixed-arities #{2}, :end-row 963, :ns "cljs.analyzer", :name "public-name?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns sym]"], :doc "Is sym public?", :row 954} {:arglist-strs ["[x]"], :end-row 968, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "js-tag?", :ns "cljs.analyzer", :row 965} {:arglist-strs ["[x]"], :end-row 977, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "normalize-js-tag", :ns "cljs.analyzer", :row 970} {:fixed-arities #{1}, :end-row 985, :ns "cljs.analyzer", :name "->type-set", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[t]"], :doc "Ensures that a type tag is a set.", :row 979} {:arglist-strs ["[t]"], :end-row 999, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "canonicalize-type", :ns "cljs.analyzer", :row 987} {:fixed-arities #{0 1 2}, :end-row 1012, :ns "cljs.analyzer", :name "add-types", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[]" "[t1]" "[t1 t2]" "[t1 t2 & ts]"], :doc "Produces a union of types.", :row 1001} {:end-row 1021, :filename "cljs/analyzer.cljc", :lang :cljs, :name "alias->type", :ns "cljs.analyzer", :row 1014} {:arglist-strs ["[pre externs]" "[pre externs top]"], :end-row 1047, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "has-extern?*", :ns "cljs.analyzer", :row 1023} {:arglist-strs ["[pre]" "[pre externs]"], :end-row 1058, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "has-extern?", :ns "cljs.analyzer", :row 1049} {:arglist-strs ["[pre]" "[pre tag-type]" "[pre tag-type externs]" "[pre tag-type externs top]"], :end-row 1073, :filename "cljs/analyzer.cljc", :fixed-arities #{1 4 3 2}, :lang :cljs, :name "js-tag", :ns "cljs.analyzer", :row 1060} {:arglist-strs ["[sym]"], :end-row 1080, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "dotted-symbol?", :ns "cljs.analyzer", :row 1075} {:arglist-strs ["[name]"], :end-row 1084, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "munge-node-lib", :ns "cljs.analyzer", :row 1082} {:arglist-strs ["[name]" "[ns name]"], :end-row 1090, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "munge-goog-module-lib", :ns "cljs.analyzer", :row 1086} {:arglist-strs ["[name]"], :end-row 1094, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "munge-global-export", :ns "cljs.analyzer", :row 1092} {:fixed-arities #{2}, :end-row 1109, :ns "cljs.analyzer", :name "resolve-alias", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns sym]"], :doc "Takes a namespace and an unqualified symbol and potentially returns a new\n  symbol to be used in lieu of the original.", :row 1096} {:arglist-strs ["[ns]"], :end-row 1116, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "ns->module-type", :ns "cljs.analyzer", :row 1111} {:end-row 1118, :filename "cljs/analyzer.cljc", :lang :cljs, :name "resolve*", :ns "cljs.analyzer", :row 1118} {:arglist-strs ["[sym current-ns]"], :end-row 1131, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "extern-pre", :ns "cljs.analyzer", :row 1126} {:arglist-strs ["[]" "[opts]"], :end-row 1138, :filename "cljs/analyzer.cljc", :fixed-arities #{0 1}, :lang :cljs, :name "node-like?", :ns "cljs.analyzer", :row 1133} {:doc "Specially-treated symbols for which we don't trigger :private-var-access warnings.", :end-row 1175, :filename "cljs/analyzer.cljc", :lang :cljs, :name "private-var-access-exceptions", :ns "cljs.analyzer", :private true, :row 1170} {:arglist-strs ["[ns env]"], :end-row 1194, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "required?", :ns "cljs.analyzer", :row 1192} {:fixed-arities #{2}, :end-row 1204, :ns "cljs.analyzer", :name "invokeable-ns?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns env]"], :doc "Returns true if ns is a required namespace and a JavaScript module that\n   might be invokeable as a function.", :row 1196} {:arglist-strs ["[ns current-ns env]"], :end-row 1222, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "resolve-invokeable-ns", :ns "cljs.analyzer", :row 1206} {:fixed-arities #{2}, :end-row 1231, :ns "cljs.analyzer", :name "resolve-import", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env import]"], :doc "goog.modules are deterministically assigned to a property of the namespace,\n   we cannot expect the reference will be globally available, so we resolve to\n   namespace local reference.", :row 1224} {:arglist-strs ["[sym lb]"], :end-row 1241, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "handle-symbol-local", :ns "cljs.analyzer", :row 1238} {:fixed-arities #{4 3 2}, :end-row 1359, :ns "cljs.analyzer", :name "resolve-var", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]" "[env sym confirm]" "[env sym confirm default?]"], :doc "Resolve a var. Accepts a side-effecting confirm fn for producing\n   warnings about unresolved vars.", :row 1243} {:fixed-arities #{2}, :end-row 1367, :ns "cljs.analyzer", :name "resolve-existing-var", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Given env, an analysis environment, and sym, a symbol, resolve an existing var.\n   Emits a warning if no such var exists.", :row 1361} {:fixed-arities #{2}, :end-row 1377, :ns "cljs.analyzer", :name "confirm-bindings", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env names]"], :doc "Given env, an analysis environment env, and names, a list of symbols, confirm\n   that all correspond to declared dynamic vars.", :row 1369} {:fixed-arities #{2}, :end-row 1412, :ns "cljs.analyzer", :name "resolve-macro-var", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Given env, an analysis environment, and sym, a symbol, resolve a macro.", :row 1379} {:end-row 1414, :filename "cljs/analyzer.cljc", :lang :cljs, :name "analyze", :ns "cljs.analyzer", :row 1414} {:end-row 1414, :filename "cljs/analyzer.cljc", :lang :cljs, :name "analyze-symbol", :ns "cljs.analyzer", :row 1414} {:end-row 1414, :filename "cljs/analyzer.cljc", :lang :cljs, :name "analyze-seq", :ns "cljs.analyzer", :row 1414} {:end-row 1419, :filename "cljs/analyzer.cljc", :lang :cljs, :name "specials", :ns "cljs.analyzer", :row 1418} {:end-row 1421, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*recur-frames*", :ns "cljs.analyzer", :row 1421} {:end-row 1422, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*loop-lets*", :ns "cljs.analyzer", :row 1422} {:end-row 1423, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*allow-redef*", :ns "cljs.analyzer", :row 1423} {:end-row 1424, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*allow-ns*", :ns "cljs.analyzer", :row 1424} {:arglist-strs ["[env sym]"], :end-row 1442, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-keyword", :ns "cljs.analyzer", :row 1439} {:arglist-strs ["[ast]"], :end-row 1449, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "get-tag", :ns "cljs.analyzer", :row 1444} {:arglist-strs ["[fn-ast params]"], :end-row 1460, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "find-matching-method", :ns "cljs.analyzer", :row 1451} {:arglist-strs ["[env t]"], :end-row 1475, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "type?", :ns "cljs.analyzer", :row 1462} {:end-row 1477, :filename "cljs/analyzer.cljc", :lang :cljs, :name "infer-tag", :ns "cljs.analyzer", :row 1477} {:arglist-strs ["[{:keys [op] :as ast}]"], :end-row 1483, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "unwrap-quote", :ns "cljs.analyzer", :row 1479} {:arglist-strs ["[env ast]"], :end-row 1515, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "infer-if", :ns "cljs.analyzer", :row 1485} {:arglist-strs ["[ast]"], :end-row 1518, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "js-var?", :ns "cljs.analyzer", :row 1517} {:arglist-strs ["[fn-ast]"], :end-row 1521, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "js-var-fn?", :ns "cljs.analyzer", :row 1520} {:arglist-strs ["[{:keys [info] :as fn-ast}]"], :end-row 1534, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "fn-ast->tag", :ns "cljs.analyzer", :row 1523} {:arglist-strs ["[env {fn-ast :fn :keys [args] :as ast}]"], :end-row 1543, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "infer-invoke", :ns "cljs.analyzer", :row 1536} {:fixed-arities #{2}, :end-row 1573, :ns "cljs.analyzer", :name "infer-tag", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env ast]"], :doc "Given env, an analysis environment, and e, an AST node, return the inferred\n   type of the node", :row 1545} {:end-row 1575, :filename "cljs/analyzer.cljc", :lang :cljs, :name "parse", :ns "cljs.analyzer", :row 1575} {:arglist-strs ["[var]" "[var expr-env]"], :end-row 1600, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "var-meta", :ns "cljs.analyzer", :row 1577} {:arglist-strs ["[env sym]"], :end-row 1613, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "var-ast", :ns "cljs.analyzer", :row 1602} {:end-row 1690, :filename "cljs/analyzer.cljc", :lang :cljs, :name "predicate->tag", :ns "cljs.analyzer", :private true, :row 1628} {:fixed-arities #{2}, :end-row 1705, :private true, :ns "cljs.analyzer", :name "simple-predicate-induced-tag", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Look for a predicate-induced tag when the test expression is a simple\n   application of a predicate to a local, as in (string? x).", :row 1692} {:end-row 1707, :filename "cljs/analyzer.cljc", :lang :cljs, :name "specials", :ns "cljs.analyzer", :row 1707} {:fixed-arities #{2}, :end-row 1727, :private true, :ns "cljs.analyzer", :name "type-check-induced-tag", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Look for a type-check-induced tag when the test expression is the use of\n  instance? on a local, as in (instance? UUID x) or implements? on a local, as\n  in (implements? ICounted x).", :row 1709} {:fixed-arities #{2}, :end-row 1739, :private true, :ns "cljs.analyzer", :name "truth-induced-tag", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Refine a tag to exclude clj-nil if the test is a local.", :row 1729} {:fixed-arities #{2}, :end-row 1750, :private true, :ns "cljs.analyzer", :name "set-test-induced-tags", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Looks at the test and sets any tags which are induced by virtue\n  of the test being truthy. For example in (if (string? x) x :bar)\n  the local x in the then branch must be of string type.", :row 1741} {:arglist-strs ["[x]"], :end-row 1887, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "valid-proto", :ns "cljs.analyzer", :row 1886} {:arglist-strs ["[env ast opts]"], :end-row 1890, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "elide-env", :ns "cljs.analyzer", :row 1889} {:arglist-strs ["[new-env]"], :end-row 1894, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "replace-env-pass", :ns "cljs.analyzer", :row 1892} {:arglist-strs ["[ast]"], :end-row 1902, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "ast-children", :ns "cljs.analyzer", :row 1896} {:arglist-strs ["[{:keys [op] :as ast}]"], :end-row 1908, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "constant-value?", :ns "cljs.analyzer", :row 1904} {:arglist-strs ["[{:keys [op] :as e}]"], :end-row 1917, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "const-expr->constant-value", :ns "cljs.analyzer", :row 1910} {:fixed-arities #{1}, :end-row 1923, :private true, :ns "cljs.analyzer", :name "earmuffed?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym]"], :row 1919} {:fixed-arities #{1}, :end-row 1929, :private true, :ns "cljs.analyzer", :name "core-ns?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns-sym]"], :row 1925} {:arglist-strs ["[env]"], :end-row 2143, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "analyze-fn-method-param", :ns "cljs.analyzer", :row 2117} {:arglist-strs ["[env form recur-frames]"], :end-row 2147, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "analyze-fn-method-body", :ns "cljs.analyzer", :row 2145} {:fixed-arities #{5}, :end-row 2183, :private true, :ns "cljs.analyzer", :name "analyze-fn-method", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env locals form type analyze-body?]"], :row 2149} {:end-row 2185, :filename "cljs/analyzer.cljc", :lang :cljs, :name "analyze-wrap-meta", :ns "cljs.analyzer", :row 2185} {:arglist-strs ["[env locals name]"], :end-row 2203, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "fn-name-var", :ns "cljs.analyzer", :row 2187} {:arglist-strs ["[menv locals type meths]"], :end-row 2206, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze-fn-methods-pass2*", :ns "cljs.analyzer", :row 2205} {:arglist-strs ["[menv locals type meths]"], :end-row 2209, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze-fn-methods-pass2", :ns "cljs.analyzer", :row 2208} {:arglist-strs ["[env exprs]"], :end-row 2349, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-do-statements*", :ns "cljs.analyzer", :row 2348} {:arglist-strs ["[env exprs]"], :end-row 2352, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-do-statements", :ns "cljs.analyzer", :row 2351} {:arglist-strs ["[env init loop-lets]"], :end-row 2379, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "analyze-let-binding-init", :ns "cljs.analyzer", :row 2377} {:arglist-strs ["[name init-expr]"], :end-row 2386, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-let-tag", :ns "cljs.analyzer", :row 2381} {:arglist-strs ["[encl-env bindings op]"], :end-row 2432, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "analyze-let-bindings*", :ns "cljs.analyzer", :row 2388} {:arglist-strs ["[encl-env bindings op]"], :end-row 2435, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "analyze-let-bindings", :ns "cljs.analyzer", :row 2434} {:arglist-strs ["[env context exprs]"], :end-row 2438, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "analyze-let-body*", :ns "cljs.analyzer", :row 2437} {:arglist-strs ["[env context exprs recur-frames loop-lets]"], :end-row 2443, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :cljs, :name "analyze-let-body", :ns "cljs.analyzer", :row 2440} {:arglist-strs ["[encl-env [_ bindings & exprs :as form] is-loop widened-tags]"], :end-row 2495, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze-let", :ns "cljs.analyzer", :row 2445} {:arglist-strs ["[env form]"], :end-row 2545, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-const", :ns "cljs.analyzer", :row 2536} {:end-row 2565, :filename "cljs/analyzer.cljc", :lang :cljs, :name "js-prim-ctor->tag", :ns "cljs.analyzer", :row 2559} {:fixed-arities #{1}, :end-row 2570, :ns "cljs.analyzer", :name "prim-ctor?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[t]"], :doc "Test whether a tag is a constructor for a JS primitive", :row 2567} {:arglist-strs ["[dep]"], :end-row 2701, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "foreign-dep?", :ns "cljs.analyzer", :row 2695} {:fixed-arities #{4 3}, :end-row 2740, :ns "cljs.analyzer", :name "analyze-deps", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[lib deps env]" "[lib deps env opts]"], :doc "Given a lib, a namespace, deps, its dependencies, env, an analysis environment\n   and opts, compiler options - analyze all of the dependencies. Required to\n   correctly analyze usage of other namespaces.", :row 2703} {:arglist-strs ["[lib sym cenv]"], :end-row 2748, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "missing-use?", :ns "cljs.analyzer", :row 2742} {:arglist-strs ["[sym cenv]"], :end-row 2753, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "missing-rename?", :ns "cljs.analyzer", :row 2750} {:arglist-strs ["[lib sym]"], :end-row 2759, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "missing-use-macro?", :ns "cljs.analyzer", :row 2755} {:arglist-strs ["[sym]"], :end-row 2765, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "missing-rename-macro?", :ns "cljs.analyzer", :row 2761} {:arglist-strs ["[uses env]"], :end-row 2771, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "missing-uses", :ns "cljs.analyzer", :row 2768} {:arglist-strs ["[renames env]"], :end-row 2776, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "missing-renames", :ns "cljs.analyzer", :row 2774} {:arglist-strs ["[use-macros env]"], :end-row 2781, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "missing-use-macros", :ns "cljs.analyzer", :row 2779} {:arglist-strs ["[use-macros env]"], :end-row 2786, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "inferred-use-macros", :ns "cljs.analyzer", :row 2784} {:arglist-strs ["[rename-macros env]"], :end-row 2790, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "inferred-rename-macros", :ns "cljs.analyzer", :row 2789} {:arglist-strs ["[uses env]"], :end-row 2798, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "check-uses", :ns "cljs.analyzer", :row 2792} {:arglist-strs ["[use-macros env]" "[use-macros missing-uses env]"], :end-row 2811, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "check-use-macros", :ns "cljs.analyzer", :row 2800} {:arglist-strs ["[{:keys [name uses use-macros] :as ast} env]"], :end-row 2829, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "check-use-macros-inferring-missing", :ns "cljs.analyzer", :row 2813} {:arglist-strs ["[{:keys [name renames] :as ast} env]"], :end-row 2848, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "check-rename-macros-inferring-missing", :ns "cljs.analyzer", :row 2831} {:arglist-strs ["[spec msg]"], :end-row 2851, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "parse-ns-error-msg", :ns "cljs.analyzer", :row 2850} {:arglist-strs ["[env macros? spec]"], :end-row 2881, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "basic-validate-ns-spec", :ns "cljs.analyzer", :row 2853} {:arglist-strs ["[env args]"], :end-row 2921, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "parse-ns-excludes", :ns "cljs.analyzer", :row 2883} {:arglist-strs ["[env [lib & filters :as spec]]"], :end-row 2955, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "use->require", :ns "cljs.analyzer", :row 2923} {:arglist-strs ["[env macros? deps aliases spec]"], :end-row 3011, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :cljs, :name "parse-require-spec", :ns "cljs.analyzer", :row 2957} {:arglist-strs ["[env deps spec]"], :end-row 3031, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "parse-import-spec", :ns "cljs.analyzer", :row 3013} {:fixed-arities #{1}, :end-row 3048, :ns "cljs.analyzer", :name "macro-autoload-ns?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[form]"], :doc "Given a spec form check whether the spec namespace requires a macro file\n   of the same name. If so return true.", :row 3035} {:fixed-arities #{1}, :end-row 3057, :ns "cljs.analyzer", :name "clj-ns->cljs-ns", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym]"], :doc "Given a symbol that starts with clojure as the first segment return the\n   same symbol with the first segment replaced with cljs", :row 3050} {:arglist-strs ["[specs]"], :end-row 3097, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "canonicalize-specs", :ns "cljs.analyzer", :row 3091} {:arglist-strs ["[specs]"], :end-row 3104, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "canonicalize-import-specs", :ns "cljs.analyzer", :row 3099} {:fixed-arities #{1}, :end-row 3155, :ns "cljs.analyzer", :name "desugar-ns-specs", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[args]"], :doc "Given an original set of ns specs desugar :include-macros and :refer-macros\n   usage into only primitive spec forms - :use, :require, :use-macros,\n   :require-macros. If a library includes a macro file of with the same name\n   as the namespace will also be desugared.", :row 3106} {:arglist-strs ["[env ns segments]"], :end-row 3166, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "find-def-clash", :ns "cljs.analyzer", :row 3157} {:arglist-strs ["[name]"], :end-row 3173, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "macro-ns-name", :ns "cljs.analyzer", :row 3168} {:fixed-arities #{3}, :end-row 3189, :private true, :ns "cljs.analyzer", :name "check-duplicate-aliases", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env old new]"], :row 3175} {:fixed-arities #{3}, :end-row 3205, :private true, :ns "cljs.analyzer", :name "merge-ns-info", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[old new env]"], :row 3191} {:arglist-strs ["[op env [_ tsym fields pmasks body :as form]]"], :end-row 3434, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "parse-type", :ns "cljs.analyzer", :row 3399} {:fixed-arities #{1}, :end-row 3446, :private true, :ns "cljs.analyzer", :name "property-symbol?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[%1]"], :row 3446} {:fixed-arities #{1}, :end-row 3457, :private true, :ns "cljs.analyzer", :name "classify-dot-form", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[[target member args]]"], :row 3448} {:end-row 3459, :filename "cljs/analyzer.cljc", :lang :cljs, :name "build-dot-form", :ns "cljs.analyzer", :row 3459} {:fixed-arities #{3}, :end-row 3480, :private true, :ns "cljs.analyzer", :name "build-method-call", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[target meth args]"], :doc "Builds the intermediate method call map used to reason about the parsed form during\n  compilation.", :row 3474} {:arglist-strs ["[env target field member+ form]"], :end-row 3572, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :cljs, :name "analyze-dot", :ns "cljs.analyzer", :row 3511} {:arglist-strs ["[form]"], :end-row 3583, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "get-js-tag", :ns "cljs.analyzer", :row 3578} {:arglist-strs ["[env s]"], :end-row 3595, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "js-star-interp", :ns "cljs.analyzer", :row 3585} {:arglist-strs ["[s]"], :end-row 3605, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "js-star-seg", :ns "cljs.analyzer", :row 3597} {:end-row 3607, :filename "cljs/analyzer.cljc", :lang :cljs, :name "NUMERIC_SET", :ns "cljs.analyzer", :row 3607} {:arglist-strs ["[t]"], :end-row 3629, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "numeric-type?", :ns "cljs.analyzer", :row 3609} {:end-row 3632, :filename "cljs/analyzer.cljc", :lang :cljs, :name "array-types", :ns "cljs.analyzer", :row 3631} {:arglist-strs ["[t]"], :end-row 3650, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "array-type?", :ns "cljs.analyzer", :row 3634} {:fixed-arities #{3}, :end-row 3660, :private true, :ns "cljs.analyzer", :name "analyze-js-star-args", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[js-op env args]"], :row 3652} {:arglist-strs ["[env jsform args form]"], :end-row 3689, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze-js-star*", :ns "cljs.analyzer", :row 3662} {:arglist-strs ["[env jsform args form]"], :end-row 3692, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze-js-star", :ns "cljs.analyzer", :row 3691} {:fixed-arities #{1}, :end-row 3718, :private true, :ns "cljs.analyzer", :name "unsorted-map?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :row 3716} {:fixed-arities #{1}, :end-row 3726, :ns "cljs.analyzer", :name "analyzed", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :doc "Mark a form as being analyzed. Assumes x satisfies IMeta. Useful to suppress\n  warnings that will have been caught by a first compiler pass.", :row 3720} {:fixed-arities #{1}, :end-row 3735, :ns "cljs.analyzer", :name "analyzed?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :doc "Returns boolean if the form has already been marked as analyzed.", :row 3728} {:fixed-arities #{1}, :end-row 3740, :private true, :ns "cljs.analyzer", :name "all-values?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[exprs]"], :row 3737} {:fixed-arities #{2}, :end-row 3746, :private true, :ns "cljs.analyzer", :name "valid-arity?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[argc method-params]"], :row 3742} {:fixed-arities #{1}, :end-row 3752, :private true, :ns "cljs.analyzer", :name "record-tag?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[tag]"], :row 3748} {:fixed-arities #{1}, :end-row 3758, :private true, :ns "cljs.analyzer", :name "record-basis", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[tag]"], :row 3754} {:fixed-arities #{2}, :end-row 3763, :private true, :ns "cljs.analyzer", :name "record-with-field?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[tag field]"], :row 3760} {:fixed-arities #{4}, :end-row 3768, :private true, :ns "cljs.analyzer", :name "invalid-arity?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[argc method-params variadic max-fixed-arity]"], :row 3765} {:arglist-strs ["[env [f & args :as form]]"], :end-row 3832, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "parse-invoke*", :ns "cljs.analyzer", :row 3770} {:arglist-strs ["[env form]"], :end-row 3836, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "parse-invoke", :ns "cljs.analyzer", :row 3834} {:arglist-strs ["[{:keys [op] :as expr}]"], :end-row 3862, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "desugar-dotted-expr", :ns "cljs.analyzer", :row 3838} {:fixed-arities #{2}, :end-row 3913, :ns "cljs.analyzer", :name "analyze-symbol", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Finds the var associated with sym", :row 3865} {:arglist-strs ["[env sym]"], :end-row 3919, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "excluded?", :ns "cljs.analyzer", :row 3915} {:arglist-strs ["[env sym]"], :end-row 3925, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "used?", :ns "cljs.analyzer", :row 3921} {:arglist-strs ["[env nstr]"], :end-row 3940, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-expander-ns", :ns "cljs.analyzer", :row 3927} {:arglist-strs ["[sym env]"], :end-row 3965, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-expander*", :ns "cljs.analyzer", :row 3942} {:fixed-arities #{2}, :end-row 3975, :ns "cljs.analyzer", :name "get-expander", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym env]"], :doc "Given a sym, a symbol identifying a macro, and env, an analysis environment\n   return the corresponding Clojure macroexpander.", :row 3967} {:arglist-strs ["[]"], :end-row 3981, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :cljs, :name "get-macroexpand-check-var", :ns "cljs.analyzer", :row 3979} {:fixed-arities #{1}, :end-row 3985, :private true, :ns "cljs.analyzer", :name "var->sym", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[var]"], :row 3983} {:fixed-arities #{3}, :end-row 3997, :private true, :ns "cljs.analyzer", :name "do-macroexpand-check", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env form mac-var]"], :row 3987} {:fixed-arities #{2}, :end-row 4008, :private true, :ns "cljs.analyzer", :name "check-macro-arity", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[mac-var form]"], :row 4000} {:arglist-strs ["[env form]"], :end-row 4068, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "macroexpand-1*", :ns "cljs.analyzer", :row 4010} {:fixed-arities #{2}, :end-row 4074, :ns "cljs.analyzer", :name "macroexpand-1", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env form]"], :doc "Given a env, an analysis environment, and form, a ClojureScript form,\n   macroexpand the form once.", :row 4070} {:end-row 4076, :filename "cljs/analyzer.cljc", :lang :cljs, :name "analyze-list", :ns "cljs.analyzer", :row 4076} {:arglist-strs ["[op env form name opts]"], :end-row 4081, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :cljs, :name "analyze-seq*", :ns "cljs.analyzer", :row 4078} {:arglist-strs ["[op env form name opts]"], :end-row 4085, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :cljs, :name "analyze-seq*-wrap", :ns "cljs.analyzer", :row 4083} {:arglist-strs ["[env form name]" "[env form name opts]"], :end-row 4110, :filename "cljs/analyzer.cljc", :fixed-arities #{4 3}, :lang :cljs, :name "analyze-seq", :ns "cljs.analyzer", :row 4087} {:arglist-strs ["[env form]"], :end-row 4120, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-map", :ns "cljs.analyzer", :row 4112} {:arglist-strs ["[env form]"], :end-row 4128, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-list", :ns "cljs.analyzer", :row 4124} {:arglist-strs ["[env form]"], :end-row 4134, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-vector", :ns "cljs.analyzer", :row 4130} {:arglist-strs ["[env form]"], :end-row 4140, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-set", :ns "cljs.analyzer", :row 4136} {:arglist-strs ["[env form]"], :end-row 4164, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-js-value", :ns "cljs.analyzer", :row 4142} {:arglist-strs ["[x]"], :end-row 4172, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "record-ns+name", :ns "cljs.analyzer", :row 4166} {:arglist-strs ["[env x]"], :end-row 4184, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-record", :ns "cljs.analyzer", :row 4174} {:arglist-strs ["[m]"], :end-row 4187, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "elide-reader-meta", :ns "cljs.analyzer", :row 4186} {:arglist-strs ["[m]"], :end-row 4190, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "elide-analyzer-meta", :ns "cljs.analyzer", :row 4189} {:arglist-strs ["[m]"], :end-row 4193, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "elide-irrelevant-meta", :ns "cljs.analyzer", :row 4192} {:arglist-strs ["[expr]"], :end-row 4204, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "analyze-wrap-meta", :ns "cljs.analyzer", :row 4195} {:arglist-strs ["[env {:keys [tag] :as ast} _]"], :end-row 4217, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "infer-type", :ns "cljs.analyzer", :row 4206} {:fixed-arities #{2}, :end-row 4220, :private true, :ns "cljs.analyzer", :name "repl-self-require?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env deps]"], :row 4219} {:end-row 4277, :filename "cljs/analyzer.cljc", :lang :cljs, :name "invoke-arg-type-validators", :ns "cljs.analyzer", :row 4267} {:arglist-strs ["[env {:keys [op] :as ast} opts]"], :end-row 4290, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "check-invoke-arg-types", :ns "cljs.analyzer", :row 4279} {:arglist-strs ["[env form name opts]"], :end-row 4335, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze-form", :ns "cljs.analyzer", :row 4316} {:end-row 4339, :filename "cljs/analyzer.cljc", :lang :cljs, :name "default-passes", :ns "cljs.analyzer", :row 4337} {:arglist-strs ["[env form name opts]"], :end-row 4350, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze*", :ns "cljs.analyzer", :row 4341} {:fixed-arities #{4 3 2}, :end-row 4369, :ns "cljs.analyzer", :name "analyze", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env form]" "[env form name]" "[env form name opts]"], :doc "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n  (one of :statement, :expr, :return), :ns (a symbol naming the\n  compilation ns)}, and form, returns an expression object (a map\n  containing at least :form, :op and :env keys). If expr has any (immediately)\n  nested exprs, must have a :children entry. This must be a vector of keywords naming\n  the immediately nested fields mapped to an expr or vector of exprs. This will\n  facilitate code walking without knowing the details of the op set.", :row 4352} {:fixed-arities #{2}, :end-row 4384, :ns "cljs.analyzer", :name "add-consts", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[compiler-state constants-map]"], :doc "Given a compiler state and a map from fully qualified symbols to constant\n  EDN values, update the compiler state marking these vars as const to support\n  direct substitution of these vars in source.", :row 4371} {:arglist-strs ["[sym]"], :end-row 4400, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "resolve-symbol", :ns "cljs.analyzer", :row 4394} {:fixed-arities #{1}, :end-row 4407, :ns "cljs.analyzer", :name "get-aliases", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Get all alias maps for a namespace.", :row 4402} {:fixed-arities #{0}, :end-row 4717, :private true, :ns "cljs.analyzer", :name "get-spec-vars", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :row 4714} {:fixed-arities #{1}, :end-row 4739, :ns "cljs.analyzer", :name "dump-specs", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Dumps registered speced vars for a given namespace into the compiler\n  environment.", :row 4719} {:fixed-arities #{1}, :end-row 4754, :ns "cljs.analyzer", :name "register-specs", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[cached-ns]"], :doc "Registers speced vars found in a namespace analysis cache.", :row 4741} {:arglist-strs ["[forms]" "[forms opts]" "[forms opts return-last?]"], :end-row 4829, :filename "cljs/analyzer.cljc", :fixed-arities #{1 3 2}, :lang :cljs, :name "analyze-form-seq", :ns "cljs.analyzer", :row 4804} {:fixed-arities #{1}, :end-row 4835, :ns "cljs.analyzer", :name "ensure-defs", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Ensures that a non-nil defs map exists in the compiler state for a given\n  ns. (A non-nil defs map signifies that the namespace has been analyzed.)", :row 4831}]} {:end-row 46, :filename "cljs/analyzer.cljc", :lang :cljs, :name "cljs.analyzer", :row 9, :ns nil, :var-definitions [{:end-row 51, :filename "cljs/analyzer.cljc", :lang :clj, :name "*unchecked-if*", :ns "cljs.analyzer", :row 51} {:end-row 52, :filename "cljs/analyzer.cljc", :lang :clj, :name "*unchecked-arrays*", :ns "cljs.analyzer", :row 52} {:end-row 55, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-ns*", :ns "cljs.analyzer", :row 55} {:end-row 56, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-file*", :ns "cljs.analyzer", :row 56} {:end-row 57, :filename "cljs/analyzer.cljc", :lang :clj, :name "*checked-arrays*", :ns "cljs.analyzer", :row 57} {:end-row 58, :filename "cljs/analyzer.cljc", :lang :clj, :name "*check-alias-dupes*", :ns "cljs.analyzer", :row 58} {:end-row 59, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-static-fns*", :ns "cljs.analyzer", :row 59} {:end-row 60, :filename "cljs/analyzer.cljc", :lang :clj, :name "*fn-invoke-direct*", :ns "cljs.analyzer", :row 60} {:end-row 61, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-macros-path*", :ns "cljs.analyzer", :row 61} {:end-row 62, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-macros-is-classpath*", :ns "cljs.analyzer", :row 62} {:end-row 63, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-dep-set*", :ns "cljs.analyzer", :row 63} {:end-row 64, :filename "cljs/analyzer.cljc", :lang :clj, :name "*analyze-deps*", :ns "cljs.analyzer", :row 64} {:end-row 65, :filename "cljs/analyzer.cljc", :lang :clj, :name "*load-tests*", :ns "cljs.analyzer", :row 65} {:end-row 66, :filename "cljs/analyzer.cljc", :lang :clj, :name "*load-macros*", :ns "cljs.analyzer", :row 66} {:end-row 67, :filename "cljs/analyzer.cljc", :lang :clj, :name "*reload-macros*", :ns "cljs.analyzer", :row 67} {:end-row 68, :filename "cljs/analyzer.cljc", :lang :clj, :name "*macro-infer*", :ns "cljs.analyzer", :row 68} {:end-row 69, :filename "cljs/analyzer.cljc", :lang :clj, :name "*passes*", :ns "cljs.analyzer", :row 69} {:end-row 70, :filename "cljs/analyzer.cljc", :lang :clj, :name "*file-defs*", :ns "cljs.analyzer", :row 70} {:end-row 71, :filename "cljs/analyzer.cljc", :lang :clj, :name "*private-var-access-nowarn*", :ns "cljs.analyzer", :row 71} {:doc "The namespace of the constants table as a symbol.", :end-row 75, :filename "cljs/analyzer.cljc", :lang :clj, :name "constants-ns-sym", :ns "cljs.analyzer", :row 73} {:end-row 89, :filename "cljs/analyzer.cljc", :lang :clj, :name "transit-read-opts", :ns "cljs.analyzer", :row 78} {:end-row 109, :filename "cljs/analyzer.cljc", :lang :clj, :name "transit-write-opts", :ns "cljs.analyzer", :row 92} {:end-row 122, :filename "cljs/analyzer.cljc", :lang :clj, :name "transit", :ns "cljs.analyzer", :row 112} {:end-row 125, :filename "cljs/analyzer.cljc", :lang :clj, :name "*verbose*", :ns "cljs.analyzer", :row 125} {:end-row 127, :filename "cljs/analyzer.cljc", :lang :clj, :name "-cljs-macros-loaded", :ns "cljs.analyzer", :row 127} {:end-row 168, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-warnings*", :ns "cljs.analyzer", :row 129} {:arglist-strs ["[]"], :end-row 171, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :clj, :name "unchecked-arrays?", :ns "cljs.analyzer", :row 170} {:arglist-strs ["[]"], :end-row 174, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :clj, :name "compiler-options", :ns "cljs.analyzer", :row 173} {:arglist-strs ["[]"], :end-row 177, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :clj, :name "get-externs", :ns "cljs.analyzer", :row 176} {:fixed-arities #{0}, :end-row 185, :ns "cljs.analyzer", :name "checked-arrays", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :doc "Returns false-y, :warn, or :error based on configuration and the\n   current value of *unchecked-arrays*.", :row 179} {:end-row 200, :filename "cljs/analyzer.cljc", :lang :clj, :name "js-reserved", :ns "cljs.analyzer", :row 187} {:end-row 203, :filename "cljs/analyzer.cljc", :lang :clj, :name "es5-allowed", :ns "cljs.analyzer", :row 202} {:end-row 205, :filename "cljs/analyzer.cljc", :lang :clj, :name "SENTINEL", :ns "cljs.analyzer", :row 205} {:arglist-strs ["[m k0 k1]" "[m k0 k1 k2]" "[m k0 k1 k2 k3]"], :end-row 226, :filename "cljs/analyzer.cljc", :fixed-arities #{4 3 5}, :lang :clj, :name "gets", :ns "cljs.analyzer", :row 208} {:end-row 254, :filename "cljs/analyzer.cljc", :lang :clj, :name "message", :ns "cljs.analyzer", :row 254} {:end-row 254, :filename "cljs/analyzer.cljc", :lang :clj, :name "namespaces", :ns "cljs.analyzer", :row 254} {:arglist-strs ["[x]"], :end-row 259, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "ast?", :ns "cljs.analyzer", :row 256} {:end-row 261, :filename "cljs/analyzer.cljc", :lang :clj, :name "error-message", :ns "cljs.analyzer", :row 261} {:arglist-strs ["[warning-type env extra]"], :end-row 485, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "default-warning-handler", :ns "cljs.analyzer", :row 479} {:end-row 488, :filename "cljs/analyzer.cljc", :lang :clj, :name "*cljs-warning-handlers*", :ns "cljs.analyzer", :row 487} {:arglist-strs ["[handlers & body]"], :end-row 493, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "with-warning-handlers", :ns "cljs.analyzer", :row 491} {:fixed-arities #{2}, :end-row 499, :private true, :ns "cljs.analyzer", :name "repeat-char", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[c n]"], :row 495} {:fixed-arities #{2}, :end-row 508, :private true, :ns "cljs.analyzer", :name "hex-format", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[s pad]"], :row 501} {:arglist-strs ["[value]"], :end-row 528, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "gen-constant-id", :ns "cljs.analyzer", :row 510} {:fixed-arities #{1 2}, :end-row 548, :private true, :ns "cljs.analyzer", :name "register-constant!", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[val]" "[env val]"], :row 530} {:end-row 551, :filename "cljs/analyzer.cljc", :lang :clj, :name "default-namespaces", :ns "cljs.analyzer", :row 550} {:end-row 570, :filename "cljs/analyzer.cljc", :lang :clj, :name "namespaces", :ns "cljs.analyzer", :row 558} {:arglist-strs ["[key]" "[cenv key]"], :end-row 579, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :clj, :name "get-namespace", :ns "cljs.analyzer", :row 572} {:arglist-strs ["[& body]"], :end-row 585, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "no-warn", :ns "cljs.analyzer", :row 582} {:arglist-strs ["[& body]"], :end-row 591, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "all-warn", :ns "cljs.analyzer", :row 588} {:arglist-strs ["[x env]"], :end-row 594, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "get-line", :ns "cljs.analyzer", :row 593} {:arglist-strs ["[x env]"], :end-row 597, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "get-col", :ns "cljs.analyzer", :row 596} {:fixed-arities #{1 2}, :end-row 616, :ns "cljs.analyzer", :name "intern-macros", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]" "[ns reload]"], :doc "Given a Clojure namespace intern all macros into the ambient ClojureScript\n   analysis environment.", :row 599} {:end-row 619, :filename "cljs/analyzer.cljc", :lang :clj, :name "load-mutex", :ns "cljs.analyzer", :row 619} {:fixed-arities #{2}, :end-row 646, :private true, :ns "cljs.analyzer", :name "load-data-reader-file", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[mappings url]"], :row 622} {:fixed-arities #{0 1}, :end-row 656, :ns "cljs.analyzer", :name "get-data-readers*", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]" "[classloader]"], :doc "returns a merged map containing all data readers defined by libraries\n      on the classpath.", :row 649} {:end-row 659, :filename "cljs/analyzer.cljc", :lang :clj, :name "get-data-readers", :ns "cljs.analyzer", :row 659} {:arglist-strs ["[]"], :end-row 675, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :clj, :name "load-data-readers*", :ns "cljs.analyzer", :row 662} {:end-row 678, :filename "cljs/analyzer.cljc", :lang :clj, :name "load-data-readers", :ns "cljs.analyzer", :row 678} {:arglist-strs ["[]"], :end-row 689, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :clj, :name "load-core", :ns "cljs.analyzer", :row 681} {:arglist-strs ["[path & body]"], :end-row 698, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "with-core-macros", :ns "cljs.analyzer", :row 692} {:arglist-strs ["[path & body]"], :end-row 708, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "with-core-macros-file", :ns "cljs.analyzer", :row 701} {:fixed-arities #{0}, :end-row 722, :ns "cljs.analyzer", :name "empty-env", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :doc "Construct an empty analysis environment. Required to analyze forms.", :row 710} {:fixed-arities #{1}, :end-row 728, :private true, :ns "cljs.analyzer", :name "source-info->error-data", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[{:keys [file line column]}]"], :row 724} {:arglist-strs ["[env]" "[name env]"], :end-row 741, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :clj, :name "source-info", :ns "cljs.analyzer", :row 730} {:arglist-strs ["[env s]"], :end-row 748, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "message", :ns "cljs.analyzer", :row 743} {:arglist-strs ["[warning-type env extra]"], :end-row 752, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "warning", :ns "cljs.analyzer", :row 750} {:fixed-arities #{1}, :end-row 757, :private true, :ns "cljs.analyzer", :name "accumulating-warning-handler", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[warn-acc]"], :row 754} {:fixed-arities #{1}, :end-row 760, :private true, :ns "cljs.analyzer", :name "replay-accumulated-warnings", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[warn-acc]"], :row 759} {:fixed-arities #{3 2}, :end-row 769, :private true, :ns "cljs.analyzer", :name "error-data", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env phase]" "[env phase symbol]"], :row 762} {:fixed-arities #{3}, :end-row 774, :private true, :ns "cljs.analyzer", :name "compile-syntax-error", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env msg symbol]"], :row 771} {:arglist-strs ["[env msg]" "[env msg cause]"], :end-row 782, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "error", :ns "cljs.analyzer", :row 776} {:arglist-strs ["[ex]"], :end-row 787, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "analysis-error?", :ns "cljs.analyzer", :row 784} {:arglist-strs ["[ex]"], :end-row 792, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "has-error-data?", :ns "cljs.analyzer", :row 789} {:arglist-strs ["[env & body]"], :end-row 802, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "wrapping-errors", :ns "cljs.analyzer", :row 795} {:end-row 805, :filename "cljs/analyzer.cljc", :lang :clj, :name "implicit-nses", :ns "cljs.analyzer", :row 805} {:arglist-strs ["[env prefix suffix]"], :end-row 810, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "implicit-import?", :ns "cljs.analyzer", :row 807} {:end-row 812, :filename "cljs/analyzer.cljc", :lang :clj, :name "get-expander", :ns "cljs.analyzer", :row 812} {:arglist-strs ["[env prefix suffix]"], :end-row 819, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "confirm-var-exist-warning", :ns "cljs.analyzer", :row 814} {:fixed-arities #{1}, :end-row 827, :ns "cljs.analyzer", :name "lib&sublib", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[lib]"], :doc "If a library name has the form foo$bar, return a vector of the library and\n   the sublibrary property.", :row 821} {:fixed-arities #{2}, :end-row 837, :ns "cljs.analyzer", :name "loaded-js-ns?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env prefix]"], :doc "Check if a JavaScript namespace has been loaded. JavaScript vars are\n  not currently checked.", :row 829} {:fixed-arities #{2}, :end-row 848, :private true, :ns "cljs.analyzer", :name "internal-js-module-exists?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[js-module-index module]"], :row 839} {:end-row 850, :filename "cljs/analyzer.cljc", :lang :clj, :name "js-module-exists?*", :ns "cljs.analyzer", :row 850} {:arglist-strs ["[module]"], :end-row 854, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "js-module-exists?", :ns "cljs.analyzer", :row 852} {:arglist-strs ["[module]"], :end-row 867, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "node-module-dep?", :ns "cljs.analyzer", :row 856} {:arglist-strs ["[module]"], :end-row 874, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "dep-has-global-exports?", :ns "cljs.analyzer", :row 869} {:arglist-strs ["[module]"], :end-row 886, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "goog-module-dep?", :ns "cljs.analyzer", :row 876} {:arglist-strs ["[env prefix suffix]" "[env prefix suffix missing-fn]"], :end-row 906, :filename "cljs/analyzer.cljc", :fixed-arities #{4 3}, :lang :clj, :name "confirm-var-exists", :ns "cljs.analyzer", :row 888} {:arglist-strs ["[]"], :end-row 912, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :clj, :name "confirm-var-exists-throw", :ns "cljs.analyzer", :row 908} {:arglist-strs ["[env name]" "[env name not-found]"], :end-row 919, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "resolve-ns-alias", :ns "cljs.analyzer", :row 914} {:arglist-strs ["[env name]" "[env name not-found]"], :end-row 926, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "resolve-macro-ns-alias", :ns "cljs.analyzer", :row 921} {:fixed-arities #{2}, :end-row 941, :ns "cljs.analyzer", :name "confirm-ns", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env ns-sym]"], :doc "Given env, an analysis environment, and ns-sym, a symbol identifying a\n   namespace, confirm that the namespace exists. Warn if not found.", :row 928} {:fixed-arities #{2}, :end-row 952, :ns "cljs.analyzer", :name "core-name?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Is sym visible from core in the current compilation namespace?", :row 943} {:fixed-arities #{2}, :end-row 963, :ns "cljs.analyzer", :name "public-name?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns sym]"], :doc "Is sym public?", :row 954} {:arglist-strs ["[x]"], :end-row 968, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "js-tag?", :ns "cljs.analyzer", :row 965} {:arglist-strs ["[x]"], :end-row 977, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "normalize-js-tag", :ns "cljs.analyzer", :row 970} {:fixed-arities #{1}, :end-row 985, :ns "cljs.analyzer", :name "->type-set", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[t]"], :doc "Ensures that a type tag is a set.", :row 979} {:arglist-strs ["[t]"], :end-row 999, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "canonicalize-type", :ns "cljs.analyzer", :row 987} {:fixed-arities #{0 1 2}, :end-row 1012, :ns "cljs.analyzer", :name "add-types", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]" "[t1]" "[t1 t2]" "[t1 t2 & ts]"], :doc "Produces a union of types.", :row 1001} {:end-row 1021, :filename "cljs/analyzer.cljc", :lang :clj, :name "alias->type", :ns "cljs.analyzer", :row 1014} {:arglist-strs ["[pre externs]" "[pre externs top]"], :end-row 1047, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "has-extern?*", :ns "cljs.analyzer", :row 1023} {:arglist-strs ["[pre]" "[pre externs]"], :end-row 1058, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :clj, :name "has-extern?", :ns "cljs.analyzer", :row 1049} {:arglist-strs ["[pre]" "[pre tag-type]" "[pre tag-type externs]" "[pre tag-type externs top]"], :end-row 1073, :filename "cljs/analyzer.cljc", :fixed-arities #{1 4 3 2}, :lang :clj, :name "js-tag", :ns "cljs.analyzer", :row 1060} {:arglist-strs ["[sym]"], :end-row 1080, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "dotted-symbol?", :ns "cljs.analyzer", :row 1075} {:arglist-strs ["[name]"], :end-row 1084, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "munge-node-lib", :ns "cljs.analyzer", :row 1082} {:arglist-strs ["[name]" "[ns name]"], :end-row 1090, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :clj, :name "munge-goog-module-lib", :ns "cljs.analyzer", :row 1086} {:arglist-strs ["[name]"], :end-row 1094, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "munge-global-export", :ns "cljs.analyzer", :row 1092} {:fixed-arities #{2}, :end-row 1109, :ns "cljs.analyzer", :name "resolve-alias", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns sym]"], :doc "Takes a namespace and an unqualified symbol and potentially returns a new\n  symbol to be used in lieu of the original.", :row 1096} {:arglist-strs ["[ns]"], :end-row 1116, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "ns->module-type", :ns "cljs.analyzer", :row 1111} {:end-row 1118, :filename "cljs/analyzer.cljc", :lang :clj, :name "resolve*", :ns "cljs.analyzer", :row 1118} {:arglist-strs ["[sym current-ns]"], :end-row 1131, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "extern-pre", :ns "cljs.analyzer", :row 1126} {:arglist-strs ["[]" "[opts]"], :end-row 1138, :filename "cljs/analyzer.cljc", :fixed-arities #{0 1}, :lang :clj, :name "node-like?", :ns "cljs.analyzer", :row 1133} {:doc "Specially-treated symbols for which we don't trigger :private-var-access warnings.", :end-row 1175, :filename "cljs/analyzer.cljc", :lang :clj, :name "private-var-access-exceptions", :ns "cljs.analyzer", :private true, :row 1170} {:arglist-strs ["[ns env]"], :end-row 1194, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "required?", :ns "cljs.analyzer", :row 1192} {:fixed-arities #{2}, :end-row 1204, :ns "cljs.analyzer", :name "invokeable-ns?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns env]"], :doc "Returns true if ns is a required namespace and a JavaScript module that\n   might be invokeable as a function.", :row 1196} {:arglist-strs ["[ns current-ns env]"], :end-row 1222, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "resolve-invokeable-ns", :ns "cljs.analyzer", :row 1206} {:fixed-arities #{2}, :end-row 1231, :ns "cljs.analyzer", :name "resolve-import", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env import]"], :doc "goog.modules are deterministically assigned to a property of the namespace,\n   we cannot expect the reference will be globally available, so we resolve to\n   namespace local reference.", :row 1224} {:arglist-strs ["[sym lb]"], :end-row 1241, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "handle-symbol-local", :ns "cljs.analyzer", :row 1238} {:fixed-arities #{4 3 2}, :end-row 1359, :ns "cljs.analyzer", :name "resolve-var", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]" "[env sym confirm]" "[env sym confirm default?]"], :doc "Resolve a var. Accepts a side-effecting confirm fn for producing\n   warnings about unresolved vars.", :row 1243} {:fixed-arities #{2}, :end-row 1367, :ns "cljs.analyzer", :name "resolve-existing-var", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Given env, an analysis environment, and sym, a symbol, resolve an existing var.\n   Emits a warning if no such var exists.", :row 1361} {:fixed-arities #{2}, :end-row 1377, :ns "cljs.analyzer", :name "confirm-bindings", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env names]"], :doc "Given env, an analysis environment env, and names, a list of symbols, confirm\n   that all correspond to declared dynamic vars.", :row 1369} {:fixed-arities #{2}, :end-row 1412, :ns "cljs.analyzer", :name "resolve-macro-var", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Given env, an analysis environment, and sym, a symbol, resolve a macro.", :row 1379} {:end-row 1414, :filename "cljs/analyzer.cljc", :lang :clj, :name "analyze", :ns "cljs.analyzer", :row 1414} {:end-row 1414, :filename "cljs/analyzer.cljc", :lang :clj, :name "analyze-symbol", :ns "cljs.analyzer", :row 1414} {:end-row 1414, :filename "cljs/analyzer.cljc", :lang :clj, :name "analyze-seq", :ns "cljs.analyzer", :row 1414} {:end-row 1419, :filename "cljs/analyzer.cljc", :lang :clj, :name "specials", :ns "cljs.analyzer", :row 1418} {:end-row 1421, :filename "cljs/analyzer.cljc", :lang :clj, :name "*recur-frames*", :ns "cljs.analyzer", :row 1421} {:end-row 1422, :filename "cljs/analyzer.cljc", :lang :clj, :name "*loop-lets*", :ns "cljs.analyzer", :row 1422} {:end-row 1423, :filename "cljs/analyzer.cljc", :lang :clj, :name "*allow-redef*", :ns "cljs.analyzer", :row 1423} {:end-row 1424, :filename "cljs/analyzer.cljc", :lang :clj, :name "*allow-ns*", :ns "cljs.analyzer", :row 1424} {:arglist-strs ["[& body]"], :end-row 1428, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "disallowing-recur", :ns "cljs.analyzer", :row 1427} {:arglist-strs ["[& body]"], :end-row 1432, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "allowing-redef", :ns "cljs.analyzer", :row 1431} {:arglist-strs ["[& body]"], :end-row 1436, :filename "cljs/analyzer.cljc", :lang :clj, :macro true, :name "disallowing-ns*", :ns "cljs.analyzer", :row 1435} {:arglist-strs ["[env sym]"], :end-row 1442, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-keyword", :ns "cljs.analyzer", :row 1439} {:arglist-strs ["[ast]"], :end-row 1449, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "get-tag", :ns "cljs.analyzer", :row 1444} {:arglist-strs ["[fn-ast params]"], :end-row 1460, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "find-matching-method", :ns "cljs.analyzer", :row 1451} {:arglist-strs ["[env t]"], :end-row 1475, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "type?", :ns "cljs.analyzer", :row 1462} {:end-row 1477, :filename "cljs/analyzer.cljc", :lang :clj, :name "infer-tag", :ns "cljs.analyzer", :row 1477} {:arglist-strs ["[{:keys [op] :as ast}]"], :end-row 1483, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "unwrap-quote", :ns "cljs.analyzer", :row 1479} {:arglist-strs ["[env ast]"], :end-row 1515, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "infer-if", :ns "cljs.analyzer", :row 1485} {:arglist-strs ["[ast]"], :end-row 1518, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "js-var?", :ns "cljs.analyzer", :row 1517} {:arglist-strs ["[fn-ast]"], :end-row 1521, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "js-var-fn?", :ns "cljs.analyzer", :row 1520} {:arglist-strs ["[{:keys [info] :as fn-ast}]"], :end-row 1534, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "fn-ast->tag", :ns "cljs.analyzer", :row 1523} {:arglist-strs ["[env {fn-ast :fn :keys [args] :as ast}]"], :end-row 1543, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "infer-invoke", :ns "cljs.analyzer", :row 1536} {:fixed-arities #{2}, :end-row 1573, :ns "cljs.analyzer", :name "infer-tag", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env ast]"], :doc "Given env, an analysis environment, and e, an AST node, return the inferred\n   type of the node", :row 1545} {:end-row 1575, :filename "cljs/analyzer.cljc", :lang :clj, :name "parse", :ns "cljs.analyzer", :row 1575} {:arglist-strs ["[var]" "[var expr-env]"], :end-row 1600, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :clj, :name "var-meta", :ns "cljs.analyzer", :row 1577} {:arglist-strs ["[env sym]"], :end-row 1613, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "var-ast", :ns "cljs.analyzer", :row 1602} {:end-row 1690, :filename "cljs/analyzer.cljc", :lang :clj, :name "predicate->tag", :ns "cljs.analyzer", :private true, :row 1628} {:fixed-arities #{2}, :end-row 1705, :private true, :ns "cljs.analyzer", :name "simple-predicate-induced-tag", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Look for a predicate-induced tag when the test expression is a simple\n   application of a predicate to a local, as in (string? x).", :row 1692} {:end-row 1707, :filename "cljs/analyzer.cljc", :lang :clj, :name "specials", :ns "cljs.analyzer", :row 1707} {:fixed-arities #{2}, :end-row 1727, :private true, :ns "cljs.analyzer", :name "type-check-induced-tag", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Look for a type-check-induced tag when the test expression is the use of\n  instance? on a local, as in (instance? UUID x) or implements? on a local, as\n  in (implements? ICounted x).", :row 1709} {:fixed-arities #{2}, :end-row 1739, :private true, :ns "cljs.analyzer", :name "truth-induced-tag", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Refine a tag to exclude clj-nil if the test is a local.", :row 1729} {:fixed-arities #{2}, :end-row 1750, :private true, :ns "cljs.analyzer", :name "set-test-induced-tags", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Looks at the test and sets any tags which are induced by virtue\n  of the test being truthy. For example in (if (string? x) x :bar)\n  the local x in the then branch must be of string type.", :row 1741} {:arglist-strs ["[x]"], :end-row 1887, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "valid-proto", :ns "cljs.analyzer", :row 1886} {:arglist-strs ["[env ast opts]"], :end-row 1890, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "elide-env", :ns "cljs.analyzer", :row 1889} {:arglist-strs ["[new-env]"], :end-row 1894, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "replace-env-pass", :ns "cljs.analyzer", :row 1892} {:arglist-strs ["[ast]"], :end-row 1902, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "ast-children", :ns "cljs.analyzer", :row 1896} {:arglist-strs ["[{:keys [op] :as ast}]"], :end-row 1908, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "constant-value?", :ns "cljs.analyzer", :row 1904} {:arglist-strs ["[{:keys [op] :as e}]"], :end-row 1917, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "const-expr->constant-value", :ns "cljs.analyzer", :row 1910} {:fixed-arities #{1}, :end-row 1923, :private true, :ns "cljs.analyzer", :name "earmuffed?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym]"], :row 1919} {:fixed-arities #{1}, :end-row 1929, :private true, :ns "cljs.analyzer", :name "core-ns?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns-sym]"], :row 1925} {:arglist-strs ["[env]"], :end-row 2143, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "analyze-fn-method-param", :ns "cljs.analyzer", :row 2117} {:arglist-strs ["[env form recur-frames]"], :end-row 2147, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "analyze-fn-method-body", :ns "cljs.analyzer", :row 2145} {:fixed-arities #{5}, :end-row 2183, :private true, :ns "cljs.analyzer", :name "analyze-fn-method", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env locals form type analyze-body?]"], :row 2149} {:end-row 2185, :filename "cljs/analyzer.cljc", :lang :clj, :name "analyze-wrap-meta", :ns "cljs.analyzer", :row 2185} {:arglist-strs ["[env locals name]"], :end-row 2203, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "fn-name-var", :ns "cljs.analyzer", :row 2187} {:arglist-strs ["[menv locals type meths]"], :end-row 2206, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze-fn-methods-pass2*", :ns "cljs.analyzer", :row 2205} {:arglist-strs ["[menv locals type meths]"], :end-row 2209, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze-fn-methods-pass2", :ns "cljs.analyzer", :row 2208} {:arglist-strs ["[env exprs]"], :end-row 2349, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-do-statements*", :ns "cljs.analyzer", :row 2348} {:arglist-strs ["[env exprs]"], :end-row 2352, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-do-statements", :ns "cljs.analyzer", :row 2351} {:arglist-strs ["[env init loop-lets]"], :end-row 2379, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "analyze-let-binding-init", :ns "cljs.analyzer", :row 2377} {:arglist-strs ["[name init-expr]"], :end-row 2386, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "get-let-tag", :ns "cljs.analyzer", :row 2381} {:arglist-strs ["[encl-env bindings op]"], :end-row 2432, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "analyze-let-bindings*", :ns "cljs.analyzer", :row 2388} {:arglist-strs ["[encl-env bindings op]"], :end-row 2435, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "analyze-let-bindings", :ns "cljs.analyzer", :row 2434} {:arglist-strs ["[env context exprs]"], :end-row 2438, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "analyze-let-body*", :ns "cljs.analyzer", :row 2437} {:arglist-strs ["[env context exprs recur-frames loop-lets]"], :end-row 2443, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :clj, :name "analyze-let-body", :ns "cljs.analyzer", :row 2440} {:arglist-strs ["[encl-env [_ bindings & exprs :as form] is-loop widened-tags]"], :end-row 2495, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze-let", :ns "cljs.analyzer", :row 2445} {:arglist-strs ["[env form]"], :end-row 2545, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-const", :ns "cljs.analyzer", :row 2536} {:end-row 2565, :filename "cljs/analyzer.cljc", :lang :clj, :name "js-prim-ctor->tag", :ns "cljs.analyzer", :row 2559} {:fixed-arities #{1}, :end-row 2570, :ns "cljs.analyzer", :name "prim-ctor?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[t]"], :doc "Test whether a tag is a constructor for a JS primitive", :row 2567} {:end-row 2672, :filename "cljs/analyzer.cljc", :lang :clj, :name "analyze-file", :ns "cljs.analyzer", :row 2672} {:fixed-arities #{1}, :end-row 2693, :ns "cljs.analyzer", :name "locate-src", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Given a namespace return the corresponding ClojureScript (.cljs or .cljc)\n     resource on the classpath or file from the root of the build.", :row 2675} {:arglist-strs ["[dep]"], :end-row 2701, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "foreign-dep?", :ns "cljs.analyzer", :row 2695} {:fixed-arities #{4 3}, :end-row 2740, :ns "cljs.analyzer", :name "analyze-deps", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[lib deps env]" "[lib deps env opts]"], :doc "Given a lib, a namespace, deps, its dependencies, env, an analysis environment\n   and opts, compiler options - analyze all of the dependencies. Required to\n   correctly analyze usage of other namespaces.", :row 2703} {:arglist-strs ["[lib sym cenv]"], :end-row 2748, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "missing-use?", :ns "cljs.analyzer", :row 2742} {:arglist-strs ["[sym cenv]"], :end-row 2753, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "missing-rename?", :ns "cljs.analyzer", :row 2750} {:arglist-strs ["[lib sym]"], :end-row 2759, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "missing-use-macro?", :ns "cljs.analyzer", :row 2755} {:arglist-strs ["[sym]"], :end-row 2765, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "missing-rename-macro?", :ns "cljs.analyzer", :row 2761} {:arglist-strs ["[uses env]"], :end-row 2771, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "missing-uses", :ns "cljs.analyzer", :row 2768} {:arglist-strs ["[renames env]"], :end-row 2776, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "missing-renames", :ns "cljs.analyzer", :row 2774} {:arglist-strs ["[use-macros env]"], :end-row 2781, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "missing-use-macros", :ns "cljs.analyzer", :row 2779} {:arglist-strs ["[use-macros env]"], :end-row 2786, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "inferred-use-macros", :ns "cljs.analyzer", :row 2784} {:arglist-strs ["[rename-macros env]"], :end-row 2790, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "inferred-rename-macros", :ns "cljs.analyzer", :row 2789} {:arglist-strs ["[uses env]"], :end-row 2798, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "check-uses", :ns "cljs.analyzer", :row 2792} {:arglist-strs ["[use-macros env]" "[use-macros missing-uses env]"], :end-row 2811, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "check-use-macros", :ns "cljs.analyzer", :row 2800} {:arglist-strs ["[{:keys [name uses use-macros] :as ast} env]"], :end-row 2829, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "check-use-macros-inferring-missing", :ns "cljs.analyzer", :row 2813} {:arglist-strs ["[{:keys [name renames] :as ast} env]"], :end-row 2848, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "check-rename-macros-inferring-missing", :ns "cljs.analyzer", :row 2831} {:arglist-strs ["[spec msg]"], :end-row 2851, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "parse-ns-error-msg", :ns "cljs.analyzer", :row 2850} {:arglist-strs ["[env macros? spec]"], :end-row 2881, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "basic-validate-ns-spec", :ns "cljs.analyzer", :row 2853} {:arglist-strs ["[env args]"], :end-row 2921, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "parse-ns-excludes", :ns "cljs.analyzer", :row 2883} {:arglist-strs ["[env [lib & filters :as spec]]"], :end-row 2955, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "use->require", :ns "cljs.analyzer", :row 2923} {:arglist-strs ["[env macros? deps aliases spec]"], :end-row 3011, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :clj, :name "parse-require-spec", :ns "cljs.analyzer", :row 2957} {:arglist-strs ["[env deps spec]"], :end-row 3031, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "parse-import-spec", :ns "cljs.analyzer", :row 3013} {:end-row 3033, :filename "cljs/analyzer.cljc", :lang :clj, :name "parse-ns", :ns "cljs.analyzer", :row 3033} {:fixed-arities #{1}, :end-row 3048, :ns "cljs.analyzer", :name "macro-autoload-ns?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[form]"], :doc "Given a spec form check whether the spec namespace requires a macro file\n   of the same name. If so return true.", :row 3035} {:fixed-arities #{1}, :end-row 3057, :ns "cljs.analyzer", :name "clj-ns->cljs-ns", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym]"], :doc "Given a symbol that starts with clojure as the first segment return the\n   same symbol with the first segment replaced with cljs", :row 3050} {:fixed-arities #{1}, :end-row 3067, :ns "cljs.analyzer", :name "aliasable-clj-ns?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym]"], :doc "Predicate for testing with a symbol represents an aliasable clojure namespace.", :row 3060} {:arglist-strs ["[[k & specs :as form]]"], :end-row 3082, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "process-rewrite-form", :ns "cljs.analyzer", :row 3070} {:fixed-arities #{1}, :end-row 3089, :ns "cljs.analyzer", :name "rewrite-cljs-aliases", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[args]"], :doc "Alias non-existing clojure.* namespaces to existing cljs.* namespaces if\n      possible.", :row 3085} {:arglist-strs ["[specs]"], :end-row 3097, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "canonicalize-specs", :ns "cljs.analyzer", :row 3091} {:arglist-strs ["[specs]"], :end-row 3104, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "canonicalize-import-specs", :ns "cljs.analyzer", :row 3099} {:fixed-arities #{1}, :end-row 3155, :ns "cljs.analyzer", :name "desugar-ns-specs", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[args]"], :doc "Given an original set of ns specs desugar :include-macros and :refer-macros\n   usage into only primitive spec forms - :use, :require, :use-macros,\n   :require-macros. If a library includes a macro file of with the same name\n   as the namespace will also be desugared.", :row 3106} {:arglist-strs ["[env ns segments]"], :end-row 3166, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "find-def-clash", :ns "cljs.analyzer", :row 3157} {:arglist-strs ["[name]"], :end-row 3173, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "macro-ns-name", :ns "cljs.analyzer", :row 3168} {:fixed-arities #{3}, :end-row 3189, :private true, :ns "cljs.analyzer", :name "check-duplicate-aliases", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env old new]"], :row 3175} {:fixed-arities #{3}, :end-row 3205, :private true, :ns "cljs.analyzer", :name "merge-ns-info", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[old new env]"], :row 3191} {:arglist-strs ["[op env [_ tsym fields pmasks body :as form]]"], :end-row 3434, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "parse-type", :ns "cljs.analyzer", :row 3399} {:fixed-arities #{1}, :end-row 3446, :private true, :ns "cljs.analyzer", :name "property-symbol?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[%1]"], :row 3446} {:fixed-arities #{1}, :end-row 3457, :private true, :ns "cljs.analyzer", :name "classify-dot-form", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[[target member args]]"], :row 3448} {:end-row 3459, :filename "cljs/analyzer.cljc", :lang :clj, :name "build-dot-form", :ns "cljs.analyzer", :row 3459} {:fixed-arities #{3}, :end-row 3480, :private true, :ns "cljs.analyzer", :name "build-method-call", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[target meth args]"], :doc "Builds the intermediate method call map used to reason about the parsed form during\n  compilation.", :row 3474} {:arglist-strs ["[env target field member+ form]"], :end-row 3572, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :clj, :name "analyze-dot", :ns "cljs.analyzer", :row 3511} {:arglist-strs ["[form]"], :end-row 3583, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "get-js-tag", :ns "cljs.analyzer", :row 3578} {:arglist-strs ["[env s]"], :end-row 3595, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "js-star-interp", :ns "cljs.analyzer", :row 3585} {:arglist-strs ["[s]"], :end-row 3605, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "js-star-seg", :ns "cljs.analyzer", :row 3597} {:end-row 3607, :filename "cljs/analyzer.cljc", :lang :clj, :name "NUMERIC_SET", :ns "cljs.analyzer", :row 3607} {:arglist-strs ["[t]"], :end-row 3629, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "numeric-type?", :ns "cljs.analyzer", :row 3609} {:end-row 3632, :filename "cljs/analyzer.cljc", :lang :clj, :name "array-types", :ns "cljs.analyzer", :row 3631} {:arglist-strs ["[t]"], :end-row 3650, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "array-type?", :ns "cljs.analyzer", :row 3634} {:fixed-arities #{3}, :end-row 3660, :private true, :ns "cljs.analyzer", :name "analyze-js-star-args", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[js-op env args]"], :row 3652} {:arglist-strs ["[env jsform args form]"], :end-row 3689, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze-js-star*", :ns "cljs.analyzer", :row 3662} {:arglist-strs ["[env jsform args form]"], :end-row 3692, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze-js-star", :ns "cljs.analyzer", :row 3691} {:fixed-arities #{1}, :end-row 3718, :private true, :ns "cljs.analyzer", :name "unsorted-map?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :row 3716} {:fixed-arities #{1}, :end-row 3726, :ns "cljs.analyzer", :name "analyzed", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :doc "Mark a form as being analyzed. Assumes x satisfies IMeta. Useful to suppress\n  warnings that will have been caught by a first compiler pass.", :row 3720} {:fixed-arities #{1}, :end-row 3735, :ns "cljs.analyzer", :name "analyzed?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :doc "Returns boolean if the form has already been marked as analyzed.", :row 3728} {:fixed-arities #{1}, :end-row 3740, :private true, :ns "cljs.analyzer", :name "all-values?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[exprs]"], :row 3737} {:fixed-arities #{2}, :end-row 3746, :private true, :ns "cljs.analyzer", :name "valid-arity?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[argc method-params]"], :row 3742} {:fixed-arities #{1}, :end-row 3752, :private true, :ns "cljs.analyzer", :name "record-tag?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[tag]"], :row 3748} {:fixed-arities #{1}, :end-row 3758, :private true, :ns "cljs.analyzer", :name "record-basis", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[tag]"], :row 3754} {:fixed-arities #{2}, :end-row 3763, :private true, :ns "cljs.analyzer", :name "record-with-field?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[tag field]"], :row 3760} {:fixed-arities #{4}, :end-row 3768, :private true, :ns "cljs.analyzer", :name "invalid-arity?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[argc method-params variadic max-fixed-arity]"], :row 3765} {:arglist-strs ["[env [f & args :as form]]"], :end-row 3832, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "parse-invoke*", :ns "cljs.analyzer", :row 3770} {:arglist-strs ["[env form]"], :end-row 3836, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "parse-invoke", :ns "cljs.analyzer", :row 3834} {:arglist-strs ["[{:keys [op] :as expr}]"], :end-row 3862, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "desugar-dotted-expr", :ns "cljs.analyzer", :row 3838} {:fixed-arities #{2}, :end-row 3913, :ns "cljs.analyzer", :name "analyze-symbol", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Finds the var associated with sym", :row 3865} {:arglist-strs ["[env sym]"], :end-row 3919, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "excluded?", :ns "cljs.analyzer", :row 3915} {:arglist-strs ["[env sym]"], :end-row 3925, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "used?", :ns "cljs.analyzer", :row 3921} {:arglist-strs ["[env nstr]"], :end-row 3940, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "get-expander-ns", :ns "cljs.analyzer", :row 3927} {:arglist-strs ["[sym env]"], :end-row 3965, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "get-expander*", :ns "cljs.analyzer", :row 3942} {:fixed-arities #{2}, :end-row 3975, :ns "cljs.analyzer", :name "get-expander", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym env]"], :doc "Given a sym, a symbol identifying a macro, and env, an analysis environment\n   return the corresponding Clojure macroexpander.", :row 3967} {:fixed-arities #{1}, :end-row 3985, :private true, :ns "cljs.analyzer", :name "var->sym", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[var]"], :row 3983} {:fixed-arities #{3}, :end-row 3997, :private true, :ns "cljs.analyzer", :name "do-macroexpand-check", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env form mac-var]"], :row 3987} {:arglist-strs ["[env form]"], :end-row 4068, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "macroexpand-1*", :ns "cljs.analyzer", :row 4010} {:fixed-arities #{2}, :end-row 4074, :ns "cljs.analyzer", :name "macroexpand-1", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env form]"], :doc "Given a env, an analysis environment, and form, a ClojureScript form,\n   macroexpand the form once.", :row 4070} {:end-row 4076, :filename "cljs/analyzer.cljc", :lang :clj, :name "analyze-list", :ns "cljs.analyzer", :row 4076} {:arglist-strs ["[op env form name opts]"], :end-row 4081, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :clj, :name "analyze-seq*", :ns "cljs.analyzer", :row 4078} {:arglist-strs ["[op env form name opts]"], :end-row 4085, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :clj, :name "analyze-seq*-wrap", :ns "cljs.analyzer", :row 4083} {:arglist-strs ["[env form name]" "[env form name opts]"], :end-row 4110, :filename "cljs/analyzer.cljc", :fixed-arities #{4 3}, :lang :clj, :name "analyze-seq", :ns "cljs.analyzer", :row 4087} {:arglist-strs ["[env form]"], :end-row 4120, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-map", :ns "cljs.analyzer", :row 4112} {:arglist-strs ["[env form]"], :end-row 4128, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-list", :ns "cljs.analyzer", :row 4124} {:arglist-strs ["[env form]"], :end-row 4134, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-vector", :ns "cljs.analyzer", :row 4130} {:arglist-strs ["[env form]"], :end-row 4140, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-set", :ns "cljs.analyzer", :row 4136} {:arglist-strs ["[env form]"], :end-row 4164, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-js-value", :ns "cljs.analyzer", :row 4142} {:arglist-strs ["[x]"], :end-row 4172, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "record-ns+name", :ns "cljs.analyzer", :row 4166} {:arglist-strs ["[env x]"], :end-row 4184, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "analyze-record", :ns "cljs.analyzer", :row 4174} {:arglist-strs ["[m]"], :end-row 4187, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "elide-reader-meta", :ns "cljs.analyzer", :row 4186} {:arglist-strs ["[m]"], :end-row 4190, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "elide-analyzer-meta", :ns "cljs.analyzer", :row 4189} {:arglist-strs ["[m]"], :end-row 4193, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "elide-irrelevant-meta", :ns "cljs.analyzer", :row 4192} {:arglist-strs ["[expr]"], :end-row 4204, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "analyze-wrap-meta", :ns "cljs.analyzer", :row 4195} {:arglist-strs ["[env {:keys [tag] :as ast} _]"], :end-row 4217, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "infer-type", :ns "cljs.analyzer", :row 4206} {:fixed-arities #{2}, :end-row 4220, :private true, :ns "cljs.analyzer", :name "repl-self-require?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env deps]"], :row 4219} {:arglist-strs ["[env {:keys [op] :as ast} opts]"], :end-row 4263, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "ns-side-effects", :ns "cljs.analyzer", :row 4223} {:end-row 4277, :filename "cljs/analyzer.cljc", :lang :clj, :name "invoke-arg-type-validators", :ns "cljs.analyzer", :row 4267} {:arglist-strs ["[env {:keys [op] :as ast} opts]"], :end-row 4290, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :clj, :name "check-invoke-arg-types", :ns "cljs.analyzer", :row 4279} {:arglist-strs ["[env form name opts]"], :end-row 4313, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze-form", :ns "cljs.analyzer", :row 4293} {:end-row 4339, :filename "cljs/analyzer.cljc", :lang :clj, :name "default-passes", :ns "cljs.analyzer", :row 4337} {:arglist-strs ["[env form name opts]"], :end-row 4350, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :clj, :name "analyze*", :ns "cljs.analyzer", :row 4341} {:fixed-arities #{4 3 2}, :end-row 4369, :ns "cljs.analyzer", :name "analyze", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[env form]" "[env form name]" "[env form name opts]"], :doc "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n  (one of :statement, :expr, :return), :ns (a symbol naming the\n  compilation ns)}, and form, returns an expression object (a map\n  containing at least :form, :op and :env keys). If expr has any (immediately)\n  nested exprs, must have a :children entry. This must be a vector of keywords naming\n  the immediately nested fields mapped to an expr or vector of exprs. This will\n  facilitate code walking without knowing the details of the op set.", :row 4352} {:fixed-arities #{2}, :end-row 4384, :ns "cljs.analyzer", :name "add-consts", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[compiler-state constants-map]"], :doc "Given a compiler state and a map from fully qualified symbols to constant\n  EDN values, update the compiler state marking these vars as const to support\n  direct substitution of these vars in source.", :row 4371} {:fixed-arities #{1}, :end-row 4392, :private true, :ns "cljs.analyzer", :name "source-path", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :doc "Returns a path suitable for providing to tools.reader as a 'filename'.", :row 4387} {:arglist-strs ["[sym]"], :end-row 4400, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "resolve-symbol", :ns "cljs.analyzer", :row 4394} {:fixed-arities #{1}, :end-row 4407, :ns "cljs.analyzer", :name "get-aliases", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Get all alias maps for a namespace.", :row 4402} {:fixed-arities #{0}, :end-row 4416, :ns "cljs.analyzer", :name "get-bridged-alias-map", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :doc "Returns clojure.tools.reader/*alias-map* for bridging", :row 4410} {:fixed-arities #{1 2}, :end-row 4445, :ns "cljs.analyzer", :name "forms-seq*", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[rdr]" "[rdr filename]"], :doc "Seq of Clojure/ClojureScript forms from rdr, a java.io.Reader. Optionally\n     accepts a filename argument which will be used in any emitted errors.", :row 4419} {:fixed-arities #{1 3 2}, :end-row 4476, :ns "cljs.analyzer", :name "forms-seq", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[f]" "[f filename]" "[f filename return-reader?]"], :doc "DEPRECATED: Seq of Clojure/ClojureScript forms from [f], which can be anything\n     for which `clojure.java.io/reader` can produce a `java.io.Reader`. Optionally\n     accepts a [filename] argument, which the reader will use in any emitted errors.", :row 4448} {:arglist-strs ["[src]"], :end-row 4487, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "gen-user-ns", :ns "cljs.analyzer", :row 4479} {:fixed-arities #{1 3 2}, :end-row 4592, :ns "cljs.analyzer", :name "parse-ns", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[src]" "[src opts]" "[src dest opts]"], :doc "Helper for parsing only the essential namespace information from a\n      ClojureScript source file and returning a cljs.closure/IJavaScript compatible\n      map _not_ a namespace AST node.\n\n      By default does not load macros or perform any analysis of dependencies. If\n      opts parameter provided :analyze-deps and :load-macros keys their values will\n      be used for *analyze-deps* and *load-macros* bindings respectively. This\n      function does _not_ side-effect the ambient compilation environment unless\n      requested via opts where :restore is false.", :row 4490} {:fixed-arities #{0 1}, :end-row 4598, :private true, :ns "cljs.analyzer", :name "cache-analysis-ext", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]" "[format]"], :row 4595} {:arglist-strs ["[opts]"], :end-row 4604, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :clj, :name "build-affecting-options", :ns "cljs.analyzer", :row 4601} {:arglist-strs ["[path opts]"], :end-row 4609, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :clj, :name "build-affecting-options-sha", :ns "cljs.analyzer", :row 4607} {:arglist-strs ["[path]" "[path opts]"], :end-row 4618, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :clj, :name "cache-base-path", :ns "cljs.analyzer", :row 4612} {:arglist-strs ["[rsrc ext]" "[rsrc ext opts]"], :end-row 4640, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "cacheable-files", :ns "cljs.analyzer", :row 4621} {:fixed-arities #{1 4 3 2 5}, :end-row 4668, :ns "cljs.analyzer", :name "cache-file", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[src]" "[src output-dir]" "[src ns-info output-dir]" "[src ns-info output-dir mode]" "[src ns-info output-dir mode opts]"], :doc "Given a ClojureScript source file returns the read/write path to the analysis\n      cache file. Defaults to the read path which is usually also the write path.", :row 4643} {:fixed-arities #{1 4 3 2}, :end-row 4700, :ns "cljs.analyzer", :name "requires-analysis?", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[src]" "[src output-dir]" "[src cache output-dir]" "[src cache output-dir opts]"], :doc "Given a src, a resource, and output-dir, a compilation output directory\n      return true or false depending on whether src needs to be (re-)analyzed.\n      Can optionally pass cache, the analysis cache file.", :row 4671} {:fixed-arities #{0}, :end-row 4708, :private true, :ns "cljs.analyzer", :name "get-spec-vars", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :row 4703} {:fixed-arities #{1}, :end-row 4739, :ns "cljs.analyzer", :name "dump-specs", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Dumps registered speced vars for a given namespace into the compiler\n  environment.", :row 4719} {:fixed-arities #{1}, :end-row 4754, :ns "cljs.analyzer", :name "register-specs", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[cached-ns]"], :doc "Registers speced vars found in a namespace analysis cache.", :row 4741} {:arglist-strs ["[ns cache-file]" "[ns cache-file src]"], :end-row 4773, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "write-analysis-cache", :ns "cljs.analyzer", :row 4757} {:arglist-strs ["[cache-file src]" "[cache-file src opts]"], :end-row 4802, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :clj, :name "read-analysis-cache", :ns "cljs.analyzer", :row 4776} {:arglist-strs ["[forms]" "[forms opts]" "[forms opts return-last?]"], :end-row 4829, :filename "cljs/analyzer.cljc", :fixed-arities #{1 3 2}, :lang :clj, :name "analyze-form-seq", :ns "cljs.analyzer", :row 4804} {:fixed-arities #{1}, :end-row 4835, :ns "cljs.analyzer", :name "ensure-defs", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Ensures that a non-nil defs map exists in the compiler state for a given\n  ns. (A non-nil defs map signifies that the namespace has been analyzed.)", :row 4831} {:fixed-arities #{1 3 2}, :end-row 4902, :ns "cljs.analyzer", :name "analyze-file", :lang :clj, :filename "cljs/analyzer.cljc", :arglist-strs ["[f]" "[f opts]" "[f skip-cache opts]"], :doc "Given a java.io.File, java.net.URL or a string identifying a resource on the\n      classpath attempt to analyze it.\n\n      This function side-effects the ambient compilation environment\n      `cljs.env/*compiler*` to aggregate analysis information. opts argument is\n      compiler options, if :cache-analysis true will cache analysis to\n      \":output-dir/some/ns/foo.cljs.cache.edn\". This function does not return a\n      meaningful value.", :row 4838} {:end-row 55, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-ns*", :ns "cljs.analyzer", :row 55} {:end-row 56, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-file*", :ns "cljs.analyzer", :row 56} {:end-row 57, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*checked-arrays*", :ns "cljs.analyzer", :row 57} {:end-row 58, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*check-alias-dupes*", :ns "cljs.analyzer", :row 58} {:end-row 59, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-static-fns*", :ns "cljs.analyzer", :row 59} {:end-row 60, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*fn-invoke-direct*", :ns "cljs.analyzer", :row 60} {:end-row 61, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-macros-path*", :ns "cljs.analyzer", :row 61} {:end-row 62, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-macros-is-classpath*", :ns "cljs.analyzer", :row 62} {:end-row 63, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-dep-set*", :ns "cljs.analyzer", :row 63} {:end-row 64, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*analyze-deps*", :ns "cljs.analyzer", :row 64} {:end-row 65, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*load-tests*", :ns "cljs.analyzer", :row 65} {:end-row 66, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*load-macros*", :ns "cljs.analyzer", :row 66} {:end-row 67, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*reload-macros*", :ns "cljs.analyzer", :row 67} {:end-row 68, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*macro-infer*", :ns "cljs.analyzer", :row 68} {:end-row 69, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*passes*", :ns "cljs.analyzer", :row 69} {:end-row 70, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*file-defs*", :ns "cljs.analyzer", :row 70} {:end-row 71, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*private-var-access-nowarn*", :ns "cljs.analyzer", :row 71} {:doc "The namespace of the constants table as a symbol.", :end-row 75, :filename "cljs/analyzer.cljc", :lang :cljs, :name "constants-ns-sym", :ns "cljs.analyzer", :row 73} {:end-row 125, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*verbose*", :ns "cljs.analyzer", :row 125} {:end-row 127, :filename "cljs/analyzer.cljc", :lang :cljs, :name "-cljs-macros-loaded", :ns "cljs.analyzer", :row 127} {:end-row 168, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-warnings*", :ns "cljs.analyzer", :row 129} {:arglist-strs ["[]"], :end-row 171, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :cljs, :name "unchecked-arrays?", :ns "cljs.analyzer", :row 170} {:arglist-strs ["[]"], :end-row 174, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :cljs, :name "compiler-options", :ns "cljs.analyzer", :row 173} {:arglist-strs ["[]"], :end-row 177, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :cljs, :name "get-externs", :ns "cljs.analyzer", :row 176} {:fixed-arities #{0}, :end-row 185, :ns "cljs.analyzer", :name "checked-arrays", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :doc "Returns false-y, :warn, or :error based on configuration and the\n   current value of *unchecked-arrays*.", :row 179} {:end-row 200, :filename "cljs/analyzer.cljc", :lang :cljs, :name "js-reserved", :ns "cljs.analyzer", :row 187} {:end-row 203, :filename "cljs/analyzer.cljc", :lang :cljs, :name "es5-allowed", :ns "cljs.analyzer", :row 202} {:end-row 206, :filename "cljs/analyzer.cljc", :lang :cljs, :name "SENTINEL", :ns "cljs.analyzer", :row 206} {:arglist-strs ["[m k0 k1]" "[m k0 k1 k2]" "[m k0 k1 k2 k3]"], :end-row 226, :filename "cljs/analyzer.cljc", :fixed-arities #{4 3 5}, :lang :cljs, :name "gets", :ns "cljs.analyzer", :row 208} {:arglist-strs ["[ss]"], :end-row 230, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "munge-path", :ns "cljs.analyzer", :row 229} {:fixed-arities #{1 2}, :end-row 238, :ns "cljs.analyzer", :name "ns->relpath", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]" "[ns ext]"], :doc "Given a namespace as a symbol return the relative path. May optionally\n     provide the file extension, defaults to :cljs.", :row 233} {:arglist-strs ["[x get-deps]" "[x depth state memo-get-deps]"], :end-row 252, :filename "cljs/analyzer.cljc", :fixed-arities #{4 2}, :lang :cljs, :name "topo-sort", :ns "cljs.analyzer", :row 241} {:end-row 254, :filename "cljs/analyzer.cljc", :lang :cljs, :name "message", :ns "cljs.analyzer", :row 254} {:end-row 254, :filename "cljs/analyzer.cljc", :lang :cljs, :name "namespaces", :ns "cljs.analyzer", :row 254} {:arglist-strs ["[x]"], :end-row 259, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "ast?", :ns "cljs.analyzer", :row 256} {:end-row 261, :filename "cljs/analyzer.cljc", :lang :cljs, :name "error-message", :ns "cljs.analyzer", :row 261} {:arglist-strs ["[warning-type env extra]"], :end-row 485, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "default-warning-handler", :ns "cljs.analyzer", :row 479} {:end-row 488, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*cljs-warning-handlers*", :ns "cljs.analyzer", :row 487} {:fixed-arities #{2}, :end-row 499, :private true, :ns "cljs.analyzer", :name "repeat-char", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[c n]"], :row 495} {:fixed-arities #{2}, :end-row 508, :private true, :ns "cljs.analyzer", :name "hex-format", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[s pad]"], :row 501} {:arglist-strs ["[value]"], :end-row 528, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "gen-constant-id", :ns "cljs.analyzer", :row 510} {:fixed-arities #{1 2}, :end-row 548, :private true, :ns "cljs.analyzer", :name "register-constant!", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[val]" "[env val]"], :row 530} {:end-row 551, :filename "cljs/analyzer.cljc", :lang :cljs, :name "default-namespaces", :ns "cljs.analyzer", :row 550} {:end-row 570, :filename "cljs/analyzer.cljc", :lang :cljs, :name "namespaces", :ns "cljs.analyzer", :row 558} {:arglist-strs ["[key]" "[cenv key]"], :end-row 579, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "get-namespace", :ns "cljs.analyzer", :row 572} {:arglist-strs ["[x env]"], :end-row 594, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-line", :ns "cljs.analyzer", :row 593} {:arglist-strs ["[x env]"], :end-row 597, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-col", :ns "cljs.analyzer", :row 596} {:fixed-arities #{1 2}, :end-row 616, :ns "cljs.analyzer", :name "intern-macros", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]" "[ns reload]"], :doc "Given a Clojure namespace intern all macros into the ambient ClojureScript\n   analysis environment.", :row 599} {:fixed-arities #{0}, :end-row 722, :ns "cljs.analyzer", :name "empty-env", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :doc "Construct an empty analysis environment. Required to analyze forms.", :row 710} {:fixed-arities #{1}, :end-row 728, :private true, :ns "cljs.analyzer", :name "source-info->error-data", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[{:keys [file line column]}]"], :row 724} {:arglist-strs ["[env]" "[name env]"], :end-row 741, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "source-info", :ns "cljs.analyzer", :row 730} {:arglist-strs ["[env s]"], :end-row 748, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "message", :ns "cljs.analyzer", :row 743} {:arglist-strs ["[warning-type env extra]"], :end-row 752, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "warning", :ns "cljs.analyzer", :row 750} {:fixed-arities #{1}, :end-row 757, :private true, :ns "cljs.analyzer", :name "accumulating-warning-handler", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[warn-acc]"], :row 754} {:fixed-arities #{1}, :end-row 760, :private true, :ns "cljs.analyzer", :name "replay-accumulated-warnings", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[warn-acc]"], :row 759} {:fixed-arities #{3 2}, :end-row 769, :private true, :ns "cljs.analyzer", :name "error-data", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env phase]" "[env phase symbol]"], :row 762} {:fixed-arities #{3}, :end-row 774, :private true, :ns "cljs.analyzer", :name "compile-syntax-error", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env msg symbol]"], :row 771} {:arglist-strs ["[env msg]" "[env msg cause]"], :end-row 782, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "error", :ns "cljs.analyzer", :row 776} {:arglist-strs ["[ex]"], :end-row 787, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "analysis-error?", :ns "cljs.analyzer", :row 784} {:arglist-strs ["[ex]"], :end-row 792, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "has-error-data?", :ns "cljs.analyzer", :row 789} {:end-row 805, :filename "cljs/analyzer.cljc", :lang :cljs, :name "implicit-nses", :ns "cljs.analyzer", :row 805} {:arglist-strs ["[env prefix suffix]"], :end-row 810, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "implicit-import?", :ns "cljs.analyzer", :row 807} {:end-row 812, :filename "cljs/analyzer.cljc", :lang :cljs, :name "get-expander", :ns "cljs.analyzer", :row 812} {:arglist-strs ["[env prefix suffix]"], :end-row 819, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "confirm-var-exist-warning", :ns "cljs.analyzer", :row 814} {:fixed-arities #{1}, :end-row 827, :ns "cljs.analyzer", :name "lib&sublib", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[lib]"], :doc "If a library name has the form foo$bar, return a vector of the library and\n   the sublibrary property.", :row 821} {:fixed-arities #{2}, :end-row 837, :ns "cljs.analyzer", :name "loaded-js-ns?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env prefix]"], :doc "Check if a JavaScript namespace has been loaded. JavaScript vars are\n  not currently checked.", :row 829} {:fixed-arities #{2}, :end-row 848, :private true, :ns "cljs.analyzer", :name "internal-js-module-exists?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[js-module-index module]"], :row 839} {:end-row 850, :filename "cljs/analyzer.cljc", :lang :cljs, :name "js-module-exists?*", :ns "cljs.analyzer", :row 850} {:arglist-strs ["[module]"], :end-row 854, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "js-module-exists?", :ns "cljs.analyzer", :row 852} {:arglist-strs ["[module]"], :end-row 867, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "node-module-dep?", :ns "cljs.analyzer", :row 856} {:arglist-strs ["[module]"], :end-row 874, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "dep-has-global-exports?", :ns "cljs.analyzer", :row 869} {:arglist-strs ["[module]"], :end-row 886, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "goog-module-dep?", :ns "cljs.analyzer", :row 876} {:arglist-strs ["[env prefix suffix]" "[env prefix suffix missing-fn]"], :end-row 906, :filename "cljs/analyzer.cljc", :fixed-arities #{4 3}, :lang :cljs, :name "confirm-var-exists", :ns "cljs.analyzer", :row 888} {:arglist-strs ["[]"], :end-row 912, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :cljs, :name "confirm-var-exists-throw", :ns "cljs.analyzer", :row 908} {:arglist-strs ["[env name]" "[env name not-found]"], :end-row 919, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "resolve-ns-alias", :ns "cljs.analyzer", :row 914} {:arglist-strs ["[env name]" "[env name not-found]"], :end-row 926, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "resolve-macro-ns-alias", :ns "cljs.analyzer", :row 921} {:fixed-arities #{2}, :end-row 941, :ns "cljs.analyzer", :name "confirm-ns", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env ns-sym]"], :doc "Given env, an analysis environment, and ns-sym, a symbol identifying a\n   namespace, confirm that the namespace exists. Warn if not found.", :row 928} {:fixed-arities #{2}, :end-row 952, :ns "cljs.analyzer", :name "core-name?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Is sym visible from core in the current compilation namespace?", :row 943} {:fixed-arities #{2}, :end-row 963, :ns "cljs.analyzer", :name "public-name?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns sym]"], :doc "Is sym public?", :row 954} {:arglist-strs ["[x]"], :end-row 968, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "js-tag?", :ns "cljs.analyzer", :row 965} {:arglist-strs ["[x]"], :end-row 977, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "normalize-js-tag", :ns "cljs.analyzer", :row 970} {:fixed-arities #{1}, :end-row 985, :ns "cljs.analyzer", :name "->type-set", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[t]"], :doc "Ensures that a type tag is a set.", :row 979} {:arglist-strs ["[t]"], :end-row 999, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "canonicalize-type", :ns "cljs.analyzer", :row 987} {:fixed-arities #{0 1 2}, :end-row 1012, :ns "cljs.analyzer", :name "add-types", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[]" "[t1]" "[t1 t2]" "[t1 t2 & ts]"], :doc "Produces a union of types.", :row 1001} {:end-row 1021, :filename "cljs/analyzer.cljc", :lang :cljs, :name "alias->type", :ns "cljs.analyzer", :row 1014} {:arglist-strs ["[pre externs]" "[pre externs top]"], :end-row 1047, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "has-extern?*", :ns "cljs.analyzer", :row 1023} {:arglist-strs ["[pre]" "[pre externs]"], :end-row 1058, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "has-extern?", :ns "cljs.analyzer", :row 1049} {:arglist-strs ["[pre]" "[pre tag-type]" "[pre tag-type externs]" "[pre tag-type externs top]"], :end-row 1073, :filename "cljs/analyzer.cljc", :fixed-arities #{1 4 3 2}, :lang :cljs, :name "js-tag", :ns "cljs.analyzer", :row 1060} {:arglist-strs ["[sym]"], :end-row 1080, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "dotted-symbol?", :ns "cljs.analyzer", :row 1075} {:arglist-strs ["[name]"], :end-row 1084, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "munge-node-lib", :ns "cljs.analyzer", :row 1082} {:arglist-strs ["[name]" "[ns name]"], :end-row 1090, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "munge-goog-module-lib", :ns "cljs.analyzer", :row 1086} {:arglist-strs ["[name]"], :end-row 1094, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "munge-global-export", :ns "cljs.analyzer", :row 1092} {:fixed-arities #{2}, :end-row 1109, :ns "cljs.analyzer", :name "resolve-alias", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns sym]"], :doc "Takes a namespace and an unqualified symbol and potentially returns a new\n  symbol to be used in lieu of the original.", :row 1096} {:arglist-strs ["[ns]"], :end-row 1116, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "ns->module-type", :ns "cljs.analyzer", :row 1111} {:end-row 1118, :filename "cljs/analyzer.cljc", :lang :cljs, :name "resolve*", :ns "cljs.analyzer", :row 1118} {:arglist-strs ["[sym current-ns]"], :end-row 1131, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "extern-pre", :ns "cljs.analyzer", :row 1126} {:arglist-strs ["[]" "[opts]"], :end-row 1138, :filename "cljs/analyzer.cljc", :fixed-arities #{0 1}, :lang :cljs, :name "node-like?", :ns "cljs.analyzer", :row 1133} {:doc "Specially-treated symbols for which we don't trigger :private-var-access warnings.", :end-row 1175, :filename "cljs/analyzer.cljc", :lang :cljs, :name "private-var-access-exceptions", :ns "cljs.analyzer", :private true, :row 1170} {:arglist-strs ["[ns env]"], :end-row 1194, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "required?", :ns "cljs.analyzer", :row 1192} {:fixed-arities #{2}, :end-row 1204, :ns "cljs.analyzer", :name "invokeable-ns?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns env]"], :doc "Returns true if ns is a required namespace and a JavaScript module that\n   might be invokeable as a function.", :row 1196} {:arglist-strs ["[ns current-ns env]"], :end-row 1222, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "resolve-invokeable-ns", :ns "cljs.analyzer", :row 1206} {:fixed-arities #{2}, :end-row 1231, :ns "cljs.analyzer", :name "resolve-import", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env import]"], :doc "goog.modules are deterministically assigned to a property of the namespace,\n   we cannot expect the reference will be globally available, so we resolve to\n   namespace local reference.", :row 1224} {:arglist-strs ["[sym lb]"], :end-row 1241, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "handle-symbol-local", :ns "cljs.analyzer", :row 1238} {:fixed-arities #{4 3 2}, :end-row 1359, :ns "cljs.analyzer", :name "resolve-var", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]" "[env sym confirm]" "[env sym confirm default?]"], :doc "Resolve a var. Accepts a side-effecting confirm fn for producing\n   warnings about unresolved vars.", :row 1243} {:fixed-arities #{2}, :end-row 1367, :ns "cljs.analyzer", :name "resolve-existing-var", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Given env, an analysis environment, and sym, a symbol, resolve an existing var.\n   Emits a warning if no such var exists.", :row 1361} {:fixed-arities #{2}, :end-row 1377, :ns "cljs.analyzer", :name "confirm-bindings", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env names]"], :doc "Given env, an analysis environment env, and names, a list of symbols, confirm\n   that all correspond to declared dynamic vars.", :row 1369} {:fixed-arities #{2}, :end-row 1412, :ns "cljs.analyzer", :name "resolve-macro-var", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Given env, an analysis environment, and sym, a symbol, resolve a macro.", :row 1379} {:end-row 1414, :filename "cljs/analyzer.cljc", :lang :cljs, :name "analyze", :ns "cljs.analyzer", :row 1414} {:end-row 1414, :filename "cljs/analyzer.cljc", :lang :cljs, :name "analyze-symbol", :ns "cljs.analyzer", :row 1414} {:end-row 1414, :filename "cljs/analyzer.cljc", :lang :cljs, :name "analyze-seq", :ns "cljs.analyzer", :row 1414} {:end-row 1419, :filename "cljs/analyzer.cljc", :lang :cljs, :name "specials", :ns "cljs.analyzer", :row 1418} {:end-row 1421, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*recur-frames*", :ns "cljs.analyzer", :row 1421} {:end-row 1422, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*loop-lets*", :ns "cljs.analyzer", :row 1422} {:end-row 1423, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*allow-redef*", :ns "cljs.analyzer", :row 1423} {:end-row 1424, :filename "cljs/analyzer.cljc", :lang :cljs, :name "*allow-ns*", :ns "cljs.analyzer", :row 1424} {:arglist-strs ["[env sym]"], :end-row 1442, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-keyword", :ns "cljs.analyzer", :row 1439} {:arglist-strs ["[ast]"], :end-row 1449, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "get-tag", :ns "cljs.analyzer", :row 1444} {:arglist-strs ["[fn-ast params]"], :end-row 1460, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "find-matching-method", :ns "cljs.analyzer", :row 1451} {:arglist-strs ["[env t]"], :end-row 1475, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "type?", :ns "cljs.analyzer", :row 1462} {:end-row 1477, :filename "cljs/analyzer.cljc", :lang :cljs, :name "infer-tag", :ns "cljs.analyzer", :row 1477} {:arglist-strs ["[{:keys [op] :as ast}]"], :end-row 1483, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "unwrap-quote", :ns "cljs.analyzer", :row 1479} {:arglist-strs ["[env ast]"], :end-row 1515, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "infer-if", :ns "cljs.analyzer", :row 1485} {:arglist-strs ["[ast]"], :end-row 1518, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "js-var?", :ns "cljs.analyzer", :row 1517} {:arglist-strs ["[fn-ast]"], :end-row 1521, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "js-var-fn?", :ns "cljs.analyzer", :row 1520} {:arglist-strs ["[{:keys [info] :as fn-ast}]"], :end-row 1534, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "fn-ast->tag", :ns "cljs.analyzer", :row 1523} {:arglist-strs ["[env {fn-ast :fn :keys [args] :as ast}]"], :end-row 1543, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "infer-invoke", :ns "cljs.analyzer", :row 1536} {:fixed-arities #{2}, :end-row 1573, :ns "cljs.analyzer", :name "infer-tag", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env ast]"], :doc "Given env, an analysis environment, and e, an AST node, return the inferred\n   type of the node", :row 1545} {:end-row 1575, :filename "cljs/analyzer.cljc", :lang :cljs, :name "parse", :ns "cljs.analyzer", :row 1575} {:arglist-strs ["[var]" "[var expr-env]"], :end-row 1600, :filename "cljs/analyzer.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "var-meta", :ns "cljs.analyzer", :row 1577} {:arglist-strs ["[env sym]"], :end-row 1613, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "var-ast", :ns "cljs.analyzer", :row 1602} {:end-row 1690, :filename "cljs/analyzer.cljc", :lang :cljs, :name "predicate->tag", :ns "cljs.analyzer", :private true, :row 1628} {:fixed-arities #{2}, :end-row 1705, :private true, :ns "cljs.analyzer", :name "simple-predicate-induced-tag", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Look for a predicate-induced tag when the test expression is a simple\n   application of a predicate to a local, as in (string? x).", :row 1692} {:end-row 1707, :filename "cljs/analyzer.cljc", :lang :cljs, :name "specials", :ns "cljs.analyzer", :row 1707} {:fixed-arities #{2}, :end-row 1727, :private true, :ns "cljs.analyzer", :name "type-check-induced-tag", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Look for a type-check-induced tag when the test expression is the use of\n  instance? on a local, as in (instance? UUID x) or implements? on a local, as\n  in (implements? ICounted x).", :row 1709} {:fixed-arities #{2}, :end-row 1739, :private true, :ns "cljs.analyzer", :name "truth-induced-tag", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Refine a tag to exclude clj-nil if the test is a local.", :row 1729} {:fixed-arities #{2}, :end-row 1750, :private true, :ns "cljs.analyzer", :name "set-test-induced-tags", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env test]"], :doc "Looks at the test and sets any tags which are induced by virtue\n  of the test being truthy. For example in (if (string? x) x :bar)\n  the local x in the then branch must be of string type.", :row 1741} {:arglist-strs ["[x]"], :end-row 1887, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "valid-proto", :ns "cljs.analyzer", :row 1886} {:arglist-strs ["[env ast opts]"], :end-row 1890, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "elide-env", :ns "cljs.analyzer", :row 1889} {:arglist-strs ["[new-env]"], :end-row 1894, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "replace-env-pass", :ns "cljs.analyzer", :row 1892} {:arglist-strs ["[ast]"], :end-row 1902, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "ast-children", :ns "cljs.analyzer", :row 1896} {:arglist-strs ["[{:keys [op] :as ast}]"], :end-row 1908, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "constant-value?", :ns "cljs.analyzer", :row 1904} {:arglist-strs ["[{:keys [op] :as e}]"], :end-row 1917, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "const-expr->constant-value", :ns "cljs.analyzer", :row 1910} {:fixed-arities #{1}, :end-row 1923, :private true, :ns "cljs.analyzer", :name "earmuffed?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym]"], :row 1919} {:fixed-arities #{1}, :end-row 1929, :private true, :ns "cljs.analyzer", :name "core-ns?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns-sym]"], :row 1925} {:arglist-strs ["[env]"], :end-row 2143, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "analyze-fn-method-param", :ns "cljs.analyzer", :row 2117} {:arglist-strs ["[env form recur-frames]"], :end-row 2147, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "analyze-fn-method-body", :ns "cljs.analyzer", :row 2145} {:fixed-arities #{5}, :end-row 2183, :private true, :ns "cljs.analyzer", :name "analyze-fn-method", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env locals form type analyze-body?]"], :row 2149} {:end-row 2185, :filename "cljs/analyzer.cljc", :lang :cljs, :name "analyze-wrap-meta", :ns "cljs.analyzer", :row 2185} {:arglist-strs ["[env locals name]"], :end-row 2203, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "fn-name-var", :ns "cljs.analyzer", :row 2187} {:arglist-strs ["[menv locals type meths]"], :end-row 2206, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze-fn-methods-pass2*", :ns "cljs.analyzer", :row 2205} {:arglist-strs ["[menv locals type meths]"], :end-row 2209, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze-fn-methods-pass2", :ns "cljs.analyzer", :row 2208} {:arglist-strs ["[env exprs]"], :end-row 2349, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-do-statements*", :ns "cljs.analyzer", :row 2348} {:arglist-strs ["[env exprs]"], :end-row 2352, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-do-statements", :ns "cljs.analyzer", :row 2351} {:arglist-strs ["[env init loop-lets]"], :end-row 2379, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "analyze-let-binding-init", :ns "cljs.analyzer", :row 2377} {:arglist-strs ["[name init-expr]"], :end-row 2386, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-let-tag", :ns "cljs.analyzer", :row 2381} {:arglist-strs ["[encl-env bindings op]"], :end-row 2432, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "analyze-let-bindings*", :ns "cljs.analyzer", :row 2388} {:arglist-strs ["[encl-env bindings op]"], :end-row 2435, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "analyze-let-bindings", :ns "cljs.analyzer", :row 2434} {:arglist-strs ["[env context exprs]"], :end-row 2438, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "analyze-let-body*", :ns "cljs.analyzer", :row 2437} {:arglist-strs ["[env context exprs recur-frames loop-lets]"], :end-row 2443, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :cljs, :name "analyze-let-body", :ns "cljs.analyzer", :row 2440} {:arglist-strs ["[encl-env [_ bindings & exprs :as form] is-loop widened-tags]"], :end-row 2495, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze-let", :ns "cljs.analyzer", :row 2445} {:arglist-strs ["[env form]"], :end-row 2545, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-const", :ns "cljs.analyzer", :row 2536} {:end-row 2565, :filename "cljs/analyzer.cljc", :lang :cljs, :name "js-prim-ctor->tag", :ns "cljs.analyzer", :row 2559} {:fixed-arities #{1}, :end-row 2570, :ns "cljs.analyzer", :name "prim-ctor?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[t]"], :doc "Test whether a tag is a constructor for a JS primitive", :row 2567} {:arglist-strs ["[dep]"], :end-row 2701, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "foreign-dep?", :ns "cljs.analyzer", :row 2695} {:fixed-arities #{4 3}, :end-row 2740, :ns "cljs.analyzer", :name "analyze-deps", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[lib deps env]" "[lib deps env opts]"], :doc "Given a lib, a namespace, deps, its dependencies, env, an analysis environment\n   and opts, compiler options - analyze all of the dependencies. Required to\n   correctly analyze usage of other namespaces.", :row 2703} {:arglist-strs ["[lib sym cenv]"], :end-row 2748, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "missing-use?", :ns "cljs.analyzer", :row 2742} {:arglist-strs ["[sym cenv]"], :end-row 2753, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "missing-rename?", :ns "cljs.analyzer", :row 2750} {:arglist-strs ["[lib sym]"], :end-row 2759, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "missing-use-macro?", :ns "cljs.analyzer", :row 2755} {:arglist-strs ["[sym]"], :end-row 2765, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "missing-rename-macro?", :ns "cljs.analyzer", :row 2761} {:arglist-strs ["[uses env]"], :end-row 2771, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "missing-uses", :ns "cljs.analyzer", :row 2768} {:arglist-strs ["[renames env]"], :end-row 2776, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "missing-renames", :ns "cljs.analyzer", :row 2774} {:arglist-strs ["[use-macros env]"], :end-row 2781, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "missing-use-macros", :ns "cljs.analyzer", :row 2779} {:arglist-strs ["[use-macros env]"], :end-row 2786, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "inferred-use-macros", :ns "cljs.analyzer", :row 2784} {:arglist-strs ["[rename-macros env]"], :end-row 2790, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "inferred-rename-macros", :ns "cljs.analyzer", :row 2789} {:arglist-strs ["[uses env]"], :end-row 2798, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "check-uses", :ns "cljs.analyzer", :row 2792} {:arglist-strs ["[use-macros env]" "[use-macros missing-uses env]"], :end-row 2811, :filename "cljs/analyzer.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "check-use-macros", :ns "cljs.analyzer", :row 2800} {:arglist-strs ["[{:keys [name uses use-macros] :as ast} env]"], :end-row 2829, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "check-use-macros-inferring-missing", :ns "cljs.analyzer", :row 2813} {:arglist-strs ["[{:keys [name renames] :as ast} env]"], :end-row 2848, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "check-rename-macros-inferring-missing", :ns "cljs.analyzer", :row 2831} {:arglist-strs ["[spec msg]"], :end-row 2851, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "parse-ns-error-msg", :ns "cljs.analyzer", :row 2850} {:arglist-strs ["[env macros? spec]"], :end-row 2881, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "basic-validate-ns-spec", :ns "cljs.analyzer", :row 2853} {:arglist-strs ["[env args]"], :end-row 2921, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "parse-ns-excludes", :ns "cljs.analyzer", :row 2883} {:arglist-strs ["[env [lib & filters :as spec]]"], :end-row 2955, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "use->require", :ns "cljs.analyzer", :row 2923} {:arglist-strs ["[env macros? deps aliases spec]"], :end-row 3011, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :cljs, :name "parse-require-spec", :ns "cljs.analyzer", :row 2957} {:arglist-strs ["[env deps spec]"], :end-row 3031, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "parse-import-spec", :ns "cljs.analyzer", :row 3013} {:fixed-arities #{1}, :end-row 3048, :ns "cljs.analyzer", :name "macro-autoload-ns?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[form]"], :doc "Given a spec form check whether the spec namespace requires a macro file\n   of the same name. If so return true.", :row 3035} {:fixed-arities #{1}, :end-row 3057, :ns "cljs.analyzer", :name "clj-ns->cljs-ns", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym]"], :doc "Given a symbol that starts with clojure as the first segment return the\n   same symbol with the first segment replaced with cljs", :row 3050} {:arglist-strs ["[specs]"], :end-row 3097, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "canonicalize-specs", :ns "cljs.analyzer", :row 3091} {:arglist-strs ["[specs]"], :end-row 3104, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "canonicalize-import-specs", :ns "cljs.analyzer", :row 3099} {:fixed-arities #{1}, :end-row 3155, :ns "cljs.analyzer", :name "desugar-ns-specs", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[args]"], :doc "Given an original set of ns specs desugar :include-macros and :refer-macros\n   usage into only primitive spec forms - :use, :require, :use-macros,\n   :require-macros. If a library includes a macro file of with the same name\n   as the namespace will also be desugared.", :row 3106} {:arglist-strs ["[env ns segments]"], :end-row 3166, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "find-def-clash", :ns "cljs.analyzer", :row 3157} {:arglist-strs ["[name]"], :end-row 3173, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "macro-ns-name", :ns "cljs.analyzer", :row 3168} {:fixed-arities #{3}, :end-row 3189, :private true, :ns "cljs.analyzer", :name "check-duplicate-aliases", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env old new]"], :row 3175} {:fixed-arities #{3}, :end-row 3205, :private true, :ns "cljs.analyzer", :name "merge-ns-info", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[old new env]"], :row 3191} {:arglist-strs ["[op env [_ tsym fields pmasks body :as form]]"], :end-row 3434, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "parse-type", :ns "cljs.analyzer", :row 3399} {:fixed-arities #{1}, :end-row 3446, :private true, :ns "cljs.analyzer", :name "property-symbol?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[%1]"], :row 3446} {:fixed-arities #{1}, :end-row 3457, :private true, :ns "cljs.analyzer", :name "classify-dot-form", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[[target member args]]"], :row 3448} {:end-row 3459, :filename "cljs/analyzer.cljc", :lang :cljs, :name "build-dot-form", :ns "cljs.analyzer", :row 3459} {:fixed-arities #{3}, :end-row 3480, :private true, :ns "cljs.analyzer", :name "build-method-call", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[target meth args]"], :doc "Builds the intermediate method call map used to reason about the parsed form during\n  compilation.", :row 3474} {:arglist-strs ["[env target field member+ form]"], :end-row 3572, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :cljs, :name "analyze-dot", :ns "cljs.analyzer", :row 3511} {:arglist-strs ["[form]"], :end-row 3583, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "get-js-tag", :ns "cljs.analyzer", :row 3578} {:arglist-strs ["[env s]"], :end-row 3595, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "js-star-interp", :ns "cljs.analyzer", :row 3585} {:arglist-strs ["[s]"], :end-row 3605, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "js-star-seg", :ns "cljs.analyzer", :row 3597} {:end-row 3607, :filename "cljs/analyzer.cljc", :lang :cljs, :name "NUMERIC_SET", :ns "cljs.analyzer", :row 3607} {:arglist-strs ["[t]"], :end-row 3629, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "numeric-type?", :ns "cljs.analyzer", :row 3609} {:end-row 3632, :filename "cljs/analyzer.cljc", :lang :cljs, :name "array-types", :ns "cljs.analyzer", :row 3631} {:arglist-strs ["[t]"], :end-row 3650, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "array-type?", :ns "cljs.analyzer", :row 3634} {:fixed-arities #{3}, :end-row 3660, :private true, :ns "cljs.analyzer", :name "analyze-js-star-args", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[js-op env args]"], :row 3652} {:arglist-strs ["[env jsform args form]"], :end-row 3689, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze-js-star*", :ns "cljs.analyzer", :row 3662} {:arglist-strs ["[env jsform args form]"], :end-row 3692, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze-js-star", :ns "cljs.analyzer", :row 3691} {:fixed-arities #{1}, :end-row 3718, :private true, :ns "cljs.analyzer", :name "unsorted-map?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :row 3716} {:fixed-arities #{1}, :end-row 3726, :ns "cljs.analyzer", :name "analyzed", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :doc "Mark a form as being analyzed. Assumes x satisfies IMeta. Useful to suppress\n  warnings that will have been caught by a first compiler pass.", :row 3720} {:fixed-arities #{1}, :end-row 3735, :ns "cljs.analyzer", :name "analyzed?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[x]"], :doc "Returns boolean if the form has already been marked as analyzed.", :row 3728} {:fixed-arities #{1}, :end-row 3740, :private true, :ns "cljs.analyzer", :name "all-values?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[exprs]"], :row 3737} {:fixed-arities #{2}, :end-row 3746, :private true, :ns "cljs.analyzer", :name "valid-arity?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[argc method-params]"], :row 3742} {:fixed-arities #{1}, :end-row 3752, :private true, :ns "cljs.analyzer", :name "record-tag?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[tag]"], :row 3748} {:fixed-arities #{1}, :end-row 3758, :private true, :ns "cljs.analyzer", :name "record-basis", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[tag]"], :row 3754} {:fixed-arities #{2}, :end-row 3763, :private true, :ns "cljs.analyzer", :name "record-with-field?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[tag field]"], :row 3760} {:fixed-arities #{4}, :end-row 3768, :private true, :ns "cljs.analyzer", :name "invalid-arity?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[argc method-params variadic max-fixed-arity]"], :row 3765} {:arglist-strs ["[env [f & args :as form]]"], :end-row 3832, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "parse-invoke*", :ns "cljs.analyzer", :row 3770} {:arglist-strs ["[env form]"], :end-row 3836, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "parse-invoke", :ns "cljs.analyzer", :row 3834} {:arglist-strs ["[{:keys [op] :as expr}]"], :end-row 3862, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "desugar-dotted-expr", :ns "cljs.analyzer", :row 3838} {:fixed-arities #{2}, :end-row 3913, :ns "cljs.analyzer", :name "analyze-symbol", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env sym]"], :doc "Finds the var associated with sym", :row 3865} {:arglist-strs ["[env sym]"], :end-row 3919, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "excluded?", :ns "cljs.analyzer", :row 3915} {:arglist-strs ["[env sym]"], :end-row 3925, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "used?", :ns "cljs.analyzer", :row 3921} {:arglist-strs ["[env nstr]"], :end-row 3940, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-expander-ns", :ns "cljs.analyzer", :row 3927} {:arglist-strs ["[sym env]"], :end-row 3965, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-expander*", :ns "cljs.analyzer", :row 3942} {:fixed-arities #{2}, :end-row 3975, :ns "cljs.analyzer", :name "get-expander", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[sym env]"], :doc "Given a sym, a symbol identifying a macro, and env, an analysis environment\n   return the corresponding Clojure macroexpander.", :row 3967} {:arglist-strs ["[]"], :end-row 3981, :filename "cljs/analyzer.cljc", :fixed-arities #{0}, :lang :cljs, :name "get-macroexpand-check-var", :ns "cljs.analyzer", :row 3979} {:fixed-arities #{1}, :end-row 3985, :private true, :ns "cljs.analyzer", :name "var->sym", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[var]"], :row 3983} {:fixed-arities #{3}, :end-row 3997, :private true, :ns "cljs.analyzer", :name "do-macroexpand-check", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env form mac-var]"], :row 3987} {:fixed-arities #{2}, :end-row 4008, :private true, :ns "cljs.analyzer", :name "check-macro-arity", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[mac-var form]"], :row 4000} {:arglist-strs ["[env form]"], :end-row 4068, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "macroexpand-1*", :ns "cljs.analyzer", :row 4010} {:fixed-arities #{2}, :end-row 4074, :ns "cljs.analyzer", :name "macroexpand-1", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env form]"], :doc "Given a env, an analysis environment, and form, a ClojureScript form,\n   macroexpand the form once.", :row 4070} {:end-row 4076, :filename "cljs/analyzer.cljc", :lang :cljs, :name "analyze-list", :ns "cljs.analyzer", :row 4076} {:arglist-strs ["[op env form name opts]"], :end-row 4081, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :cljs, :name "analyze-seq*", :ns "cljs.analyzer", :row 4078} {:arglist-strs ["[op env form name opts]"], :end-row 4085, :filename "cljs/analyzer.cljc", :fixed-arities #{5}, :lang :cljs, :name "analyze-seq*-wrap", :ns "cljs.analyzer", :row 4083} {:arglist-strs ["[env form name]" "[env form name opts]"], :end-row 4110, :filename "cljs/analyzer.cljc", :fixed-arities #{4 3}, :lang :cljs, :name "analyze-seq", :ns "cljs.analyzer", :row 4087} {:arglist-strs ["[env form]"], :end-row 4120, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-map", :ns "cljs.analyzer", :row 4112} {:arglist-strs ["[env form]"], :end-row 4128, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-list", :ns "cljs.analyzer", :row 4124} {:arglist-strs ["[env form]"], :end-row 4134, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-vector", :ns "cljs.analyzer", :row 4130} {:arglist-strs ["[env form]"], :end-row 4140, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-set", :ns "cljs.analyzer", :row 4136} {:arglist-strs ["[env form]"], :end-row 4164, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-js-value", :ns "cljs.analyzer", :row 4142} {:arglist-strs ["[x]"], :end-row 4172, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "record-ns+name", :ns "cljs.analyzer", :row 4166} {:arglist-strs ["[env x]"], :end-row 4184, :filename "cljs/analyzer.cljc", :fixed-arities #{2}, :lang :cljs, :name "analyze-record", :ns "cljs.analyzer", :row 4174} {:arglist-strs ["[m]"], :end-row 4187, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "elide-reader-meta", :ns "cljs.analyzer", :row 4186} {:arglist-strs ["[m]"], :end-row 4190, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "elide-analyzer-meta", :ns "cljs.analyzer", :row 4189} {:arglist-strs ["[m]"], :end-row 4193, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "elide-irrelevant-meta", :ns "cljs.analyzer", :row 4192} {:arglist-strs ["[expr]"], :end-row 4204, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "analyze-wrap-meta", :ns "cljs.analyzer", :row 4195} {:arglist-strs ["[env {:keys [tag] :as ast} _]"], :end-row 4217, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "infer-type", :ns "cljs.analyzer", :row 4206} {:fixed-arities #{2}, :end-row 4220, :private true, :ns "cljs.analyzer", :name "repl-self-require?", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env deps]"], :row 4219} {:end-row 4277, :filename "cljs/analyzer.cljc", :lang :cljs, :name "invoke-arg-type-validators", :ns "cljs.analyzer", :row 4267} {:arglist-strs ["[env {:keys [op] :as ast} opts]"], :end-row 4290, :filename "cljs/analyzer.cljc", :fixed-arities #{3}, :lang :cljs, :name "check-invoke-arg-types", :ns "cljs.analyzer", :row 4279} {:arglist-strs ["[env form name opts]"], :end-row 4335, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze-form", :ns "cljs.analyzer", :row 4316} {:end-row 4339, :filename "cljs/analyzer.cljc", :lang :cljs, :name "default-passes", :ns "cljs.analyzer", :row 4337} {:arglist-strs ["[env form name opts]"], :end-row 4350, :filename "cljs/analyzer.cljc", :fixed-arities #{4}, :lang :cljs, :name "analyze*", :ns "cljs.analyzer", :row 4341} {:fixed-arities #{4 3 2}, :end-row 4369, :ns "cljs.analyzer", :name "analyze", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[env form]" "[env form name]" "[env form name opts]"], :doc "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n  (one of :statement, :expr, :return), :ns (a symbol naming the\n  compilation ns)}, and form, returns an expression object (a map\n  containing at least :form, :op and :env keys). If expr has any (immediately)\n  nested exprs, must have a :children entry. This must be a vector of keywords naming\n  the immediately nested fields mapped to an expr or vector of exprs. This will\n  facilitate code walking without knowing the details of the op set.", :row 4352} {:fixed-arities #{2}, :end-row 4384, :ns "cljs.analyzer", :name "add-consts", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[compiler-state constants-map]"], :doc "Given a compiler state and a map from fully qualified symbols to constant\n  EDN values, update the compiler state marking these vars as const to support\n  direct substitution of these vars in source.", :row 4371} {:arglist-strs ["[sym]"], :end-row 4400, :filename "cljs/analyzer.cljc", :fixed-arities #{1}, :lang :cljs, :name "resolve-symbol", :ns "cljs.analyzer", :row 4394} {:fixed-arities #{1}, :end-row 4407, :ns "cljs.analyzer", :name "get-aliases", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Get all alias maps for a namespace.", :row 4402} {:fixed-arities #{0}, :end-row 4717, :private true, :ns "cljs.analyzer", :name "get-spec-vars", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[]"], :row 4714} {:fixed-arities #{1}, :end-row 4739, :ns "cljs.analyzer", :name "dump-specs", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Dumps registered speced vars for a given namespace into the compiler\n  environment.", :row 4719} {:fixed-arities #{1}, :end-row 4754, :ns "cljs.analyzer", :name "register-specs", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[cached-ns]"], :doc "Registers speced vars found in a namespace analysis cache.", :row 4741} {:arglist-strs ["[forms]" "[forms opts]" "[forms opts return-last?]"], :end-row 4829, :filename "cljs/analyzer.cljc", :fixed-arities #{1 3 2}, :lang :cljs, :name "analyze-form-seq", :ns "cljs.analyzer", :row 4804} {:fixed-arities #{1}, :end-row 4835, :ns "cljs.analyzer", :name "ensure-defs", :lang :cljs, :filename "cljs/analyzer.cljc", :arglist-strs ["[ns]"], :doc "Ensures that a non-nil defs map exists in the compiler state for a given\n  ns. (A non-nil defs map signifies that the namespace has been analyzed.)", :row 4831}]} {:end-row 13, :filename "cljs/instant.clj", :name "cljs.instant", :row 9, :ns nil, :var-definitions [{:end-row 20, :filename "cljs/instant.clj", :name "utc-format", :ns "cljs.instant", :private true, :row 17} {:arglist-strs ["[s]"], :end-row 23, :filename "cljs/instant.clj", :fixed-arities #{1}, :name "remove-last-char", :ns "cljs.instant", :private true, :row 22} {:fixed-arities #{2}, :end-row 30, :private true, :ns "cljs.instant", :name "print-instant", :filename "cljs/instant.clj", :arglist-strs ["[instant w]"], :doc "Print a java.time.Instant as RFC3339 timestamp, always in UTC.", :row 25} {:fixed-arities #{10}, :end-row 46, :private true, :ns "cljs.instant", :name "construct-instant", :filename "cljs/instant.clj", :arglist-strs ["[years months days hours minutes seconds nanoseconds offset-sign offset-hours offset-minutes]"], :doc "Construct a java.time.Instant, which has nanosecond precision.", :row 40} {:arglist-strs ["[cs]"], :doc "To read an instant as a java.time.Instant, bind *data-readers* to a\n  map with this var as the value for the 'inst key. Instant preserves\n  fractional seconds with nanosecond precision. The timezone offset will\n  be used to convert into UTC.", :end-row 54, :filename "cljs/instant.clj", :fixed-arities #{1}, :name "read-instant-instant", :ns "cljs.instant", :row 48}]} {:end-row 23, :filename "cljs/cli.clj", :name "cljs.cli", :row 9, :ns nil, :var-definitions [{:end-row 25, :filename "cljs/cli.clj", :name "main", :ns "cljs.cli", :row 25} {:end-row 51, :filename "cljs/cli.clj", :name "help-template", :ns "cljs.cli", :private true, :row 30} {:arglist-strs ["[ws]" "[ws max-len]"], :end-row 69, :filename "cljs/cli.clj", :fixed-arities #{1 2}, :name "auto-fill", :ns "cljs.cli", :private true, :row 53} {:arglist-strs ["[cs {:keys [arg doc]}]"], :end-row 89, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "opt->str", :ns "cljs.cli", :private true, :row 71} {:arglist-strs ["[options group]"], :end-row 99, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "group->str", :ns "cljs.cli", :private true, :row 91} {:arglist-strs ["[options]"], :end-row 105, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "primary-groups-str", :ns "cljs.cli", :private true, :row 101} {:arglist-strs ["[{:keys [groups] :as options}]"], :end-row 116, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "all-groups-str", :ns "cljs.cli", :private true, :row 107} {:arglist-strs ["[options]"], :end-row 127, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "main-str", :ns "cljs.cli", :private true, :row 118} {:arglist-strs ["[options]"], :end-row 132, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "options-str", :ns "cljs.cli", :private true, :row 129} {:end-row 134, :filename "cljs/cli.clj", :name "merged-commands", :ns "cljs.cli", :row 134} {:arglist-strs ["[repl-env]"], :end-row 138, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "help-str", :ns "cljs.cli", :row 136} {:arglist-strs ["[cfg output-dir]"], :end-row 145, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "output-dir-opt", :ns "cljs.cli", :private true, :row 143} {:arglist-strs ["[cfg value]"], :end-row 149, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "verbose-opt", :ns "cljs.cli", :private true, :row 147} {:arglist-strs ["[[path :as paths]]"], :end-row 172, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "validate-watch-paths", :ns "cljs.cli", :private true, :row 151} {:arglist-strs ["[cfg paths]"], :end-row 178, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "watch-opt", :ns "cljs.cli", :private true, :row 174} {:arglist-strs ["[cfg level]"], :end-row 182, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "optimize-opt", :ns "cljs.cli", :private true, :row 180} {:arglist-strs ["[cfg path]"], :end-row 186, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "output-to-opt", :ns "cljs.cli", :private true, :row 184} {:arglist-strs ["[cfg deps-cmd]"], :end-row 190, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "deps-cmd-opt", :ns "cljs.cli", :private true, :row 188} {:arglist-strs ["[cfg target]"], :end-row 195, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "target-opt", :ns "cljs.cli", :private true, :row 192} {:arglist-strs ["[x]"], :end-row 201, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "missing-file", :ns "cljs.cli", :row 197} {:arglist-strs ["[x]"], :end-row 211, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "missing-resource", :ns "cljs.cli", :row 203} {:arglist-strs ["[str]"], :end-row 225, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "read-edn-opts", :ns "cljs.cli", :row 213} {:arglist-strs ["[str]"], :end-row 228, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "load-edn-opts", :ns "cljs.cli", :row 227} {:arglist-strs ["[cfg ropts]"], :end-row 236, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "repl-env-opts-opt", :ns "cljs.cli", :private true, :row 230} {:arglist-strs ["[cfg copts]"], :end-row 244, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "compile-opts-opt", :ns "cljs.cli", :private true, :row 238} {:arglist-strs ["[cfg file]"], :end-row 263, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "init-opt", :ns "cljs.cli", :private true, :row 246} {:arglist-strs ["[cfg form-str]"], :end-row 270, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "eval-opt", :ns "cljs.cli", :private true, :row 265} {:arglist-strs ["[commands k opt]" "[commands k opt default]"], :end-row 277, :filename "cljs/cli.clj", :fixed-arities #{4 3}, :name "get-dispatch", :ns "cljs.cli", :row 272} {:arglist-strs ["[inits commands]"], :doc "Common initialize routine for repl, script, and null opts", :end-row 285, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "initialize", :ns "cljs.cli", :row 279} {:arglist-strs ["[]"], :end-row 291, :filename "cljs/cli.clj", :fixed-arities #{0}, :name "temp-out-dir", :ns "cljs.cli", :row 287} {:arglist-strs ["[repl-env]"], :end-row 296, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "repl-name", :ns "cljs.cli", :private true, :row 293} {:arglist-strs ["[repl-env options inits]"], :end-row 303, :filename "cljs/cli.clj", :fixed-arities #{3}, :name "fast-initial-prompt?", :ns "cljs.cli", :private true, :row 298} {:arglist-strs ["[target default]"], :end-row 310, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "target->repl-env", :ns "cljs.cli", :row 305} {:fixed-arities #{3}, :end-row 341, :private true, :ns "cljs.cli", :name "repl-opt", :filename "cljs/cli.clj", :arglist-strs ["[repl-env [_ & args] {:keys [repl-env-options options inits] :as cfg}]"], :doc "Start a repl with args and inits. Print greeting if no eval options were\npresent", :row 312} {:arglist-strs ["[repl-env {:keys [main script args repl-env-options options inits] :as cfg}]"], :end-row 431, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "default-main", :ns "cljs.cli", :row 343} {:fixed-arities #{3}, :end-row 438, :private true, :ns "cljs.cli", :name "main-opt", :filename "cljs/cli.clj", :arglist-strs ["[repl-env [_ ns & args] cfg]"], :doc "Call the -main function from a namespace with string arguments from\n  the command line.", :row 433} {:fixed-arities #{3}, :end-row 444, :private true, :ns "cljs.cli", :name "null-opt", :filename "cljs/cli.clj", :arglist-strs ["[repl-env args cfg]"], :doc "No repl or script opt present, just bind args and run inits", :row 440} {:arglist-strs ["[repl-env _ _]"], :end-row 448, :filename "cljs/cli.clj", :fixed-arities #{3}, :name "help-opt", :ns "cljs.cli", :private true, :row 446} {:arglist-strs ["[repl-env [path & args] cfg]"], :end-row 453, :filename "cljs/cli.clj", :fixed-arities #{3}, :name "script-opt", :ns "cljs.cli", :private true, :row 450} {:arglist-strs ["[cenv path opts]"], :end-row 462, :filename "cljs/cli.clj", :fixed-arities #{3}, :name "watch-proc", :ns "cljs.cli", :row 455} {:arglist-strs ["[_ [_ address-port & args] {:keys [options] :as cfg}]"], :end-row 475, :filename "cljs/cli.clj", :fixed-arities #{3}, :name "serve-opt", :ns "cljs.cli", :private true, :row 464} {:arglist-strs ["[_ _ {:keys [options] :as cfg}]"], :end-row 479, :filename "cljs/cli.clj", :fixed-arities #{3}, :name "install-deps-opt", :ns "cljs.cli", :private true, :row 477} {:arglist-strs ["[{:keys [ns options] :as cfg}]"], :end-row 484, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "get-main-ns", :ns "cljs.cli", :row 481} {:arglist-strs ["[repl-env {:keys [ns args options post-compile-fn] :as cfg}]"], :end-row 538, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "default-compile", :ns "cljs.cli", :row 486} {:arglist-strs ["[repl-env [_ ns & args] cfg]"], :end-row 543, :filename "cljs/cli.clj", :fixed-arities #{3}, :name "compile-opt", :ns "cljs.cli", :private true, :row 540} {:arglist-strs ["[commands k]"], :end-row 549, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "get-options", :ns "cljs.cli", :row 545} {:arglist-strs ["[commands]"], :end-row 557, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "bool-init-options", :ns "cljs.cli", :row 551} {:arglist-strs ["[commands k opt]"], :end-row 560, :filename "cljs/cli.clj", :fixed-arities #{3}, :name "dispatch?", :ns "cljs.cli", :row 559} {:arglist-strs ["[commands]" "[commands {:keys [groups main init]}]"], :end-row 579, :filename "cljs/cli.clj", :fixed-arities #{1 2}, :name "add-commands", :ns "cljs.cli", :row 562} {:end-row 663, :filename "cljs/cli.clj", :name "default-commands", :ns "cljs.cli", :row 581} {:arglist-strs ["[commands args]"], :end-row 686, :filename "cljs/cli.clj", :fixed-arities #{2}, :name "normalize", :ns "cljs.cli", :row 665} {:arglist-strs ["[repl-env]"], :end-row 690, :filename "cljs/cli.clj", :fixed-arities #{1}, :name "merged-commands", :ns "cljs.cli", :row 688} {:arglist-strs ["[repl-env & args]"], :doc "A generic runner for ClojureScript. repl-env must satisfy\n  cljs.repl/IReplEnvOptions and cljs.repl/IJavaScriptEnv protocols. args is a\n  sequence of command line flags.", :end-row 707, :filename "cljs/cli.clj", :name "main", :ns "cljs.cli", :row 692}]} {:author "Stuart Sierra, with contributions and suggestions by \n  Chas Emerick, Allen Rohner, Stuart Halloway, David Nolen, and\n  Leon Grapenthin", :doc "A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \"is\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (= 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \"abcde\" \"ab\"))\n\n   You can type an \"is\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user> (is (= 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (= 5 (+ 2 2))\n         actual: (not (= 5 4))\n       false\n\n   The \"expected:\" line shows you the original expression, and the\n   \"actual:\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n   \"false\" on the last line is the value returned from the\n   expression.  The \"is\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \"(is (thrown? c ...))\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \"(is (thrown-with-msg? c re ...))\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\"Divide by zero\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \"is\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (= 5 (+ 2 2)) \"Crazy arithmetic\")\n\n   In addition, you can document groups of assertions with the\n   \"testing\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \"testing\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec <http://rspec.info/>\n\n   (testing \"Arithmetic\"\n     (testing \"with positive integers\"\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4))))\n     (testing \"with negative integers\"\n       (is (= -4 (+ -2 -2)))\n       (is (= -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \"testing\" macro may only be used\n   INSIDE a \"deftest\" form (see below).\n\n\n   DEFINING TESTS\n\n   (deftest addition\n     (is (= 4 (+ 2 2)))\n     (is (= 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (= 1 (- 4 3)))\n     (is (= 3 (- 7 4))))\n\n   This creates functions named \"addition\" and \"subtraction\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel's \"Practical Common Lisp\"\n   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \"(arithmetic addition)\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n   DEFINING ASYNC TESTS\n\n   (deftest addition\n     (async done\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4)))\n       (done)))\n\n   Async tests are constructed with the async macro. The first argument to\n   the macro is the test completion callback. The body of the async macro may\n   be any series of expressions. The completion callback must be invoked when\n   all assertions have run. There is no support for asynchronous coordination -\n   core.async is recommended for this. Note the body of the async test must be\n   truly asynchronous to avoid stack overflow.\n\n   RUNNING TESTS\n\n   Run tests with the function \"(run-tests namespaces...)\":\n\n   (run-tests 'your.namespace 'some.other.namespace)\n\n   If you don't specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \"(run-all-tests)\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \"arithmetic\" example above, you\n   probably do not want the \"addition\" and \"subtraction\" tests run\n   separately.  In that case, you must define a special function\n   named \"test-ns-hook\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   \"run-tests\" also optionally takes a testing enviroment. A default\n   one is supplied for you by invoking \"empty-env\".  The test\n   environment contains everything needed to run tests including the\n   report results map. Fixtures must be present here if you want them\n   to run. Note that code that relies on \"test-ns\" will\n   automatically be supplied the appropriate defined fixtures.  For\n   example, this is done for you if you use \"run-tests\".\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can set the ClojureScript compiler build option\n   \":load-tests\" to false when loading or compiling code in\n   production.  This will prevent any tests from being created by\n   or \"deftest\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is a map of one or two functions that run code before and\n   after tests.  It looks like this:\n\n   {:before (fn []\n              Perform setup, establish bindings, whatever.\n              )\n    :after (fn []\n             Tear-down / clean-up code here.\n             )}\n\n   Both are optional and can be left out.\n\n   Fixtures are attached to namespaces in one of two ways.  \"each\"\n   fixtures are run repeatedly, once for each test function created\n   with \"deftest\".  \"each\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \"each\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just maps like the example above.\n   They can also be passed directly, like this:\n   (use-fixtures :each\n     {:before (fn [] setup...), :after (fn [] cleanup...)})\n\n   The other kind of fixture, a \"once\" fixture, is only run once,\n   around ALL the tests in the namespace.  \"once\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \"once\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   WRAPPING FIXTURES\n\n   Instead of a map, a fixture can be specified like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   This style is incompatible with async tests. If an async test is\n   encountered, testing will be aborted. It can't be mixed with\n   fixtures specified as maps.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \"is\" macro by defining new\n   methods for the \"assert-expr\" multimethod.  These methods are\n   called during expansion of the \"is\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by specifying a\n   :reporter key in the test environment. It is normally set to\n   :cljs.test/default. Set this to the desired key and supply custom\n   implementations of the \"report\" multimethod.\n\n   The 'event' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to 'is'\n\n   The \"testing\" strings will be a list in the :testing-contexts\n   property of the test environment, and the vars being tested will be\n   a list in the :testing-vars property of the test environment.\n\n   For additional event types, see the examples in the code.\n", :end-row 247, :filename "cljs/test.cljs", :name "cljs.test", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[]" "[reporter]"], :doc "Generates a testing environment with a reporter.\n   (empty-env) - uses the :cljs.test/default reporter.\n   (empty-env :cljs.test/pprint) - pretty prints all data structures. \n   (empty-env reporter) - uses a reporter of your choosing.\n\n   To create your own reporter see cljs.test/report", :end-row 267, :filename "cljs/test.cljs", :fixed-arities #{0 1}, :name "empty-env", :ns "cljs.test", :row 252} {:end-row 269, :filename "cljs/test.cljs", :name "*current-env*", :ns "cljs.test", :row 269} {:arglist-strs ["[]"], :end-row 272, :filename "cljs/test.cljs", :fixed-arities #{0}, :name "get-current-env", :ns "cljs.test", :row 271} {:arglist-strs ["[ks f & args]"], :end-row 275, :filename "cljs/test.cljs", :name "update-current-env!", :ns "cljs.test", :row 274} {:arglist-strs ["[new-env]"], :end-row 278, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "set-env!", :ns "cljs.test", :row 277} {:arglist-strs ["[]"], :end-row 281, :filename "cljs/test.cljs", :fixed-arities #{0}, :name "clear-env!", :ns "cljs.test", :row 280} {:arglist-strs ["[]"], :end-row 287, :filename "cljs/test.cljs", :fixed-arities #{0}, :name "get-and-clear-env!", :ns "cljs.test", :row 283} {:arglist-strs ["[m]"], :doc "Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.", :end-row 297, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "testing-vars-str", :ns "cljs.test", :row 289} {:arglist-strs ["[]"], :doc "Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.", :end-row 303, :filename "cljs/test.cljs", :fixed-arities #{0}, :name "testing-contexts-str", :ns "cljs.test", :row 299} {:arglist-strs ["[name]"], :doc "Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.", :end-row 310, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "inc-report-counter!", :ns "cljs.test", :row 305} {:doc "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.", :end-row 318, :filename "cljs/test.cljs", :name "report", :ns "cljs.test", :row 312} {:arglist-strs ["[m]"], :end-row 328, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "print-comparison", :ns "cljs.test", :private true, :row 325} {:arglist-strs ["[stack-element]"], :end-row 376, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "js-line-and-column", :ns "cljs.test", :row 366} {:arglist-strs ["[stack-element]"], :end-row 386, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "js-filename", :ns "cljs.test", :row 378} {:arglist-strs ["[filename line column]"], :end-row 404, :filename "cljs/test.cljs", :fixed-arities #{3}, :name "mapped-line-and-column", :ns "cljs.test", :row 388} {:arglist-strs ["[exception depth]"], :end-row 418, :filename "cljs/test.cljs", :fixed-arities #{2}, :name "file-and-line", :ns "cljs.test", :row 406} {:arglist-strs ["[m]"], :end-row 425, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "do-report", :ns "cljs.test", :row 420} {:doc "Marker protocol denoting CPS function to begin asynchronous\n  testing.", :end-row 432, :filename "cljs/test.cljs", :name "IAsyncTest", :ns "cljs.test", :row 430} {:arglist-strs ["[x]"], :doc "Returns whether x implements IAsyncTest.", :end-row 437, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "async?", :ns "cljs.test", :row 434} {:arglist-strs ["[fns]"], :doc "Invoke all functions in fns with no arguments. A fn can optionally\n  return\n\n  an async test - is invoked with a continuation running left fns\n\n  a seq of fns tagged per block - are invoked immediately after fn", :end-row 456, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "run-block", :ns "cljs.test", :row 439} {:arglist-strs ["[fns]"], :doc "Tag a seq of fns to be picked up by run-block as injected\n  continuation.  See run-block.", :end-row 463, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "block", :ns "cljs.test", :row 458} {:arglist-strs ["[v t]"], :end-row 487, :filename "cljs/test.cljs", :fixed-arities #{2}, :name "test-var-block*", :ns "cljs.test", :private true, :row 468} {:arglist-strs ["[v]"], :doc "Like test-var, but returns a block for further composition and\n  later execution.", :end-row 494, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "test-var-block", :ns "cljs.test", :row 489} {:arglist-strs ["[v]"], :doc "If v has a function in its :test metadata, calls that function,\n  add v to :testing-vars property of env.", :end-row 500, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "test-var", :ns "cljs.test", :row 496} {:fixed-arities #{1}, :end-row 507, :private true, :ns "cljs.test", :name "default-fixture", :filename "cljs/test.cljs", :arglist-strs ["[f]"], :doc "The default, empty, fixture function.  Just calls its argument.\n\n  NOTE: Incompatible with map fixtures.", :row 502} {:arglist-strs ["[f1 f2]"], :doc "Composes two fixture functions, creating a new fixture function\n  that combines their behavior.\n\n  NOTE: Incompatible with map fixtures.", :end-row 515, :filename "cljs/test.cljs", :fixed-arities #{2}, :name "compose-fixtures", :ns "cljs.test", :row 509} {:arglist-strs ["[fixtures]"], :doc "Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.\n\n  NOTE: Incompatible with map fixtures.", :end-row 523, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "join-fixtures", :ns "cljs.test", :row 517} {:fixed-arities #{2}, :end-row 530, :private true, :ns "cljs.test", :name "wrap-map-fixtures", :filename "cljs/test.cljs", :arglist-strs ["[map-fixtures block]"], :doc "Wraps block in map-fixtures.", :row 525} {:arglist-strs ["[once each]"], :end-row 547, :filename "cljs/test.cljs", :fixed-arities #{2}, :name "execution-strategy", :ns "cljs.test", :private true, :row 532} {:arglist-strs ["[f]"], :end-row 554, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "disable-async", :ns "cljs.test", :private true, :row 549} {:arglist-strs ["[vars]"], :doc "Like test-vars, but returns a block for further composition and\n  later execution.", :end-row 587, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "test-vars-block", :ns "cljs.test", :row 556} {:arglist-strs ["[vars]"], :doc "Groups vars by their namespace and runs test-var on them with\n  appropriate fixtures assuming they are present in the current\n  testing environment.", :end-row 596, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "test-vars", :ns "cljs.test", :row 589} {:arglist-strs ["[summary]"], :doc "Returns true if the given test summary indicates all tests\n  were successful, false otherwise.", :end-row 606, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "successful?", :ns "cljs.test", :row 601} {:fixed-arities #{2}, :end-row 23, :ns "cljs.test", :name "function?", :lang :clj, :filename "cljs/test.cljc", :arglist-strs ["[menv x]"], :doc "Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).", :row 19} {:fixed-arities #{2}, :end-row 46, :ns "cljs.test", :name "assert-predicate", :lang :clj, :filename "cljs/test.cljc", :arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).", :row 25} {:fixed-arities #{2}, :end-row 63, :ns "cljs.test", :name "assert-any", :lang :clj, :filename "cljs/test.cljc", :arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.", :row 48} {:fixed-arities #{0}, :end-row 67, :private true, :ns "cljs.test", :name "cljs-output-dir", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]"], :row 65} {:end-row 81, :filename "cljs/test.cljc", :lang :clj, :name "assert-expr", :ns "cljs.test", :row 76} {:fixed-arities #{2}, :end-row 169, :ns "cljs.test", :name "try-expr", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[msg form]"], :doc "Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.", :row 158} {:fixed-arities #{1 2}, :end-row 190, :ns "cljs.test", :name "is", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[form]" "[form msg]"], :doc "Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.", :row 174} {:end-row 214, :ns "cljs.test", :name "are", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[argv expr & args]"], :doc "Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.", :row 192} {:end-row 225, :ns "cljs.test", :name "testing", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[string & body]"], :doc "Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).", :row 216} {:end-row 246, :ns "cljs.test", :name "deftest", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[name & body]"], :doc "Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored.", :row 230} {:end-row 265, :ns "cljs.test", :name "async", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[done & body]"], :doc "Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))", :row 248} {:arglist-strs ["[x]"], :end-row 271, :filename "cljs/test.cljc", :fixed-arities #{1}, :lang :clj, :name "ns?", :ns "cljs.test", :row 270} {:end-row 306, :ns "cljs.test", :name "run-tests-block", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[env-or-ns & namespaces]"], :doc "Like test-vars, but returns a block for further composition and\n  later execution.", :row 273} {:fixed-arities #{0 1}, :end-row 320, :ns "cljs.test", :name "run-tests", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]" "[env-or-ns]" "[env-or-ns & namespaces]"], :doc "Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod.", :row 308} {:fixed-arities #{0 1 2}, :end-row 334, :ns "cljs.test", :name "run-all-tests", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]" "[re]" "[re env]"], :doc "Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.", :row 322} {:fixed-arities #{1}, :end-row 357, :ns "cljs.test", :name "test-all-vars-block", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[[quote ns]]"], :row 336} {:fixed-arities #{1}, :end-row 366, :ns "cljs.test", :name "test-all-vars", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[[quote ns :as form]]"], :doc "Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures.", :row 359} {:fixed-arities #{2}, :end-row 383, :ns "cljs.test", :name "test-ns-block", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[env [quote ns :as form]]"], :doc "Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env.", :row 368} {:fixed-arities #{1 2}, :end-row 397, :ns "cljs.test", :name "test-ns", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[ns]" "[env [quote ns :as form]]"], :doc "If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  ", :row 385} {:arglist-strs ["[type & fns]"], :end-row 412, :filename "cljs/test.cljc", :lang :clj, :macro true, :name "use-fixtures", :ns "cljs.test", :row 402} {:fixed-arities #{2}, :end-row 23, :ns "cljs.test", :name "function?", :lang :cljs, :filename "cljs/test.cljc", :arglist-strs ["[menv x]"], :doc "Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).", :row 19} {:fixed-arities #{2}, :end-row 46, :ns "cljs.test", :name "assert-predicate", :lang :cljs, :filename "cljs/test.cljc", :arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).", :row 25} {:fixed-arities #{2}, :end-row 63, :ns "cljs.test", :name "assert-any", :lang :cljs, :filename "cljs/test.cljc", :arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.", :row 48} {:fixed-arities #{0}, :end-row 67, :private true, :ns "cljs.test", :name "cljs-output-dir", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]"], :row 65} {:end-row 81, :filename "cljs/test.cljc", :lang :cljs, :name "assert-expr", :ns "cljs.test", :row 76} {:fixed-arities #{2}, :end-row 169, :ns "cljs.test", :name "try-expr", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[msg form]"], :doc "Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.", :row 158} {:fixed-arities #{1 2}, :end-row 190, :ns "cljs.test", :name "is", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[form]" "[form msg]"], :doc "Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.", :row 174} {:end-row 214, :ns "cljs.test", :name "are", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[argv expr & args]"], :doc "Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.", :row 192} {:end-row 225, :ns "cljs.test", :name "testing", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[string & body]"], :doc "Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).", :row 216} {:end-row 246, :ns "cljs.test", :name "deftest", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[name & body]"], :doc "Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored.", :row 230} {:end-row 265, :ns "cljs.test", :name "async", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[done & body]"], :doc "Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))", :row 248} {:arglist-strs ["[x]"], :end-row 271, :filename "cljs/test.cljc", :fixed-arities #{1}, :lang :cljs, :name "ns?", :ns "cljs.test", :row 270} {:end-row 306, :ns "cljs.test", :name "run-tests-block", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[env-or-ns & namespaces]"], :doc "Like test-vars, but returns a block for further composition and\n  later execution.", :row 273} {:fixed-arities #{0 1}, :end-row 320, :ns "cljs.test", :name "run-tests", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]" "[env-or-ns]" "[env-or-ns & namespaces]"], :doc "Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod.", :row 308} {:fixed-arities #{0 1 2}, :end-row 334, :ns "cljs.test", :name "run-all-tests", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]" "[re]" "[re env]"], :doc "Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.", :row 322} {:fixed-arities #{1}, :end-row 357, :ns "cljs.test", :name "test-all-vars-block", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[[quote ns]]"], :row 336} {:fixed-arities #{1}, :end-row 366, :ns "cljs.test", :name "test-all-vars", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[[quote ns :as form]]"], :doc "Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures.", :row 359} {:fixed-arities #{2}, :end-row 383, :ns "cljs.test", :name "test-ns-block", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[env [quote ns :as form]]"], :doc "Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env.", :row 368} {:fixed-arities #{1 2}, :end-row 397, :ns "cljs.test", :name "test-ns", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[ns]" "[env [quote ns :as form]]"], :doc "If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  ", :row 385} {:arglist-strs ["[type & fns]"], :end-row 412, :filename "cljs/test.cljc", :lang :cljs, :macro true, :name "use-fixtures", :ns "cljs.test", :row 402}]} {:end-row 14, :filename "cljs/module_graph.cljc", :lang :clj, :name "cljs.module-graph", :row 9, :ns nil, :var-definitions [{:fixed-arities #{2}, :end-row 43, :ns "cljs.module-graph", :name "find-sources-for-module-entry", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry sources]"], :doc "Given an entry as a symbol, find all matching inputs in sources. If the\n  symbol ends in a *, then the symbol will be treated as a wildcard. This\n  function returns a set and is not order preserving. If there are no matches\n  returns nil.", :row 16} {:fixed-arities #{1}, :end-row 56, :ns "cljs.module-graph", :name "normalize", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Normalize compiler :modules. All symbols in a module :entries will be\n  converted into munged strings.", :row 47} {:fixed-arities #{1}, :end-row 63, :ns "cljs.module-graph", :name "add-cljs-base", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Adds :cljs-base module to compiler :modules if not already present.", :row 58} {:fixed-arities #{1}, :end-row 74, :ns "cljs.module-graph", :name "add-cljs-base-dep", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Adds :cljs-base to any module in compiler :modules with an empty :depends-on.", :row 65} {:fixed-arities #{2}, :end-row 86, :ns "cljs.module-graph", :name "depth-of", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[module-name modules]"], :doc "Compute the depth of module-name based on dependency information in\n   compiler :modules.", :row 76} {:fixed-arities #{1}, :end-row 95, :ns "cljs.module-graph", :name "annotate-depths", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Annotate all modules in compiler :modules with depth information.", :row 88} {:arglist-strs ["[input]"], :end-row 100, :filename "cljs/module_graph.cljc", :fixed-arities #{1}, :lang :clj, :name "normalize-input", :ns "cljs.module-graph", :row 97} {:fixed-arities #{1}, :end-row 116, :ns "cljs.module-graph", :name "index-inputs", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[inputs]"], :doc "Index compiler inputs by :provides. If an input has multiple entries\n  in :provides will result in multiple entries in the map. The keys will be munged\n  strings not symbols.", :row 102} {:arglist-strs ["[indexed path seen validated]"], :end-row 132, :filename "cljs/module_graph.cljc", :fixed-arities #{4}, :lang :clj, :name "validate-inputs*", :ns "cljs.module-graph", :row 118} {:fixed-arities #{1 3}, :end-row 145, :ns "cljs.module-graph", :name "validate-inputs", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[inputs]" "[inputs path seen]"], :doc "Throws on the presence of circular dependencies", :row 134} {:fixed-arities #{3}, :end-row 157, :ns "cljs.module-graph", :name "deps-for", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[x graph deps-key]"], :doc "Return all dependencies for x in a graph using deps-key.", :row 147} {:fixed-arities #{2}, :end-row 162, :ns "cljs.module-graph", :name "deps-for-entry", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry indexed-inputs]"], :doc "Return all dependencies for an entry using a compiler inputs index.", :row 159} {:fixed-arities #{2}, :end-row 167, :ns "cljs.module-graph", :name "deps-for-module", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[module modules]"], :doc "Return all dependencies of a module using compiler :modules.", :row 164} {:fixed-arities #{2}, :end-row 178, :ns "cljs.module-graph", :name "deepest-common-parent", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules all-modules]"], :doc "Given a set of modules and a compiler :modules graph, compute the deepest\n  common parent module.", :row 169} {:fixed-arities #{2}, :end-row 186, :ns "cljs.module-graph", :name "canonical-name", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry indexed-inputs]"], :doc "Given an entry use indexed-inputs to return the canonical name. Throws if\n   entry cannot be found.", :row 180} {:fixed-arities #{2}, :end-row 204, :ns "cljs.module-graph", :name "validate-modules", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules indexed-inputs]"], :doc "Check that a compiler :modules map does not contain user supplied duplicates.\n   Throws if modules fails validation.", :row 188} {:fixed-arities #{2}, :end-row 248, :ns "cljs.module-graph", :name "inputs->assigned-modules", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[inputs modules]"], :doc "Given compiler inputs assign each to a single module. This is done by first\n  starting with :entries. Dependencies for every entry in a module are also added\n  to that module. Inputs may of course be assigned to several modules initially\n  but we must eventually choose one. User supplied module :entries are respected\n  but all other input assignments are computed automatically via\n  deepest-common-parent. This function returns a map assigning all inputs (indexed\n  by munged name) to a single module. Any orphan inputs will be assigned to\n  :cljs-base.", :row 206} {:fixed-arities #{2}, :end-row 272, :ns "cljs.module-graph", :name "expand-modules", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules inputs]"], :doc "Given compiler :modules and a dependency sorted list of compiler inputs return\n   a complete :modules map where all depended upon inputs are assigned.", :row 250} {:fixed-arities #{2}, :end-row 294, :ns "cljs.module-graph", :name "topo-sort", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[graph edges-key]"], :doc "Topologically sort a graph using the given edges-key.", :row 282} {:arglist-strs ["[modules-with-base]"], :end-row 298, :filename "cljs/module_graph.cljc", :fixed-arities #{1}, :lang :clj, :name "sort-modules", :ns "cljs.module-graph", :row 296} {:end-row 313, :filename "cljs/module_graph.cljc", :lang :clj, :name "ms", :ns "cljs.module-graph", :row 301} {:arglist-strs ["[f0 f1]"], :end-row 319, :filename "cljs/module_graph.cljc", :fixed-arities #{2}, :lang :clj, :name "parent?", :ns "cljs.module-graph", :row 316} {:arglist-strs ["[{:keys [lib-path] :as ijs} {:keys [output-dir] :as opts}]"], :end-row 331, :filename "cljs/module_graph.cljc", :fixed-arities #{2}, :lang :clj, :name "maybe-add-out-file", :ns "cljs.module-graph", :row 325} {:fixed-arities #{3}, :end-row 380, :ns "cljs.module-graph", :name "modules->module-uris", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules inputs {:keys [optimizations asset-path output-dir] :as opts}]"], :doc "Given a :modules map, a dependency sorted list of compiler inputs, and\n   compiler options return a Closure module uris map. This map will include\n   all inputs by leveraging expand-modules.", :row 333} {:fixed-arities #{1}, :end-row 390, :ns "cljs.module-graph", :name "modules->module-infos", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Given a :modules map return a Closure module info map which maps modules\n   to depended upon modules.", :row 382} {:fixed-arities #{2}, :end-row 402, :ns "cljs.module-graph", :name "module-for", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry modules]"], :doc "Given an entry find the module it belongs to.", :row 392} {:fixed-arities #{2}, :end-row 43, :ns "cljs.module-graph", :name "find-sources-for-module-entry", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry sources]"], :doc "Given an entry as a symbol, find all matching inputs in sources. If the\n  symbol ends in a *, then the symbol will be treated as a wildcard. This\n  function returns a set and is not order preserving. If there are no matches\n  returns nil.", :row 16} {:fixed-arities #{1}, :end-row 56, :ns "cljs.module-graph", :name "normalize", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Normalize compiler :modules. All symbols in a module :entries will be\n  converted into munged strings.", :row 47} {:fixed-arities #{1}, :end-row 63, :ns "cljs.module-graph", :name "add-cljs-base", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Adds :cljs-base module to compiler :modules if not already present.", :row 58} {:fixed-arities #{1}, :end-row 74, :ns "cljs.module-graph", :name "add-cljs-base-dep", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Adds :cljs-base to any module in compiler :modules with an empty :depends-on.", :row 65} {:fixed-arities #{2}, :end-row 86, :ns "cljs.module-graph", :name "depth-of", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[module-name modules]"], :doc "Compute the depth of module-name based on dependency information in\n   compiler :modules.", :row 76} {:fixed-arities #{1}, :end-row 95, :ns "cljs.module-graph", :name "annotate-depths", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Annotate all modules in compiler :modules with depth information.", :row 88} {:arglist-strs ["[input]"], :end-row 100, :filename "cljs/module_graph.cljc", :fixed-arities #{1}, :lang :cljs, :name "normalize-input", :ns "cljs.module-graph", :row 97} {:fixed-arities #{1}, :end-row 116, :ns "cljs.module-graph", :name "index-inputs", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[inputs]"], :doc "Index compiler inputs by :provides. If an input has multiple entries\n  in :provides will result in multiple entries in the map. The keys will be munged\n  strings not symbols.", :row 102} {:arglist-strs ["[indexed path seen validated]"], :end-row 132, :filename "cljs/module_graph.cljc", :fixed-arities #{4}, :lang :cljs, :name "validate-inputs*", :ns "cljs.module-graph", :row 118} {:fixed-arities #{1 3}, :end-row 145, :ns "cljs.module-graph", :name "validate-inputs", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[inputs]" "[inputs path seen]"], :doc "Throws on the presence of circular dependencies", :row 134} {:fixed-arities #{3}, :end-row 157, :ns "cljs.module-graph", :name "deps-for", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[x graph deps-key]"], :doc "Return all dependencies for x in a graph using deps-key.", :row 147} {:fixed-arities #{2}, :end-row 162, :ns "cljs.module-graph", :name "deps-for-entry", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry indexed-inputs]"], :doc "Return all dependencies for an entry using a compiler inputs index.", :row 159} {:fixed-arities #{2}, :end-row 167, :ns "cljs.module-graph", :name "deps-for-module", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[module modules]"], :doc "Return all dependencies of a module using compiler :modules.", :row 164} {:fixed-arities #{2}, :end-row 178, :ns "cljs.module-graph", :name "deepest-common-parent", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules all-modules]"], :doc "Given a set of modules and a compiler :modules graph, compute the deepest\n  common parent module.", :row 169} {:fixed-arities #{2}, :end-row 186, :ns "cljs.module-graph", :name "canonical-name", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry indexed-inputs]"], :doc "Given an entry use indexed-inputs to return the canonical name. Throws if\n   entry cannot be found.", :row 180} {:fixed-arities #{2}, :end-row 204, :ns "cljs.module-graph", :name "validate-modules", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules indexed-inputs]"], :doc "Check that a compiler :modules map does not contain user supplied duplicates.\n   Throws if modules fails validation.", :row 188} {:fixed-arities #{2}, :end-row 248, :ns "cljs.module-graph", :name "inputs->assigned-modules", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[inputs modules]"], :doc "Given compiler inputs assign each to a single module. This is done by first\n  starting with :entries. Dependencies for every entry in a module are also added\n  to that module. Inputs may of course be assigned to several modules initially\n  but we must eventually choose one. User supplied module :entries are respected\n  but all other input assignments are computed automatically via\n  deepest-common-parent. This function returns a map assigning all inputs (indexed\n  by munged name) to a single module. Any orphan inputs will be assigned to\n  :cljs-base.", :row 206} {:fixed-arities #{2}, :end-row 272, :ns "cljs.module-graph", :name "expand-modules", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules inputs]"], :doc "Given compiler :modules and a dependency sorted list of compiler inputs return\n   a complete :modules map where all depended upon inputs are assigned.", :row 250} {:fixed-arities #{2}, :end-row 294, :ns "cljs.module-graph", :name "topo-sort", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[graph edges-key]"], :doc "Topologically sort a graph using the given edges-key.", :row 282} {:arglist-strs ["[modules-with-base]"], :end-row 298, :filename "cljs/module_graph.cljc", :fixed-arities #{1}, :lang :cljs, :name "sort-modules", :ns "cljs.module-graph", :row 296} {:end-row 313, :filename "cljs/module_graph.cljc", :lang :cljs, :name "ms", :ns "cljs.module-graph", :row 301} {:arglist-strs ["[f0 f1]"], :end-row 319, :filename "cljs/module_graph.cljc", :fixed-arities #{2}, :lang :cljs, :name "parent?", :ns "cljs.module-graph", :row 316} {:arglist-strs ["[{:keys [lib-path] :as ijs} {:keys [output-dir] :as opts}]"], :end-row 331, :filename "cljs/module_graph.cljc", :fixed-arities #{2}, :lang :cljs, :name "maybe-add-out-file", :ns "cljs.module-graph", :row 325} {:fixed-arities #{3}, :end-row 380, :ns "cljs.module-graph", :name "modules->module-uris", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules inputs {:keys [optimizations asset-path output-dir] :as opts}]"], :doc "Given a :modules map, a dependency sorted list of compiler inputs, and\n   compiler options return a Closure module uris map. This map will include\n   all inputs by leveraging expand-modules.", :row 333} {:fixed-arities #{1}, :end-row 390, :ns "cljs.module-graph", :name "modules->module-infos", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Given a :modules map return a Closure module info map which maps modules\n   to depended upon modules.", :row 382} {:fixed-arities #{2}, :end-row 402, :ns "cljs.module-graph", :name "module-for", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry modules]"], :doc "Given an entry find the module it belongs to.", :row 392}]} {:end-row 14, :filename "cljs/module_graph.cljc", :lang :cljs, :name "cljs.module-graph", :row 9, :ns nil, :var-definitions [{:fixed-arities #{2}, :end-row 43, :ns "cljs.module-graph", :name "find-sources-for-module-entry", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry sources]"], :doc "Given an entry as a symbol, find all matching inputs in sources. If the\n  symbol ends in a *, then the symbol will be treated as a wildcard. This\n  function returns a set and is not order preserving. If there are no matches\n  returns nil.", :row 16} {:fixed-arities #{1}, :end-row 56, :ns "cljs.module-graph", :name "normalize", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Normalize compiler :modules. All symbols in a module :entries will be\n  converted into munged strings.", :row 47} {:fixed-arities #{1}, :end-row 63, :ns "cljs.module-graph", :name "add-cljs-base", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Adds :cljs-base module to compiler :modules if not already present.", :row 58} {:fixed-arities #{1}, :end-row 74, :ns "cljs.module-graph", :name "add-cljs-base-dep", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Adds :cljs-base to any module in compiler :modules with an empty :depends-on.", :row 65} {:fixed-arities #{2}, :end-row 86, :ns "cljs.module-graph", :name "depth-of", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[module-name modules]"], :doc "Compute the depth of module-name based on dependency information in\n   compiler :modules.", :row 76} {:fixed-arities #{1}, :end-row 95, :ns "cljs.module-graph", :name "annotate-depths", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Annotate all modules in compiler :modules with depth information.", :row 88} {:arglist-strs ["[input]"], :end-row 100, :filename "cljs/module_graph.cljc", :fixed-arities #{1}, :lang :clj, :name "normalize-input", :ns "cljs.module-graph", :row 97} {:fixed-arities #{1}, :end-row 116, :ns "cljs.module-graph", :name "index-inputs", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[inputs]"], :doc "Index compiler inputs by :provides. If an input has multiple entries\n  in :provides will result in multiple entries in the map. The keys will be munged\n  strings not symbols.", :row 102} {:arglist-strs ["[indexed path seen validated]"], :end-row 132, :filename "cljs/module_graph.cljc", :fixed-arities #{4}, :lang :clj, :name "validate-inputs*", :ns "cljs.module-graph", :row 118} {:fixed-arities #{1 3}, :end-row 145, :ns "cljs.module-graph", :name "validate-inputs", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[inputs]" "[inputs path seen]"], :doc "Throws on the presence of circular dependencies", :row 134} {:fixed-arities #{3}, :end-row 157, :ns "cljs.module-graph", :name "deps-for", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[x graph deps-key]"], :doc "Return all dependencies for x in a graph using deps-key.", :row 147} {:fixed-arities #{2}, :end-row 162, :ns "cljs.module-graph", :name "deps-for-entry", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry indexed-inputs]"], :doc "Return all dependencies for an entry using a compiler inputs index.", :row 159} {:fixed-arities #{2}, :end-row 167, :ns "cljs.module-graph", :name "deps-for-module", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[module modules]"], :doc "Return all dependencies of a module using compiler :modules.", :row 164} {:fixed-arities #{2}, :end-row 178, :ns "cljs.module-graph", :name "deepest-common-parent", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules all-modules]"], :doc "Given a set of modules and a compiler :modules graph, compute the deepest\n  common parent module.", :row 169} {:fixed-arities #{2}, :end-row 186, :ns "cljs.module-graph", :name "canonical-name", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry indexed-inputs]"], :doc "Given an entry use indexed-inputs to return the canonical name. Throws if\n   entry cannot be found.", :row 180} {:fixed-arities #{2}, :end-row 204, :ns "cljs.module-graph", :name "validate-modules", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules indexed-inputs]"], :doc "Check that a compiler :modules map does not contain user supplied duplicates.\n   Throws if modules fails validation.", :row 188} {:fixed-arities #{2}, :end-row 248, :ns "cljs.module-graph", :name "inputs->assigned-modules", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[inputs modules]"], :doc "Given compiler inputs assign each to a single module. This is done by first\n  starting with :entries. Dependencies for every entry in a module are also added\n  to that module. Inputs may of course be assigned to several modules initially\n  but we must eventually choose one. User supplied module :entries are respected\n  but all other input assignments are computed automatically via\n  deepest-common-parent. This function returns a map assigning all inputs (indexed\n  by munged name) to a single module. Any orphan inputs will be assigned to\n  :cljs-base.", :row 206} {:fixed-arities #{2}, :end-row 272, :ns "cljs.module-graph", :name "expand-modules", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules inputs]"], :doc "Given compiler :modules and a dependency sorted list of compiler inputs return\n   a complete :modules map where all depended upon inputs are assigned.", :row 250} {:fixed-arities #{2}, :end-row 294, :ns "cljs.module-graph", :name "topo-sort", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[graph edges-key]"], :doc "Topologically sort a graph using the given edges-key.", :row 282} {:arglist-strs ["[modules-with-base]"], :end-row 298, :filename "cljs/module_graph.cljc", :fixed-arities #{1}, :lang :clj, :name "sort-modules", :ns "cljs.module-graph", :row 296} {:end-row 313, :filename "cljs/module_graph.cljc", :lang :clj, :name "ms", :ns "cljs.module-graph", :row 301} {:arglist-strs ["[f0 f1]"], :end-row 319, :filename "cljs/module_graph.cljc", :fixed-arities #{2}, :lang :clj, :name "parent?", :ns "cljs.module-graph", :row 316} {:arglist-strs ["[{:keys [lib-path] :as ijs} {:keys [output-dir] :as opts}]"], :end-row 331, :filename "cljs/module_graph.cljc", :fixed-arities #{2}, :lang :clj, :name "maybe-add-out-file", :ns "cljs.module-graph", :row 325} {:fixed-arities #{3}, :end-row 380, :ns "cljs.module-graph", :name "modules->module-uris", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules inputs {:keys [optimizations asset-path output-dir] :as opts}]"], :doc "Given a :modules map, a dependency sorted list of compiler inputs, and\n   compiler options return a Closure module uris map. This map will include\n   all inputs by leveraging expand-modules.", :row 333} {:fixed-arities #{1}, :end-row 390, :ns "cljs.module-graph", :name "modules->module-infos", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Given a :modules map return a Closure module info map which maps modules\n   to depended upon modules.", :row 382} {:fixed-arities #{2}, :end-row 402, :ns "cljs.module-graph", :name "module-for", :lang :clj, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry modules]"], :doc "Given an entry find the module it belongs to.", :row 392} {:fixed-arities #{2}, :end-row 43, :ns "cljs.module-graph", :name "find-sources-for-module-entry", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry sources]"], :doc "Given an entry as a symbol, find all matching inputs in sources. If the\n  symbol ends in a *, then the symbol will be treated as a wildcard. This\n  function returns a set and is not order preserving. If there are no matches\n  returns nil.", :row 16} {:fixed-arities #{1}, :end-row 56, :ns "cljs.module-graph", :name "normalize", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Normalize compiler :modules. All symbols in a module :entries will be\n  converted into munged strings.", :row 47} {:fixed-arities #{1}, :end-row 63, :ns "cljs.module-graph", :name "add-cljs-base", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Adds :cljs-base module to compiler :modules if not already present.", :row 58} {:fixed-arities #{1}, :end-row 74, :ns "cljs.module-graph", :name "add-cljs-base-dep", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Adds :cljs-base to any module in compiler :modules with an empty :depends-on.", :row 65} {:fixed-arities #{2}, :end-row 86, :ns "cljs.module-graph", :name "depth-of", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[module-name modules]"], :doc "Compute the depth of module-name based on dependency information in\n   compiler :modules.", :row 76} {:fixed-arities #{1}, :end-row 95, :ns "cljs.module-graph", :name "annotate-depths", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Annotate all modules in compiler :modules with depth information.", :row 88} {:arglist-strs ["[input]"], :end-row 100, :filename "cljs/module_graph.cljc", :fixed-arities #{1}, :lang :cljs, :name "normalize-input", :ns "cljs.module-graph", :row 97} {:fixed-arities #{1}, :end-row 116, :ns "cljs.module-graph", :name "index-inputs", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[inputs]"], :doc "Index compiler inputs by :provides. If an input has multiple entries\n  in :provides will result in multiple entries in the map. The keys will be munged\n  strings not symbols.", :row 102} {:arglist-strs ["[indexed path seen validated]"], :end-row 132, :filename "cljs/module_graph.cljc", :fixed-arities #{4}, :lang :cljs, :name "validate-inputs*", :ns "cljs.module-graph", :row 118} {:fixed-arities #{1 3}, :end-row 145, :ns "cljs.module-graph", :name "validate-inputs", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[inputs]" "[inputs path seen]"], :doc "Throws on the presence of circular dependencies", :row 134} {:fixed-arities #{3}, :end-row 157, :ns "cljs.module-graph", :name "deps-for", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[x graph deps-key]"], :doc "Return all dependencies for x in a graph using deps-key.", :row 147} {:fixed-arities #{2}, :end-row 162, :ns "cljs.module-graph", :name "deps-for-entry", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry indexed-inputs]"], :doc "Return all dependencies for an entry using a compiler inputs index.", :row 159} {:fixed-arities #{2}, :end-row 167, :ns "cljs.module-graph", :name "deps-for-module", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[module modules]"], :doc "Return all dependencies of a module using compiler :modules.", :row 164} {:fixed-arities #{2}, :end-row 178, :ns "cljs.module-graph", :name "deepest-common-parent", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules all-modules]"], :doc "Given a set of modules and a compiler :modules graph, compute the deepest\n  common parent module.", :row 169} {:fixed-arities #{2}, :end-row 186, :ns "cljs.module-graph", :name "canonical-name", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry indexed-inputs]"], :doc "Given an entry use indexed-inputs to return the canonical name. Throws if\n   entry cannot be found.", :row 180} {:fixed-arities #{2}, :end-row 204, :ns "cljs.module-graph", :name "validate-modules", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules indexed-inputs]"], :doc "Check that a compiler :modules map does not contain user supplied duplicates.\n   Throws if modules fails validation.", :row 188} {:fixed-arities #{2}, :end-row 248, :ns "cljs.module-graph", :name "inputs->assigned-modules", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[inputs modules]"], :doc "Given compiler inputs assign each to a single module. This is done by first\n  starting with :entries. Dependencies for every entry in a module are also added\n  to that module. Inputs may of course be assigned to several modules initially\n  but we must eventually choose one. User supplied module :entries are respected\n  but all other input assignments are computed automatically via\n  deepest-common-parent. This function returns a map assigning all inputs (indexed\n  by munged name) to a single module. Any orphan inputs will be assigned to\n  :cljs-base.", :row 206} {:fixed-arities #{2}, :end-row 272, :ns "cljs.module-graph", :name "expand-modules", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules inputs]"], :doc "Given compiler :modules and a dependency sorted list of compiler inputs return\n   a complete :modules map where all depended upon inputs are assigned.", :row 250} {:fixed-arities #{2}, :end-row 294, :ns "cljs.module-graph", :name "topo-sort", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[graph edges-key]"], :doc "Topologically sort a graph using the given edges-key.", :row 282} {:arglist-strs ["[modules-with-base]"], :end-row 298, :filename "cljs/module_graph.cljc", :fixed-arities #{1}, :lang :cljs, :name "sort-modules", :ns "cljs.module-graph", :row 296} {:end-row 313, :filename "cljs/module_graph.cljc", :lang :cljs, :name "ms", :ns "cljs.module-graph", :row 301} {:arglist-strs ["[f0 f1]"], :end-row 319, :filename "cljs/module_graph.cljc", :fixed-arities #{2}, :lang :cljs, :name "parent?", :ns "cljs.module-graph", :row 316} {:arglist-strs ["[{:keys [lib-path] :as ijs} {:keys [output-dir] :as opts}]"], :end-row 331, :filename "cljs/module_graph.cljc", :fixed-arities #{2}, :lang :cljs, :name "maybe-add-out-file", :ns "cljs.module-graph", :row 325} {:fixed-arities #{3}, :end-row 380, :ns "cljs.module-graph", :name "modules->module-uris", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules inputs {:keys [optimizations asset-path output-dir] :as opts}]"], :doc "Given a :modules map, a dependency sorted list of compiler inputs, and\n   compiler options return a Closure module uris map. This map will include\n   all inputs by leveraging expand-modules.", :row 333} {:fixed-arities #{1}, :end-row 390, :ns "cljs.module-graph", :name "modules->module-infos", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[modules]"], :doc "Given a :modules map return a Closure module info map which maps modules\n   to depended upon modules.", :row 382} {:fixed-arities #{2}, :end-row 402, :ns "cljs.module-graph", :name "module-for", :lang :cljs, :filename "cljs/module_graph.cljc", :arglist-strs ["[entry modules]"], :doc "Given an entry find the module it belongs to.", :row 392}]} {:end-row 14, :filename "cljs/test.cljc", :lang :clj, :name "cljs.test", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[]" "[reporter]"], :doc "Generates a testing environment with a reporter.\n   (empty-env) - uses the :cljs.test/default reporter.\n   (empty-env :cljs.test/pprint) - pretty prints all data structures. \n   (empty-env reporter) - uses a reporter of your choosing.\n\n   To create your own reporter see cljs.test/report", :end-row 267, :filename "cljs/test.cljs", :fixed-arities #{0 1}, :name "empty-env", :ns "cljs.test", :row 252} {:end-row 269, :filename "cljs/test.cljs", :name "*current-env*", :ns "cljs.test", :row 269} {:arglist-strs ["[]"], :end-row 272, :filename "cljs/test.cljs", :fixed-arities #{0}, :name "get-current-env", :ns "cljs.test", :row 271} {:arglist-strs ["[ks f & args]"], :end-row 275, :filename "cljs/test.cljs", :name "update-current-env!", :ns "cljs.test", :row 274} {:arglist-strs ["[new-env]"], :end-row 278, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "set-env!", :ns "cljs.test", :row 277} {:arglist-strs ["[]"], :end-row 281, :filename "cljs/test.cljs", :fixed-arities #{0}, :name "clear-env!", :ns "cljs.test", :row 280} {:arglist-strs ["[]"], :end-row 287, :filename "cljs/test.cljs", :fixed-arities #{0}, :name "get-and-clear-env!", :ns "cljs.test", :row 283} {:arglist-strs ["[m]"], :doc "Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.", :end-row 297, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "testing-vars-str", :ns "cljs.test", :row 289} {:arglist-strs ["[]"], :doc "Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.", :end-row 303, :filename "cljs/test.cljs", :fixed-arities #{0}, :name "testing-contexts-str", :ns "cljs.test", :row 299} {:arglist-strs ["[name]"], :doc "Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.", :end-row 310, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "inc-report-counter!", :ns "cljs.test", :row 305} {:doc "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.", :end-row 318, :filename "cljs/test.cljs", :name "report", :ns "cljs.test", :row 312} {:arglist-strs ["[m]"], :end-row 328, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "print-comparison", :ns "cljs.test", :private true, :row 325} {:arglist-strs ["[stack-element]"], :end-row 376, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "js-line-and-column", :ns "cljs.test", :row 366} {:arglist-strs ["[stack-element]"], :end-row 386, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "js-filename", :ns "cljs.test", :row 378} {:arglist-strs ["[filename line column]"], :end-row 404, :filename "cljs/test.cljs", :fixed-arities #{3}, :name "mapped-line-and-column", :ns "cljs.test", :row 388} {:arglist-strs ["[exception depth]"], :end-row 418, :filename "cljs/test.cljs", :fixed-arities #{2}, :name "file-and-line", :ns "cljs.test", :row 406} {:arglist-strs ["[m]"], :end-row 425, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "do-report", :ns "cljs.test", :row 420} {:doc "Marker protocol denoting CPS function to begin asynchronous\n  testing.", :end-row 432, :filename "cljs/test.cljs", :name "IAsyncTest", :ns "cljs.test", :row 430} {:arglist-strs ["[x]"], :doc "Returns whether x implements IAsyncTest.", :end-row 437, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "async?", :ns "cljs.test", :row 434} {:arglist-strs ["[fns]"], :doc "Invoke all functions in fns with no arguments. A fn can optionally\n  return\n\n  an async test - is invoked with a continuation running left fns\n\n  a seq of fns tagged per block - are invoked immediately after fn", :end-row 456, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "run-block", :ns "cljs.test", :row 439} {:arglist-strs ["[fns]"], :doc "Tag a seq of fns to be picked up by run-block as injected\n  continuation.  See run-block.", :end-row 463, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "block", :ns "cljs.test", :row 458} {:arglist-strs ["[v t]"], :end-row 487, :filename "cljs/test.cljs", :fixed-arities #{2}, :name "test-var-block*", :ns "cljs.test", :private true, :row 468} {:arglist-strs ["[v]"], :doc "Like test-var, but returns a block for further composition and\n  later execution.", :end-row 494, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "test-var-block", :ns "cljs.test", :row 489} {:arglist-strs ["[v]"], :doc "If v has a function in its :test metadata, calls that function,\n  add v to :testing-vars property of env.", :end-row 500, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "test-var", :ns "cljs.test", :row 496} {:fixed-arities #{1}, :end-row 507, :private true, :ns "cljs.test", :name "default-fixture", :filename "cljs/test.cljs", :arglist-strs ["[f]"], :doc "The default, empty, fixture function.  Just calls its argument.\n\n  NOTE: Incompatible with map fixtures.", :row 502} {:arglist-strs ["[f1 f2]"], :doc "Composes two fixture functions, creating a new fixture function\n  that combines their behavior.\n\n  NOTE: Incompatible with map fixtures.", :end-row 515, :filename "cljs/test.cljs", :fixed-arities #{2}, :name "compose-fixtures", :ns "cljs.test", :row 509} {:arglist-strs ["[fixtures]"], :doc "Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.\n\n  NOTE: Incompatible with map fixtures.", :end-row 523, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "join-fixtures", :ns "cljs.test", :row 517} {:fixed-arities #{2}, :end-row 530, :private true, :ns "cljs.test", :name "wrap-map-fixtures", :filename "cljs/test.cljs", :arglist-strs ["[map-fixtures block]"], :doc "Wraps block in map-fixtures.", :row 525} {:arglist-strs ["[once each]"], :end-row 547, :filename "cljs/test.cljs", :fixed-arities #{2}, :name "execution-strategy", :ns "cljs.test", :private true, :row 532} {:arglist-strs ["[f]"], :end-row 554, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "disable-async", :ns "cljs.test", :private true, :row 549} {:arglist-strs ["[vars]"], :doc "Like test-vars, but returns a block for further composition and\n  later execution.", :end-row 587, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "test-vars-block", :ns "cljs.test", :row 556} {:arglist-strs ["[vars]"], :doc "Groups vars by their namespace and runs test-var on them with\n  appropriate fixtures assuming they are present in the current\n  testing environment.", :end-row 596, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "test-vars", :ns "cljs.test", :row 589} {:arglist-strs ["[summary]"], :doc "Returns true if the given test summary indicates all tests\n  were successful, false otherwise.", :end-row 606, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "successful?", :ns "cljs.test", :row 601} {:fixed-arities #{2}, :end-row 23, :ns "cljs.test", :name "function?", :lang :clj, :filename "cljs/test.cljc", :arglist-strs ["[menv x]"], :doc "Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).", :row 19} {:fixed-arities #{2}, :end-row 46, :ns "cljs.test", :name "assert-predicate", :lang :clj, :filename "cljs/test.cljc", :arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).", :row 25} {:fixed-arities #{2}, :end-row 63, :ns "cljs.test", :name "assert-any", :lang :clj, :filename "cljs/test.cljc", :arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.", :row 48} {:fixed-arities #{0}, :end-row 67, :private true, :ns "cljs.test", :name "cljs-output-dir", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]"], :row 65} {:end-row 81, :filename "cljs/test.cljc", :lang :clj, :name "assert-expr", :ns "cljs.test", :row 76} {:fixed-arities #{2}, :end-row 169, :ns "cljs.test", :name "try-expr", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[msg form]"], :doc "Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.", :row 158} {:fixed-arities #{1 2}, :end-row 190, :ns "cljs.test", :name "is", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[form]" "[form msg]"], :doc "Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.", :row 174} {:end-row 214, :ns "cljs.test", :name "are", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[argv expr & args]"], :doc "Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.", :row 192} {:end-row 225, :ns "cljs.test", :name "testing", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[string & body]"], :doc "Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).", :row 216} {:end-row 246, :ns "cljs.test", :name "deftest", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[name & body]"], :doc "Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored.", :row 230} {:end-row 265, :ns "cljs.test", :name "async", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[done & body]"], :doc "Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))", :row 248} {:arglist-strs ["[x]"], :end-row 271, :filename "cljs/test.cljc", :fixed-arities #{1}, :lang :clj, :name "ns?", :ns "cljs.test", :row 270} {:end-row 306, :ns "cljs.test", :name "run-tests-block", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[env-or-ns & namespaces]"], :doc "Like test-vars, but returns a block for further composition and\n  later execution.", :row 273} {:fixed-arities #{0 1}, :end-row 320, :ns "cljs.test", :name "run-tests", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]" "[env-or-ns]" "[env-or-ns & namespaces]"], :doc "Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod.", :row 308} {:fixed-arities #{0 1 2}, :end-row 334, :ns "cljs.test", :name "run-all-tests", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]" "[re]" "[re env]"], :doc "Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.", :row 322} {:fixed-arities #{1}, :end-row 357, :ns "cljs.test", :name "test-all-vars-block", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[[quote ns]]"], :row 336} {:fixed-arities #{1}, :end-row 366, :ns "cljs.test", :name "test-all-vars", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[[quote ns :as form]]"], :doc "Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures.", :row 359} {:fixed-arities #{2}, :end-row 383, :ns "cljs.test", :name "test-ns-block", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[env [quote ns :as form]]"], :doc "Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env.", :row 368} {:fixed-arities #{1 2}, :end-row 397, :ns "cljs.test", :name "test-ns", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[ns]" "[env [quote ns :as form]]"], :doc "If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  ", :row 385} {:arglist-strs ["[type & fns]"], :end-row 412, :filename "cljs/test.cljc", :lang :clj, :macro true, :name "use-fixtures", :ns "cljs.test", :row 402} {:fixed-arities #{2}, :end-row 23, :ns "cljs.test", :name "function?", :lang :cljs, :filename "cljs/test.cljc", :arglist-strs ["[menv x]"], :doc "Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).", :row 19} {:fixed-arities #{2}, :end-row 46, :ns "cljs.test", :name "assert-predicate", :lang :cljs, :filename "cljs/test.cljc", :arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).", :row 25} {:fixed-arities #{2}, :end-row 63, :ns "cljs.test", :name "assert-any", :lang :cljs, :filename "cljs/test.cljc", :arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.", :row 48} {:fixed-arities #{0}, :end-row 67, :private true, :ns "cljs.test", :name "cljs-output-dir", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]"], :row 65} {:end-row 81, :filename "cljs/test.cljc", :lang :cljs, :name "assert-expr", :ns "cljs.test", :row 76} {:fixed-arities #{2}, :end-row 169, :ns "cljs.test", :name "try-expr", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[msg form]"], :doc "Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.", :row 158} {:fixed-arities #{1 2}, :end-row 190, :ns "cljs.test", :name "is", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[form]" "[form msg]"], :doc "Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.", :row 174} {:end-row 214, :ns "cljs.test", :name "are", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[argv expr & args]"], :doc "Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.", :row 192} {:end-row 225, :ns "cljs.test", :name "testing", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[string & body]"], :doc "Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).", :row 216} {:end-row 246, :ns "cljs.test", :name "deftest", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[name & body]"], :doc "Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored.", :row 230} {:end-row 265, :ns "cljs.test", :name "async", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[done & body]"], :doc "Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))", :row 248} {:arglist-strs ["[x]"], :end-row 271, :filename "cljs/test.cljc", :fixed-arities #{1}, :lang :cljs, :name "ns?", :ns "cljs.test", :row 270} {:end-row 306, :ns "cljs.test", :name "run-tests-block", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[env-or-ns & namespaces]"], :doc "Like test-vars, but returns a block for further composition and\n  later execution.", :row 273} {:fixed-arities #{0 1}, :end-row 320, :ns "cljs.test", :name "run-tests", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]" "[env-or-ns]" "[env-or-ns & namespaces]"], :doc "Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod.", :row 308} {:fixed-arities #{0 1 2}, :end-row 334, :ns "cljs.test", :name "run-all-tests", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]" "[re]" "[re env]"], :doc "Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.", :row 322} {:fixed-arities #{1}, :end-row 357, :ns "cljs.test", :name "test-all-vars-block", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[[quote ns]]"], :row 336} {:fixed-arities #{1}, :end-row 366, :ns "cljs.test", :name "test-all-vars", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[[quote ns :as form]]"], :doc "Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures.", :row 359} {:fixed-arities #{2}, :end-row 383, :ns "cljs.test", :name "test-ns-block", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[env [quote ns :as form]]"], :doc "Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env.", :row 368} {:fixed-arities #{1 2}, :end-row 397, :ns "cljs.test", :name "test-ns", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[ns]" "[env [quote ns :as form]]"], :doc "If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  ", :row 385} {:arglist-strs ["[type & fns]"], :end-row 412, :filename "cljs/test.cljc", :lang :cljs, :macro true, :name "use-fixtures", :ns "cljs.test", :row 402}]} {:end-row 14, :filename "cljs/test.cljc", :lang :cljs, :name "cljs.test", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[]" "[reporter]"], :doc "Generates a testing environment with a reporter.\n   (empty-env) - uses the :cljs.test/default reporter.\n   (empty-env :cljs.test/pprint) - pretty prints all data structures. \n   (empty-env reporter) - uses a reporter of your choosing.\n\n   To create your own reporter see cljs.test/report", :end-row 267, :filename "cljs/test.cljs", :fixed-arities #{0 1}, :name "empty-env", :ns "cljs.test", :row 252} {:end-row 269, :filename "cljs/test.cljs", :name "*current-env*", :ns "cljs.test", :row 269} {:arglist-strs ["[]"], :end-row 272, :filename "cljs/test.cljs", :fixed-arities #{0}, :name "get-current-env", :ns "cljs.test", :row 271} {:arglist-strs ["[ks f & args]"], :end-row 275, :filename "cljs/test.cljs", :name "update-current-env!", :ns "cljs.test", :row 274} {:arglist-strs ["[new-env]"], :end-row 278, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "set-env!", :ns "cljs.test", :row 277} {:arglist-strs ["[]"], :end-row 281, :filename "cljs/test.cljs", :fixed-arities #{0}, :name "clear-env!", :ns "cljs.test", :row 280} {:arglist-strs ["[]"], :end-row 287, :filename "cljs/test.cljs", :fixed-arities #{0}, :name "get-and-clear-env!", :ns "cljs.test", :row 283} {:arglist-strs ["[m]"], :doc "Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.", :end-row 297, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "testing-vars-str", :ns "cljs.test", :row 289} {:arglist-strs ["[]"], :doc "Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.", :end-row 303, :filename "cljs/test.cljs", :fixed-arities #{0}, :name "testing-contexts-str", :ns "cljs.test", :row 299} {:arglist-strs ["[name]"], :doc "Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.", :end-row 310, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "inc-report-counter!", :ns "cljs.test", :row 305} {:doc "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.", :end-row 318, :filename "cljs/test.cljs", :name "report", :ns "cljs.test", :row 312} {:arglist-strs ["[m]"], :end-row 328, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "print-comparison", :ns "cljs.test", :private true, :row 325} {:arglist-strs ["[stack-element]"], :end-row 376, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "js-line-and-column", :ns "cljs.test", :row 366} {:arglist-strs ["[stack-element]"], :end-row 386, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "js-filename", :ns "cljs.test", :row 378} {:arglist-strs ["[filename line column]"], :end-row 404, :filename "cljs/test.cljs", :fixed-arities #{3}, :name "mapped-line-and-column", :ns "cljs.test", :row 388} {:arglist-strs ["[exception depth]"], :end-row 418, :filename "cljs/test.cljs", :fixed-arities #{2}, :name "file-and-line", :ns "cljs.test", :row 406} {:arglist-strs ["[m]"], :end-row 425, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "do-report", :ns "cljs.test", :row 420} {:doc "Marker protocol denoting CPS function to begin asynchronous\n  testing.", :end-row 432, :filename "cljs/test.cljs", :name "IAsyncTest", :ns "cljs.test", :row 430} {:arglist-strs ["[x]"], :doc "Returns whether x implements IAsyncTest.", :end-row 437, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "async?", :ns "cljs.test", :row 434} {:arglist-strs ["[fns]"], :doc "Invoke all functions in fns with no arguments. A fn can optionally\n  return\n\n  an async test - is invoked with a continuation running left fns\n\n  a seq of fns tagged per block - are invoked immediately after fn", :end-row 456, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "run-block", :ns "cljs.test", :row 439} {:arglist-strs ["[fns]"], :doc "Tag a seq of fns to be picked up by run-block as injected\n  continuation.  See run-block.", :end-row 463, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "block", :ns "cljs.test", :row 458} {:arglist-strs ["[v t]"], :end-row 487, :filename "cljs/test.cljs", :fixed-arities #{2}, :name "test-var-block*", :ns "cljs.test", :private true, :row 468} {:arglist-strs ["[v]"], :doc "Like test-var, but returns a block for further composition and\n  later execution.", :end-row 494, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "test-var-block", :ns "cljs.test", :row 489} {:arglist-strs ["[v]"], :doc "If v has a function in its :test metadata, calls that function,\n  add v to :testing-vars property of env.", :end-row 500, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "test-var", :ns "cljs.test", :row 496} {:fixed-arities #{1}, :end-row 507, :private true, :ns "cljs.test", :name "default-fixture", :filename "cljs/test.cljs", :arglist-strs ["[f]"], :doc "The default, empty, fixture function.  Just calls its argument.\n\n  NOTE: Incompatible with map fixtures.", :row 502} {:arglist-strs ["[f1 f2]"], :doc "Composes two fixture functions, creating a new fixture function\n  that combines their behavior.\n\n  NOTE: Incompatible with map fixtures.", :end-row 515, :filename "cljs/test.cljs", :fixed-arities #{2}, :name "compose-fixtures", :ns "cljs.test", :row 509} {:arglist-strs ["[fixtures]"], :doc "Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.\n\n  NOTE: Incompatible with map fixtures.", :end-row 523, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "join-fixtures", :ns "cljs.test", :row 517} {:fixed-arities #{2}, :end-row 530, :private true, :ns "cljs.test", :name "wrap-map-fixtures", :filename "cljs/test.cljs", :arglist-strs ["[map-fixtures block]"], :doc "Wraps block in map-fixtures.", :row 525} {:arglist-strs ["[once each]"], :end-row 547, :filename "cljs/test.cljs", :fixed-arities #{2}, :name "execution-strategy", :ns "cljs.test", :private true, :row 532} {:arglist-strs ["[f]"], :end-row 554, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "disable-async", :ns "cljs.test", :private true, :row 549} {:arglist-strs ["[vars]"], :doc "Like test-vars, but returns a block for further composition and\n  later execution.", :end-row 587, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "test-vars-block", :ns "cljs.test", :row 556} {:arglist-strs ["[vars]"], :doc "Groups vars by their namespace and runs test-var on them with\n  appropriate fixtures assuming they are present in the current\n  testing environment.", :end-row 596, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "test-vars", :ns "cljs.test", :row 589} {:arglist-strs ["[summary]"], :doc "Returns true if the given test summary indicates all tests\n  were successful, false otherwise.", :end-row 606, :filename "cljs/test.cljs", :fixed-arities #{1}, :name "successful?", :ns "cljs.test", :row 601} {:fixed-arities #{2}, :end-row 23, :ns "cljs.test", :name "function?", :lang :clj, :filename "cljs/test.cljc", :arglist-strs ["[menv x]"], :doc "Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).", :row 19} {:fixed-arities #{2}, :end-row 46, :ns "cljs.test", :name "assert-predicate", :lang :clj, :filename "cljs/test.cljc", :arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).", :row 25} {:fixed-arities #{2}, :end-row 63, :ns "cljs.test", :name "assert-any", :lang :clj, :filename "cljs/test.cljc", :arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.", :row 48} {:fixed-arities #{0}, :end-row 67, :private true, :ns "cljs.test", :name "cljs-output-dir", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]"], :row 65} {:end-row 81, :filename "cljs/test.cljc", :lang :clj, :name "assert-expr", :ns "cljs.test", :row 76} {:fixed-arities #{2}, :end-row 169, :ns "cljs.test", :name "try-expr", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[msg form]"], :doc "Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.", :row 158} {:fixed-arities #{1 2}, :end-row 190, :ns "cljs.test", :name "is", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[form]" "[form msg]"], :doc "Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.", :row 174} {:end-row 214, :ns "cljs.test", :name "are", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[argv expr & args]"], :doc "Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.", :row 192} {:end-row 225, :ns "cljs.test", :name "testing", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[string & body]"], :doc "Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).", :row 216} {:end-row 246, :ns "cljs.test", :name "deftest", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[name & body]"], :doc "Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored.", :row 230} {:end-row 265, :ns "cljs.test", :name "async", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[done & body]"], :doc "Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))", :row 248} {:arglist-strs ["[x]"], :end-row 271, :filename "cljs/test.cljc", :fixed-arities #{1}, :lang :clj, :name "ns?", :ns "cljs.test", :row 270} {:end-row 306, :ns "cljs.test", :name "run-tests-block", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[env-or-ns & namespaces]"], :doc "Like test-vars, but returns a block for further composition and\n  later execution.", :row 273} {:fixed-arities #{0 1}, :end-row 320, :ns "cljs.test", :name "run-tests", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]" "[env-or-ns]" "[env-or-ns & namespaces]"], :doc "Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod.", :row 308} {:fixed-arities #{0 1 2}, :end-row 334, :ns "cljs.test", :name "run-all-tests", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]" "[re]" "[re env]"], :doc "Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.", :row 322} {:fixed-arities #{1}, :end-row 357, :ns "cljs.test", :name "test-all-vars-block", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[[quote ns]]"], :row 336} {:fixed-arities #{1}, :end-row 366, :ns "cljs.test", :name "test-all-vars", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[[quote ns :as form]]"], :doc "Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures.", :row 359} {:fixed-arities #{2}, :end-row 383, :ns "cljs.test", :name "test-ns-block", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[env [quote ns :as form]]"], :doc "Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env.", :row 368} {:fixed-arities #{1 2}, :end-row 397, :ns "cljs.test", :name "test-ns", :lang :clj, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[ns]" "[env [quote ns :as form]]"], :doc "If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  ", :row 385} {:arglist-strs ["[type & fns]"], :end-row 412, :filename "cljs/test.cljc", :lang :clj, :macro true, :name "use-fixtures", :ns "cljs.test", :row 402} {:fixed-arities #{2}, :end-row 23, :ns "cljs.test", :name "function?", :lang :cljs, :filename "cljs/test.cljc", :arglist-strs ["[menv x]"], :doc "Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).", :row 19} {:fixed-arities #{2}, :end-row 46, :ns "cljs.test", :name "assert-predicate", :lang :cljs, :filename "cljs/test.cljc", :arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).", :row 25} {:fixed-arities #{2}, :end-row 63, :ns "cljs.test", :name "assert-any", :lang :cljs, :filename "cljs/test.cljc", :arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.", :row 48} {:fixed-arities #{0}, :end-row 67, :private true, :ns "cljs.test", :name "cljs-output-dir", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]"], :row 65} {:end-row 81, :filename "cljs/test.cljc", :lang :cljs, :name "assert-expr", :ns "cljs.test", :row 76} {:fixed-arities #{2}, :end-row 169, :ns "cljs.test", :name "try-expr", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[msg form]"], :doc "Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.", :row 158} {:fixed-arities #{1 2}, :end-row 190, :ns "cljs.test", :name "is", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[form]" "[form msg]"], :doc "Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.", :row 174} {:end-row 214, :ns "cljs.test", :name "are", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[argv expr & args]"], :doc "Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.", :row 192} {:end-row 225, :ns "cljs.test", :name "testing", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[string & body]"], :doc "Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).", :row 216} {:end-row 246, :ns "cljs.test", :name "deftest", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[name & body]"], :doc "Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When cljs.analyzer/*load-tests* is false, deftest is ignored.", :row 230} {:end-row 265, :ns "cljs.test", :name "async", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[done & body]"], :doc "Wraps body as a CPS function that can be returned from a test to\n  continue asynchronously.  Binds done to a function that must be\n  invoked once and from an async context after any assertions.\n\n  (deftest example-with-timeout\n    (async done\n      (js/setTimeout (fn []\n                       ;; make assertions in async context...\n                       (done) ;; ...then call done\n                       )\n                     0)))", :row 248} {:arglist-strs ["[x]"], :end-row 271, :filename "cljs/test.cljc", :fixed-arities #{1}, :lang :cljs, :name "ns?", :ns "cljs.test", :row 270} {:end-row 306, :ns "cljs.test", :name "run-tests-block", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[env-or-ns & namespaces]"], :doc "Like test-vars, but returns a block for further composition and\n  later execution.", :row 273} {:fixed-arities #{0 1}, :end-row 320, :ns "cljs.test", :name "run-tests", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]" "[env-or-ns]" "[env-or-ns & namespaces]"], :doc "Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given. Does not return a meaningful\n  value due to the possiblity of asynchronous execution. To detect test\n  completion add a :end-run-tests method case to the cljs.test/report\n  multimethod.", :row 308} {:fixed-arities #{0 1 2}, :end-row 334, :ns "cljs.test", :name "run-all-tests", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[]" "[re]" "[re env]"], :doc "Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.", :row 322} {:fixed-arities #{1}, :end-row 357, :ns "cljs.test", :name "test-all-vars-block", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[[quote ns]]"], :row 336} {:fixed-arities #{1}, :end-row 366, :ns "cljs.test", :name "test-all-vars", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[[quote ns :as form]]"], :doc "Calls test-vars on every var with :test metadata interned in the\n  namespace, with fixtures.", :row 359} {:fixed-arities #{2}, :end-row 383, :ns "cljs.test", :name "test-ns-block", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[env [quote ns :as form]]"], :doc "Like test-ns, but returns a block for further composition and\n  later execution.  Does not clear the current env.", :row 368} {:fixed-arities #{1 2}, :end-row 397, :ns "cljs.test", :name "test-ns", :lang :cljs, :filename "cljs/test.cljc", :macro true, :arglist-strs ["[ns]" "[env [quote ns :as form]]"], :doc "If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  ", :row 385} {:arglist-strs ["[type & fns]"], :end-row 412, :filename "cljs/test.cljc", :lang :cljs, :macro true, :name "use-fixtures", :ns "cljs.test", :row 402}]} {:end-row 32, :filename "cljs/repl.cljc", :lang :clj, :name "cljs.repl", :row 9, :ns nil, :var-definitions [{:end-row 34, :filename "cljs/repl.cljc", :lang :clj, :name "*cljs-verbose*", :ns "cljs.repl", :row 34} {:end-row 35, :filename "cljs/repl.cljc", :lang :clj, :name "*repl-opts*", :ns "cljs.repl", :row 35} {:end-row 36, :filename "cljs/repl.cljc", :lang :clj, :name "*repl-env*", :ns "cljs.repl", :row 36} {:doc "Set of all known REPL options.", :end-row 43, :filename "cljs/repl.cljc", :lang :clj, :name "known-repl-opts", :ns "cljs.repl", :row 38} {:end-row 47, :private true, :ns "cljs.repl", :name "err-out", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[& body]"], :row 45} {:fixed-arities #{1}, :end-row 64, :ns "cljs.repl", :name "skip-if-eol", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[s]"], :doc "If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\newline.", :row 52} {:fixed-arities #{1}, :end-row 83, :ns "cljs.repl", :name "skip-whitespace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[s]"], :doc "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.", :row 66} {:fixed-arities #{3 2}, :end-row 110, :ns "cljs.repl", :name "repl-read", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[request-prompt request-exit]" "[request-prompt request-exit opts]"], :doc "Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.", :row 85} {:end-row 116, :filename "cljs/repl.cljc", :lang :clj, :name "IReplEnvOptions", :ns "cljs.repl", :row 115} {:fixed-arities #{1}, :end-row 116, :ns "cljs.repl", :name "-repl-options", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]"], :doc "Return default REPL options for a REPL Env", :row 116} {:arglist-strs ["[repl-env]"], :end-row 119, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "repl-options", :ns "cljs.repl", :row 118} {:end-row 125, :filename "cljs/repl.cljc", :lang :clj, :name "IJavaScriptEnv", :ns "cljs.repl", :row 121} {:fixed-arities #{2}, :end-row 122, :ns "cljs.repl", :name "-setup", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env opts]"], :doc "initialize the environment", :row 122} {:fixed-arities #{4}, :end-row 123, :ns "cljs.repl", :name "-evaluate", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env filename line js]"], :doc "evaluate a javascript string", :row 123} {:fixed-arities #{3}, :end-row 124, :ns "cljs.repl", :name "-load", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env provides url]"], :doc "load code at url into the environment", :row 124} {:fixed-arities #{1}, :end-row 125, :ns "cljs.repl", :name "-tear-down", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]"], :doc "dispose of the environment", :row 125} {:arglist-strs ["[repl-env opts]"], :end-row 128, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "setup", :ns "cljs.repl", :row 127} {:arglist-strs ["[repl-env filename line js]"], :end-row 131, :filename "cljs/repl.cljc", :fixed-arities #{4}, :lang :clj, :name "evaluate", :ns "cljs.repl", :row 130} {:arglist-strs ["[repl-env provides url]"], :end-row 134, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :clj, :name "load", :ns "cljs.repl", :row 133} {:arglist-strs ["[repl-env]"], :end-row 137, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "tear-down", :ns "cljs.repl", :row 136} {:end-row 147, :filename "cljs/repl.cljc", :lang :clj, :name "IParseError", :ns "cljs.repl", :row 144} {:fixed-arities #{3}, :end-row 147, :ns "cljs.repl", :name "-parse-error", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env error build-options]"], :doc "Given the original JavaScript error return the error to actually\n     use.", :row 145} {:end-row 159, :filename "cljs/repl.cljc", :lang :clj, :name "IGetError", :ns "cljs.repl", :row 149} {:fixed-arities #{4}, :end-row 159, :ns "cljs.repl", :name "-get-error", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env name env build-options]"], :doc "Given a symbol representing a var holding an error, an analysis\n     environment, and the REPL/compiler options return the canonical error\n     representation:\n\n     {:value <string>\n      :stacktrace <string>}\n\n    :value should be the host environment JavaScript error message string.\n    :stacktrace should be the host JavaScript environment stacktrace string.", :row 150} {:end-row 174, :filename "cljs/repl.cljc", :lang :clj, :name "IParseStacktrace", :ns "cljs.repl", :row 161} {:fixed-arities #{4}, :end-row 174, :ns "cljs.repl", :name "-parse-stacktrace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env stacktrace error build-options]"], :doc "Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir. If\n     no source file can be supplied (such as REPL defs), :file may be a custom\n     identifier string surrounded by angle brackets, i.e. \"<cljs repl>\".", :row 162} {:end-row 179, :filename "cljs/repl.cljc", :lang :clj, :name "IPrintStacktrace", :ns "cljs.repl", :row 176} {:fixed-arities #{4}, :end-row 179, :ns "cljs.repl", :name "-print-stacktrace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env stacktrace error build-options]"], :doc "Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing.", :row 177} {:fixed-arities #{1 2}, :end-row 191, :private true, :ns "cljs.repl", :name "env->opts", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]" "[repl-env opts]"], :doc "Returns a hash-map containing all of the entries in [repl-env], translating\n:working-dir to :output-dir.", :row 181} {:arglist-strs ["[ijs]"], :end-row 196, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "add-url", :ns "cljs.repl", :row 193} {:arglist-strs ["[ns opts]"], :end-row 204, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "ns->input", :ns "cljs.repl", :row 198} {:arglist-strs ["[input]"], :end-row 207, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "compilable?", :ns "cljs.repl", :row 206} {:fixed-arities #{3}, :end-row 224, :private true, :ns "cljs.repl", :name "load-sources", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env sources opts]"], :doc "Load the compiled `sources` into the REPL.", :row 209} {:fixed-arities #{3}, :end-row 231, :private true, :ns "cljs.repl", :name "load-cljs-loader", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env sources opts]"], :doc "Compile and load the cljs.loader namespace if it's present in `sources`.", :row 226} {:fixed-arities #{3 2}, :end-row 252, :ns "cljs.repl", :name "load-namespace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env ns]" "[repl-env ns opts]"], :doc "Load a namespace and all of its dependencies into the evaluation environment.\n  The environment is responsible for ensuring that each namespace is\n  loaded once and only once. Returns the compiled sources.", :row 233} {:fixed-arities #{3 2}, :end-row 259, :private true, :ns "cljs.repl", :name "load-dependencies", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env requires]" "[repl-env requires opts]"], :doc "Compile and load the given `requires` and return the compiled sources.", :row 254} {:fixed-arities #{1}, :end-row 273, :ns "cljs.repl", :name "js-src->cljs-src", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Map a JavaScript output file back to the original ClojureScript source\n   file (.cljs or .cljc).", :row 261} {:fixed-arities #{1}, :end-row 293, :ns "cljs.repl", :name "read-source-map", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Return the source map for the JavaScript source file.", :row 275} {:fixed-arities #{1}, :end-row 301, :ns "cljs.repl", :name "ns-info", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Given a path to a js source file return the ns info for the corresponding\n   ClojureScript file if it exists.", :row 295} {:fixed-arities #{3}, :end-row 322, :private true, :ns "cljs.repl", :name "mapped-line-column-call", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[source-map line column]"], :doc "Given a cljs.source-map source map data structure map a generated line\n   and column back to the original line, column, and function called.", :row 303} {:fixed-arities #{2}, :end-row 362, :private true, :ns "cljs.repl", :name "mapped-frame", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[{:keys [function file line column]} opts]"], :doc "Given opts and a canonicalized JavaScript stacktrace frame, return the\n  ClojureScript frame.", :row 324} {:fixed-arities #{1 2}, :end-row 392, :ns "cljs.repl", :name "mapped-stacktrace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[stacktrace]" "[stacktrace opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   return the ClojureScript stacktrace. The canonical stacktrace must be\n   in the form:\n\n    [{:file <string>\n      :function <string>\n      :line <integer>\n      :column <integer>}*]\n\n   :file must be a URL path (without protocol) relative to :output-dir or a\n   identifier delimited by angle brackets. The returned mapped stacktrace will\n   also contain :url entries to the original sources if it can be determined\n   from the classpath.", :row 364} {:arglist-strs ["[file {:keys [output-dir temp-output-dir?]}]"], :end-row 403, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "file-display", :ns "cljs.repl", :row 394} {:fixed-arities #{1 2}, :end-row 415, :ns "cljs.repl", :name "print-mapped-stacktrace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[stacktrace]" "[stacktrace opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   print the ClojureScript stacktrace. See mapped-stacktrace.", :row 405} {:end-row 418, :filename "cljs/repl.cljc", :lang :clj, :name "st", :ns "cljs.repl", :row 418} {:fixed-arities #{4 5}, :end-row 491, :private true, :ns "cljs.repl", :name "display-error", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env ret form opts]" "[repl-env ret form f opts]"], :row 469} {:fixed-arities #{1}, :end-row 496, :private true, :ns "cljs.repl", :name "bytes-to-base64-str", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[bytes]"], :doc "Convert a byte array into a base-64 encoded string.", :row 493} {:fixed-arities #{4 6 5}, :end-row 583, :ns "cljs.repl", :name "evaluate-form", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env env filename form]" "[repl-env env filename form wrap]" "[repl-env env filename form wrap opts]"], :doc "Evaluate a ClojureScript form in the JavaScript environment. Returns a\n  string which is the ClojureScript return value. This string may or may\n  not be readable by the Clojure reader.", :row 498} {:arglist-strs ["[repl-env filename res]"], :end-row 590, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :clj, :name "load-stream", :ns "cljs.repl", :row 585} {:arglist-strs ["[repl-env f]" "[repl-env f opts]"], :end-row 626, :filename "cljs/repl.cljc", :fixed-arities #{3 2}, :lang :clj, :name "load-file", :ns "cljs.repl", :row 592} {:fixed-arities #{1}, :end-row 635, :private true, :ns "cljs.repl", :name "root-resource", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[lib]"], :doc "Returns the root directory path for a lib", :row 628} {:fixed-arities #{1}, :end-row 641, :private true, :ns "cljs.repl", :name "root-directory", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[lib]"], :doc "Returns the root resource path for a lib", :row 637} {:fixed-arities #{1}, :end-row 650, :private true, :ns "cljs.repl", :name "load-path->cp-path", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[path]"], :row 643} {:fixed-arities #{1}, :end-row 671, :private true, :ns "cljs.repl", :name "wrap-fn", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[form]"], :row 652} {:fixed-arities #{1}, :end-row 683, :private true, :ns "cljs.repl", :name "init-wrap-fn", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[form]"], :row 673} {:fixed-arities #{4 3}, :end-row 699, :ns "cljs.repl", :name "eval-cljs", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env env form]" "[repl-env env form opts]"], :doc "Given a REPL evaluation environment, an analysis environment, and a\n   form, evaluate the form and return the result. The result is always the value\n   represented as a string.", :row 685} {:arglist-strs ["[specs]"], :end-row 704, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "decorate-specs", :ns "cljs.repl", :row 701} {:fixed-arities #{1}, :end-row 747, :private true, :ns "cljs.repl", :name "wrap-self", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Takes a self-ish fn and returns it wrapped with exception handling.\n  Compiler state is restored if self-ish fn fails.", :row 734} {:fixed-arities #{2}, :end-row 752, :private true, :ns "cljs.repl", :name "wrap-special-fns", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[wfn fns]"], :row 749} {:end-row 793, :filename "cljs/repl.cljc", :lang :clj, :name "default-special-fns", :ns "cljs.repl", :row 754} {:fixed-arities #{1 2}, :end-row 803, :ns "cljs.repl", :name "analyze-source", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[src-dir]" "[src-dir opts]"], :doc "Given a source directory, analyzes all .cljs files. Used to populate\n  (:cljs.analyzer/namespaces compiler-env) so as to support code reflection.", :row 795} {:arglist-strs ["[]"], :end-row 806, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :clj, :name "repl-title", :ns "cljs.repl", :row 805} {:arglist-strs ["[]"], :end-row 809, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :clj, :name "repl-quit-prompt", :ns "cljs.repl", :row 808} {:arglist-strs ["[]"], :end-row 812, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :clj, :name "repl-prompt", :ns "cljs.repl", :row 811} {:fixed-arities #{1}, :end-row 818, :ns "cljs.repl", :name "demunge", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[fn-name]"], :doc "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", :row 814} {:end-row 824, :filename "cljs/repl.cljc", :lang :clj, :name "core-namespaces", :ns "cljs.repl", :private true, :row 820} {:fixed-arities #{1}, :end-row 830, :private true, :ns "cljs.repl", :name "core-class?", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[class-name]"], :row 826} {:fixed-arities #{1}, :end-row 838, :private true, :ns "cljs.repl", :name "file-name", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[full-path]"], :doc "Helper to get just the file name part of a path or nil", :row 832} {:fixed-arities #{2}, :end-row 848, :private true, :ns "cljs.repl", :name "java-loc->source", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[clazz method]"], :doc "Convert Java class name and method symbol to source symbol, either a\n  Clojure function or Java class and method.", :row 840} {:fixed-arities #{1}, :end-row 905, :ns "cljs.repl", :name "ex-triage", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[datafied-throwable]"], :doc "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error", :row 850} {:fixed-arities #{1}, :end-row 980, :ns "cljs.repl", :name "ex-str", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[{:keys [:clojure.error/phase :clojure.error/source :clojure.error/line :clojure.error/column :clojure.error/symbol :clojure.error/class :clojure.error/cause :clojure.error/spec] :as triage-data}]"], :doc "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.", :row 907} {:arglist-strs ["[e repl-env opts]"], :end-row 998, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :clj, :name "repl-caught", :ns "cljs.repl", :row 982} {:arglist-strs ["[x]"], :end-row 1001, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "repl-nil?", :ns "cljs.repl", :row 1000} {:arglist-strs ["[renv inits]"], :end-row 1017, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "run-inits", :ns "cljs.repl", :row 1003} {:arglist-strs ["[opts]"], :end-row 1026, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "maybe-install-npm-deps", :ns "cljs.repl", :row 1019} {:arglist-strs ["[quit-prompt prompt]"], :end-row 1031, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "initial-prompt", :ns "cljs.repl", :row 1028} {:arglist-strs ["[repl-env {:keys [init inits need-prompt quit-prompt prompt flush read eval print caught reader print-no-newline source-map-inline wrap repl-requires ::fast-initial-prompt? compiler-env bind-err] :or {need-prompt #(if (readers/indexing-reader? *in*) (== (readers/get-column-number *in*) 1) (identity true)) fast-initial-prompt? false quit-prompt repl-title prompt repl-prompt flush flush read repl-read eval eval-cljs print println caught repl-caught reader #(readers/source-logging-push-back-reader *in* 1 \"<NO_SOURCE_FILE>\") print-no-newline print source-map-inline true repl-requires '[[cljs.repl :refer-macros [source doc find-doc apropos dir pst]] [cljs.pprint :refer [pprint] :refer-macros [pp]]] bind-err true} :as opts}]"], :end-row 1226, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "repl*", :ns "cljs.repl", :row 1033} {:arglist-strs ["[repl-env & opts]"], :doc "Generic, reusable, read-eval-print loop. By default, reads from *in* using\n  a c.t.r.reader-types/source-logging-push-back-reader,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  c.t.r.reader-types/PushbackReader or duplicate its behavior of both supporting\n  unread and collapsing CR, LF, and CRLF into a single \\newline. Options\n  are sequential keyword-value pairs. The first argument is the JavaScript\n  evaluation environment, the second argument is an extended version of the\n  standard ClojureScript compiler options. In addition to ClojureScript compiler\n  build options it also take a set of options similar to clojure.main/repl with\n  adjustments for ClojureScript evalution and compilation model:\n\n  Available clojure.main/repl style options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: #(if (c.t.r.readers-types/indexing-reader? *in*)\n                   (== (c.t.r.reader-types/get-column-number *in*) 1)\n                   (identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument. The eval function must take repl-env, the JavaScript evaluation\n       environment, env, the ClojureScript analysis environment, the form\n       and opts, the standard ClojureScript REPL/compiler options.\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: println\n\n     - :caught, function of three arguments, a throwable, called when\n       read, eval, or print throws an exception or error default. The second\n       argument is the JavaScript evaluation environment this permits context\n       sensitive handling if necessary. The third argument is opts, the standard\n       ClojureScript REPL/compiler options. In the case of errors or exception\n       in the JavaScript target, these will be thrown as\n       clojure.lang.IExceptionInfo instances.\n       default: repl-caught\n\n     - :reader, the c.t.r reader to use.\n       default: c.t.r.reader-types/source-logging-push-back-reader\n\n     - :print-no-newline, print without a newline.\n       default: print\n\n     - :source-map-inline, whether inline source maps should be enabled. Most\n       useful in browser context. Implies using a fresh reader for each form.\n       default: true", :end-row 1298, :filename "cljs/repl.cljc", :lang :clj, :name "repl", :ns "cljs.repl", :row 1228} {:end-row 1409, :filename "cljs/repl.cljc", :lang :clj, :name "special-doc-map", :ns "cljs.repl", :row 1303} {:fixed-arities #{1}, :end-row 1414, :private true, :ns "cljs.repl", :name "special-doc", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[name-symbol]"], :row 1411} {:end-row 1424, :filename "cljs/repl.cljc", :lang :clj, :name "repl-special-doc-map", :ns "cljs.repl", :row 1416} {:fixed-arities #{1}, :end-row 1429, :private true, :ns "cljs.repl", :name "repl-special-doc", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[name-symbol]"], :row 1426} {:fixed-arities #{1}, :end-row 1469, :ns "cljs.repl", :name "doc", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[name]"], :doc "Prints documentation for a var or special form given its name,\n  or for a spec if given a keyword", :row 1431} {:fixed-arities #{1}, :end-row 1493, :ns "cljs.repl", :name "find-doc", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[re-string-or-pattern]"], :doc "Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern", :row 1471} {:fixed-arities #{2}, :end-row 1518, :ns "cljs.repl", :name "source-fn", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[env x]"], :doc "Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)", :row 1495} {:end-row 1521, :filename "cljs/repl.cljc", :lang :clj, :name "cenv", :ns "cljs.repl", :row 1521} {:end-row 1522, :filename "cljs/repl.cljc", :lang :clj, :name "aenv", :ns "cljs.repl", :row 1522} {:fixed-arities #{1}, :end-row 1538, :ns "cljs.repl", :name "source", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[n]"], :doc "Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .cljs is in the classpath.\n\n  Example: (source filter)", :row 1531} {:fixed-arities #{1}, :end-row 1545, :private true, :ns "cljs.repl", :name "named-publics-vars", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[ns]"], :doc "Gets the public vars in a namespace that are not anonymous.", :row 1540} {:fixed-arities #{1}, :end-row 1562, :ns "cljs.repl", :name "apropos", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[str-or-pattern]"], :doc "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.", :row 1547} {:fixed-arities #{1}, :end-row 1570, :private true, :ns "cljs.repl", :name "resolve-ns", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[ns-sym]"], :doc "Resolves a namespace symbol to a namespace by first checking to see if it\n  is a namespace alias.", :row 1564} {:fixed-arities #{1}, :end-row 1576, :ns "cljs.repl", :name "dir", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[ns]"], :doc "Prints a sorted directory of public vars in a namespace", :row 1572} {:fixed-arities #{0 1}, :end-row 1595, :ns "cljs.repl", :name "pst", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[]" "[e]"], :row 1578} {:end-row 34, :filename "cljs/repl.cljc", :lang :cljs, :name "*cljs-verbose*", :ns "cljs.repl", :row 34} {:end-row 35, :filename "cljs/repl.cljc", :lang :cljs, :name "*repl-opts*", :ns "cljs.repl", :row 35} {:end-row 36, :filename "cljs/repl.cljc", :lang :cljs, :name "*repl-env*", :ns "cljs.repl", :row 36} {:doc "Set of all known REPL options.", :end-row 43, :filename "cljs/repl.cljc", :lang :cljs, :name "known-repl-opts", :ns "cljs.repl", :row 38} {:end-row 47, :private true, :ns "cljs.repl", :name "err-out", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[& body]"], :row 45} {:fixed-arities #{1}, :end-row 64, :ns "cljs.repl", :name "skip-if-eol", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[s]"], :doc "If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\newline.", :row 52} {:fixed-arities #{1}, :end-row 83, :ns "cljs.repl", :name "skip-whitespace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[s]"], :doc "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.", :row 66} {:fixed-arities #{3 2}, :end-row 110, :ns "cljs.repl", :name "repl-read", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[request-prompt request-exit]" "[request-prompt request-exit opts]"], :doc "Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.", :row 85} {:end-row 116, :filename "cljs/repl.cljc", :lang :cljs, :name "IReplEnvOptions", :ns "cljs.repl", :row 115} {:fixed-arities #{1}, :end-row 116, :ns "cljs.repl", :name "-repl-options", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]"], :doc "Return default REPL options for a REPL Env", :row 116} {:arglist-strs ["[repl-env]"], :end-row 119, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "repl-options", :ns "cljs.repl", :row 118} {:end-row 125, :filename "cljs/repl.cljc", :lang :cljs, :name "IJavaScriptEnv", :ns "cljs.repl", :row 121} {:fixed-arities #{2}, :end-row 122, :ns "cljs.repl", :name "-setup", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env opts]"], :doc "initialize the environment", :row 122} {:fixed-arities #{4}, :end-row 123, :ns "cljs.repl", :name "-evaluate", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env filename line js]"], :doc "evaluate a javascript string", :row 123} {:fixed-arities #{3}, :end-row 124, :ns "cljs.repl", :name "-load", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env provides url]"], :doc "load code at url into the environment", :row 124} {:fixed-arities #{1}, :end-row 125, :ns "cljs.repl", :name "-tear-down", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]"], :doc "dispose of the environment", :row 125} {:arglist-strs ["[repl-env opts]"], :end-row 128, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "setup", :ns "cljs.repl", :row 127} {:arglist-strs ["[repl-env filename line js]"], :end-row 131, :filename "cljs/repl.cljc", :fixed-arities #{4}, :lang :cljs, :name "evaluate", :ns "cljs.repl", :row 130} {:arglist-strs ["[repl-env provides url]"], :end-row 134, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :cljs, :name "load", :ns "cljs.repl", :row 133} {:arglist-strs ["[repl-env]"], :end-row 137, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "tear-down", :ns "cljs.repl", :row 136} {:end-row 147, :filename "cljs/repl.cljc", :lang :cljs, :name "IParseError", :ns "cljs.repl", :row 144} {:fixed-arities #{3}, :end-row 147, :ns "cljs.repl", :name "-parse-error", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env error build-options]"], :doc "Given the original JavaScript error return the error to actually\n     use.", :row 145} {:end-row 159, :filename "cljs/repl.cljc", :lang :cljs, :name "IGetError", :ns "cljs.repl", :row 149} {:fixed-arities #{4}, :end-row 159, :ns "cljs.repl", :name "-get-error", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env name env build-options]"], :doc "Given a symbol representing a var holding an error, an analysis\n     environment, and the REPL/compiler options return the canonical error\n     representation:\n\n     {:value <string>\n      :stacktrace <string>}\n\n    :value should be the host environment JavaScript error message string.\n    :stacktrace should be the host JavaScript environment stacktrace string.", :row 150} {:end-row 174, :filename "cljs/repl.cljc", :lang :cljs, :name "IParseStacktrace", :ns "cljs.repl", :row 161} {:fixed-arities #{4}, :end-row 174, :ns "cljs.repl", :name "-parse-stacktrace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env stacktrace error build-options]"], :doc "Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir. If\n     no source file can be supplied (such as REPL defs), :file may be a custom\n     identifier string surrounded by angle brackets, i.e. \"<cljs repl>\".", :row 162} {:end-row 179, :filename "cljs/repl.cljc", :lang :cljs, :name "IPrintStacktrace", :ns "cljs.repl", :row 176} {:fixed-arities #{4}, :end-row 179, :ns "cljs.repl", :name "-print-stacktrace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env stacktrace error build-options]"], :doc "Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing.", :row 177} {:fixed-arities #{1 2}, :end-row 191, :private true, :ns "cljs.repl", :name "env->opts", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]" "[repl-env opts]"], :doc "Returns a hash-map containing all of the entries in [repl-env], translating\n:working-dir to :output-dir.", :row 181} {:arglist-strs ["[ijs]"], :end-row 196, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "add-url", :ns "cljs.repl", :row 193} {:arglist-strs ["[ns opts]"], :end-row 204, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "ns->input", :ns "cljs.repl", :row 198} {:arglist-strs ["[input]"], :end-row 207, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "compilable?", :ns "cljs.repl", :row 206} {:fixed-arities #{3}, :end-row 224, :private true, :ns "cljs.repl", :name "load-sources", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env sources opts]"], :doc "Load the compiled `sources` into the REPL.", :row 209} {:fixed-arities #{3}, :end-row 231, :private true, :ns "cljs.repl", :name "load-cljs-loader", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env sources opts]"], :doc "Compile and load the cljs.loader namespace if it's present in `sources`.", :row 226} {:fixed-arities #{3 2}, :end-row 252, :ns "cljs.repl", :name "load-namespace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env ns]" "[repl-env ns opts]"], :doc "Load a namespace and all of its dependencies into the evaluation environment.\n  The environment is responsible for ensuring that each namespace is\n  loaded once and only once. Returns the compiled sources.", :row 233} {:fixed-arities #{3 2}, :end-row 259, :private true, :ns "cljs.repl", :name "load-dependencies", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env requires]" "[repl-env requires opts]"], :doc "Compile and load the given `requires` and return the compiled sources.", :row 254} {:fixed-arities #{1}, :end-row 273, :ns "cljs.repl", :name "js-src->cljs-src", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Map a JavaScript output file back to the original ClojureScript source\n   file (.cljs or .cljc).", :row 261} {:fixed-arities #{1}, :end-row 293, :ns "cljs.repl", :name "read-source-map", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Return the source map for the JavaScript source file.", :row 275} {:fixed-arities #{1}, :end-row 301, :ns "cljs.repl", :name "ns-info", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Given a path to a js source file return the ns info for the corresponding\n   ClojureScript file if it exists.", :row 295} {:fixed-arities #{3}, :end-row 322, :private true, :ns "cljs.repl", :name "mapped-line-column-call", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[source-map line column]"], :doc "Given a cljs.source-map source map data structure map a generated line\n   and column back to the original line, column, and function called.", :row 303} {:fixed-arities #{2}, :end-row 362, :private true, :ns "cljs.repl", :name "mapped-frame", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[{:keys [function file line column]} opts]"], :doc "Given opts and a canonicalized JavaScript stacktrace frame, return the\n  ClojureScript frame.", :row 324} {:fixed-arities #{1 2}, :end-row 392, :ns "cljs.repl", :name "mapped-stacktrace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[stacktrace]" "[stacktrace opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   return the ClojureScript stacktrace. The canonical stacktrace must be\n   in the form:\n\n    [{:file <string>\n      :function <string>\n      :line <integer>\n      :column <integer>}*]\n\n   :file must be a URL path (without protocol) relative to :output-dir or a\n   identifier delimited by angle brackets. The returned mapped stacktrace will\n   also contain :url entries to the original sources if it can be determined\n   from the classpath.", :row 364} {:arglist-strs ["[file {:keys [output-dir temp-output-dir?]}]"], :end-row 403, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "file-display", :ns "cljs.repl", :row 394} {:fixed-arities #{1 2}, :end-row 415, :ns "cljs.repl", :name "print-mapped-stacktrace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[stacktrace]" "[stacktrace opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   print the ClojureScript stacktrace. See mapped-stacktrace.", :row 405} {:end-row 418, :filename "cljs/repl.cljc", :lang :cljs, :name "st", :ns "cljs.repl", :row 418} {:fixed-arities #{4 5}, :end-row 491, :private true, :ns "cljs.repl", :name "display-error", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env ret form opts]" "[repl-env ret form f opts]"], :row 469} {:fixed-arities #{1}, :end-row 496, :private true, :ns "cljs.repl", :name "bytes-to-base64-str", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[bytes]"], :doc "Convert a byte array into a base-64 encoded string.", :row 493} {:fixed-arities #{4 6 5}, :end-row 583, :ns "cljs.repl", :name "evaluate-form", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env env filename form]" "[repl-env env filename form wrap]" "[repl-env env filename form wrap opts]"], :doc "Evaluate a ClojureScript form in the JavaScript environment. Returns a\n  string which is the ClojureScript return value. This string may or may\n  not be readable by the Clojure reader.", :row 498} {:arglist-strs ["[repl-env filename res]"], :end-row 590, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :cljs, :name "load-stream", :ns "cljs.repl", :row 585} {:arglist-strs ["[repl-env f]" "[repl-env f opts]"], :end-row 626, :filename "cljs/repl.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "load-file", :ns "cljs.repl", :row 592} {:fixed-arities #{1}, :end-row 635, :private true, :ns "cljs.repl", :name "root-resource", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[lib]"], :doc "Returns the root directory path for a lib", :row 628} {:fixed-arities #{1}, :end-row 641, :private true, :ns "cljs.repl", :name "root-directory", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[lib]"], :doc "Returns the root resource path for a lib", :row 637} {:fixed-arities #{1}, :end-row 650, :private true, :ns "cljs.repl", :name "load-path->cp-path", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[path]"], :row 643} {:fixed-arities #{1}, :end-row 671, :private true, :ns "cljs.repl", :name "wrap-fn", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[form]"], :row 652} {:fixed-arities #{1}, :end-row 683, :private true, :ns "cljs.repl", :name "init-wrap-fn", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[form]"], :row 673} {:fixed-arities #{4 3}, :end-row 699, :ns "cljs.repl", :name "eval-cljs", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env env form]" "[repl-env env form opts]"], :doc "Given a REPL evaluation environment, an analysis environment, and a\n   form, evaluate the form and return the result. The result is always the value\n   represented as a string.", :row 685} {:arglist-strs ["[specs]"], :end-row 704, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "decorate-specs", :ns "cljs.repl", :row 701} {:fixed-arities #{1}, :end-row 747, :private true, :ns "cljs.repl", :name "wrap-self", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Takes a self-ish fn and returns it wrapped with exception handling.\n  Compiler state is restored if self-ish fn fails.", :row 734} {:fixed-arities #{2}, :end-row 752, :private true, :ns "cljs.repl", :name "wrap-special-fns", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[wfn fns]"], :row 749} {:end-row 793, :filename "cljs/repl.cljc", :lang :cljs, :name "default-special-fns", :ns "cljs.repl", :row 754} {:fixed-arities #{1 2}, :end-row 803, :ns "cljs.repl", :name "analyze-source", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[src-dir]" "[src-dir opts]"], :doc "Given a source directory, analyzes all .cljs files. Used to populate\n  (:cljs.analyzer/namespaces compiler-env) so as to support code reflection.", :row 795} {:arglist-strs ["[]"], :end-row 806, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :cljs, :name "repl-title", :ns "cljs.repl", :row 805} {:arglist-strs ["[]"], :end-row 809, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :cljs, :name "repl-quit-prompt", :ns "cljs.repl", :row 808} {:arglist-strs ["[]"], :end-row 812, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :cljs, :name "repl-prompt", :ns "cljs.repl", :row 811} {:fixed-arities #{1}, :end-row 818, :ns "cljs.repl", :name "demunge", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[fn-name]"], :doc "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", :row 814} {:end-row 824, :filename "cljs/repl.cljc", :lang :cljs, :name "core-namespaces", :ns "cljs.repl", :private true, :row 820} {:fixed-arities #{1}, :end-row 830, :private true, :ns "cljs.repl", :name "core-class?", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[class-name]"], :row 826} {:fixed-arities #{1}, :end-row 838, :private true, :ns "cljs.repl", :name "file-name", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[full-path]"], :doc "Helper to get just the file name part of a path or nil", :row 832} {:fixed-arities #{2}, :end-row 848, :private true, :ns "cljs.repl", :name "java-loc->source", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[clazz method]"], :doc "Convert Java class name and method symbol to source symbol, either a\n  Clojure function or Java class and method.", :row 840} {:fixed-arities #{1}, :end-row 905, :ns "cljs.repl", :name "ex-triage", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[datafied-throwable]"], :doc "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error", :row 850} {:fixed-arities #{1}, :end-row 980, :ns "cljs.repl", :name "ex-str", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[{:keys [:clojure.error/phase :clojure.error/source :clojure.error/line :clojure.error/column :clojure.error/symbol :clojure.error/class :clojure.error/cause :clojure.error/spec] :as triage-data}]"], :doc "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.", :row 907} {:arglist-strs ["[e repl-env opts]"], :end-row 998, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :cljs, :name "repl-caught", :ns "cljs.repl", :row 982} {:arglist-strs ["[x]"], :end-row 1001, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "repl-nil?", :ns "cljs.repl", :row 1000} {:arglist-strs ["[renv inits]"], :end-row 1017, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "run-inits", :ns "cljs.repl", :row 1003} {:arglist-strs ["[opts]"], :end-row 1026, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "maybe-install-npm-deps", :ns "cljs.repl", :row 1019} {:arglist-strs ["[quit-prompt prompt]"], :end-row 1031, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "initial-prompt", :ns "cljs.repl", :row 1028} {:arglist-strs ["[repl-env {:keys [init inits need-prompt quit-prompt prompt flush read eval print caught reader print-no-newline source-map-inline wrap repl-requires ::fast-initial-prompt? compiler-env bind-err] :or {need-prompt #(if (readers/indexing-reader? *in*) (== (readers/get-column-number *in*) 1) (identity true)) fast-initial-prompt? false quit-prompt repl-title prompt repl-prompt flush flush read repl-read eval eval-cljs print println caught repl-caught reader #(readers/source-logging-push-back-reader *in* 1 \"<NO_SOURCE_FILE>\") print-no-newline print source-map-inline true repl-requires '[[cljs.repl :refer-macros [source doc find-doc apropos dir pst]] [cljs.pprint :refer [pprint] :refer-macros [pp]]] bind-err true} :as opts}]"], :end-row 1226, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "repl*", :ns "cljs.repl", :row 1033} {:arglist-strs ["[repl-env & opts]"], :doc "Generic, reusable, read-eval-print loop. By default, reads from *in* using\n  a c.t.r.reader-types/source-logging-push-back-reader,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  c.t.r.reader-types/PushbackReader or duplicate its behavior of both supporting\n  unread and collapsing CR, LF, and CRLF into a single \\newline. Options\n  are sequential keyword-value pairs. The first argument is the JavaScript\n  evaluation environment, the second argument is an extended version of the\n  standard ClojureScript compiler options. In addition to ClojureScript compiler\n  build options it also take a set of options similar to clojure.main/repl with\n  adjustments for ClojureScript evalution and compilation model:\n\n  Available clojure.main/repl style options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: #(if (c.t.r.readers-types/indexing-reader? *in*)\n                   (== (c.t.r.reader-types/get-column-number *in*) 1)\n                   (identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument. The eval function must take repl-env, the JavaScript evaluation\n       environment, env, the ClojureScript analysis environment, the form\n       and opts, the standard ClojureScript REPL/compiler options.\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: println\n\n     - :caught, function of three arguments, a throwable, called when\n       read, eval, or print throws an exception or error default. The second\n       argument is the JavaScript evaluation environment this permits context\n       sensitive handling if necessary. The third argument is opts, the standard\n       ClojureScript REPL/compiler options. In the case of errors or exception\n       in the JavaScript target, these will be thrown as\n       clojure.lang.IExceptionInfo instances.\n       default: repl-caught\n\n     - :reader, the c.t.r reader to use.\n       default: c.t.r.reader-types/source-logging-push-back-reader\n\n     - :print-no-newline, print without a newline.\n       default: print\n\n     - :source-map-inline, whether inline source maps should be enabled. Most\n       useful in browser context. Implies using a fresh reader for each form.\n       default: true", :end-row 1298, :filename "cljs/repl.cljc", :lang :cljs, :name "repl", :ns "cljs.repl", :row 1228} {:end-row 1409, :filename "cljs/repl.cljc", :lang :cljs, :name "special-doc-map", :ns "cljs.repl", :row 1303} {:fixed-arities #{1}, :end-row 1414, :private true, :ns "cljs.repl", :name "special-doc", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[name-symbol]"], :row 1411} {:end-row 1424, :filename "cljs/repl.cljc", :lang :cljs, :name "repl-special-doc-map", :ns "cljs.repl", :row 1416} {:fixed-arities #{1}, :end-row 1429, :private true, :ns "cljs.repl", :name "repl-special-doc", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[name-symbol]"], :row 1426} {:fixed-arities #{1}, :end-row 1469, :ns "cljs.repl", :name "doc", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[name]"], :doc "Prints documentation for a var or special form given its name,\n  or for a spec if given a keyword", :row 1431} {:fixed-arities #{1}, :end-row 1493, :ns "cljs.repl", :name "find-doc", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[re-string-or-pattern]"], :doc "Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern", :row 1471} {:fixed-arities #{2}, :end-row 1518, :ns "cljs.repl", :name "source-fn", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[env x]"], :doc "Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)", :row 1495} {:end-row 1521, :filename "cljs/repl.cljc", :lang :cljs, :name "cenv", :ns "cljs.repl", :row 1521} {:end-row 1522, :filename "cljs/repl.cljc", :lang :cljs, :name "aenv", :ns "cljs.repl", :row 1522} {:fixed-arities #{1}, :end-row 1538, :ns "cljs.repl", :name "source", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[n]"], :doc "Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .cljs is in the classpath.\n\n  Example: (source filter)", :row 1531} {:fixed-arities #{1}, :end-row 1545, :private true, :ns "cljs.repl", :name "named-publics-vars", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[ns]"], :doc "Gets the public vars in a namespace that are not anonymous.", :row 1540} {:fixed-arities #{1}, :end-row 1562, :ns "cljs.repl", :name "apropos", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[str-or-pattern]"], :doc "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.", :row 1547} {:fixed-arities #{1}, :end-row 1570, :private true, :ns "cljs.repl", :name "resolve-ns", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[ns-sym]"], :doc "Resolves a namespace symbol to a namespace by first checking to see if it\n  is a namespace alias.", :row 1564} {:fixed-arities #{1}, :end-row 1576, :ns "cljs.repl", :name "dir", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[ns]"], :doc "Prints a sorted directory of public vars in a namespace", :row 1572} {:fixed-arities #{0 1}, :end-row 1595, :ns "cljs.repl", :name "pst", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[]" "[e]"], :row 1578} {:arglist-strs ["[{n :ns nm :name :as m}]"], :end-row 60, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "print-doc", :ns "cljs.repl", :row 15} {:arglist-strs ["[o]"], :doc "Constructs a data representation for a Error with keys:\n    :cause - root cause message\n    :phase - error phase\n    :via - cause chain, with cause keys:\n             :type - exception class symbol\n             :message - exception message\n             :data - ex-data\n             :at - top stack element\n    :trace - root cause stack elements", :end-row 97, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "Error->map", :ns "cljs.repl", :row 62} {:arglist-strs ["[datafied-throwable]"], :doc "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error", :end-row 154, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "ex-triage", :ns "cljs.repl", :row 99} {:arglist-strs ["[{:clojure.error/keys [phase source line column symbol class cause spec] :as triage-data}]"], :doc "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.", :end-row 227, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "ex-str", :ns "cljs.repl", :row 156} {:arglist-strs ["[error]"], :end-row 230, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "error->str", :ns "cljs.repl", :row 229}]} {:end-row 32, :filename "cljs/repl.cljc", :lang :cljs, :name "cljs.repl", :row 9, :ns nil, :var-definitions [{:end-row 34, :filename "cljs/repl.cljc", :lang :clj, :name "*cljs-verbose*", :ns "cljs.repl", :row 34} {:end-row 35, :filename "cljs/repl.cljc", :lang :clj, :name "*repl-opts*", :ns "cljs.repl", :row 35} {:end-row 36, :filename "cljs/repl.cljc", :lang :clj, :name "*repl-env*", :ns "cljs.repl", :row 36} {:doc "Set of all known REPL options.", :end-row 43, :filename "cljs/repl.cljc", :lang :clj, :name "known-repl-opts", :ns "cljs.repl", :row 38} {:end-row 47, :private true, :ns "cljs.repl", :name "err-out", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[& body]"], :row 45} {:fixed-arities #{1}, :end-row 64, :ns "cljs.repl", :name "skip-if-eol", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[s]"], :doc "If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\newline.", :row 52} {:fixed-arities #{1}, :end-row 83, :ns "cljs.repl", :name "skip-whitespace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[s]"], :doc "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.", :row 66} {:fixed-arities #{3 2}, :end-row 110, :ns "cljs.repl", :name "repl-read", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[request-prompt request-exit]" "[request-prompt request-exit opts]"], :doc "Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.", :row 85} {:end-row 116, :filename "cljs/repl.cljc", :lang :clj, :name "IReplEnvOptions", :ns "cljs.repl", :row 115} {:fixed-arities #{1}, :end-row 116, :ns "cljs.repl", :name "-repl-options", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]"], :doc "Return default REPL options for a REPL Env", :row 116} {:arglist-strs ["[repl-env]"], :end-row 119, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "repl-options", :ns "cljs.repl", :row 118} {:end-row 125, :filename "cljs/repl.cljc", :lang :clj, :name "IJavaScriptEnv", :ns "cljs.repl", :row 121} {:fixed-arities #{2}, :end-row 122, :ns "cljs.repl", :name "-setup", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env opts]"], :doc "initialize the environment", :row 122} {:fixed-arities #{4}, :end-row 123, :ns "cljs.repl", :name "-evaluate", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env filename line js]"], :doc "evaluate a javascript string", :row 123} {:fixed-arities #{3}, :end-row 124, :ns "cljs.repl", :name "-load", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env provides url]"], :doc "load code at url into the environment", :row 124} {:fixed-arities #{1}, :end-row 125, :ns "cljs.repl", :name "-tear-down", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]"], :doc "dispose of the environment", :row 125} {:arglist-strs ["[repl-env opts]"], :end-row 128, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "setup", :ns "cljs.repl", :row 127} {:arglist-strs ["[repl-env filename line js]"], :end-row 131, :filename "cljs/repl.cljc", :fixed-arities #{4}, :lang :clj, :name "evaluate", :ns "cljs.repl", :row 130} {:arglist-strs ["[repl-env provides url]"], :end-row 134, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :clj, :name "load", :ns "cljs.repl", :row 133} {:arglist-strs ["[repl-env]"], :end-row 137, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "tear-down", :ns "cljs.repl", :row 136} {:end-row 147, :filename "cljs/repl.cljc", :lang :clj, :name "IParseError", :ns "cljs.repl", :row 144} {:fixed-arities #{3}, :end-row 147, :ns "cljs.repl", :name "-parse-error", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env error build-options]"], :doc "Given the original JavaScript error return the error to actually\n     use.", :row 145} {:end-row 159, :filename "cljs/repl.cljc", :lang :clj, :name "IGetError", :ns "cljs.repl", :row 149} {:fixed-arities #{4}, :end-row 159, :ns "cljs.repl", :name "-get-error", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env name env build-options]"], :doc "Given a symbol representing a var holding an error, an analysis\n     environment, and the REPL/compiler options return the canonical error\n     representation:\n\n     {:value <string>\n      :stacktrace <string>}\n\n    :value should be the host environment JavaScript error message string.\n    :stacktrace should be the host JavaScript environment stacktrace string.", :row 150} {:end-row 174, :filename "cljs/repl.cljc", :lang :clj, :name "IParseStacktrace", :ns "cljs.repl", :row 161} {:fixed-arities #{4}, :end-row 174, :ns "cljs.repl", :name "-parse-stacktrace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env stacktrace error build-options]"], :doc "Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir. If\n     no source file can be supplied (such as REPL defs), :file may be a custom\n     identifier string surrounded by angle brackets, i.e. \"<cljs repl>\".", :row 162} {:end-row 179, :filename "cljs/repl.cljc", :lang :clj, :name "IPrintStacktrace", :ns "cljs.repl", :row 176} {:fixed-arities #{4}, :end-row 179, :ns "cljs.repl", :name "-print-stacktrace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env stacktrace error build-options]"], :doc "Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing.", :row 177} {:fixed-arities #{1 2}, :end-row 191, :private true, :ns "cljs.repl", :name "env->opts", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]" "[repl-env opts]"], :doc "Returns a hash-map containing all of the entries in [repl-env], translating\n:working-dir to :output-dir.", :row 181} {:arglist-strs ["[ijs]"], :end-row 196, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "add-url", :ns "cljs.repl", :row 193} {:arglist-strs ["[ns opts]"], :end-row 204, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "ns->input", :ns "cljs.repl", :row 198} {:arglist-strs ["[input]"], :end-row 207, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "compilable?", :ns "cljs.repl", :row 206} {:fixed-arities #{3}, :end-row 224, :private true, :ns "cljs.repl", :name "load-sources", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env sources opts]"], :doc "Load the compiled `sources` into the REPL.", :row 209} {:fixed-arities #{3}, :end-row 231, :private true, :ns "cljs.repl", :name "load-cljs-loader", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env sources opts]"], :doc "Compile and load the cljs.loader namespace if it's present in `sources`.", :row 226} {:fixed-arities #{3 2}, :end-row 252, :ns "cljs.repl", :name "load-namespace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env ns]" "[repl-env ns opts]"], :doc "Load a namespace and all of its dependencies into the evaluation environment.\n  The environment is responsible for ensuring that each namespace is\n  loaded once and only once. Returns the compiled sources.", :row 233} {:fixed-arities #{3 2}, :end-row 259, :private true, :ns "cljs.repl", :name "load-dependencies", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env requires]" "[repl-env requires opts]"], :doc "Compile and load the given `requires` and return the compiled sources.", :row 254} {:fixed-arities #{1}, :end-row 273, :ns "cljs.repl", :name "js-src->cljs-src", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Map a JavaScript output file back to the original ClojureScript source\n   file (.cljs or .cljc).", :row 261} {:fixed-arities #{1}, :end-row 293, :ns "cljs.repl", :name "read-source-map", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Return the source map for the JavaScript source file.", :row 275} {:fixed-arities #{1}, :end-row 301, :ns "cljs.repl", :name "ns-info", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Given a path to a js source file return the ns info for the corresponding\n   ClojureScript file if it exists.", :row 295} {:fixed-arities #{3}, :end-row 322, :private true, :ns "cljs.repl", :name "mapped-line-column-call", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[source-map line column]"], :doc "Given a cljs.source-map source map data structure map a generated line\n   and column back to the original line, column, and function called.", :row 303} {:fixed-arities #{2}, :end-row 362, :private true, :ns "cljs.repl", :name "mapped-frame", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[{:keys [function file line column]} opts]"], :doc "Given opts and a canonicalized JavaScript stacktrace frame, return the\n  ClojureScript frame.", :row 324} {:fixed-arities #{1 2}, :end-row 392, :ns "cljs.repl", :name "mapped-stacktrace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[stacktrace]" "[stacktrace opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   return the ClojureScript stacktrace. The canonical stacktrace must be\n   in the form:\n\n    [{:file <string>\n      :function <string>\n      :line <integer>\n      :column <integer>}*]\n\n   :file must be a URL path (without protocol) relative to :output-dir or a\n   identifier delimited by angle brackets. The returned mapped stacktrace will\n   also contain :url entries to the original sources if it can be determined\n   from the classpath.", :row 364} {:arglist-strs ["[file {:keys [output-dir temp-output-dir?]}]"], :end-row 403, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "file-display", :ns "cljs.repl", :row 394} {:fixed-arities #{1 2}, :end-row 415, :ns "cljs.repl", :name "print-mapped-stacktrace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[stacktrace]" "[stacktrace opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   print the ClojureScript stacktrace. See mapped-stacktrace.", :row 405} {:end-row 418, :filename "cljs/repl.cljc", :lang :clj, :name "st", :ns "cljs.repl", :row 418} {:fixed-arities #{4 5}, :end-row 491, :private true, :ns "cljs.repl", :name "display-error", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env ret form opts]" "[repl-env ret form f opts]"], :row 469} {:fixed-arities #{1}, :end-row 496, :private true, :ns "cljs.repl", :name "bytes-to-base64-str", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[bytes]"], :doc "Convert a byte array into a base-64 encoded string.", :row 493} {:fixed-arities #{4 6 5}, :end-row 583, :ns "cljs.repl", :name "evaluate-form", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env env filename form]" "[repl-env env filename form wrap]" "[repl-env env filename form wrap opts]"], :doc "Evaluate a ClojureScript form in the JavaScript environment. Returns a\n  string which is the ClojureScript return value. This string may or may\n  not be readable by the Clojure reader.", :row 498} {:arglist-strs ["[repl-env filename res]"], :end-row 590, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :clj, :name "load-stream", :ns "cljs.repl", :row 585} {:arglist-strs ["[repl-env f]" "[repl-env f opts]"], :end-row 626, :filename "cljs/repl.cljc", :fixed-arities #{3 2}, :lang :clj, :name "load-file", :ns "cljs.repl", :row 592} {:fixed-arities #{1}, :end-row 635, :private true, :ns "cljs.repl", :name "root-resource", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[lib]"], :doc "Returns the root directory path for a lib", :row 628} {:fixed-arities #{1}, :end-row 641, :private true, :ns "cljs.repl", :name "root-directory", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[lib]"], :doc "Returns the root resource path for a lib", :row 637} {:fixed-arities #{1}, :end-row 650, :private true, :ns "cljs.repl", :name "load-path->cp-path", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[path]"], :row 643} {:fixed-arities #{1}, :end-row 671, :private true, :ns "cljs.repl", :name "wrap-fn", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[form]"], :row 652} {:fixed-arities #{1}, :end-row 683, :private true, :ns "cljs.repl", :name "init-wrap-fn", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[form]"], :row 673} {:fixed-arities #{4 3}, :end-row 699, :ns "cljs.repl", :name "eval-cljs", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env env form]" "[repl-env env form opts]"], :doc "Given a REPL evaluation environment, an analysis environment, and a\n   form, evaluate the form and return the result. The result is always the value\n   represented as a string.", :row 685} {:arglist-strs ["[specs]"], :end-row 704, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "decorate-specs", :ns "cljs.repl", :row 701} {:fixed-arities #{1}, :end-row 747, :private true, :ns "cljs.repl", :name "wrap-self", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Takes a self-ish fn and returns it wrapped with exception handling.\n  Compiler state is restored if self-ish fn fails.", :row 734} {:fixed-arities #{2}, :end-row 752, :private true, :ns "cljs.repl", :name "wrap-special-fns", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[wfn fns]"], :row 749} {:end-row 793, :filename "cljs/repl.cljc", :lang :clj, :name "default-special-fns", :ns "cljs.repl", :row 754} {:fixed-arities #{1 2}, :end-row 803, :ns "cljs.repl", :name "analyze-source", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[src-dir]" "[src-dir opts]"], :doc "Given a source directory, analyzes all .cljs files. Used to populate\n  (:cljs.analyzer/namespaces compiler-env) so as to support code reflection.", :row 795} {:arglist-strs ["[]"], :end-row 806, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :clj, :name "repl-title", :ns "cljs.repl", :row 805} {:arglist-strs ["[]"], :end-row 809, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :clj, :name "repl-quit-prompt", :ns "cljs.repl", :row 808} {:arglist-strs ["[]"], :end-row 812, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :clj, :name "repl-prompt", :ns "cljs.repl", :row 811} {:fixed-arities #{1}, :end-row 818, :ns "cljs.repl", :name "demunge", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[fn-name]"], :doc "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", :row 814} {:end-row 824, :filename "cljs/repl.cljc", :lang :clj, :name "core-namespaces", :ns "cljs.repl", :private true, :row 820} {:fixed-arities #{1}, :end-row 830, :private true, :ns "cljs.repl", :name "core-class?", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[class-name]"], :row 826} {:fixed-arities #{1}, :end-row 838, :private true, :ns "cljs.repl", :name "file-name", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[full-path]"], :doc "Helper to get just the file name part of a path or nil", :row 832} {:fixed-arities #{2}, :end-row 848, :private true, :ns "cljs.repl", :name "java-loc->source", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[clazz method]"], :doc "Convert Java class name and method symbol to source symbol, either a\n  Clojure function or Java class and method.", :row 840} {:fixed-arities #{1}, :end-row 905, :ns "cljs.repl", :name "ex-triage", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[datafied-throwable]"], :doc "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error", :row 850} {:fixed-arities #{1}, :end-row 980, :ns "cljs.repl", :name "ex-str", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[{:keys [:clojure.error/phase :clojure.error/source :clojure.error/line :clojure.error/column :clojure.error/symbol :clojure.error/class :clojure.error/cause :clojure.error/spec] :as triage-data}]"], :doc "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.", :row 907} {:arglist-strs ["[e repl-env opts]"], :end-row 998, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :clj, :name "repl-caught", :ns "cljs.repl", :row 982} {:arglist-strs ["[x]"], :end-row 1001, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "repl-nil?", :ns "cljs.repl", :row 1000} {:arglist-strs ["[renv inits]"], :end-row 1017, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "run-inits", :ns "cljs.repl", :row 1003} {:arglist-strs ["[opts]"], :end-row 1026, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "maybe-install-npm-deps", :ns "cljs.repl", :row 1019} {:arglist-strs ["[quit-prompt prompt]"], :end-row 1031, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "initial-prompt", :ns "cljs.repl", :row 1028} {:arglist-strs ["[repl-env {:keys [init inits need-prompt quit-prompt prompt flush read eval print caught reader print-no-newline source-map-inline wrap repl-requires ::fast-initial-prompt? compiler-env bind-err] :or {need-prompt #(if (readers/indexing-reader? *in*) (== (readers/get-column-number *in*) 1) (identity true)) fast-initial-prompt? false quit-prompt repl-title prompt repl-prompt flush flush read repl-read eval eval-cljs print println caught repl-caught reader #(readers/source-logging-push-back-reader *in* 1 \"<NO_SOURCE_FILE>\") print-no-newline print source-map-inline true repl-requires '[[cljs.repl :refer-macros [source doc find-doc apropos dir pst]] [cljs.pprint :refer [pprint] :refer-macros [pp]]] bind-err true} :as opts}]"], :end-row 1226, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "repl*", :ns "cljs.repl", :row 1033} {:arglist-strs ["[repl-env & opts]"], :doc "Generic, reusable, read-eval-print loop. By default, reads from *in* using\n  a c.t.r.reader-types/source-logging-push-back-reader,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  c.t.r.reader-types/PushbackReader or duplicate its behavior of both supporting\n  unread and collapsing CR, LF, and CRLF into a single \\newline. Options\n  are sequential keyword-value pairs. The first argument is the JavaScript\n  evaluation environment, the second argument is an extended version of the\n  standard ClojureScript compiler options. In addition to ClojureScript compiler\n  build options it also take a set of options similar to clojure.main/repl with\n  adjustments for ClojureScript evalution and compilation model:\n\n  Available clojure.main/repl style options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: #(if (c.t.r.readers-types/indexing-reader? *in*)\n                   (== (c.t.r.reader-types/get-column-number *in*) 1)\n                   (identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument. The eval function must take repl-env, the JavaScript evaluation\n       environment, env, the ClojureScript analysis environment, the form\n       and opts, the standard ClojureScript REPL/compiler options.\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: println\n\n     - :caught, function of three arguments, a throwable, called when\n       read, eval, or print throws an exception or error default. The second\n       argument is the JavaScript evaluation environment this permits context\n       sensitive handling if necessary. The third argument is opts, the standard\n       ClojureScript REPL/compiler options. In the case of errors or exception\n       in the JavaScript target, these will be thrown as\n       clojure.lang.IExceptionInfo instances.\n       default: repl-caught\n\n     - :reader, the c.t.r reader to use.\n       default: c.t.r.reader-types/source-logging-push-back-reader\n\n     - :print-no-newline, print without a newline.\n       default: print\n\n     - :source-map-inline, whether inline source maps should be enabled. Most\n       useful in browser context. Implies using a fresh reader for each form.\n       default: true", :end-row 1298, :filename "cljs/repl.cljc", :lang :clj, :name "repl", :ns "cljs.repl", :row 1228} {:end-row 1409, :filename "cljs/repl.cljc", :lang :clj, :name "special-doc-map", :ns "cljs.repl", :row 1303} {:fixed-arities #{1}, :end-row 1414, :private true, :ns "cljs.repl", :name "special-doc", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[name-symbol]"], :row 1411} {:end-row 1424, :filename "cljs/repl.cljc", :lang :clj, :name "repl-special-doc-map", :ns "cljs.repl", :row 1416} {:fixed-arities #{1}, :end-row 1429, :private true, :ns "cljs.repl", :name "repl-special-doc", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[name-symbol]"], :row 1426} {:fixed-arities #{1}, :end-row 1469, :ns "cljs.repl", :name "doc", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[name]"], :doc "Prints documentation for a var or special form given its name,\n  or for a spec if given a keyword", :row 1431} {:fixed-arities #{1}, :end-row 1493, :ns "cljs.repl", :name "find-doc", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[re-string-or-pattern]"], :doc "Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern", :row 1471} {:fixed-arities #{2}, :end-row 1518, :ns "cljs.repl", :name "source-fn", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[env x]"], :doc "Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)", :row 1495} {:end-row 1521, :filename "cljs/repl.cljc", :lang :clj, :name "cenv", :ns "cljs.repl", :row 1521} {:end-row 1522, :filename "cljs/repl.cljc", :lang :clj, :name "aenv", :ns "cljs.repl", :row 1522} {:fixed-arities #{1}, :end-row 1538, :ns "cljs.repl", :name "source", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[n]"], :doc "Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .cljs is in the classpath.\n\n  Example: (source filter)", :row 1531} {:fixed-arities #{1}, :end-row 1545, :private true, :ns "cljs.repl", :name "named-publics-vars", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[ns]"], :doc "Gets the public vars in a namespace that are not anonymous.", :row 1540} {:fixed-arities #{1}, :end-row 1562, :ns "cljs.repl", :name "apropos", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[str-or-pattern]"], :doc "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.", :row 1547} {:fixed-arities #{1}, :end-row 1570, :private true, :ns "cljs.repl", :name "resolve-ns", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[ns-sym]"], :doc "Resolves a namespace symbol to a namespace by first checking to see if it\n  is a namespace alias.", :row 1564} {:fixed-arities #{1}, :end-row 1576, :ns "cljs.repl", :name "dir", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[ns]"], :doc "Prints a sorted directory of public vars in a namespace", :row 1572} {:fixed-arities #{0 1}, :end-row 1595, :ns "cljs.repl", :name "pst", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[]" "[e]"], :row 1578} {:end-row 34, :filename "cljs/repl.cljc", :lang :cljs, :name "*cljs-verbose*", :ns "cljs.repl", :row 34} {:end-row 35, :filename "cljs/repl.cljc", :lang :cljs, :name "*repl-opts*", :ns "cljs.repl", :row 35} {:end-row 36, :filename "cljs/repl.cljc", :lang :cljs, :name "*repl-env*", :ns "cljs.repl", :row 36} {:doc "Set of all known REPL options.", :end-row 43, :filename "cljs/repl.cljc", :lang :cljs, :name "known-repl-opts", :ns "cljs.repl", :row 38} {:end-row 47, :private true, :ns "cljs.repl", :name "err-out", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[& body]"], :row 45} {:fixed-arities #{1}, :end-row 64, :ns "cljs.repl", :name "skip-if-eol", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[s]"], :doc "If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\newline.", :row 52} {:fixed-arities #{1}, :end-row 83, :ns "cljs.repl", :name "skip-whitespace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[s]"], :doc "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.", :row 66} {:fixed-arities #{3 2}, :end-row 110, :ns "cljs.repl", :name "repl-read", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[request-prompt request-exit]" "[request-prompt request-exit opts]"], :doc "Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.", :row 85} {:end-row 116, :filename "cljs/repl.cljc", :lang :cljs, :name "IReplEnvOptions", :ns "cljs.repl", :row 115} {:fixed-arities #{1}, :end-row 116, :ns "cljs.repl", :name "-repl-options", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]"], :doc "Return default REPL options for a REPL Env", :row 116} {:arglist-strs ["[repl-env]"], :end-row 119, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "repl-options", :ns "cljs.repl", :row 118} {:end-row 125, :filename "cljs/repl.cljc", :lang :cljs, :name "IJavaScriptEnv", :ns "cljs.repl", :row 121} {:fixed-arities #{2}, :end-row 122, :ns "cljs.repl", :name "-setup", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env opts]"], :doc "initialize the environment", :row 122} {:fixed-arities #{4}, :end-row 123, :ns "cljs.repl", :name "-evaluate", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env filename line js]"], :doc "evaluate a javascript string", :row 123} {:fixed-arities #{3}, :end-row 124, :ns "cljs.repl", :name "-load", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env provides url]"], :doc "load code at url into the environment", :row 124} {:fixed-arities #{1}, :end-row 125, :ns "cljs.repl", :name "-tear-down", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]"], :doc "dispose of the environment", :row 125} {:arglist-strs ["[repl-env opts]"], :end-row 128, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "setup", :ns "cljs.repl", :row 127} {:arglist-strs ["[repl-env filename line js]"], :end-row 131, :filename "cljs/repl.cljc", :fixed-arities #{4}, :lang :cljs, :name "evaluate", :ns "cljs.repl", :row 130} {:arglist-strs ["[repl-env provides url]"], :end-row 134, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :cljs, :name "load", :ns "cljs.repl", :row 133} {:arglist-strs ["[repl-env]"], :end-row 137, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "tear-down", :ns "cljs.repl", :row 136} {:end-row 147, :filename "cljs/repl.cljc", :lang :cljs, :name "IParseError", :ns "cljs.repl", :row 144} {:fixed-arities #{3}, :end-row 147, :ns "cljs.repl", :name "-parse-error", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env error build-options]"], :doc "Given the original JavaScript error return the error to actually\n     use.", :row 145} {:end-row 159, :filename "cljs/repl.cljc", :lang :cljs, :name "IGetError", :ns "cljs.repl", :row 149} {:fixed-arities #{4}, :end-row 159, :ns "cljs.repl", :name "-get-error", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env name env build-options]"], :doc "Given a symbol representing a var holding an error, an analysis\n     environment, and the REPL/compiler options return the canonical error\n     representation:\n\n     {:value <string>\n      :stacktrace <string>}\n\n    :value should be the host environment JavaScript error message string.\n    :stacktrace should be the host JavaScript environment stacktrace string.", :row 150} {:end-row 174, :filename "cljs/repl.cljc", :lang :cljs, :name "IParseStacktrace", :ns "cljs.repl", :row 161} {:fixed-arities #{4}, :end-row 174, :ns "cljs.repl", :name "-parse-stacktrace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env stacktrace error build-options]"], :doc "Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir. If\n     no source file can be supplied (such as REPL defs), :file may be a custom\n     identifier string surrounded by angle brackets, i.e. \"<cljs repl>\".", :row 162} {:end-row 179, :filename "cljs/repl.cljc", :lang :cljs, :name "IPrintStacktrace", :ns "cljs.repl", :row 176} {:fixed-arities #{4}, :end-row 179, :ns "cljs.repl", :name "-print-stacktrace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env stacktrace error build-options]"], :doc "Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing.", :row 177} {:fixed-arities #{1 2}, :end-row 191, :private true, :ns "cljs.repl", :name "env->opts", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]" "[repl-env opts]"], :doc "Returns a hash-map containing all of the entries in [repl-env], translating\n:working-dir to :output-dir.", :row 181} {:arglist-strs ["[ijs]"], :end-row 196, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "add-url", :ns "cljs.repl", :row 193} {:arglist-strs ["[ns opts]"], :end-row 204, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "ns->input", :ns "cljs.repl", :row 198} {:arglist-strs ["[input]"], :end-row 207, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "compilable?", :ns "cljs.repl", :row 206} {:fixed-arities #{3}, :end-row 224, :private true, :ns "cljs.repl", :name "load-sources", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env sources opts]"], :doc "Load the compiled `sources` into the REPL.", :row 209} {:fixed-arities #{3}, :end-row 231, :private true, :ns "cljs.repl", :name "load-cljs-loader", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env sources opts]"], :doc "Compile and load the cljs.loader namespace if it's present in `sources`.", :row 226} {:fixed-arities #{3 2}, :end-row 252, :ns "cljs.repl", :name "load-namespace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env ns]" "[repl-env ns opts]"], :doc "Load a namespace and all of its dependencies into the evaluation environment.\n  The environment is responsible for ensuring that each namespace is\n  loaded once and only once. Returns the compiled sources.", :row 233} {:fixed-arities #{3 2}, :end-row 259, :private true, :ns "cljs.repl", :name "load-dependencies", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env requires]" "[repl-env requires opts]"], :doc "Compile and load the given `requires` and return the compiled sources.", :row 254} {:fixed-arities #{1}, :end-row 273, :ns "cljs.repl", :name "js-src->cljs-src", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Map a JavaScript output file back to the original ClojureScript source\n   file (.cljs or .cljc).", :row 261} {:fixed-arities #{1}, :end-row 293, :ns "cljs.repl", :name "read-source-map", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Return the source map for the JavaScript source file.", :row 275} {:fixed-arities #{1}, :end-row 301, :ns "cljs.repl", :name "ns-info", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Given a path to a js source file return the ns info for the corresponding\n   ClojureScript file if it exists.", :row 295} {:fixed-arities #{3}, :end-row 322, :private true, :ns "cljs.repl", :name "mapped-line-column-call", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[source-map line column]"], :doc "Given a cljs.source-map source map data structure map a generated line\n   and column back to the original line, column, and function called.", :row 303} {:fixed-arities #{2}, :end-row 362, :private true, :ns "cljs.repl", :name "mapped-frame", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[{:keys [function file line column]} opts]"], :doc "Given opts and a canonicalized JavaScript stacktrace frame, return the\n  ClojureScript frame.", :row 324} {:fixed-arities #{1 2}, :end-row 392, :ns "cljs.repl", :name "mapped-stacktrace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[stacktrace]" "[stacktrace opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   return the ClojureScript stacktrace. The canonical stacktrace must be\n   in the form:\n\n    [{:file <string>\n      :function <string>\n      :line <integer>\n      :column <integer>}*]\n\n   :file must be a URL path (without protocol) relative to :output-dir or a\n   identifier delimited by angle brackets. The returned mapped stacktrace will\n   also contain :url entries to the original sources if it can be determined\n   from the classpath.", :row 364} {:arglist-strs ["[file {:keys [output-dir temp-output-dir?]}]"], :end-row 403, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "file-display", :ns "cljs.repl", :row 394} {:fixed-arities #{1 2}, :end-row 415, :ns "cljs.repl", :name "print-mapped-stacktrace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[stacktrace]" "[stacktrace opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   print the ClojureScript stacktrace. See mapped-stacktrace.", :row 405} {:end-row 418, :filename "cljs/repl.cljc", :lang :cljs, :name "st", :ns "cljs.repl", :row 418} {:fixed-arities #{4 5}, :end-row 491, :private true, :ns "cljs.repl", :name "display-error", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env ret form opts]" "[repl-env ret form f opts]"], :row 469} {:fixed-arities #{1}, :end-row 496, :private true, :ns "cljs.repl", :name "bytes-to-base64-str", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[bytes]"], :doc "Convert a byte array into a base-64 encoded string.", :row 493} {:fixed-arities #{4 6 5}, :end-row 583, :ns "cljs.repl", :name "evaluate-form", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env env filename form]" "[repl-env env filename form wrap]" "[repl-env env filename form wrap opts]"], :doc "Evaluate a ClojureScript form in the JavaScript environment. Returns a\n  string which is the ClojureScript return value. This string may or may\n  not be readable by the Clojure reader.", :row 498} {:arglist-strs ["[repl-env filename res]"], :end-row 590, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :cljs, :name "load-stream", :ns "cljs.repl", :row 585} {:arglist-strs ["[repl-env f]" "[repl-env f opts]"], :end-row 626, :filename "cljs/repl.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "load-file", :ns "cljs.repl", :row 592} {:fixed-arities #{1}, :end-row 635, :private true, :ns "cljs.repl", :name "root-resource", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[lib]"], :doc "Returns the root directory path for a lib", :row 628} {:fixed-arities #{1}, :end-row 641, :private true, :ns "cljs.repl", :name "root-directory", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[lib]"], :doc "Returns the root resource path for a lib", :row 637} {:fixed-arities #{1}, :end-row 650, :private true, :ns "cljs.repl", :name "load-path->cp-path", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[path]"], :row 643} {:fixed-arities #{1}, :end-row 671, :private true, :ns "cljs.repl", :name "wrap-fn", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[form]"], :row 652} {:fixed-arities #{1}, :end-row 683, :private true, :ns "cljs.repl", :name "init-wrap-fn", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[form]"], :row 673} {:fixed-arities #{4 3}, :end-row 699, :ns "cljs.repl", :name "eval-cljs", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env env form]" "[repl-env env form opts]"], :doc "Given a REPL evaluation environment, an analysis environment, and a\n   form, evaluate the form and return the result. The result is always the value\n   represented as a string.", :row 685} {:arglist-strs ["[specs]"], :end-row 704, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "decorate-specs", :ns "cljs.repl", :row 701} {:fixed-arities #{1}, :end-row 747, :private true, :ns "cljs.repl", :name "wrap-self", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Takes a self-ish fn and returns it wrapped with exception handling.\n  Compiler state is restored if self-ish fn fails.", :row 734} {:fixed-arities #{2}, :end-row 752, :private true, :ns "cljs.repl", :name "wrap-special-fns", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[wfn fns]"], :row 749} {:end-row 793, :filename "cljs/repl.cljc", :lang :cljs, :name "default-special-fns", :ns "cljs.repl", :row 754} {:fixed-arities #{1 2}, :end-row 803, :ns "cljs.repl", :name "analyze-source", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[src-dir]" "[src-dir opts]"], :doc "Given a source directory, analyzes all .cljs files. Used to populate\n  (:cljs.analyzer/namespaces compiler-env) so as to support code reflection.", :row 795} {:arglist-strs ["[]"], :end-row 806, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :cljs, :name "repl-title", :ns "cljs.repl", :row 805} {:arglist-strs ["[]"], :end-row 809, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :cljs, :name "repl-quit-prompt", :ns "cljs.repl", :row 808} {:arglist-strs ["[]"], :end-row 812, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :cljs, :name "repl-prompt", :ns "cljs.repl", :row 811} {:fixed-arities #{1}, :end-row 818, :ns "cljs.repl", :name "demunge", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[fn-name]"], :doc "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", :row 814} {:end-row 824, :filename "cljs/repl.cljc", :lang :cljs, :name "core-namespaces", :ns "cljs.repl", :private true, :row 820} {:fixed-arities #{1}, :end-row 830, :private true, :ns "cljs.repl", :name "core-class?", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[class-name]"], :row 826} {:fixed-arities #{1}, :end-row 838, :private true, :ns "cljs.repl", :name "file-name", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[full-path]"], :doc "Helper to get just the file name part of a path or nil", :row 832} {:fixed-arities #{2}, :end-row 848, :private true, :ns "cljs.repl", :name "java-loc->source", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[clazz method]"], :doc "Convert Java class name and method symbol to source symbol, either a\n  Clojure function or Java class and method.", :row 840} {:fixed-arities #{1}, :end-row 905, :ns "cljs.repl", :name "ex-triage", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[datafied-throwable]"], :doc "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error", :row 850} {:fixed-arities #{1}, :end-row 980, :ns "cljs.repl", :name "ex-str", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[{:keys [:clojure.error/phase :clojure.error/source :clojure.error/line :clojure.error/column :clojure.error/symbol :clojure.error/class :clojure.error/cause :clojure.error/spec] :as triage-data}]"], :doc "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.", :row 907} {:arglist-strs ["[e repl-env opts]"], :end-row 998, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :cljs, :name "repl-caught", :ns "cljs.repl", :row 982} {:arglist-strs ["[x]"], :end-row 1001, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "repl-nil?", :ns "cljs.repl", :row 1000} {:arglist-strs ["[renv inits]"], :end-row 1017, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "run-inits", :ns "cljs.repl", :row 1003} {:arglist-strs ["[opts]"], :end-row 1026, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "maybe-install-npm-deps", :ns "cljs.repl", :row 1019} {:arglist-strs ["[quit-prompt prompt]"], :end-row 1031, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "initial-prompt", :ns "cljs.repl", :row 1028} {:arglist-strs ["[repl-env {:keys [init inits need-prompt quit-prompt prompt flush read eval print caught reader print-no-newline source-map-inline wrap repl-requires ::fast-initial-prompt? compiler-env bind-err] :or {need-prompt #(if (readers/indexing-reader? *in*) (== (readers/get-column-number *in*) 1) (identity true)) fast-initial-prompt? false quit-prompt repl-title prompt repl-prompt flush flush read repl-read eval eval-cljs print println caught repl-caught reader #(readers/source-logging-push-back-reader *in* 1 \"<NO_SOURCE_FILE>\") print-no-newline print source-map-inline true repl-requires '[[cljs.repl :refer-macros [source doc find-doc apropos dir pst]] [cljs.pprint :refer [pprint] :refer-macros [pp]]] bind-err true} :as opts}]"], :end-row 1226, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "repl*", :ns "cljs.repl", :row 1033} {:arglist-strs ["[repl-env & opts]"], :doc "Generic, reusable, read-eval-print loop. By default, reads from *in* using\n  a c.t.r.reader-types/source-logging-push-back-reader,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  c.t.r.reader-types/PushbackReader or duplicate its behavior of both supporting\n  unread and collapsing CR, LF, and CRLF into a single \\newline. Options\n  are sequential keyword-value pairs. The first argument is the JavaScript\n  evaluation environment, the second argument is an extended version of the\n  standard ClojureScript compiler options. In addition to ClojureScript compiler\n  build options it also take a set of options similar to clojure.main/repl with\n  adjustments for ClojureScript evalution and compilation model:\n\n  Available clojure.main/repl style options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: #(if (c.t.r.readers-types/indexing-reader? *in*)\n                   (== (c.t.r.reader-types/get-column-number *in*) 1)\n                   (identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument. The eval function must take repl-env, the JavaScript evaluation\n       environment, env, the ClojureScript analysis environment, the form\n       and opts, the standard ClojureScript REPL/compiler options.\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: println\n\n     - :caught, function of three arguments, a throwable, called when\n       read, eval, or print throws an exception or error default. The second\n       argument is the JavaScript evaluation environment this permits context\n       sensitive handling if necessary. The third argument is opts, the standard\n       ClojureScript REPL/compiler options. In the case of errors or exception\n       in the JavaScript target, these will be thrown as\n       clojure.lang.IExceptionInfo instances.\n       default: repl-caught\n\n     - :reader, the c.t.r reader to use.\n       default: c.t.r.reader-types/source-logging-push-back-reader\n\n     - :print-no-newline, print without a newline.\n       default: print\n\n     - :source-map-inline, whether inline source maps should be enabled. Most\n       useful in browser context. Implies using a fresh reader for each form.\n       default: true", :end-row 1298, :filename "cljs/repl.cljc", :lang :cljs, :name "repl", :ns "cljs.repl", :row 1228} {:end-row 1409, :filename "cljs/repl.cljc", :lang :cljs, :name "special-doc-map", :ns "cljs.repl", :row 1303} {:fixed-arities #{1}, :end-row 1414, :private true, :ns "cljs.repl", :name "special-doc", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[name-symbol]"], :row 1411} {:end-row 1424, :filename "cljs/repl.cljc", :lang :cljs, :name "repl-special-doc-map", :ns "cljs.repl", :row 1416} {:fixed-arities #{1}, :end-row 1429, :private true, :ns "cljs.repl", :name "repl-special-doc", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[name-symbol]"], :row 1426} {:fixed-arities #{1}, :end-row 1469, :ns "cljs.repl", :name "doc", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[name]"], :doc "Prints documentation for a var or special form given its name,\n  or for a spec if given a keyword", :row 1431} {:fixed-arities #{1}, :end-row 1493, :ns "cljs.repl", :name "find-doc", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[re-string-or-pattern]"], :doc "Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern", :row 1471} {:fixed-arities #{2}, :end-row 1518, :ns "cljs.repl", :name "source-fn", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[env x]"], :doc "Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)", :row 1495} {:end-row 1521, :filename "cljs/repl.cljc", :lang :cljs, :name "cenv", :ns "cljs.repl", :row 1521} {:end-row 1522, :filename "cljs/repl.cljc", :lang :cljs, :name "aenv", :ns "cljs.repl", :row 1522} {:fixed-arities #{1}, :end-row 1538, :ns "cljs.repl", :name "source", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[n]"], :doc "Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .cljs is in the classpath.\n\n  Example: (source filter)", :row 1531} {:fixed-arities #{1}, :end-row 1545, :private true, :ns "cljs.repl", :name "named-publics-vars", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[ns]"], :doc "Gets the public vars in a namespace that are not anonymous.", :row 1540} {:fixed-arities #{1}, :end-row 1562, :ns "cljs.repl", :name "apropos", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[str-or-pattern]"], :doc "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.", :row 1547} {:fixed-arities #{1}, :end-row 1570, :private true, :ns "cljs.repl", :name "resolve-ns", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[ns-sym]"], :doc "Resolves a namespace symbol to a namespace by first checking to see if it\n  is a namespace alias.", :row 1564} {:fixed-arities #{1}, :end-row 1576, :ns "cljs.repl", :name "dir", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[ns]"], :doc "Prints a sorted directory of public vars in a namespace", :row 1572} {:fixed-arities #{0 1}, :end-row 1595, :ns "cljs.repl", :name "pst", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[]" "[e]"], :row 1578} {:arglist-strs ["[{n :ns nm :name :as m}]"], :end-row 60, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "print-doc", :ns "cljs.repl", :row 15} {:arglist-strs ["[o]"], :doc "Constructs a data representation for a Error with keys:\n    :cause - root cause message\n    :phase - error phase\n    :via - cause chain, with cause keys:\n             :type - exception class symbol\n             :message - exception message\n             :data - ex-data\n             :at - top stack element\n    :trace - root cause stack elements", :end-row 97, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "Error->map", :ns "cljs.repl", :row 62} {:arglist-strs ["[datafied-throwable]"], :doc "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error", :end-row 154, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "ex-triage", :ns "cljs.repl", :row 99} {:arglist-strs ["[{:clojure.error/keys [phase source line column symbol class cause spec] :as triage-data}]"], :doc "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.", :end-row 227, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "ex-str", :ns "cljs.repl", :row 156} {:arglist-strs ["[error]"], :end-row 230, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "error->str", :ns "cljs.repl", :row 229}]} {:doc "A namespace that exists solely to provide a place for \"compiler\"\nstate that is accessed/maintained by many different components.", :end-row 14, :filename "cljs/env.cljc", :lang :clj, :name "cljs.env", :row 9, :ns nil, :var-definitions [{:end-row 44, :filename "cljs/env.cljc", :lang :clj, :name "*compiler*", :ns "cljs.env", :row 44} {:arglist-strs ["[options]"], :end-row 57, :filename "cljs/env.cljc", :fixed-arities #{1}, :lang :clj, :name "default-compiler-env*", :ns "cljs.env", :row 46} {:arglist-strs ["[]" "[options]"], :end-row 62, :filename "cljs/env.cljc", :fixed-arities #{0 1}, :lang :clj, :name "default-compiler-env", :ns "cljs.env", :row 59} {:end-row 77, :ns "cljs.env", :name "with-compiler-env", :lang :clj, :filename "cljs/env.cljc", :macro true, :arglist-strs ["[env & body]"], :doc "Evaluates [body] with [env] bound as the value of the `*compiler*` var in\n   this namespace.", :row 65} {:arglist-strs ["[& body]"], :end-row 90, :filename "cljs/env.cljc", :lang :clj, :macro true, :name "ensure", :ns "cljs.env", :row 80} {:end-row 44, :filename "cljs/env.cljc", :lang :cljs, :name "*compiler*", :ns "cljs.env", :row 44} {:arglist-strs ["[options]"], :end-row 57, :filename "cljs/env.cljc", :fixed-arities #{1}, :lang :cljs, :name "default-compiler-env*", :ns "cljs.env", :row 46} {:arglist-strs ["[]" "[options]"], :end-row 62, :filename "cljs/env.cljc", :fixed-arities #{0 1}, :lang :cljs, :name "default-compiler-env", :ns "cljs.env", :row 59}]} {:doc "A namespace that exists solely to provide a place for \"compiler\"\nstate that is accessed/maintained by many different components.", :end-row 14, :filename "cljs/env.cljc", :lang :cljs, :name "cljs.env", :row 9, :ns nil, :var-definitions [{:end-row 44, :filename "cljs/env.cljc", :lang :clj, :name "*compiler*", :ns "cljs.env", :row 44} {:arglist-strs ["[options]"], :end-row 57, :filename "cljs/env.cljc", :fixed-arities #{1}, :lang :clj, :name "default-compiler-env*", :ns "cljs.env", :row 46} {:arglist-strs ["[]" "[options]"], :end-row 62, :filename "cljs/env.cljc", :fixed-arities #{0 1}, :lang :clj, :name "default-compiler-env", :ns "cljs.env", :row 59} {:end-row 77, :ns "cljs.env", :name "with-compiler-env", :lang :clj, :filename "cljs/env.cljc", :macro true, :arglist-strs ["[env & body]"], :doc "Evaluates [body] with [env] bound as the value of the `*compiler*` var in\n   this namespace.", :row 65} {:arglist-strs ["[& body]"], :end-row 90, :filename "cljs/env.cljc", :lang :clj, :macro true, :name "ensure", :ns "cljs.env", :row 80} {:end-row 44, :filename "cljs/env.cljc", :lang :cljs, :name "*compiler*", :ns "cljs.env", :row 44} {:arglist-strs ["[options]"], :end-row 57, :filename "cljs/env.cljc", :fixed-arities #{1}, :lang :cljs, :name "default-compiler-env*", :ns "cljs.env", :row 46} {:arglist-strs ["[]" "[options]"], :end-row 62, :filename "cljs/env.cljc", :fixed-arities #{0 1}, :lang :cljs, :name "default-compiler-env", :ns "cljs.env", :row 59}]} {:doc "This is intended to be a stable api for those who need programmatic access\n  to ClojureScript's project building facilities.\n\n  For example: a build script may need to how to invalidate compiled\n  files so that they will be recompiled.", :end-row 22, :filename "cljs/build/api.clj", :name "cljs.build.api", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[ns-sym]" "[ns-sym output-dir]"], :doc "Given an output directory and a clojurescript namespace return the\n  compilation target file for that namespace.\n\n  For example:\n  (target-file-from-cljs-ns \"resources/out\" 'example.core) ->\n  <File: \"resources/out/example/core.js\">", :end-row 35, :filename "cljs/build/api.clj", :fixed-arities #{1 2}, :name "target-file-for-cljs-ns", :ns "cljs.build.api", :row 27} {:arglist-strs ["[ns-sym]" "[ns-sym output-dir]"], :doc "Backdates a cljs target file so that it the cljs compiler will recompile it.", :end-row 40, :filename "cljs/build/api.clj", :fixed-arities #{1 2}, :name "mark-cljs-ns-for-recompile!", :ns "cljs.build.api", :row 37} {:arglist-strs ["[namespaces]" "[state namespaces]"], :doc "Takes a list of Clojure (.clj) namespaces that define macros and\n  returns a list ClojureScript (.cljs) namespaces that depend on those macro\n  namespaces.\n\n  For example where example.macros is defined in the clojure file\n  \"example/macros.clj\" and both 'example.core and 'example.util are\n  ClojureScript namespaces that require and use the macros from\n  'example.macros :\n  (cljs-dependents-for-macro-namespaces 'example.macros) ->\n  ('example.core 'example.util)", :end-row 57, :filename "cljs/build/api.clj", :fixed-arities #{1 2}, :name "cljs-dependents-for-macro-namespaces", :ns "cljs.build.api", :row 42} {:arglist-strs ["[f]"], :doc "Given a Google Closure style JavaScript file or resource return the namespace\n  information for the given file. Only returns the value extracted from the\n  first provide statement.", :end-row 64, :filename "cljs/build/api.clj", :fixed-arities #{1}, :name "parse-js-ns", :ns "cljs.build.api", :row 59} {:arglist-strs ["[src]" "[src opts]" "[state src opts]"], :doc "Given a ClojureScript source file return the target file. May optionally\n  provide build options with :output-dir specified.", :end-row 76, :filename "cljs/build/api.clj", :fixed-arities #{1 3 2}, :name "src-file->target-file", :ns "cljs.build.api", :row 66} {:arglist-strs ["[src]" "[src opts]" "[state src opts]"], :doc "Given a ClojureScript or Google Closure style JavaScript source file return\n  the goog.require statement for it.", :end-row 88, :filename "cljs/build/api.clj", :fixed-arities #{1 3 2}, :name "src-file->goog-require", :ns "cljs.build.api", :row 78} {:arglist-strs ["[xs]"], :doc "Given a sequence of cljs.closure/IJavaScript values, create an index using\n  :provides. The original values will appear under each :provide.", :end-row 98, :filename "cljs/build/api.clj", :fixed-arities #{1}, :name "index-ijs", :ns "cljs.build.api", :row 90} {:arglist-strs ["[opts ijs]"], :doc "Given compiler options and a IJavaScript instance return the corresponding\n  goog.addDependency string", :end-row 107, :filename "cljs/build/api.clj", :fixed-arities #{2}, :name "goog-dep-string", :ns "cljs.build.api", :row 103} {:arglist-strs ["[opts ijs]"], :doc "Ensure that the given IJavaScript exists on disk in the output directory.\n  Return updated IJavaScript with the new location if necessary.", :end-row 113, :filename "cljs/build/api.clj", :fixed-arities #{2}, :name "source-on-disk", :ns "cljs.build.api", :row 109} {:arglist-strs ["[ns]"], :doc "Given a namespace as a symbol return the corresponding resource if it exists.", :end-row 118, :filename "cljs/build/api.clj", :fixed-arities #{1}, :name "ns->source", :ns "cljs.build.api", :row 115} {:arglist-strs ["[ns]" "[ns compiler-env]"], :doc "Given a namespace and compilation environment return the relative path and\n  uri of the corresponding source regardless of the source language extension:\n  .cljs, .cljc, .js. Returns a map containing :relative-path a string, and\n  :uri a URL.", :end-row 128, :filename "cljs/build/api.clj", :fixed-arities #{1 2}, :name "ns->location", :ns "cljs.build.api", :row 120} {:arglist-strs ["[x]" "[x opts]"], :doc "Given a cljs.closure/Compilable value, return the corresponding\n  cljs.closure/IJavaScript value.", :end-row 136, :filename "cljs/build/api.clj", :fixed-arities #{1 2}, :name "compilable->ijs", :ns "cljs.build.api", :row 130} {:arglist-strs ["[xs]" "[xs opts]" "[state xs opts]"], :doc "Given a sequence of cljs.closure/IJavaScript values, return a set that includes\n  all dependencies.", :end-row 147, :filename "cljs/build/api.clj", :fixed-arities #{1 3 2}, :name "add-dependency-sources", :ns "cljs.build.api", :row 138} {:arglist-strs ["[opts & ijss]"], :doc "DEPRECATED: Given one or more IJavaScript objects in dependency order, produce\n  a new sequence of IJavaScript objects which includes the input list\n  plus all dependencies in dependency order.", :end-row 154, :filename "cljs/build/api.clj", :name "add-dependencies", :ns "cljs.build.api", :row 149} {:arglist-strs ["[state xs opts]"], :doc "Given a collection of IJavaScript values representing a build, index all\n  node modules, convert all JS modules (ES6 etc), and store the updated\n  js-dependency-index (likely changed due to modules) in compiler state.", :end-row 161, :filename "cljs/build/api.clj", :fixed-arities #{3}, :name "handle-js-modules", :ns "cljs.build.api", :row 156} {:arglist-strs ["[xs]"], :doc "Topologically sort a collection of IJavaScript values.", :end-row 166, :filename "cljs/build/api.clj", :fixed-arities #{1}, :name "dependency-order", :ns "cljs.build.api", :row 163} {:arglist-strs ["[opts]"], :doc "Given a valid map of build options add any standard implicit options. For\n  example :optimizations :none implies :cache-analysis true and :source-map\n  true.", :end-row 173, :filename "cljs/build/api.clj", :fixed-arities #{1}, :name "add-implicit-options", :ns "cljs.build.api", :row 168} {:arglist-strs ["[& xs]"], :doc "Given a list of directories and files, return a compilable object that may\n  be passed to build or watch.", :end-row 192, :filename "cljs/build/api.clj", :name "inputs", :ns "cljs.build.api", :row 175} {:arglist-strs ["[opts compilable]" "[state opts compilable]"], :doc "Given a Compilable, compile it and return an IJavaScript.", :end-row 200, :filename "cljs/build/api.clj", :fixed-arities #{3 2}, :name "compile", :ns "cljs.build.api", :row 194} {:arglist-strs ["[opts & sources]"], :doc "Ensure that all JavaScript source files are on disk (not in jars),\n   write the goog deps file including only the libraries that are being\n   used and write the deps file for the current project.\n\n   The deps file for the current project will include third-party\n   libraries.", :end-row 210, :filename "cljs/build/api.clj", :name "output-unoptimized", :ns "cljs.build.api", :row 202} {:arglist-strs ["[opts]" "[source opts]" "[source opts compiler-env]"], :doc "Given compiler options, produce runnable JavaScript. An optional source\n   parameter may be provided.", :end-row 231, :filename "cljs/build/api.clj", :fixed-arities #{1 3 2}, :name "build", :ns "cljs.build.api", :row 212} {:arglist-strs ["[source opts]" "[source opts compiler-env]" "[source opts compiler-env stop]"], :doc "Given a source which can be compiled, watch it for changes to produce.", :end-row 244, :filename "cljs/build/api.clj", :fixed-arities #{4 3 2}, :name "watch", :ns "cljs.build.api", :row 233} {:arglist-strs ["[m]"], :end-row 256, :filename "cljs/build/api.clj", :fixed-arities #{1}, :name "compiler-opts?", :ns "cljs.build.api", :row 249} {:arglist-strs ["[dependencies]" "[dependencies opts]"], :doc "EXPERIMENTAL: Install the supplied dependencies via NPM. dependencies must be\n   a map of name to version or a valid compiler options map.", :end-row 271, :filename "cljs/build/api.clj", :fixed-arities #{1 2}, :name "install-node-deps!", :ns "cljs.build.api", :row 258} {:arglist-strs ["[dependencies]" "[dependencies opts]"], :doc "EXPERIMENTAL: Get the Node.js dependency graph of the supplied dependencies.\n   Dependencies must be a sequence of strings or symbols naming packages or paths\n   within packages (e.g. [react \"react-dom/server\"] or a valid compiler options\n   map. Assumes dependencies have been been previously installed, either by\n   `cljs.build.api/install-node-deps!` or by an NPM client, and reside in the\n   `node_modules` directory.", :end-row 290, :filename "cljs/build/api.clj", :fixed-arities #{1 2}, :name "get-node-deps", :ns "cljs.build.api", :row 273} {:arglist-strs ["[entries]" "[entries opts]"], :doc "EXPERIMENTAL: return the foreign libs entries as computed by running\n   the module-deps package on the supplied JavaScript entry points. Assumes\n   that the `@cljs-oss/module-deps` NPM package is either locally or globally\n   installed.", :end-row 301, :filename "cljs/build/api.clj", :fixed-arities #{1 2}, :name "node-inputs", :ns "cljs.build.api", :row 292} {:arglist-strs ["[]" "[opts]"], :doc "Return a sequence of requirable libraries found under node_modules.", :end-row 309, :filename "cljs/build/api.clj", :fixed-arities #{0 1}, :name "node-modules", :ns "cljs.build.api", :row 303}]} {:end-row 10, :filename "cljs/env/macros.clj", :name "cljs.env.macros", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[env & body]"], :doc "Evaluates [body] with [env] bound as the value of the `*compiler*` var in\n this namespace.", :end-row 26, :filename "cljs/env/macros.clj", :macro true, :name "with-compiler-env", :ns "cljs.env.macros", :row 12} {:arglist-strs ["[& body]"], :end-row 37, :filename "cljs/env/macros.clj", :macro true, :name "ensure", :ns "cljs.env.macros", :row 28}]} {:end-row 13, :filename "cljs/loader.cljs", :name "cljs.loader", :row 9, :ns nil, :var-definitions [{:end-row 15, :filename "cljs/loader.cljs", :name "module-infos", :ns "cljs.loader", :row 15} {:end-row 19, :filename "cljs/loader.cljs", :name "module-uris", :ns "cljs.loader", :row 16} {:arglist-strs ["[x graph]"], :end-row 24, :filename "cljs/loader.cljs", :fixed-arities #{2}, :name "deps-for", :ns "cljs.loader", :row 21} {:arglist-strs ["[x]"], :end-row 28, :filename "cljs/loader.cljs", :fixed-arities #{1}, :name "munge-kw", :ns "cljs.loader", :row 26} {:arglist-strs ["[x]"], :end-row 32, :filename "cljs/loader.cljs", :fixed-arities #{1}, :name "to-tr-url", :ns "cljs.loader", :row 30} {:arglist-strs ["[m]"], :end-row 39, :filename "cljs/loader.cljs", :fixed-arities #{1}, :name "to-js", :ns "cljs.loader", :row 34} {:arglist-strs ["[]"], :end-row 45, :filename "cljs/loader.cljs", :fixed-arities #{0}, :name "create-module-manager", :ns "cljs.loader", :row 41} {:end-row 47, :filename "cljs/loader.cljs", :name "*module-manager*", :ns "cljs.loader", :row 47} {:arglist-strs ["[module-name]"], :doc "Return true if modules is loaded. module-name should be a keyword matching\n   a :modules module definition.", :end-row 62, :filename "cljs/loader.cljs", :fixed-arities #{1}, :name "loaded?", :ns "cljs.loader", :row 53} {:arglist-strs ["[module-name]" "[module-name cb]"], :doc "Load a module. module-name should be a keyword matching a :modules module\n   definition.", :end-row 76, :filename "cljs/loader.cljs", :fixed-arities #{1 2}, :name "load", :ns "cljs.loader", :row 64} {:arglist-strs ["[module-name]"], :doc "Set a module as being loaded. module-name should be a keyword matching a\n  :modules module definition. Will mark all parent modules as also being\n  loaded.", :end-row 94, :filename "cljs/loader.cljs", :fixed-arities #{1}, :name "set-loaded!", :ns "cljs.loader", :row 78} {:arglist-strs ["[module-name]"], :doc "Prefetch a module. module-name should be a keyword matching a :modules\n  module definition. Will download the module but not evaluate it. To\n  complete module load, one must also call cljs.loader/load after prefetching\n  the module. Does nothing if the module is loading or has been loaded.", :end-row 107, :filename "cljs/loader.cljs", :fixed-arities #{1}, :name "prefetch", :ns "cljs.loader", :row 96}]} {:end-row 58, :filename "cljs/core.cljc", :lang :clj, :name "cljs.core", :row 9, :ns nil, :var-definitions [{:fixed-arities #{2}, :end-row 90, :ns "cljs.core", :name "import-macros", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[ns [& vars]]"], :row 64} {:end-row 192, :ns "cljs.core", :name "doto", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x & forms]"], :doc "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new js/Map) (.set \"a\" 1) (.set \"b\" 2))", :row 178} {:end-row 389, :ns "cljs.core", :name "memfn", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & args]"], :doc "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a JavaScript\n  method as a first-class fn.", :row 380} {:fixed-arities #{1}, :end-row 590, :private true, :ns "cljs.core", :name "assert-valid-fdecl", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :doc "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.", :row 553} {:fixed-arities #{1}, :end-row 617, :private true, :ns "cljs.core", :name "sigs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 592} {:fixed-arities #{2}, :end-row 627, :ns "cljs.core", :name "defonce", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x init]"], :doc "defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated", :row 619} {:arglist-strs ["[bindings]"], :end-row 730, :filename "cljs/core.cljc", :fixed-arities #{1}, :lang :clj, :name "destructure", :ns "cljs.core", :row 629} {:end-row 736, :private true, :ns "cljs.core", :name "return-first", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :row 732} {:fixed-arities #{2}, :end-row 770, :ns "cljs.core", :name "goog-define", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[sym default]"], :doc "Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n    or\n    :closure-defines {your-app.core/DEBUG! true}", :row 738} {:end-row 787, :ns "cljs.core", :name "let", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => binding-form init-expr\n  binding-form => name, or destructuring-form\n  destructuring-form => map-destructure-form, or seq-destructure-form\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\n\n  See https://clojure.org/reference/special_forms#binding-forms for\n  more information about destructuring.", :row 772} {:end-row 811, :ns "cljs.core", :name "loop", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", :row 789} {:doc "protocol fqn -> [partition number, bit]", :end-row 829, :filename "cljs/core.cljc", :lang :clj, :name "fast-path-protocols", :ns "cljs.core", :row 813} {:doc "total number of partitions", :end-row 837, :filename "cljs/core.cljc", :lang :clj, :name "fast-path-protocol-partitions-count", :ns "cljs.core", :row 831} {:fixed-arities #{2}, :end-row 842, :private true, :ns "cljs.core", :name "compatible?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[inferred-tag allowed-tags]"], :row 839} {:fixed-arities #{3}, :end-row 847, :private true, :ns "cljs.core", :name "typed-expr?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env form allowed-tags]"], :row 844} {:fixed-arities #{1}, :end-row 850, :private true, :ns "cljs.core", :name "string-expr", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[e]"], :row 849} {:fixed-arities #{0 1}, :end-row 867, :ns "cljs.core", :name "str", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & ys]"], :row 852} {:fixed-arities #{1}, :end-row 870, :private true, :ns "cljs.core", :name "bool-expr", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[e]"], :row 869} {:fixed-arities #{2}, :end-row 875, :private true, :ns "cljs.core", :name "simple-test-expr?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env ast]"], :row 872} {:fixed-arities #{0 1}, :end-row 886, :ns "cljs.core", :name "and", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", :row 877} {:fixed-arities #{0 1}, :end-row 897, :ns "cljs.core", :name "or", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", :row 888} {:fixed-arities #{1}, :end-row 900, :ns "cljs.core", :name "nil?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 899} {:fixed-arities #{1}, :end-row 903, :ns "cljs.core", :name "some?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 902} {:fixed-arities #{1}, :end-row 906, :ns "cljs.core", :name "coercive-not", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 905} {:fixed-arities #{2}, :end-row 909, :ns "cljs.core", :name "coercive-not=", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]"], :row 908} {:fixed-arities #{2}, :end-row 912, :ns "cljs.core", :name "coercive-=", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]"], :row 911} {:fixed-arities #{1}, :end-row 916, :ns "cljs.core", :name "coercive-boolean", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 914} {:fixed-arities #{1}, :end-row 921, :ns "cljs.core", :name "truth_", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 919} {:fixed-arities #{0}, :end-row 924, :ns "cljs.core", :name "js-arguments", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 923} {:fixed-arities #{2}, :end-row 927, :ns "cljs.core", :name "js-delete", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key]"], :row 926} {:fixed-arities #{2}, :end-row 930, :ns "cljs.core", :name "js-in", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[key obj]"], :row 929} {:fixed-arities #{0}, :end-row 937, :ns "cljs.core", :name "js-debugger", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :doc "Emit JavaScript \"debugger;\" statement", :row 932} {:fixed-arities #{1}, :end-row 951, :ns "cljs.core", :name "js-comment", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[comment]"], :doc "Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline", :row 939} {:fixed-arities #{2}, :end-row 957, :ns "cljs.core", :name "unsafe-cast", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[t x]"], :doc "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type.", :row 953} {:fixed-arities #{1}, :end-row 962, :ns "cljs.core", :name "js-inline-comment", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[comment]"], :doc "Emit an inline JavaScript comment.", :row 959} {:fixed-arities #{1}, :end-row 965, :ns "cljs.core", :name "true?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 964} {:fixed-arities #{1}, :end-row 968, :ns "cljs.core", :name "false?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 967} {:fixed-arities #{1}, :end-row 971, :ns "cljs.core", :name "string?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 970} {:fixed-arities #{1}, :end-row 974, :ns "cljs.core", :name "js-fn?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 973} {:fixed-arities #{1}, :end-row 991, :ns "cljs.core", :name "exists?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :doc "Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript.", :row 976} {:fixed-arities #{1}, :end-row 996, :ns "cljs.core", :name "undefined?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :doc "Return true if argument is identical to the JavaScript undefined value.", :row 993} {:fixed-arities #{2}, :end-row 999, :ns "cljs.core", :name "identical?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a b]"], :row 998} {:fixed-arities #{2}, :end-row 1008, :ns "cljs.core", :name "instance?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[c x]"], :row 1001} {:fixed-arities #{1}, :end-row 1011, :ns "cljs.core", :name "number?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1010} {:fixed-arities #{1}, :end-row 1014, :ns "cljs.core", :name "symbol?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1013} {:fixed-arities #{1}, :end-row 1017, :ns "cljs.core", :name "keyword?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1016} {:fixed-arities #{2}, :end-row 1030, :ns "cljs.core", :name "aget", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[array idx]" "[array idx & idxs]"], :row 1019} {:fixed-arities #{3}, :end-row 1044, :ns "cljs.core", :name "aset", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :row 1032} {:fixed-arities #{2}, :end-row 1051, :ns "cljs.core", :name "unchecked-get", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key]"], :doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :row 1046} {:fixed-arities #{3}, :end-row 1058, :ns "cljs.core", :name "unchecked-set", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key val]"], :doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :row 1053} {:fixed-arities #{0 1 2}, :end-row 1064, :ns "cljs.core", :name "+", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :row 1060} {:fixed-arities #{1}, :end-row 1066, :ns "cljs.core", :name "byte", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1066} {:fixed-arities #{1}, :end-row 1067, :ns "cljs.core", :name "short", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1067} {:fixed-arities #{1}, :end-row 1068, :ns "cljs.core", :name "float", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1068} {:fixed-arities #{1}, :end-row 1069, :ns "cljs.core", :name "double", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1069} {:fixed-arities #{1}, :end-row 1071, :ns "cljs.core", :name "unchecked-byte", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1071} {:fixed-arities #{1}, :end-row 1072, :ns "cljs.core", :name "unchecked-char", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1072} {:fixed-arities #{1}, :end-row 1073, :ns "cljs.core", :name "unchecked-short", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1073} {:fixed-arities #{1}, :end-row 1074, :ns "cljs.core", :name "unchecked-float", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1074} {:fixed-arities #{1}, :end-row 1075, :ns "cljs.core", :name "unchecked-double", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1075} {:arglist-strs ["[& xs]"], :end-row 1078, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-add", :ns "cljs.core", :row 1077} {:arglist-strs ["[& xs]"], :end-row 1081, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-add-int", :ns "cljs.core", :row 1080} {:fixed-arities #{1}, :end-row 1084, :ns "cljs.core", :name "unchecked-dec", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1083} {:fixed-arities #{1}, :end-row 1087, :ns "cljs.core", :name "unchecked-dec-int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1086} {:arglist-strs ["[& xs]"], :end-row 1090, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-divide-int", :ns "cljs.core", :row 1089} {:fixed-arities #{1}, :end-row 1093, :ns "cljs.core", :name "unchecked-inc", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1092} {:fixed-arities #{1}, :end-row 1096, :ns "cljs.core", :name "unchecked-inc-int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1095} {:arglist-strs ["[& xs]"], :end-row 1099, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-multiply", :ns "cljs.core", :row 1098} {:arglist-strs ["[& xs]"], :end-row 1102, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-multiply-int", :ns "cljs.core", :row 1101} {:fixed-arities #{1}, :end-row 1105, :ns "cljs.core", :name "unchecked-negate", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1104} {:fixed-arities #{1}, :end-row 1108, :ns "cljs.core", :name "unchecked-negate-int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1107} {:fixed-arities #{2}, :end-row 1111, :ns "cljs.core", :name "unchecked-remainder-int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1110} {:arglist-strs ["[& xs]"], :end-row 1114, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-subtract", :ns "cljs.core", :row 1113} {:arglist-strs ["[& xs]"], :end-row 1117, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-subtract-int", :ns "cljs.core", :row 1116} {:fixed-arities #{1 2}, :end-row 1122, :ns "cljs.core", :name "-", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1119} {:fixed-arities #{0 1 2}, :end-row 1128, :ns "cljs.core", :name "*", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :row 1124} {:fixed-arities #{1 2}, :end-row 1133, :ns "cljs.core", :name "/", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1130} {:fixed-arities #{1 2}, :end-row 1138, :ns "cljs.core", :name "divide", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1135} {:fixed-arities #{1 2}, :end-row 1143, :ns "cljs.core", :name "<", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1140} {:fixed-arities #{1 2}, :end-row 1148, :ns "cljs.core", :name "<=", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1145} {:fixed-arities #{1 2}, :end-row 1153, :ns "cljs.core", :name ">", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1150} {:fixed-arities #{1 2}, :end-row 1158, :ns "cljs.core", :name ">=", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1155} {:fixed-arities #{1 2}, :end-row 1163, :ns "cljs.core", :name "==", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1160} {:fixed-arities #{1}, :end-row 1166, :ns "cljs.core", :name "dec", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1165} {:fixed-arities #{1}, :end-row 1169, :ns "cljs.core", :name "inc", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1168} {:fixed-arities #{1}, :end-row 1172, :ns "cljs.core", :name "zero?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1171} {:fixed-arities #{1}, :end-row 1175, :ns "cljs.core", :name "pos?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1174} {:fixed-arities #{1}, :end-row 1178, :ns "cljs.core", :name "neg?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1177} {:fixed-arities #{1 2}, :end-row 1184, :ns "cljs.core", :name "max", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1180} {:fixed-arities #{1 2}, :end-row 1190, :ns "cljs.core", :name "min", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1186} {:fixed-arities #{2}, :end-row 1193, :ns "cljs.core", :name "js-mod", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[num div]"], :row 1192} {:fixed-arities #{1}, :end-row 1196, :ns "cljs.core", :name "bit-not", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1195} {:fixed-arities #{2}, :end-row 1200, :ns "cljs.core", :name "bit-and", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1198} {:fixed-arities #{2}, :end-row 1205, :ns "cljs.core", :name "unsafe-bit-and", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1203} {:fixed-arities #{2}, :end-row 1209, :ns "cljs.core", :name "bit-or", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1207} {:fixed-arities #{1}, :end-row 1212, :ns "cljs.core", :name "int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1211} {:fixed-arities #{2}, :end-row 1216, :ns "cljs.core", :name "bit-xor", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1214} {:fixed-arities #{2}, :end-row 1220, :ns "cljs.core", :name "bit-and-not", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1218} {:fixed-arities #{2}, :end-row 1223, :ns "cljs.core", :name "bit-clear", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1222} {:fixed-arities #{2}, :end-row 1226, :ns "cljs.core", :name "bit-flip", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1225} {:fixed-arities #{2}, :end-row 1229, :ns "cljs.core", :name "bit-test", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1228} {:fixed-arities #{2}, :end-row 1232, :ns "cljs.core", :name "bit-shift-left", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1231} {:fixed-arities #{2}, :end-row 1235, :ns "cljs.core", :name "bit-shift-right", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1234} {:fixed-arities #{2}, :end-row 1238, :ns "cljs.core", :name "bit-shift-right-zero-fill", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1237} {:fixed-arities #{2}, :end-row 1241, :ns "cljs.core", :name "unsigned-bit-shift-right", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1240} {:fixed-arities #{2}, :end-row 1244, :ns "cljs.core", :name "bit-set", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1243} {:fixed-arities #{2}, :end-row 1248, :ns "cljs.core", :name "mask", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[hash shift]"], :row 1247} {:fixed-arities #{2}, :end-row 1252, :ns "cljs.core", :name "bitpos", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[hash shift]"], :row 1251} {:fixed-arities #{3}, :end-row 1262, :ns "cljs.core", :name "caching-hash", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[coll hash-fn hash-key]"], :row 1255} {:fixed-arities #{5}, :end-row 1271, :private true, :ns "cljs.core", :name "do-curried", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[name doc meta args body]"], :row 1266} {:end-row 1277, :private true, :ns "cljs.core", :name "defcurried", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name doc meta args & body]"], :doc "Builds another arity of the fn that returns a fn awaiting the last\n  param", :row 1273} {:fixed-arities #{3}, :end-row 1288, :private true, :ns "cljs.core", :name "do-rfn", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[f1 k fkv]"], :row 1279} {:fixed-arities #{2}, :end-row 1293, :private true, :ns "cljs.core", :name "rfn", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[[f1 k] fkv]"], :doc "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.", :row 1290} {:fixed-arities #{1}, :end-row 1301, :private true, :ns "cljs.core", :name "protocol-prefix", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[psym]"], :row 1297} {:end-row 1311, :filename "cljs/core.cljc", :lang :clj, :name "base-type", :ns "cljs.core", :private true, :row 1303} {:end-row 1319, :filename "cljs/core.cljc", :lang :clj, :name "js-base-type", :ns "cljs.core", :private true, :row 1313} {:end-row 1380, :ns "cljs.core", :name "reify", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& impls]"], :doc "reify creates an object implementing a protocol.\n  reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \"foo\"]\n       (reify Object\n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"]\n       (reify ISeqable\n         (-seq [this] (seq f)))))\n  == (\"f\" \"o\" \"o\"))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", :row 1321} {:end-row 1388, :ns "cljs.core", :name "specify!", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & impls]"], :doc "Identical to reify but mutates its first argument.", :row 1382} {:end-row 1395, :ns "cljs.core", :name "specify", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & impls]"], :doc "Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance.", :row 1390} {:fixed-arities #{0}, :end-row 1398, :private true, :ns "cljs.core", :name "js-this", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 1397} {:end-row 1404, :ns "cljs.core", :name "this-as", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & body]"], :doc "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.", :row 1400} {:fixed-arities #{1}, :end-row 1407, :private true, :ns "cljs.core", :name "to-property", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[sym]"], :row 1406} {:fixed-arities #{3}, :end-row 1425, :private true, :ns "cljs.core", :name "update-protocol-var", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[p type env]"], :row 1409} {:fixed-arities #{2}, :end-row 1430, :private true, :ns "cljs.core", :name "resolve-var", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env sym]"], :row 1427} {:fixed-arities #{1}, :end-row 1437, :private true, :ns "cljs.core", :name "->impl-map", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[impls]"], :row 1432} {:fixed-arities #{5}, :end-row 1448, :private true, :ns "cljs.core", :name "base-assign-impls", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env resolve tsym type [p sigs]]"], :row 1439} {:end-row 1450, :filename "cljs/core.cljc", :lang :clj, :name "extend-prefix", :ns "cljs.core", :private true, :row 1450} {:fixed-arities #{2}, :end-row 1461, :private true, :ns "cljs.core", :name "adapt-obj-params", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1459} {:fixed-arities #{2}, :end-row 1468, :private true, :ns "cljs.core", :name "adapt-ifn-params", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1463} {:fixed-arities #{2}, :end-row 1474, :private true, :ns "cljs.core", :name "adapt-ifn-invoke-params", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1471} {:fixed-arities #{2}, :end-row 1480, :private true, :ns "cljs.core", :name "adapt-proto-params", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1476} {:fixed-arities #{3}, :end-row 1489, :private true, :ns "cljs.core", :name "add-obj-methods", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym sigs]"], :row 1482} {:fixed-arities #{3}, :end-row 1497, :private true, :ns "cljs.core", :name "ifn-invoke-methods", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym [f & meths :as form]]"], :row 1491} {:fixed-arities #{3}, :end-row 1518, :private true, :ns "cljs.core", :name "add-ifn-methods", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym [f & meths :as form]]"], :row 1499} {:fixed-arities #{4}, :end-row 1530, :private true, :ns "cljs.core", :name "add-proto-methods*", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[pprefix type type-sym [f & meths :as form]]"], :row 1520} {:fixed-arities #{5}, :end-row 1547, :private true, :ns "cljs.core", :name "proto-assign-impls", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env resolve type-sym type [p sigs]]"], :row 1532} {:fixed-arities #{3}, :end-row 1577, :private true, :ns "cljs.core", :name "validate-impl-sigs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env p method]"], :row 1549} {:fixed-arities #{2}, :end-row 1595, :private true, :ns "cljs.core", :name "validate-impls", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env impls]"], :row 1579} {:fixed-arities #{2}, :end-row 1599, :private true, :ns "cljs.core", :name "type-hint-first-arg", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym argv]"], :row 1597} {:fixed-arities #{2}, :end-row 1603, :private true, :ns "cljs.core", :name "type-hint-single-arity-sig", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1601} {:fixed-arities #{2}, :end-row 1607, :private true, :ns "cljs.core", :name "type-hint-multi-arity-sig", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1605} {:fixed-arities #{2}, :end-row 1611, :private true, :ns "cljs.core", :name "type-hint-multi-arity-sigs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sigs]"], :row 1609} {:fixed-arities #{2}, :end-row 1617, :private true, :ns "cljs.core", :name "type-hint-sigs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1613} {:fixed-arities #{2}, :end-row 1623, :private true, :ns "cljs.core", :name "type-hint-impl-map", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym impl-map]"], :row 1619} {:end-row 1665, :ns "cljs.core", :name "extend-type", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[type-sym & impls]"], :doc "Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y] ...) ...)", :row 1625} {:fixed-arities #{2}, :end-row 1687, :private true, :ns "cljs.core", :name "prepare-protocol-masks", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env impls]"], :row 1667} {:fixed-arities #{3}, :end-row 1692, :private true, :ns "cljs.core", :name "annotate-specs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[annots v [f sigs]]"], :row 1689} {:arglist-strs ["[type specs fields]" "[type specs fields inline]"], :end-row 1709, :filename "cljs/core.cljc", :fixed-arities #{4 3}, :lang :clj, :name "dt->et", :ns "cljs.core", :row 1694} {:fixed-arities #{2}, :end-row 1715, :private true, :ns "cljs.core", :name "collect-protocols", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[impls env]"], :row 1711} {:fixed-arities #{3}, :end-row 1726, :private true, :ns "cljs.core", :name "build-positional-factory", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[rsym rname fields]"], :row 1717} {:fixed-arities #{3}, :end-row 1733, :private true, :ns "cljs.core", :name "validate-fields", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[case name fields]"], :row 1728} {:end-row 1803, :ns "cljs.core", :name "deftype", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[t fields & impls]"], :doc "(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", :row 1735} {:fixed-arities #{5}, :end-row 1910, :private true, :ns "cljs.core", :name "emit-defrecord", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env tagname rname fields impls]"], :doc "Do not use this directly - use defrecord", :row 1805} {:fixed-arities #{3}, :end-row 1922, :private true, :ns "cljs.core", :name "build-map-factory", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[rsym rname fields]"], :row 1912} {:end-row 1991, :ns "cljs.core", :name "defrecord", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[rsym fields & impls]"], :doc "(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", :row 1924} {:end-row 2177, :ns "cljs.core", :name "defprotocol", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym & doc+methods]"], :doc "A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", :row 1993} {:fixed-arities #{2}, :end-row 2203, :ns "cljs.core", :name "implements?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym x]"], :doc "EXPERIMENTAL", :row 2179} {:fixed-arities #{2}, :end-row 2235, :ns "cljs.core", :name "satisfies?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym x]"], :doc "Returns true if x satisfies the protocol", :row 2205} {:end-row 2243, :ns "cljs.core", :name "lazy-seq", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls.", :row 2237} {:end-row 2251, :ns "cljs.core", :name "delay", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.", :row 2245} {:end-row 2275, :ns "cljs.core", :name "with-redefs", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing.", :row 2253} {:end-row 2288, :ns "cljs.core", :name "binding", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", :row 2277} {:end-row 2329, :ns "cljs.core", :name "condp", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[pred expr & clauses]"], :doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an Error is thrown.", :row 2290} {:fixed-arities #{4}, :end-row 2346, :private true, :ns "cljs.core", :name "assoc-test", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[m test expr env]"], :row 2331} {:fixed-arities #{2}, :end-row 2351, :private true, :ns "cljs.core", :name "const?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env x]"], :row 2348} {:end-row 2422, :ns "cljs.core", :name "case", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[e & clauses]"], :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", :row 2353} {:fixed-arities #{1}, :end-row 2425, :private true, :ns "cljs.core", :name "when-assert", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 2424} {:fixed-arities #{1 2}, :end-row 2438, :ns "cljs.core", :name "assert", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x message]"], :doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.", :row 2427} {:fixed-arities #{2}, :end-row 2525, :ns "cljs.core", :name "for", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[seq-exprs body-expr]"], :doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))", :row 2440} {:end-row 2581, :ns "cljs.core", :name "doseq", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[seq-exprs & body]"], :doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", :row 2527} {:arglist-strs ["[& rest]"], :end-row 2590, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "array", :ns "cljs.core", :row 2583} {:fixed-arities #{1 2}, :end-row 2608, :ns "cljs.core", :name "make-array", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[size]" "[type size]" "[type size & more-sizes]"], :row 2592} {:fixed-arities #{0 1}, :end-row 2617, :ns "cljs.core", :name "list", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & xs]"], :row 2610} {:fixed-arities #{0}, :end-row 2628, :ns "cljs.core", :name "vector", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& xs]"], :row 2619} {:fixed-arities #{0}, :end-row 2638, :ns "cljs.core", :name "array-map", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& kvs]"], :row 2630} {:fixed-arities #{0}, :end-row 2651, :ns "cljs.core", :name "hash-map", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& kvs]"], :row 2640} {:fixed-arities #{0}, :end-row 2665, :ns "cljs.core", :name "hash-set", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& xs]"], :row 2653} {:fixed-arities #{1}, :end-row 2674, :private true, :ns "cljs.core", :name "js-obj*", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[kvs]"], :row 2667} {:arglist-strs ["[& rest]"], :end-row 2694, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "js-obj", :ns "cljs.core", :row 2676} {:fixed-arities #{1}, :end-row 2699, :ns "cljs.core", :name "alength", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a]"], :row 2696} {:fixed-arities #{4}, :end-row 2715, :ns "cljs.core", :name "amap", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a idx ret expr]"], :doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret.", :row 2701} {:fixed-arities #{5}, :end-row 2727, :ns "cljs.core", :name "areduce", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a idx ret init expr]"], :doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret.", :row 2717} {:end-row 2741, :ns "cljs.core", :name "dotimes", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", :row 2729} {:end-row 2751, :private true, :ns "cljs.core", :name "check-valid-options", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[options & valid-keys]"], :doc "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", :row 2743} {:end-row 2798, :ns "cljs.core", :name "defmulti", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[mm-name & options]"], :doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy", :row 2753} {:end-row 2803, :ns "cljs.core", :name "defmethod", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[multifn dispatch-val & fn-tail]"], :doc "Creates and installs a new method of multimethod associated with dispatch-value. ", :row 2800} {:fixed-arities #{1}, :end-row 2813, :ns "cljs.core", :name "time", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr]"], :doc "Evaluates expr and prints the time it took. Returns the value of expr.", :row 2805} {:end-row 2831, :ns "cljs.core", :name "simple-benchmark", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]"], :doc "Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case.", :row 2815} {:end-row 2833, :filename "cljs/core.cljc", :lang :clj, :name "cs", :ns "cljs.core", :private true, :row 2833} {:fixed-arities #{0 1}, :end-row 2844, :private true, :ns "cljs.core", :name "gen-apply-to-helper", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[]" "[n]"], :row 2835} {:fixed-arities #{0}, :end-row 2854, :ns "cljs.core", :name "gen-apply-to", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 2846} {:fixed-arities #{3}, :end-row 2878, :private true, :ns "cljs.core", :name "gen-apply-to-simple-helper", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[f num-args args]"], :row 2856} {:fixed-arities #{3}, :end-row 2882, :ns "cljs.core", :name "gen-apply-to-simple", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[f num-args args]"], :row 2880} {:end-row 2893, :ns "cljs.core", :name "with-out-str", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls.", :row 2884} {:end-row 2902, :ns "cljs.core", :name "lazy-cat", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& colls]"], :doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", :row 2895} {:fixed-arities #{1}, :end-row 2905, :ns "cljs.core", :name "js-str", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[s]"], :row 2904} {:fixed-arities #{1}, :end-row 2911, :ns "cljs.core", :name "es6-iterable", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[ty]"], :row 2907} {:fixed-arities #{1}, :end-row 2927, :ns "cljs.core", :name "ns-publics", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the public intern mappings for the namespace.", :row 2913} {:fixed-arities #{1}, :end-row 2941, :ns "cljs.core", :name "ns-imports", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the import mappings for the namespace.", :row 2929} {:fixed-arities #{1}, :end-row 2955, :ns "cljs.core", :name "ns-interns", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the intern mappings for the namespace.", :row 2943} {:fixed-arities #{2}, :end-row 2967, :ns "cljs.core", :name "ns-unmap", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns quoted-sym]"], :doc "Removes the mappings for the symbol from the namespace.", :row 2957} {:end-row 2974, :ns "cljs.core", :name "vswap!", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[vol f & args]"], :doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", :row 2969} {:arglist-strs ["[x & forms]"], :end-row 2978, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "locking", :ns "cljs.core", :row 2976} {:fixed-arities #{0}, :end-row 2981, :private true, :ns "cljs.core", :name "ns-special-form", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 2981} {:end-row 3036, :ns "cljs.core", :name "require", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib's name also locates its root directory\n  within classpath using Java's package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace.\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n  :rename specifies a map from referred var names to different\n    symbols (and can be used to prevent clashes)\n\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require '[clojure.string :as string])", :row 2983} {:end-row 3041, :ns "cljs.core", :name "require-macros", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Similar to require but only for macros.", :row 3038} {:end-row 3054, :ns "cljs.core", :name "use", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Like require, but referring vars specified by the mandatory\n  :only option.\n\n  Example:\n\n  The following would load the library clojure.set while referring\n  the intersection var.\n\n  (use '[clojure.set :only [intersection]])", :row 3043} {:end-row 3059, :ns "cljs.core", :name "use-macros", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Similar to use but only for macros.", :row 3056} {:end-row 3068, :ns "cljs.core", :name "import", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& import-symbols-or-lists]"], :doc "import-list => (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", :row 3061} {:end-row 3081, :ns "cljs.core", :name "refer-clojure", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Refers to all the public vars of `cljs.core`, subject to\n  filters.\n  Filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  Filters can be used to select a subset, via exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent clashes.", :row 3070} {:fixed-arities #{1}, :end-row 3085, :ns "cljs.core", :name "load-file*", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[f]"], :row 3084} {:fixed-arities #{1}, :end-row 3096, :ns "cljs.core", :name "macroexpand-1", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted]"], :doc "If form represents a macro form, returns its expansion,\n  else returns form.", :row 3087} {:fixed-arities #{1}, :end-row 3112, :ns "cljs.core", :name "macroexpand", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted]"], :doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", :row 3098} {:fixed-arities #{1}, :end-row 3115, :private true, :ns "cljs.core", :name "multi-arity-fn?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 3114} {:fixed-arities #{1}, :end-row 3119, :private true, :ns "cljs.core", :name "variadic-fn?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 3117} {:fixed-arities #{3 2}, :end-row 3155, :private true, :ns "cljs.core", :name "variadic-fn*", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[sym method]" "[sym [arglist & body :as method] solo]"], :row 3121} {:fixed-arities #{1}, :end-row 3162, :ns "cljs.core", :name "copy-arguments", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[dest]"], :row 3157} {:fixed-arities #{1}, :end-row 3169, :private true, :ns "cljs.core", :name "elide-implicit-macro-args", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[arglists]"], :row 3164} {:fixed-arities #{4}, :end-row 3199, :private true, :ns "cljs.core", :name "variadic-fn", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[name meta [[arglist & body :as method] :as fdecl] emit-var?]"], :row 3171} {:fixed-arities #{4}, :end-row 3286, :private true, :ns "cljs.core", :name "multi-arity-fn", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[name meta fdecl emit-var?]"], :row 3209} {:doc "Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", :end-row 3368, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "defn", :ns "cljs.core", :row 3297} {:end-row 3414, :ns "cljs.core", :name "defmacro", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[&form &env name & args]"], :doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", :row 3373} {:fixed-arities #{1}, :end-row 3435, :ns "cljs.core", :name "resolve", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-sym]"], :doc "Returns the var to which a symbol will be resolved in the namespace else nil.", :row 3419} {:end-row 117, :ns "cljs.core", :name "->", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x & forms]"], :doc "Threads the expr through the forms. Inserts x as the\n     second item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     second item in second form, etc.", :row 104} {:end-row 133, :ns "cljs.core", :name "->>", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x & forms]"], :doc "Threads the expr through the forms. Inserts x as the\n     last item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     last item in second form, etc.", :row 120} {:fixed-arities #{2}, :end-row 151, :ns "cljs.core", :name "..", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x form]" "[x form & more]"], :doc "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n     Expands into a member access (.) of the first member on the first\n     argument, followed by the next member on the result, etc. For\n     instance:\n\n     (.. System (getProperties) (get \"os.name\"))\n\n     expands to:\n\n     (. (. System (getProperties)) (get \"os.name\"))\n\n     but is easier to write, read, and understand.", :row 136} {:end-row 156, :ns "cljs.core", :name "comment", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Ignores body, yields nil", :row 154} {:end-row 171, :ns "cljs.core", :name "cond", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& clauses]"], :doc "Takes a set of test/expr pairs. It evaluates each test one at a\n     time.  If a test returns logical true, cond evaluates and returns\n     the value of the corresponding expr and doesn't evaluate any of the\n     other tests or exprs. (cond) returns nil.", :row 159} {:end-row 176, :ns "cljs.core", :name "declare", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& names]"], :doc "defs the supplied var names with no bindings, useful for making forward declarations.", :row 174} {:end-row 192, :ns "cljs.core", :name "doto", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x & forms]"], :doc "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new js/Map) (.set \"a\" 1) (.set \"b\" 2))", :row 178} {:fixed-arities #{1}, :end-row 200, :private true, :ns "cljs.core", :name "parse-impls", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[specs]"], :row 195} {:fixed-arities #{2}, :end-row 208, :private true, :ns "cljs.core", :name "emit-extend-protocol", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[p specs]"], :row 203} {:end-row 247, :ns "cljs.core", :name "extend-protocol", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[p & specs]"], :doc "Useful when you want to provide several implementations of the same\n     protocol all at once. Takes a single protocol and the implementation\n     of that protocol for one or more types. Expands into calls to\n     extend-type:\n\n     (extend-protocol Protocol\n       AType\n         (foo [x] ...)\n         (bar [x y] ...)\n       BType\n         (foo [x] ...)\n         (bar [x y] ...)\n       AClass\n         (foo [x] ...)\n         (bar [x y] ...)\n       nil\n         (foo [x] ...)\n         (bar [x y] ...))\n\n     expands into:\n\n     (do\n      (clojure.core/extend-type AType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type BType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type AClass Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type nil Protocol\n        (foo [x] ...)\n        (bar [x y] ...)))", :row 211} {:fixed-arities #{2}, :end-row 266, :private true, :ns "cljs.core", :name "maybe-destructured", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[params body]"], :row 250} {:end-row 330, :ns "cljs.core", :name "fn", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& sigs]"], :doc "params => positional-params* , or positional-params* & rest-param\n     positional-param => binding-form\n     rest-param => binding-form\n     binding-form => name, or destructuring-form\n\n     Defines a function\n\n     See https://clojure.org/reference/special_forms#fn for more information", :row 269} {:end-row 336, :ns "cljs.core", :name "defn-", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & decls]"], :doc "same as defn, yielding non-public def", :row 333} {:fixed-arities #{3 2}, :end-row 356, :ns "cljs.core", :name "if-let", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings then]" "[bindings then else & oldform]"], :doc "bindings => binding-form test\n\n     If test is true, evaluates then with binding-form bound to the value of\n     test, if not, yields else", :row 339} {:fixed-arities #{3 2}, :end-row 364, :ns "cljs.core", :name "if-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[test then]" "[test then else]"], :doc "Evaluates test. If logical false, evaluates and returns then expr,\n     otherwise else expr, if supplied, else nil.", :row 359} {:end-row 378, :ns "cljs.core", :name "letfn", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[fnspecs & body]"], :doc "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n     Takes a vector of function specs and a body, and generates a set of\n     bindings of functions to their names. All of the names are available\n     in all of the definitions of the functions, as well as the body.", :row 367} {:end-row 389, :ns "cljs.core", :name "memfn", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & args]"], :doc "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a JavaScript\n  method as a first-class fn.", :row 380} {:end-row 395, :ns "cljs.core", :name "when", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[test & body]"], :doc "Evaluates test. If logical true, evaluates body in an implicit do.", :row 392} {:end-row 409, :ns "cljs.core", :name "when-first", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => x xs\n\n     Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", :row 398} {:end-row 424, :ns "cljs.core", :name "when-let", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => binding-form test\n\n     When test is true, evaluates body with binding-form bound to the value of test", :row 412} {:end-row 430, :ns "cljs.core", :name "when-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[test & body]"], :doc "Evaluates test. If logical false, evaluates body in an implicit do.", :row 427} {:end-row 440, :ns "cljs.core", :name "while", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[test & body]"], :doc "Repeatedly executes body while test expression is true. Presumes\n     some side-effect will cause test to become false/nil. Returns nil", :row 433} {:end-row 457, :ns "cljs.core", :name "cond->", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & clauses]"], :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n     through each form for which the corresponding test\n     expression is true. Note that, unlike cond branching, cond-> threading does\n     not short circuit after the first true test expression.", :row 443} {:end-row 474, :ns "cljs.core", :name "cond->>", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & clauses]"], :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n     through each form for which the corresponding test expression\n     is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n     after the first true test expression.", :row 460} {:end-row 486, :ns "cljs.core", :name "as->", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr name & forms]"], :doc "Binds name to expr, evaluates the first form in the lexical context\n     of that binding, then binds name to that result, repeating for each\n     successive form, returning the result of the last form.", :row 477} {:end-row 500, :ns "cljs.core", :name "some->", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & forms]"], :doc "When expr is not nil, threads it into the first form (via ->),\n     and when that result is not nil, through the next etc", :row 489} {:end-row 514, :ns "cljs.core", :name "some->>", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & forms]"], :doc "When expr is not nil, threads it into the first form (via ->>),\n     and when that result is not nil, through the next etc", :row 503} {:fixed-arities #{3 2}, :end-row 534, :ns "cljs.core", :name "if-some", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings then]" "[bindings then else & oldform]"], :doc "bindings => binding-form test\n\n      If test is not nil, evaluates then with binding-form bound to the\n      value of test, if not, yields else", :row 517} {:end-row 551, :ns "cljs.core", :name "when-some", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => binding-form test\n\n      When test is not nil, evaluates body with binding-form bound to the\n      value of test", :row 537} {:fixed-arities #{1}, :end-row 590, :private true, :ns "cljs.core", :name "assert-valid-fdecl", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :doc "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.", :row 553} {:fixed-arities #{1}, :end-row 617, :private true, :ns "cljs.core", :name "sigs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 592} {:fixed-arities #{2}, :end-row 627, :ns "cljs.core", :name "defonce", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x init]"], :doc "defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated", :row 619} {:arglist-strs ["[bindings]"], :end-row 730, :filename "cljs/core.cljc", :fixed-arities #{1}, :lang :cljs, :name "destructure", :ns "cljs.core", :row 629} {:end-row 736, :private true, :ns "cljs.core", :name "return-first", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :row 732} {:fixed-arities #{2}, :end-row 770, :ns "cljs.core", :name "goog-define", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[sym default]"], :doc "Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n    or\n    :closure-defines {your-app.core/DEBUG! true}", :row 738} {:end-row 787, :ns "cljs.core", :name "let", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => binding-form init-expr\n  binding-form => name, or destructuring-form\n  destructuring-form => map-destructure-form, or seq-destructure-form\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\n\n  See https://clojure.org/reference/special_forms#binding-forms for\n  more information about destructuring.", :row 772} {:end-row 811, :ns "cljs.core", :name "loop", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", :row 789} {:doc "protocol fqn -> [partition number, bit]", :end-row 829, :filename "cljs/core.cljc", :lang :cljs, :name "fast-path-protocols", :ns "cljs.core", :row 813} {:doc "total number of partitions", :end-row 837, :filename "cljs/core.cljc", :lang :cljs, :name "fast-path-protocol-partitions-count", :ns "cljs.core", :row 831} {:fixed-arities #{2}, :end-row 842, :private true, :ns "cljs.core", :name "compatible?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[inferred-tag allowed-tags]"], :row 839} {:fixed-arities #{3}, :end-row 847, :private true, :ns "cljs.core", :name "typed-expr?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env form allowed-tags]"], :row 844} {:fixed-arities #{1}, :end-row 850, :private true, :ns "cljs.core", :name "string-expr", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[e]"], :row 849} {:fixed-arities #{0 1}, :end-row 867, :ns "cljs.core", :name "str", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & ys]"], :row 852} {:fixed-arities #{1}, :end-row 870, :private true, :ns "cljs.core", :name "bool-expr", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[e]"], :row 869} {:fixed-arities #{2}, :end-row 875, :private true, :ns "cljs.core", :name "simple-test-expr?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env ast]"], :row 872} {:fixed-arities #{0 1}, :end-row 886, :ns "cljs.core", :name "and", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", :row 877} {:fixed-arities #{0 1}, :end-row 897, :ns "cljs.core", :name "or", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", :row 888} {:fixed-arities #{1}, :end-row 900, :ns "cljs.core", :name "nil?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 899} {:fixed-arities #{1}, :end-row 903, :ns "cljs.core", :name "some?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 902} {:fixed-arities #{1}, :end-row 906, :ns "cljs.core", :name "coercive-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 905} {:fixed-arities #{2}, :end-row 909, :ns "cljs.core", :name "coercive-not=", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]"], :row 908} {:fixed-arities #{2}, :end-row 912, :ns "cljs.core", :name "coercive-=", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]"], :row 911} {:fixed-arities #{1}, :end-row 916, :ns "cljs.core", :name "coercive-boolean", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 914} {:fixed-arities #{1}, :end-row 921, :ns "cljs.core", :name "truth_", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 919} {:fixed-arities #{0}, :end-row 924, :ns "cljs.core", :name "js-arguments", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 923} {:fixed-arities #{2}, :end-row 927, :ns "cljs.core", :name "js-delete", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key]"], :row 926} {:fixed-arities #{2}, :end-row 930, :ns "cljs.core", :name "js-in", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[key obj]"], :row 929} {:fixed-arities #{0}, :end-row 937, :ns "cljs.core", :name "js-debugger", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :doc "Emit JavaScript \"debugger;\" statement", :row 932} {:fixed-arities #{1}, :end-row 951, :ns "cljs.core", :name "js-comment", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[comment]"], :doc "Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline", :row 939} {:fixed-arities #{2}, :end-row 957, :ns "cljs.core", :name "unsafe-cast", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[t x]"], :doc "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type.", :row 953} {:fixed-arities #{1}, :end-row 962, :ns "cljs.core", :name "js-inline-comment", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[comment]"], :doc "Emit an inline JavaScript comment.", :row 959} {:fixed-arities #{1}, :end-row 965, :ns "cljs.core", :name "true?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 964} {:fixed-arities #{1}, :end-row 968, :ns "cljs.core", :name "false?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 967} {:fixed-arities #{1}, :end-row 971, :ns "cljs.core", :name "string?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 970} {:fixed-arities #{1}, :end-row 974, :ns "cljs.core", :name "js-fn?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 973} {:fixed-arities #{1}, :end-row 991, :ns "cljs.core", :name "exists?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :doc "Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript.", :row 976} {:fixed-arities #{1}, :end-row 996, :ns "cljs.core", :name "undefined?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :doc "Return true if argument is identical to the JavaScript undefined value.", :row 993} {:fixed-arities #{2}, :end-row 999, :ns "cljs.core", :name "identical?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a b]"], :row 998} {:fixed-arities #{2}, :end-row 1008, :ns "cljs.core", :name "instance?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[c x]"], :row 1001} {:fixed-arities #{1}, :end-row 1011, :ns "cljs.core", :name "number?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1010} {:fixed-arities #{1}, :end-row 1014, :ns "cljs.core", :name "symbol?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1013} {:fixed-arities #{1}, :end-row 1017, :ns "cljs.core", :name "keyword?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1016} {:fixed-arities #{2}, :end-row 1030, :ns "cljs.core", :name "aget", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[array idx]" "[array idx & idxs]"], :row 1019} {:fixed-arities #{3}, :end-row 1044, :ns "cljs.core", :name "aset", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :row 1032} {:fixed-arities #{2}, :end-row 1051, :ns "cljs.core", :name "unchecked-get", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key]"], :doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :row 1046} {:fixed-arities #{3}, :end-row 1058, :ns "cljs.core", :name "unchecked-set", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key val]"], :doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :row 1053} {:fixed-arities #{0 1 2}, :end-row 1064, :ns "cljs.core", :name "+", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :row 1060} {:fixed-arities #{1}, :end-row 1066, :ns "cljs.core", :name "byte", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1066} {:fixed-arities #{1}, :end-row 1067, :ns "cljs.core", :name "short", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1067} {:fixed-arities #{1}, :end-row 1068, :ns "cljs.core", :name "float", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1068} {:fixed-arities #{1}, :end-row 1069, :ns "cljs.core", :name "double", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1069} {:fixed-arities #{1}, :end-row 1071, :ns "cljs.core", :name "unchecked-byte", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1071} {:fixed-arities #{1}, :end-row 1072, :ns "cljs.core", :name "unchecked-char", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1072} {:fixed-arities #{1}, :end-row 1073, :ns "cljs.core", :name "unchecked-short", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1073} {:fixed-arities #{1}, :end-row 1074, :ns "cljs.core", :name "unchecked-float", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1074} {:fixed-arities #{1}, :end-row 1075, :ns "cljs.core", :name "unchecked-double", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1075} {:arglist-strs ["[& xs]"], :end-row 1078, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-add", :ns "cljs.core", :row 1077} {:arglist-strs ["[& xs]"], :end-row 1081, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-add-int", :ns "cljs.core", :row 1080} {:fixed-arities #{1}, :end-row 1084, :ns "cljs.core", :name "unchecked-dec", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1083} {:fixed-arities #{1}, :end-row 1087, :ns "cljs.core", :name "unchecked-dec-int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1086} {:arglist-strs ["[& xs]"], :end-row 1090, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-divide-int", :ns "cljs.core", :row 1089} {:fixed-arities #{1}, :end-row 1093, :ns "cljs.core", :name "unchecked-inc", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1092} {:fixed-arities #{1}, :end-row 1096, :ns "cljs.core", :name "unchecked-inc-int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1095} {:arglist-strs ["[& xs]"], :end-row 1099, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-multiply", :ns "cljs.core", :row 1098} {:arglist-strs ["[& xs]"], :end-row 1102, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-multiply-int", :ns "cljs.core", :row 1101} {:fixed-arities #{1}, :end-row 1105, :ns "cljs.core", :name "unchecked-negate", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1104} {:fixed-arities #{1}, :end-row 1108, :ns "cljs.core", :name "unchecked-negate-int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1107} {:fixed-arities #{2}, :end-row 1111, :ns "cljs.core", :name "unchecked-remainder-int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1110} {:arglist-strs ["[& xs]"], :end-row 1114, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-subtract", :ns "cljs.core", :row 1113} {:arglist-strs ["[& xs]"], :end-row 1117, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-subtract-int", :ns "cljs.core", :row 1116} {:fixed-arities #{1 2}, :end-row 1122, :ns "cljs.core", :name "-", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1119} {:fixed-arities #{0 1 2}, :end-row 1128, :ns "cljs.core", :name "*", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :row 1124} {:fixed-arities #{1 2}, :end-row 1133, :ns "cljs.core", :name "/", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1130} {:fixed-arities #{1 2}, :end-row 1138, :ns "cljs.core", :name "divide", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1135} {:fixed-arities #{1 2}, :end-row 1143, :ns "cljs.core", :name "<", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1140} {:fixed-arities #{1 2}, :end-row 1148, :ns "cljs.core", :name "<=", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1145} {:fixed-arities #{1 2}, :end-row 1153, :ns "cljs.core", :name ">", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1150} {:fixed-arities #{1 2}, :end-row 1158, :ns "cljs.core", :name ">=", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1155} {:fixed-arities #{1 2}, :end-row 1163, :ns "cljs.core", :name "==", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1160} {:fixed-arities #{1}, :end-row 1166, :ns "cljs.core", :name "dec", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1165} {:fixed-arities #{1}, :end-row 1169, :ns "cljs.core", :name "inc", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1168} {:fixed-arities #{1}, :end-row 1172, :ns "cljs.core", :name "zero?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1171} {:fixed-arities #{1}, :end-row 1175, :ns "cljs.core", :name "pos?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1174} {:fixed-arities #{1}, :end-row 1178, :ns "cljs.core", :name "neg?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1177} {:fixed-arities #{1 2}, :end-row 1184, :ns "cljs.core", :name "max", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1180} {:fixed-arities #{1 2}, :end-row 1190, :ns "cljs.core", :name "min", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1186} {:fixed-arities #{2}, :end-row 1193, :ns "cljs.core", :name "js-mod", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[num div]"], :row 1192} {:fixed-arities #{1}, :end-row 1196, :ns "cljs.core", :name "bit-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1195} {:fixed-arities #{2}, :end-row 1200, :ns "cljs.core", :name "bit-and", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1198} {:fixed-arities #{2}, :end-row 1205, :ns "cljs.core", :name "unsafe-bit-and", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1203} {:fixed-arities #{2}, :end-row 1209, :ns "cljs.core", :name "bit-or", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1207} {:fixed-arities #{1}, :end-row 1212, :ns "cljs.core", :name "int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1211} {:fixed-arities #{2}, :end-row 1216, :ns "cljs.core", :name "bit-xor", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1214} {:fixed-arities #{2}, :end-row 1220, :ns "cljs.core", :name "bit-and-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1218} {:fixed-arities #{2}, :end-row 1223, :ns "cljs.core", :name "bit-clear", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1222} {:fixed-arities #{2}, :end-row 1226, :ns "cljs.core", :name "bit-flip", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1225} {:fixed-arities #{2}, :end-row 1229, :ns "cljs.core", :name "bit-test", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1228} {:fixed-arities #{2}, :end-row 1232, :ns "cljs.core", :name "bit-shift-left", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1231} {:fixed-arities #{2}, :end-row 1235, :ns "cljs.core", :name "bit-shift-right", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1234} {:fixed-arities #{2}, :end-row 1238, :ns "cljs.core", :name "bit-shift-right-zero-fill", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1237} {:fixed-arities #{2}, :end-row 1241, :ns "cljs.core", :name "unsigned-bit-shift-right", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1240} {:fixed-arities #{2}, :end-row 1244, :ns "cljs.core", :name "bit-set", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1243} {:fixed-arities #{2}, :end-row 1248, :ns "cljs.core", :name "mask", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[hash shift]"], :row 1247} {:fixed-arities #{2}, :end-row 1252, :ns "cljs.core", :name "bitpos", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[hash shift]"], :row 1251} {:fixed-arities #{3}, :end-row 1262, :ns "cljs.core", :name "caching-hash", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[coll hash-fn hash-key]"], :row 1255} {:fixed-arities #{5}, :end-row 1271, :private true, :ns "cljs.core", :name "do-curried", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[name doc meta args body]"], :row 1266} {:end-row 1277, :private true, :ns "cljs.core", :name "defcurried", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name doc meta args & body]"], :doc "Builds another arity of the fn that returns a fn awaiting the last\n  param", :row 1273} {:fixed-arities #{3}, :end-row 1288, :private true, :ns "cljs.core", :name "do-rfn", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[f1 k fkv]"], :row 1279} {:fixed-arities #{2}, :end-row 1293, :private true, :ns "cljs.core", :name "rfn", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[[f1 k] fkv]"], :doc "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.", :row 1290} {:fixed-arities #{1}, :end-row 1301, :private true, :ns "cljs.core", :name "protocol-prefix", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[psym]"], :row 1297} {:end-row 1311, :filename "cljs/core.cljc", :lang :cljs, :name "base-type", :ns "cljs.core", :private true, :row 1303} {:end-row 1319, :filename "cljs/core.cljc", :lang :cljs, :name "js-base-type", :ns "cljs.core", :private true, :row 1313} {:end-row 1380, :ns "cljs.core", :name "reify", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& impls]"], :doc "reify creates an object implementing a protocol.\n  reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \"foo\"]\n       (reify Object\n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"]\n       (reify ISeqable\n         (-seq [this] (seq f)))))\n  == (\"f\" \"o\" \"o\"))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", :row 1321} {:end-row 1388, :ns "cljs.core", :name "specify!", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & impls]"], :doc "Identical to reify but mutates its first argument.", :row 1382} {:end-row 1395, :ns "cljs.core", :name "specify", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & impls]"], :doc "Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance.", :row 1390} {:fixed-arities #{0}, :end-row 1398, :private true, :ns "cljs.core", :name "js-this", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 1397} {:end-row 1404, :ns "cljs.core", :name "this-as", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & body]"], :doc "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.", :row 1400} {:fixed-arities #{1}, :end-row 1407, :private true, :ns "cljs.core", :name "to-property", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[sym]"], :row 1406} {:fixed-arities #{3}, :end-row 1425, :private true, :ns "cljs.core", :name "update-protocol-var", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[p type env]"], :row 1409} {:fixed-arities #{2}, :end-row 1430, :private true, :ns "cljs.core", :name "resolve-var", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env sym]"], :row 1427} {:fixed-arities #{1}, :end-row 1437, :private true, :ns "cljs.core", :name "->impl-map", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[impls]"], :row 1432} {:fixed-arities #{5}, :end-row 1448, :private true, :ns "cljs.core", :name "base-assign-impls", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env resolve tsym type [p sigs]]"], :row 1439} {:end-row 1450, :filename "cljs/core.cljc", :lang :cljs, :name "extend-prefix", :ns "cljs.core", :private true, :row 1450} {:fixed-arities #{2}, :end-row 1461, :private true, :ns "cljs.core", :name "adapt-obj-params", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1459} {:fixed-arities #{2}, :end-row 1468, :private true, :ns "cljs.core", :name "adapt-ifn-params", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1463} {:fixed-arities #{2}, :end-row 1474, :private true, :ns "cljs.core", :name "adapt-ifn-invoke-params", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1471} {:fixed-arities #{2}, :end-row 1480, :private true, :ns "cljs.core", :name "adapt-proto-params", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1476} {:fixed-arities #{3}, :end-row 1489, :private true, :ns "cljs.core", :name "add-obj-methods", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym sigs]"], :row 1482} {:fixed-arities #{3}, :end-row 1497, :private true, :ns "cljs.core", :name "ifn-invoke-methods", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym [f & meths :as form]]"], :row 1491} {:fixed-arities #{3}, :end-row 1518, :private true, :ns "cljs.core", :name "add-ifn-methods", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym [f & meths :as form]]"], :row 1499} {:fixed-arities #{4}, :end-row 1530, :private true, :ns "cljs.core", :name "add-proto-methods*", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[pprefix type type-sym [f & meths :as form]]"], :row 1520} {:fixed-arities #{5}, :end-row 1547, :private true, :ns "cljs.core", :name "proto-assign-impls", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env resolve type-sym type [p sigs]]"], :row 1532} {:fixed-arities #{3}, :end-row 1577, :private true, :ns "cljs.core", :name "validate-impl-sigs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env p method]"], :row 1549} {:fixed-arities #{2}, :end-row 1595, :private true, :ns "cljs.core", :name "validate-impls", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env impls]"], :row 1579} {:fixed-arities #{2}, :end-row 1599, :private true, :ns "cljs.core", :name "type-hint-first-arg", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym argv]"], :row 1597} {:fixed-arities #{2}, :end-row 1603, :private true, :ns "cljs.core", :name "type-hint-single-arity-sig", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1601} {:fixed-arities #{2}, :end-row 1607, :private true, :ns "cljs.core", :name "type-hint-multi-arity-sig", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1605} {:fixed-arities #{2}, :end-row 1611, :private true, :ns "cljs.core", :name "type-hint-multi-arity-sigs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sigs]"], :row 1609} {:fixed-arities #{2}, :end-row 1617, :private true, :ns "cljs.core", :name "type-hint-sigs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1613} {:fixed-arities #{2}, :end-row 1623, :private true, :ns "cljs.core", :name "type-hint-impl-map", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym impl-map]"], :row 1619} {:end-row 1665, :ns "cljs.core", :name "extend-type", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[type-sym & impls]"], :doc "Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y] ...) ...)", :row 1625} {:fixed-arities #{2}, :end-row 1687, :private true, :ns "cljs.core", :name "prepare-protocol-masks", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env impls]"], :row 1667} {:fixed-arities #{3}, :end-row 1692, :private true, :ns "cljs.core", :name "annotate-specs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[annots v [f sigs]]"], :row 1689} {:arglist-strs ["[type specs fields]" "[type specs fields inline]"], :end-row 1709, :filename "cljs/core.cljc", :fixed-arities #{4 3}, :lang :cljs, :name "dt->et", :ns "cljs.core", :row 1694} {:fixed-arities #{2}, :end-row 1715, :private true, :ns "cljs.core", :name "collect-protocols", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[impls env]"], :row 1711} {:fixed-arities #{3}, :end-row 1726, :private true, :ns "cljs.core", :name "build-positional-factory", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[rsym rname fields]"], :row 1717} {:fixed-arities #{3}, :end-row 1733, :private true, :ns "cljs.core", :name "validate-fields", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[case name fields]"], :row 1728} {:end-row 1803, :ns "cljs.core", :name "deftype", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[t fields & impls]"], :doc "(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", :row 1735} {:fixed-arities #{5}, :end-row 1910, :private true, :ns "cljs.core", :name "emit-defrecord", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env tagname rname fields impls]"], :doc "Do not use this directly - use defrecord", :row 1805} {:fixed-arities #{3}, :end-row 1922, :private true, :ns "cljs.core", :name "build-map-factory", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[rsym rname fields]"], :row 1912} {:end-row 1991, :ns "cljs.core", :name "defrecord", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[rsym fields & impls]"], :doc "(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", :row 1924} {:end-row 2177, :ns "cljs.core", :name "defprotocol", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym & doc+methods]"], :doc "A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", :row 1993} {:fixed-arities #{2}, :end-row 2203, :ns "cljs.core", :name "implements?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym x]"], :doc "EXPERIMENTAL", :row 2179} {:fixed-arities #{2}, :end-row 2235, :ns "cljs.core", :name "satisfies?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym x]"], :doc "Returns true if x satisfies the protocol", :row 2205} {:end-row 2243, :ns "cljs.core", :name "lazy-seq", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls.", :row 2237} {:end-row 2251, :ns "cljs.core", :name "delay", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.", :row 2245} {:end-row 2275, :ns "cljs.core", :name "with-redefs", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing.", :row 2253} {:end-row 2288, :ns "cljs.core", :name "binding", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", :row 2277} {:end-row 2329, :ns "cljs.core", :name "condp", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[pred expr & clauses]"], :doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an Error is thrown.", :row 2290} {:fixed-arities #{4}, :end-row 2346, :private true, :ns "cljs.core", :name "assoc-test", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[m test expr env]"], :row 2331} {:fixed-arities #{2}, :end-row 2351, :private true, :ns "cljs.core", :name "const?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env x]"], :row 2348} {:end-row 2422, :ns "cljs.core", :name "case", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[e & clauses]"], :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", :row 2353} {:fixed-arities #{1}, :end-row 2425, :private true, :ns "cljs.core", :name "when-assert", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 2424} {:fixed-arities #{1 2}, :end-row 2438, :ns "cljs.core", :name "assert", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x message]"], :doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.", :row 2427} {:fixed-arities #{2}, :end-row 2525, :ns "cljs.core", :name "for", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[seq-exprs body-expr]"], :doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))", :row 2440} {:end-row 2581, :ns "cljs.core", :name "doseq", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[seq-exprs & body]"], :doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", :row 2527} {:arglist-strs ["[& rest]"], :end-row 2590, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "array", :ns "cljs.core", :row 2583} {:fixed-arities #{1 2}, :end-row 2608, :ns "cljs.core", :name "make-array", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[size]" "[type size]" "[type size & more-sizes]"], :row 2592} {:fixed-arities #{0 1}, :end-row 2617, :ns "cljs.core", :name "list", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & xs]"], :row 2610} {:fixed-arities #{0}, :end-row 2628, :ns "cljs.core", :name "vector", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& xs]"], :row 2619} {:fixed-arities #{0}, :end-row 2638, :ns "cljs.core", :name "array-map", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& kvs]"], :row 2630} {:fixed-arities #{0}, :end-row 2651, :ns "cljs.core", :name "hash-map", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& kvs]"], :row 2640} {:fixed-arities #{0}, :end-row 2665, :ns "cljs.core", :name "hash-set", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& xs]"], :row 2653} {:fixed-arities #{1}, :end-row 2674, :private true, :ns "cljs.core", :name "js-obj*", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[kvs]"], :row 2667} {:arglist-strs ["[& rest]"], :end-row 2694, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "js-obj", :ns "cljs.core", :row 2676} {:fixed-arities #{1}, :end-row 2699, :ns "cljs.core", :name "alength", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a]"], :row 2696} {:fixed-arities #{4}, :end-row 2715, :ns "cljs.core", :name "amap", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a idx ret expr]"], :doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret.", :row 2701} {:fixed-arities #{5}, :end-row 2727, :ns "cljs.core", :name "areduce", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a idx ret init expr]"], :doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret.", :row 2717} {:end-row 2741, :ns "cljs.core", :name "dotimes", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", :row 2729} {:end-row 2751, :private true, :ns "cljs.core", :name "check-valid-options", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[options & valid-keys]"], :doc "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", :row 2743} {:end-row 2798, :ns "cljs.core", :name "defmulti", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[mm-name & options]"], :doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy", :row 2753} {:end-row 2803, :ns "cljs.core", :name "defmethod", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[multifn dispatch-val & fn-tail]"], :doc "Creates and installs a new method of multimethod associated with dispatch-value. ", :row 2800} {:fixed-arities #{1}, :end-row 2813, :ns "cljs.core", :name "time", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr]"], :doc "Evaluates expr and prints the time it took. Returns the value of expr.", :row 2805} {:end-row 2831, :ns "cljs.core", :name "simple-benchmark", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]"], :doc "Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case.", :row 2815} {:end-row 2833, :filename "cljs/core.cljc", :lang :cljs, :name "cs", :ns "cljs.core", :private true, :row 2833} {:fixed-arities #{0 1}, :end-row 2844, :private true, :ns "cljs.core", :name "gen-apply-to-helper", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[]" "[n]"], :row 2835} {:fixed-arities #{0}, :end-row 2854, :ns "cljs.core", :name "gen-apply-to", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 2846} {:fixed-arities #{3}, :end-row 2878, :private true, :ns "cljs.core", :name "gen-apply-to-simple-helper", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[f num-args args]"], :row 2856} {:fixed-arities #{3}, :end-row 2882, :ns "cljs.core", :name "gen-apply-to-simple", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[f num-args args]"], :row 2880} {:end-row 2893, :ns "cljs.core", :name "with-out-str", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls.", :row 2884} {:end-row 2902, :ns "cljs.core", :name "lazy-cat", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& colls]"], :doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", :row 2895} {:fixed-arities #{1}, :end-row 2905, :ns "cljs.core", :name "js-str", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[s]"], :row 2904} {:fixed-arities #{1}, :end-row 2911, :ns "cljs.core", :name "es6-iterable", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[ty]"], :row 2907} {:fixed-arities #{1}, :end-row 2927, :ns "cljs.core", :name "ns-publics", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the public intern mappings for the namespace.", :row 2913} {:fixed-arities #{1}, :end-row 2941, :ns "cljs.core", :name "ns-imports", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the import mappings for the namespace.", :row 2929} {:fixed-arities #{1}, :end-row 2955, :ns "cljs.core", :name "ns-interns", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the intern mappings for the namespace.", :row 2943} {:fixed-arities #{2}, :end-row 2967, :ns "cljs.core", :name "ns-unmap", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns quoted-sym]"], :doc "Removes the mappings for the symbol from the namespace.", :row 2957} {:end-row 2974, :ns "cljs.core", :name "vswap!", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[vol f & args]"], :doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", :row 2969} {:arglist-strs ["[x & forms]"], :end-row 2978, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "locking", :ns "cljs.core", :row 2976} {:fixed-arities #{0}, :end-row 2981, :private true, :ns "cljs.core", :name "ns-special-form", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 2981} {:end-row 3036, :ns "cljs.core", :name "require", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib's name also locates its root directory\n  within classpath using Java's package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace.\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n  :rename specifies a map from referred var names to different\n    symbols (and can be used to prevent clashes)\n\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require '[clojure.string :as string])", :row 2983} {:end-row 3041, :ns "cljs.core", :name "require-macros", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Similar to require but only for macros.", :row 3038} {:end-row 3054, :ns "cljs.core", :name "use", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Like require, but referring vars specified by the mandatory\n  :only option.\n\n  Example:\n\n  The following would load the library clojure.set while referring\n  the intersection var.\n\n  (use '[clojure.set :only [intersection]])", :row 3043} {:end-row 3059, :ns "cljs.core", :name "use-macros", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Similar to use but only for macros.", :row 3056} {:end-row 3068, :ns "cljs.core", :name "import", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& import-symbols-or-lists]"], :doc "import-list => (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", :row 3061} {:end-row 3081, :ns "cljs.core", :name "refer-clojure", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Refers to all the public vars of `cljs.core`, subject to\n  filters.\n  Filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  Filters can be used to select a subset, via exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent clashes.", :row 3070} {:fixed-arities #{1}, :end-row 3085, :ns "cljs.core", :name "load-file*", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[f]"], :row 3084} {:fixed-arities #{1}, :end-row 3096, :ns "cljs.core", :name "macroexpand-1", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted]"], :doc "If form represents a macro form, returns its expansion,\n  else returns form.", :row 3087} {:fixed-arities #{1}, :end-row 3112, :ns "cljs.core", :name "macroexpand", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted]"], :doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", :row 3098} {:fixed-arities #{1}, :end-row 3115, :private true, :ns "cljs.core", :name "multi-arity-fn?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 3114} {:fixed-arities #{1}, :end-row 3119, :private true, :ns "cljs.core", :name "variadic-fn?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 3117} {:fixed-arities #{3 2}, :end-row 3155, :private true, :ns "cljs.core", :name "variadic-fn*", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[sym method]" "[sym [arglist & body :as method] solo]"], :row 3121} {:fixed-arities #{1}, :end-row 3162, :ns "cljs.core", :name "copy-arguments", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[dest]"], :row 3157} {:fixed-arities #{1}, :end-row 3169, :private true, :ns "cljs.core", :name "elide-implicit-macro-args", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[arglists]"], :row 3164} {:fixed-arities #{4}, :end-row 3199, :private true, :ns "cljs.core", :name "variadic-fn", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[name meta [[arglist & body :as method] :as fdecl] emit-var?]"], :row 3171} {:fixed-arities #{4}, :end-row 3286, :private true, :ns "cljs.core", :name "multi-arity-fn", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[name meta fdecl emit-var?]"], :row 3209} {:doc "Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", :end-row 3368, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "defn", :ns "cljs.core", :row 3297} {:end-row 3414, :ns "cljs.core", :name "defmacro", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[&form &env name & args]"], :doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", :row 3373} {:fixed-arities #{1}, :end-row 3435, :ns "cljs.core", :name "resolve", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-sym]"], :doc "Returns the var to which a symbol will be resolved in the namespace else nil.", :row 3419} {:end-row 19, :filename "cljs/core.cljs", :name "*clojurescript-version*", :ns "cljs.core", :row 19} {:end-row 26, :filename "cljs/core.cljs", :name "*unchecked-if*", :ns "cljs.core", :row 26} {:end-row 30, :filename "cljs/core.cljs", :name "*unchecked-arrays*", :ns "cljs.core", :row 30} {:end-row 33, :filename "cljs/core.cljs", :name "*warn-on-infer*", :ns "cljs.core", :row 33} {:end-row 37, :filename "cljs/core.cljs", :name "PROTOCOL_SENTINEL", :ns "cljs.core", :row 37} {:end-row 39, :filename "cljs/core.cljs", :name "MODULE_URIS", :ns "cljs.core", :row 39} {:end-row 40, :filename "cljs/core.cljs", :name "MODULE_INFOS", :ns "cljs.core", :row 40} {:doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :end-row 48, :filename "cljs/core.cljs", :name "*target*", :ns "cljs.core", :row 42} {:doc "Manually set the JavaScript global context. Only \"window\", \"self\"\n  , and \"global\" supported. ", :end-row 54, :filename "cljs/core.cljs", :name "*global*", :ns "cljs.core", :row 50} {:doc "Var bound to the current namespace. Only used for bootstrapping.", :end-row 60, :filename "cljs/core.cljs", :name "*ns*", :ns "cljs.core", :row 56} {:end-row 65, :filename "cljs/core.cljs", :name "*out*", :ns "cljs.core", :row 62} {:end-row 69, :filename "cljs/core.cljs", :name "*assert*", :ns "cljs.core", :row 67} {:doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :end-row 75, :filename "cljs/core.cljs", :name "*print-fn*", :ns "cljs.core", :row 71} {:end-row 77, :filename "cljs/core.cljs", :name "boolean", :ns "cljs.core", :row 77} {:arglist-strs ["[f]"], :doc "Arranges to have tap functions executed via the supplied f, a\n  function of no arguments. Returns true if successful, false otherwise.", :end-row 86, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "*exec-tap-fn*", :ns "cljs.core", :row 79} {:doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed.", :end-row 92, :filename "cljs/core.cljs", :name "*print-err-fn*", :ns "cljs.core", :row 88} {:arglist-strs ["[f]"], :doc "Set *print-fn* to f.", :end-row 96, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set-print-fn!", :ns "cljs.core", :row 94} {:arglist-strs ["[f]"], :doc "Set *print-err-fn* to f.", :end-row 100, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set-print-err-fn!", :ns "cljs.core", :row 98} {:doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", :end-row 107, :filename "cljs/core.cljs", :name "*flush-on-newline*", :ns "cljs.core", :row 102} {:doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects.", :end-row 114, :filename "cljs/core.cljs", :name "*print-newline*", :ns "cljs.core", :row 109} {:doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", :end-row 122, :filename "cljs/core.cljs", :name "*print-readably*", :ns "cljs.core", :row 116} {:doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", :end-row 130, :filename "cljs/core.cljs", :name "*print-meta*", :ns "cljs.core", :row 124} {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :end-row 138, :filename "cljs/core.cljs", :name "*print-dup*", :ns "cljs.core", :row 132} {:doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true.", :end-row 146, :filename "cljs/core.cljs", :name "*print-namespace-maps*", :ns "cljs.core", :row 140} {:doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", :end-row 158, :filename "cljs/core.cljs", :name "*print-length*", :ns "cljs.core", :row 148} {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :end-row 171, :filename "cljs/core.cljs", :name "*print-level*", :ns "cljs.core", :row 160} {:doc "*print-fns-bodies* controls whether functions print their source or\n    only their names.", :end-row 177, :filename "cljs/core.cljs", :name "*print-fn-bodies*", :ns "cljs.core", :row 173} {:end-row 182, :filename "cljs/core.cljs", :name "*loaded-libs*", :ns "cljs.core", :row 179} {:arglist-strs ["[]"], :end-row 189, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "pr-opts", :ns "cljs.core", :private true, :row 184} {:end-row 191, :filename "cljs/core.cljs", :name "into-array", :ns "cljs.core", :row 191} {:arglist-strs ["[]"], :doc "Set *print-fn* to console.log", :end-row 205, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "enable-console-print!", :ns "cljs.core", :row 193} {:doc "bound in a repl thread to the most recent value printed", :end-row 209, :filename "cljs/core.cljs", :name "*1", :ns "cljs.core", :row 207} {:doc "bound in a repl thread to the second most recent value printed", :end-row 213, :filename "cljs/core.cljs", :name "*2", :ns "cljs.core", :row 211} {:doc "bound in a repl thread to the third most recent value printed", :end-row 217, :filename "cljs/core.cljs", :name "*3", :ns "cljs.core", :row 215} {:doc "bound in a repl thread to the most recent exception caught by the repl", :end-row 221, :filename "cljs/core.cljs", :name "*e", :ns "cljs.core", :row 219} {:arglist-strs ["[x]"], :doc "Internal - do not use!", :end-row 226, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "truth_", :ns "cljs.core", :row 223} {:end-row 228, :filename "cljs/core.cljs", :name "not-native", :ns "cljs.core", :row 228} {:end-row 230, :filename "cljs/core.cljs", :name "instance?", :ns "cljs.core", :row 230} {:end-row 230, :filename "cljs/core.cljs", :name "Keyword", :ns "cljs.core", :row 230} {:arglist-strs ["[x y]"], :doc "Tests if 2 arguments are the same object", :end-row 235, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "identical?", :ns "cljs.core", :row 232} {:arglist-strs ["[x]"], :doc "Returns true if x is nil, false otherwise.", :end-row 240, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "nil?", :ns "cljs.core", :row 237} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript array.", :end-row 247, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "array?", :ns "cljs.core", :row 242} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript number.", :end-row 252, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "number?", :ns "cljs.core", :row 249} {:arglist-strs ["[x]"], :doc "Returns true if x is logical false, false otherwise.", :end-row 260, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "not", :ns "cljs.core", :row 254} {:arglist-strs ["[x]"], :doc "Returns true if x is not nil, false otherwise.", :end-row 264, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "some?", :ns "cljs.core", :row 262} {:arglist-strs ["[x]"], :doc "Returns true if x's constructor is Object", :end-row 271, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "object?", :ns "cljs.core", :row 266} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript string.", :end-row 276, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "string?", :ns "cljs.core", :row 273} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript string of length one.", :end-row 281, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "char?", :ns "cljs.core", :row 278} {:arglist-strs ["[x]"], :doc "Returns true if given any argument.", :end-row 285, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "any?", :ns "cljs.core", :row 283} {:arglist-strs ["[p x]"], :doc "Internal - do not use!", :end-row 295, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "native-satisfies?", :ns "cljs.core", :row 288} {:arglist-strs ["[x]"], :end-row 300, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "is_proto_", :ns "cljs.core", :row 298} {:doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments", :end-row 306, :filename "cljs/core.cljs", :name "*main-cli-fn*", :ns "cljs.core", :row 302} {:doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied", :end-row 311, :filename "cljs/core.cljs", :name "*command-line-args*", :ns "cljs.core", :row 308} {:arglist-strs ["[x]"], :doc "Return x's constructor.", :end-row 317, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "type", :ns "cljs.core", :row 313} {:arglist-strs ["[proto obj]"], :end-row 326, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "missing-protocol", :ns "cljs.core", :row 319} {:arglist-strs ["[ty]"], :end-row 331, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "type->str", :ns "cljs.core", :row 328} {:arglist-strs ["[file]"], :end-row 336, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "load-file", :ns "cljs.core", :row 334} {:end-row 340, :filename "cljs/core.cljs", :name "ITER_SYMBOL", :ns "cljs.core", :row 340} {:end-row 341, :filename "cljs/core.cljs", :name "ITER_SYMBOL", :ns "cljs.core", :row 341} {:end-row 368, :filename "cljs/core.cljs", :name "CHAR_MAP", :ns "cljs.core", :row 343} {:end-row 395, :filename "cljs/core.cljs", :name "DEMUNGE_MAP", :ns "cljs.core", :row 370} {:end-row 397, :filename "cljs/core.cljs", :name "DEMUNGE_PATTERN", :ns "cljs.core", :row 397} {:arglist-strs ["[]"], :doc "Returns highest resolution time offered by host in milliseconds.", :end-row 412, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "system-time", :ns "cljs.core", :row 399} {:end-row 416, :filename "cljs/core.cljs", :name "apply", :ns "cljs.core", :row 416} {:arglist-strs ["[size]" "[type size]" "[type size & more-sizes]"], :doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :end-row 432, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "make-array", :ns "cljs.core", :row 418} {:arglist-strs ["[arr]"], :doc "Returns a javascript array, cloned from the passed in array", :end-row 441, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "aclone", :ns "cljs.core", :row 434} {:arglist-strs ["[var-args]"], :doc "Creates a new javascript array.\n@param {...*} var_args", :end-row 453, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "array", :ns "cljs.core", :row 443} {:arglist-strs ["[e]"], :end-row 458, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "maybe-warn", :ns "cljs.core", :private true, :row 455} {:arglist-strs ["[array idx]" "[array idx & idxs]"], :end-row 472, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "checked-aget", :ns "cljs.core", :private true, :row 460} {:arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :end-row 486, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "checked-aset", :ns "cljs.core", :private true, :row 474} {:arglist-strs ["[array idx]" "[array idx & idxs]"], :end-row 494, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "checked-aget'", :ns "cljs.core", :private true, :row 488} {:arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :end-row 502, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "checked-aset'", :ns "cljs.core", :private true, :row 496} {:arglist-strs ["[array idx]" "[array idx & idxs]"], :doc "Returns the value at the index/indices. Works on JavaScript arrays.", :end-row 509, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "aget", :ns "cljs.core", :row 504} {:arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.", :end-row 517, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "aset", :ns "cljs.core", :row 511} {:arglist-strs ["[array]"], :doc "Returns the length of the array. Works on arrays of all types.", :end-row 522, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "alength", :ns "cljs.core", :row 519} {:end-row 524, :filename "cljs/core.cljs", :name "reduce", :ns "cljs.core", :row 524} {:arglist-strs ["[aseq]" "[type aseq]"], :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :end-row 532, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "into-array", :ns "cljs.core", :row 526} {:arglist-strs ["[obj s & args]"], :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :end-row 538, :filename "cljs/core.cljs", :name "js-invoke", :ns "cljs.core", :row 534} {:arglist-strs ["[x]"], :doc "Returns true if x is an instance of Symbol", :end-row 545, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js-symbol?", :ns "cljs.core", :row 540} {:doc "Marker protocol", :end-row 550, :filename "cljs/core.cljs", :name "Fn", :ns "cljs.core", :row 549} {:doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :end-row 578, :filename "cljs/core.cljs", :name "IFn", :ns "cljs.core", :row 552} {:arglist-strs ["[this]" "[this a]" "[this a b]" "[this a b c]" "[this a b c d]" "[this a b c d e]" "[this a b c d e f]" "[this a b c d e f g]" "[this a b c d e f g h]" "[this a b c d e f g h i]" "[this a b c d e f g h i j]" "[this a b c d e f g h i j k]" "[this a b c d e f g h i j k l]" "[this a b c d e f g h i j k l m]" "[this a b c d e f g h i j k l m n]" "[this a b c d e f g h i j k l m n o]" "[this a b c d e f g h i j k l m n o p]" "[this a b c d e f g h i j k l m n o p q]" "[this a b c d e f g h i j k l m n o p q r]" "[this a b c d e f g h i j k l m n o p q r s]" "[this a b c d e f g h i j k l m n o p q r s t]" "[this a b c d e f g h i j k l m n o p q r s t rest]"], :end-row 578, :filename "cljs/core.cljs", :fixed-arities #{7 20 1 4 15 21 13 22 6 17 3 12 2 19 11 9 5 14 16 10 18 8}, :name "-invoke", :ns "cljs.core", :row 556} {:doc "Protocol for cloning a value.", :end-row 583, :filename "cljs/core.cljs", :name "ICloneable", :ns "cljs.core", :row 580} {:arglist-strs ["[value]"], :doc "Creates a clone of value.", :end-row 583, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-clone", :ns "cljs.core", :row 582} {:doc "Protocol for adding the ability to count a collection in constant time.", :end-row 588, :filename "cljs/core.cljs", :name "ICounted", :ns "cljs.core", :row 585} {:arglist-strs ["[coll]"], :doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :end-row 588, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-count", :ns "cljs.core", :row 587} {:doc "Protocol for creating an empty collection.", :end-row 594, :filename "cljs/core.cljs", :name "IEmptyableCollection", :ns "cljs.core", :row 590} {:arglist-strs ["[coll]"], :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :end-row 594, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-empty", :ns "cljs.core", :row 592} {:doc "Protocol for adding to a collection.", :end-row 602, :filename "cljs/core.cljs", :name "ICollection", :ns "cljs.core", :row 596} {:arglist-strs ["[coll o]"], :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :end-row 602, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-conj", :ns "cljs.core", :row 598} {:doc "Protocol for collections to provide indexed-based access to their items.", :end-row 611, :filename "cljs/core.cljs", :name "IIndexed", :ns "cljs.core", :row 607} {:arglist-strs ["[coll n]" "[coll n not-found]"], :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :end-row 611, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-nth", :ns "cljs.core", :row 609} {:doc "Marker protocol indicating an array sequence.", :end-row 614, :filename "cljs/core.cljs", :name "ASeq", :ns "cljs.core", :row 613} {:doc "Protocol for collections to provide access to their items as sequences.", :end-row 624, :filename "cljs/core.cljs", :name "ISeq", :ns "cljs.core", :row 616} {:arglist-strs ["[coll]"], :doc "Returns the first item in the collection coll. Used by cljs.core/first.", :end-row 619, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-first", :ns "cljs.core", :row 618} {:arglist-strs ["[coll]"], :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :end-row 624, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-rest", :ns "cljs.core", :row 620} {:doc "Protocol for accessing the next items of a collection.", :end-row 632, :filename "cljs/core.cljs", :name "INext", :ns "cljs.core", :row 626} {:arglist-strs ["[coll]"], :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :end-row 632, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-next", :ns "cljs.core", :row 628} {:doc "Protocol for looking up a value in a data structure.", :end-row 638, :filename "cljs/core.cljs", :name "ILookup", :ns "cljs.core", :row 634} {:arglist-strs ["[o k]" "[o k not-found]"], :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :end-row 638, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-lookup", :ns "cljs.core", :row 636} {:doc "Protocol for adding associativity to collections.", :end-row 647, :filename "cljs/core.cljs", :name "IAssociative", :ns "cljs.core", :row 640} {:arglist-strs ["[coll k]"], :doc "Returns true if k is a key in coll.", :end-row 643, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-contains-key?", :ns "cljs.core", :row 642} {:arglist-strs ["[coll k v]"], :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :end-row 647, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-assoc", :ns "cljs.core", :row 645} {:doc "Protocol for implementing entry finding in collections.", :end-row 651, :filename "cljs/core.cljs", :name "IFind", :ns "cljs.core", :row 649} {:arglist-strs ["[coll k]"], :doc "Returns the map entry for key, or nil if key not present.", :end-row 651, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-find", :ns "cljs.core", :row 651} {:doc "Protocol for adding mapping functionality to collections.", :end-row 657, :filename "cljs/core.cljs", :name "IMap", :ns "cljs.core", :row 653} {:arglist-strs ["[coll k]"], :doc "Returns a new collection of coll without the mapping for key k.", :end-row 657, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-dissoc", :ns "cljs.core", :row 656} {:doc "Protocol for examining a map entry.", :end-row 664, :filename "cljs/core.cljs", :name "IMapEntry", :ns "cljs.core", :row 659} {:arglist-strs ["[coll]"], :doc "Returns the key of the map entry.", :end-row 662, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-key", :ns "cljs.core", :row 661} {:arglist-strs ["[coll]"], :doc "Returns the value of the map entry.", :end-row 664, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-val", :ns "cljs.core", :row 663} {:doc "Protocol for adding set functionality to a collection.", :end-row 669, :filename "cljs/core.cljs", :name "ISet", :ns "cljs.core", :row 666} {:arglist-strs ["[coll v]"], :doc "Returns a new collection of coll that does not contain v.", :end-row 669, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-disjoin", :ns "cljs.core", :row 668} {:doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :end-row 679, :filename "cljs/core.cljs", :name "IStack", :ns "cljs.core", :row 671} {:arglist-strs ["[coll]"], :doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :end-row 676, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-peek", :ns "cljs.core", :row 675} {:arglist-strs ["[coll]"], :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :end-row 679, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-pop", :ns "cljs.core", :row 677} {:doc "Protocol for adding vector functionality to collections.", :end-row 684, :filename "cljs/core.cljs", :name "IVector", :ns "cljs.core", :row 681} {:arglist-strs ["[coll n val]"], :doc "Returns a new vector with value val added at position n.", :end-row 684, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-assoc-n", :ns "cljs.core", :row 683} {:doc "Protocol for adding dereference functionality to a reference.", :end-row 689, :filename "cljs/core.cljs", :name "IDeref", :ns "cljs.core", :row 686} {:arglist-strs ["[o]"], :doc "Returns the value of the reference o.", :end-row 689, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-deref", :ns "cljs.core", :row 688} {:end-row 692, :filename "cljs/core.cljs", :name "IDerefWithTimeout", :ns "cljs.core", :row 691} {:arglist-strs ["[o msec timeout-val]"], :end-row 692, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-deref-with-timeout", :ns "cljs.core", :row 692} {:doc "Protocol for accessing the metadata of an object.", :end-row 697, :filename "cljs/core.cljs", :name "IMeta", :ns "cljs.core", :row 694} {:arglist-strs ["[o]"], :doc "Returns the metadata of object o.", :end-row 697, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-meta", :ns "cljs.core", :row 696} {:doc "Protocol for adding metadata to an object.", :end-row 702, :filename "cljs/core.cljs", :name "IWithMeta", :ns "cljs.core", :row 699} {:arglist-strs ["[o meta]"], :doc "Returns a new object with value of o and metadata meta added to it.", :end-row 702, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-with-meta", :ns "cljs.core", :row 701} {:doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :end-row 710, :filename "cljs/core.cljs", :name "IReduce", :ns "cljs.core", :row 704} {:arglist-strs ["[coll f]" "[coll f start]"], :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :end-row 710, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-reduce", :ns "cljs.core", :row 707} {:doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :end-row 717, :filename "cljs/core.cljs", :name "IKVReduce", :ns "cljs.core", :row 712} {:arglist-strs ["[coll f init]"], :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :end-row 717, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-kv-reduce", :ns "cljs.core", :row 715} {:doc "Protocol for adding value comparison functionality to a type.", :end-row 722, :filename "cljs/core.cljs", :name "IEquiv", :ns "cljs.core", :row 719} {:arglist-strs ["[o other]"], :doc "Returns true if o and other are equal, false otherwise.", :end-row 722, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-equiv", :ns "cljs.core", :row 721} {:doc "Protocol for adding hashing functionality to a type.", :end-row 727, :filename "cljs/core.cljs", :name "IHash", :ns "cljs.core", :row 724} {:arglist-strs ["[o]"], :doc "Returns the hash code of o.", :end-row 727, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-hash", :ns "cljs.core", :row 726} {:doc "Protocol for adding the ability to a type to be transformed into a sequence.", :end-row 732, :filename "cljs/core.cljs", :name "ISeqable", :ns "cljs.core", :row 729} {:arglist-strs ["[o]"], :doc "Returns a seq of o, or nil if o is empty.", :end-row 732, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-seq", :ns "cljs.core", :row 731} {:doc "Marker interface indicating a persistent collection of sequential items", :end-row 735, :filename "cljs/core.cljs", :name "ISequential", :ns "cljs.core", :row 734} {:doc "Marker interface indicating a persistent list", :end-row 738, :filename "cljs/core.cljs", :name "IList", :ns "cljs.core", :row 737} {:doc "Marker interface indicating a record object", :end-row 741, :filename "cljs/core.cljs", :name "IRecord", :ns "cljs.core", :row 740} {:doc "Protocol for reversing a seq.", :end-row 746, :filename "cljs/core.cljs", :name "IReversible", :ns "cljs.core", :row 743} {:arglist-strs ["[coll]"], :doc "Returns a seq of the items in coll in reversed order.", :end-row 746, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-rseq", :ns "cljs.core", :row 745} {:doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :end-row 763, :filename "cljs/core.cljs", :name "ISorted", :ns "cljs.core", :row 748} {:arglist-strs ["[coll ascending?]"], :doc "Returns a sorted seq from coll in either ascending or descending order.", :end-row 752, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-sorted-seq", :ns "cljs.core", :row 751} {:arglist-strs ["[coll k ascending?]"], :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :end-row 759, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-sorted-seq-from", :ns "cljs.core", :row 753} {:arglist-strs ["[coll entry]"], :doc "Returns the key for entry.", :end-row 761, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-entry-key", :ns "cljs.core", :row 760} {:arglist-strs ["[coll]"], :doc "Returns the comparator for coll.", :end-row 763, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-comparator", :ns "cljs.core", :row 762} {:doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :end-row 770, :filename "cljs/core.cljs", :name "IWriter", :ns "cljs.core", :row 765} {:arglist-strs ["[writer s]"], :doc "Writes s with writer and returns the result.", :end-row 768, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-write", :ns "cljs.core", :row 767} {:arglist-strs ["[writer]"], :doc "Flush writer.", :end-row 770, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-flush", :ns "cljs.core", :row 769} {:doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :end-row 778, :filename "cljs/core.cljs", :name "IPrintWithWriter", :ns "cljs.core", :row 772} {:arglist-strs ["[o writer opts]"], :end-row 778, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-pr-writer", :ns "cljs.core", :row 778} {:doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq.", :end-row 784, :filename "cljs/core.cljs", :name "IPending", :ns "cljs.core", :row 780} {:arglist-strs ["[x]"], :doc "Returns true if a value for x has been produced, false otherwise.", :end-row 784, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-realized?", :ns "cljs.core", :row 783} {:doc "Protocol for types that can be watched. Currently only implemented by Atom.", :end-row 794, :filename "cljs/core.cljs", :name "IWatchable", :ns "cljs.core", :row 786} {:arglist-strs ["[this oldval newval]"], :doc "Calls all watchers with this, oldval and newval.", :end-row 789, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-notify-watches", :ns "cljs.core", :row 788} {:arglist-strs ["[this key f]"], :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :end-row 792, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-add-watch", :ns "cljs.core", :row 790} {:arglist-strs ["[this key]"], :doc "Removes watcher that corresponds to key from this.", :end-row 794, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-remove-watch", :ns "cljs.core", :row 793} {:doc "Protocol for collections which can transformed to transients.", :end-row 799, :filename "cljs/core.cljs", :name "IEditableCollection", :ns "cljs.core", :row 796} {:arglist-strs ["[coll]"], :doc "Returns a new, transient version of the collection, in constant time.", :end-row 799, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-as-transient", :ns "cljs.core", :row 798} {:doc "Protocol for adding basic functionality to transient collections.", :end-row 806, :filename "cljs/core.cljs", :name "ITransientCollection", :ns "cljs.core", :row 801} {:arglist-strs ["[tcoll val]"], :doc "Adds value val to tcoll and returns tcoll.", :end-row 804, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-conj!", :ns "cljs.core", :row 803} {:arglist-strs ["[tcoll]"], :doc "Creates a persistent data structure from tcoll and returns it.", :end-row 806, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-persistent!", :ns "cljs.core", :row 805} {:doc "Protocol for adding associativity to transient collections.", :end-row 812, :filename "cljs/core.cljs", :name "ITransientAssociative", :ns "cljs.core", :row 808} {:arglist-strs ["[tcoll key val]"], :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :end-row 812, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-assoc!", :ns "cljs.core", :row 810} {:doc "Protocol for adding mapping functionality to transient collections.", :end-row 817, :filename "cljs/core.cljs", :name "ITransientMap", :ns "cljs.core", :row 814} {:arglist-strs ["[tcoll key]"], :doc "Returns a new transient collection of tcoll without the mapping for key.", :end-row 817, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-dissoc!", :ns "cljs.core", :row 816} {:doc "Protocol for adding vector functionality to transient collections.", :end-row 824, :filename "cljs/core.cljs", :name "ITransientVector", :ns "cljs.core", :row 819} {:arglist-strs ["[tcoll n val]"], :doc "Returns tcoll with value val added at position n.", :end-row 822, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-assoc-n!", :ns "cljs.core", :row 821} {:arglist-strs ["[tcoll]"], :doc "Returns tcoll with the last item removed from it.", :end-row 824, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-pop!", :ns "cljs.core", :row 823} {:doc "Protocol for adding set functionality to a transient collection.", :end-row 829, :filename "cljs/core.cljs", :name "ITransientSet", :ns "cljs.core", :row 826} {:arglist-strs ["[tcoll v]"], :doc "Returns tcoll without v.", :end-row 829, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-disjoin!", :ns "cljs.core", :row 828} {:doc "Protocol for values that can be compared.", :end-row 835, :filename "cljs/core.cljs", :name "IComparable", :ns "cljs.core", :row 831} {:arglist-strs ["[x y]"], :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :end-row 835, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-compare", :ns "cljs.core", :row 833} {:doc "Protocol for accessing the items of a chunk.", :end-row 840, :filename "cljs/core.cljs", :name "IChunk", :ns "cljs.core", :row 837} {:arglist-strs ["[coll]"], :doc "Return a new chunk of coll with the first item removed.", :end-row 840, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-drop-first", :ns "cljs.core", :row 839} {:doc "Protocol for accessing a collection as sequential chunks.", :end-row 847, :filename "cljs/core.cljs", :name "IChunkedSeq", :ns "cljs.core", :row 842} {:arglist-strs ["[coll]"], :doc "Returns the first chunk in coll.", :end-row 845, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-chunked-first", :ns "cljs.core", :row 844} {:arglist-strs ["[coll]"], :doc "Return a new collection of coll with the first chunk removed.", :end-row 847, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-chunked-rest", :ns "cljs.core", :row 846} {:doc "Protocol for accessing the chunks of a collection.", :end-row 852, :filename "cljs/core.cljs", :name "IChunkedNext", :ns "cljs.core", :row 849} {:arglist-strs ["[coll]"], :doc "Returns a new collection of coll without the first chunk.", :end-row 852, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-chunked-next", :ns "cljs.core", :row 851} {:doc "Protocol for adding a name.", :end-row 859, :filename "cljs/core.cljs", :name "INamed", :ns "cljs.core", :row 854} {:arglist-strs ["[x]"], :doc "Returns the name String of x.", :end-row 857, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-name", :ns "cljs.core", :row 856} {:arglist-strs ["[x]"], :doc "Returns the namespace String of x.", :end-row 859, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-namespace", :ns "cljs.core", :row 858} {:doc "Marker protocol indicating an atom.", :end-row 862, :filename "cljs/core.cljs", :name "IAtom", :ns "cljs.core", :row 861} {:doc "Protocol for adding resetting functionality.", :end-row 867, :filename "cljs/core.cljs", :name "IReset", :ns "cljs.core", :row 864} {:arglist-strs ["[o new-value]"], :doc "Sets the value of o to new-value.", :end-row 867, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-reset!", :ns "cljs.core", :row 866} {:doc "Protocol for adding swapping functionality.", :end-row 872, :filename "cljs/core.cljs", :name "ISwap", :ns "cljs.core", :row 869} {:arglist-strs ["[o f]" "[o f a]" "[o f a b]" "[o f a b xs]"], :doc "Swaps the value of o to be (apply f current-value-of-atom args).", :end-row 872, :filename "cljs/core.cljs", :fixed-arities #{4 3 2 5}, :name "-swap!", :ns "cljs.core", :row 871} {:doc "Protocol for adding volatile functionality.", :end-row 878, :filename "cljs/core.cljs", :name "IVolatile", :ns "cljs.core", :row 874} {:arglist-strs ["[o new-value]"], :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :end-row 878, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-vreset!", :ns "cljs.core", :row 876} {:doc "Protocol for iterating over a collection.", :end-row 883, :filename "cljs/core.cljs", :name "IIterable", :ns "cljs.core", :row 880} {:arglist-strs ["[coll]"], :doc "Returns an iterator for coll.", :end-row 883, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-iterator", :ns "cljs.core", :row 882} {:end-row 890, :filename "cljs/core.cljs", :name "StringBufferWriter", :ns "cljs.core", :row 887} {:arglist-strs ["[sb]"], :end-row 890, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->StringBufferWriter", :ns "cljs.core", :row 887} {:arglist-strs ["[obj]"], :doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :end-row 900, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pr-str*", :ns "cljs.core", :row 892} {:arglist-strs ["[x n]"], :end-row 908, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "int-rotate-left", :ns "cljs.core", :row 905} {:arglist-strs ["[a b]"], :end-row 913, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "imul", :ns "cljs.core", :row 913} {:arglist-strs ["[a b]"], :end-row 922, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "imul", :ns "cljs.core", :row 914} {:end-row 925, :filename "cljs/core.cljs", :name "m3-seed", :ns "cljs.core", :row 925} {:end-row 926, :filename "cljs/core.cljs", :name "m3-C1", :ns "cljs.core", :row 926} {:end-row 927, :filename "cljs/core.cljs", :name "m3-C2", :ns "cljs.core", :row 927} {:arglist-strs ["[k1]"], :end-row 930, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "m3-mix-K1", :ns "cljs.core", :row 929} {:arglist-strs ["[h1 k1]"], :end-row 933, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "m3-mix-H1", :ns "cljs.core", :row 932} {:arglist-strs ["[h1 len]"], :end-row 942, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "m3-fmix", :ns "cljs.core", :row 935} {:arglist-strs ["[in]"], :end-row 949, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "m3-hash-int", :ns "cljs.core", :row 944} {:arglist-strs ["[in]"], :end-row 963, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "m3-hash-unencoded-chars", :ns "cljs.core", :row 951} {:end-row 967, :filename "cljs/core.cljs", :name "list", :ns "cljs.core", :row 967} {:end-row 967, :filename "cljs/core.cljs", :name "Symbol", :ns "cljs.core", :row 967} {:end-row 967, :filename "cljs/core.cljs", :name "=", :ns "cljs.core", :row 967} {:end-row 967, :filename "cljs/core.cljs", :name "compare", :ns "cljs.core", :row 967} {:end-row 970, :filename "cljs/core.cljs", :name "string-hash-cache", :ns "cljs.core", :row 970} {:end-row 971, :filename "cljs/core.cljs", :name "string-hash-cache-count", :ns "cljs.core", :row 971} {:arglist-strs ["[s]"], :end-row 983, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-string*", :ns "cljs.core", :row 974} {:arglist-strs ["[k]"], :end-row 989, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "add-to-string-hash-cache", :ns "cljs.core", :row 985} {:arglist-strs ["[k]"], :end-row 1000, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-string", :ns "cljs.core", :row 991} {:arglist-strs ["[o]"], :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =.", :end-row 1036, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash", :ns "cljs.core", :row 1002} {:arglist-strs ["[seed hash]"], :end-row 1043, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "hash-combine", :ns "cljs.core", :row 1038} {:arglist-strs ["[c x]"], :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false", :end-row 1049, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "instance?", :ns "cljs.core", :row 1045} {:arglist-strs ["[x]"], :doc "Return true if x is a Symbol", :end-row 1054, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "symbol?", :ns "cljs.core", :row 1051} {:arglist-strs ["[sym]"], :end-row 1059, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-symbol", :ns "cljs.core", :private true, :row 1056} {:arglist-strs ["[a b]"], :end-row 1071, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "compare-symbols", :ns "cljs.core", :private true, :row 1061} {:end-row 1073, :filename "cljs/core.cljs", :name "get", :ns "cljs.core", :row 1073} {:end-row 1107, :filename "cljs/core.cljs", :name "Symbol", :ns "cljs.core", :row 1075} {:arglist-strs ["[ns name str _hash _meta]"], :end-row 1107, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Symbol", :ns "cljs.core", :row 1075} {:arglist-strs ["[v]"], :doc "Returns true if v is of type cljs.core.Var", :end-row 1112, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "var?", :ns "cljs.core", :row 1109} {:arglist-strs ["[name]" "[ns name]"], :doc "Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars.", :end-row 1131, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "symbol", :ns "cljs.core", :row 1114} {:end-row 1199, :filename "cljs/core.cljs", :name "Var", :ns "cljs.core", :row 1133} {:arglist-strs ["[val sym _meta]"], :end-row 1199, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->Var", :ns "cljs.core", :row 1133} {:end-row 1203, :filename "cljs/core.cljs", :name "array-seq", :ns "cljs.core", :row 1203} {:end-row 1203, :filename "cljs/core.cljs", :name "prim-seq", :ns "cljs.core", :row 1203} {:end-row 1203, :filename "cljs/core.cljs", :name "IndexedSeq", :ns "cljs.core", :row 1203} {:arglist-strs ["[x]"], :doc "Return true if x implements IIterable protocol.", :end-row 1208, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "iterable?", :ns "cljs.core", :row 1205} {:arglist-strs ["[x]"], :doc "Return true if x has a JavaScript iterator property", :end-row 1214, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js-iterable?", :ns "cljs.core", :row 1210} {:arglist-strs ["[value]"], :doc "Clone the supplied value which must implement ICloneable.", :end-row 1219, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "clone", :ns "cljs.core", :row 1216} {:arglist-strs ["[value]"], :doc "Return true if x implements ICloneable protocol.", :end-row 1224, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "cloneable?", :ns "cljs.core", :row 1221} {:end-row 1226, :filename "cljs/core.cljs", :name "es6-iterator-seq", :ns "cljs.core", :row 1226} {:arglist-strs ["[coll]"], :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :end-row 1253, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seq", :ns "cljs.core", :row 1228} {:arglist-strs ["[coll]"], :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :end-row 1264, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "first", :ns "cljs.core", :row 1255} {:arglist-strs ["[coll]"], :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :end-row 1277, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "rest", :ns "cljs.core", :row 1266} {:arglist-strs ["[coll]"], :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :end-row 1286, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "next", :ns "cljs.core", :row 1279} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :end-row 1304, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "=", :ns "cljs.core", :row 1288} {:end-row 1314, :filename "cljs/core.cljs", :name "ES6Iterator", :ns "cljs.core", :row 1307} {:arglist-strs ["[s]"], :end-row 1314, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->ES6Iterator", :ns "cljs.core", :row 1307} {:arglist-strs ["[coll]"], :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll.", :end-row 1319, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "es6-iterator", :ns "cljs.core", :row 1316} {:end-row 1329, :filename "cljs/core.cljs", :name "ES6IteratorSeq", :ns "cljs.core", :row 1321} {:arglist-strs ["[value iter _rest]"], :end-row 1329, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->ES6IteratorSeq", :ns "cljs.core", :row 1321} {:arglist-strs ["[iter]"], :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.", :end-row 1337, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "es6-iterator-seq", :ns "cljs.core", :row 1331} {:arglist-strs ["[hash-basis count]"], :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :end-row 1351, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "mix-collection-hash", :ns "cljs.core", :row 1341} {:arglist-strs ["[coll]"], :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :end-row 1362, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-ordered-coll", :ns "cljs.core", :row 1353} {:end-row 1365, :filename "cljs/core.cljs", :name "empty-ordered-hash", :ns "cljs.core", :private true, :row 1364} {:arglist-strs ["[coll]"], :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :end-row 1377, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-unordered-coll", :ns "cljs.core", :row 1367} {:end-row 1380, :filename "cljs/core.cljs", :name "empty-unordered-hash", :ns "cljs.core", :private true, :row 1379} {:end-row 1383, :filename "cljs/core.cljs", :name "hash-map", :ns "cljs.core", :row 1383} {:end-row 1383, :filename "cljs/core.cljs", :name "list", :ns "cljs.core", :row 1383} {:end-row 1383, :filename "cljs/core.cljs", :name "equiv-sequential", :ns "cljs.core", :row 1383} {:end-row 1406, :filename "cljs/core.cljs", :name "Inst", :ns "cljs.core", :row 1405} {:arglist-strs ["[inst]"], :end-row 1406, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "inst-ms*", :ns "cljs.core", :row 1406} {:arglist-strs ["[inst]"], :doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", :end-row 1415, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "inst-ms", :ns "cljs.core", :row 1412} {:arglist-strs ["[x]"], :doc "Return true if x satisfies Inst", :end-row 1420, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "inst?", :ns "cljs.core", :row 1417} {:end-row 1426, :filename "cljs/core.cljs", :name "with-meta", :ns "cljs.core", :row 1426} {:arglist-strs ["[x]"], :doc "Returns a number one greater than num.", :end-row 1441, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "inc", :ns "cljs.core", :row 1439} {:end-row 1443, :filename "cljs/core.cljs", :name "deref", :ns "cljs.core", :row 1443} {:end-row 1447, :filename "cljs/core.cljs", :name "Reduced", :ns "cljs.core", :row 1445} {:arglist-strs ["[val]"], :end-row 1447, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Reduced", :ns "cljs.core", :row 1445} {:arglist-strs ["[x]"], :doc "Wraps x in a way such that a reduce will terminate with the value x", :end-row 1452, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reduced", :ns "cljs.core", :row 1449} {:arglist-strs ["[r]"], :doc "Returns true if x is the result of a call to reduced", :end-row 1457, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reduced?", :ns "cljs.core", :row 1454} {:arglist-strs ["[x]"], :doc "If x is already reduced?, returns it, else returns (reduced x)", :end-row 1462, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ensure-reduced", :ns "cljs.core", :row 1459} {:arglist-strs ["[x]"], :doc "If x is reduced?, returns (deref x), else returns x", :end-row 1467, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unreduced", :ns "cljs.core", :row 1464} {:arglist-strs ["[o]"], :doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?.", :end-row 1477, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "deref", :ns "cljs.core", :row 1471} {:fixed-arities #{3 2}, :end-row 1501, :private true, :ns "cljs.core", :name "ci-reduce", :filename "cljs/core.cljs", :arglist-strs ["[cicoll f]" "[cicoll f val]"], :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :row 1479} {:arglist-strs ["[arr f]" "[arr f val]" "[arr f val idx]"], :end-row 1532, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "array-reduce", :ns "cljs.core", :private true, :row 1503} {:end-row 1534, :filename "cljs/core.cljs", :name "hash-coll", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "cons", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "drop", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "count", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "nth", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "RSeq", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "List", :ns "cljs.core", :row 1534} {:arglist-strs ["[x]"], :doc "Returns true if coll implements count in constant time", :end-row 1538, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "counted?", :ns "cljs.core", :row 1536} {:arglist-strs ["[x]"], :doc "Returns true if coll implements nth in constant time", :end-row 1542, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "indexed?", :ns "cljs.core", :row 1540} {:arglist-strs ["[coll x]" "[coll x start]"], :end-row 1559, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-indexOf", :ns "cljs.core", :private true, :row 1544} {:arglist-strs ["[coll x]" "[coll x start]"], :end-row 1576, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-lastIndexOf", :ns "cljs.core", :private true, :row 1561} {:end-row 1585, :filename "cljs/core.cljs", :name "IndexedSeqIterator", :ns "cljs.core", :row 1578} {:arglist-strs ["[arr i]"], :end-row 1585, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->IndexedSeqIterator", :ns "cljs.core", :row 1578} {:end-row 1673, :filename "cljs/core.cljs", :name "IndexedSeq", :ns "cljs.core", :row 1587} {:arglist-strs ["[arr i meta]"], :end-row 1673, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->IndexedSeq", :ns "cljs.core", :row 1587} {:arglist-strs ["[prim]" "[prim i]"], :doc "Create seq from a primitive JavaScript Array-like.", :end-row 1683, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "prim-seq", :ns "cljs.core", :row 1677} {:arglist-strs ["[array]" "[array i]"], :doc "Create a seq from a JavaScript array.", :end-row 1690, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "array-seq", :ns "cljs.core", :row 1685} {:end-row 1692, :filename "cljs/core.cljs", :name "with-meta", :ns "cljs.core", :row 1692} {:end-row 1692, :filename "cljs/core.cljs", :name "seq-reduce", :ns "cljs.core", :row 1692} {:end-row 1755, :filename "cljs/core.cljs", :name "RSeq", :ns "cljs.core", :row 1694} {:arglist-strs ["[ci i meta]"], :end-row 1755, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->RSeq", :ns "cljs.core", :row 1694} {:arglist-strs ["[coll]"], :doc "Same as (first (next x))", :end-row 1762, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "second", :ns "cljs.core", :row 1759} {:arglist-strs ["[coll]"], :doc "Same as (first (first x))", :end-row 1767, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ffirst", :ns "cljs.core", :row 1764} {:arglist-strs ["[coll]"], :doc "Same as (next (first x))", :end-row 1772, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "nfirst", :ns "cljs.core", :row 1769} {:arglist-strs ["[coll]"], :doc "Same as (first (next x))", :end-row 1777, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "fnext", :ns "cljs.core", :row 1774} {:arglist-strs ["[coll]"], :doc "Same as (next (next x))", :end-row 1782, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "nnext", :ns "cljs.core", :row 1779} {:arglist-strs ["[s]"], :doc "Return the last item in coll, in linear time", :end-row 1790, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "last", :ns "cljs.core", :row 1784} {:arglist-strs ["[]" "[coll]" "[coll x]" "[coll x & xs]"], :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).\n  (conj coll) returns coll. (conj) returns [].\n  The 'addition' may happen at different 'places' depending\n  on the concrete type.", :end-row 1811, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "conj", :ns "cljs.core", :row 1796} {:arglist-strs ["[coll]"], :doc "Returns an empty collection of the same category as coll, or nil", :end-row 1824, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "empty", :ns "cljs.core", :row 1813} {:arglist-strs ["[coll]"], :end-row 1830, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "accumulating-seq-count", :ns "cljs.core", :private true, :row 1826} {:arglist-strs ["[coll]"], :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :end-row 1851, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "count", :ns "cljs.core", :row 1832} {:arglist-strs ["[coll n]" "[coll n not-found]"], :end-row 1871, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "linear-traversal-nth", :ns "cljs.core", :private true, :row 1853} {:arglist-strs ["[coll n]" "[coll n not-found]"], :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :end-row 1943, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "nth", :ns "cljs.core", :row 1873} {:arglist-strs ["[coll n]"], :doc "Returns the nth rest of coll, coll when n is 0.", :end-row 1951, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "nthrest", :ns "cljs.core", :row 1945} {:arglist-strs ["[o k]" "[o k not-found]"], :doc "Returns the value mapped to key, not-found or nil if key not present\n  in associative collection, set, string, array, or ILookup instance.", :end-row 1994, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "get", :ns "cljs.core", :row 1953} {:end-row 1996, :filename "cljs/core.cljs", :name "PersistentHashMap", :ns "cljs.core", :row 1996} {:end-row 1996, :filename "cljs/core.cljs", :name "PersistentArrayMap", :ns "cljs.core", :row 1996} {:end-row 1996, :filename "cljs/core.cljs", :name "MapEntry", :ns "cljs.core", :row 1996} {:arglist-strs ["[coll k v]" "[coll k v & kvs]"], :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index. Note - index must be <= (count vector).", :end-row 2013, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "assoc", :ns "cljs.core", :row 1998} {:arglist-strs ["[coll]" "[coll k]" "[coll k & ks]"], :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :end-row 2027, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "dissoc", :ns "cljs.core", :row 2015} {:arglist-strs ["[f]"], :doc "Return true if f is a JavaScript function or satisfies the Fn protocol.", :end-row 2032, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "fn?", :ns "cljs.core", :row 2029} {:end-row 2085, :filename "cljs/core.cljs", :name "MetaFn", :ns "cljs.core", :row 2034} {:arglist-strs ["[afn meta]"], :end-row 2085, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->MetaFn", :ns "cljs.core", :row 2034} {:arglist-strs ["[o meta]"], :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :end-row 2094, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "with-meta", :ns "cljs.core", :row 2087} {:arglist-strs ["[o]"], :doc "Returns the metadata of obj, returns nil if there is no metadata.", :end-row 2101, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "meta", :ns "cljs.core", :row 2096} {:arglist-strs ["[coll]"], :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :end-row 2108, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "peek", :ns "cljs.core", :row 2103} {:arglist-strs ["[coll]"], :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :end-row 2116, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pop", :ns "cljs.core", :row 2110} {:arglist-strs ["[coll]" "[coll k]" "[coll k & ks]"], :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :end-row 2130, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "disj", :ns "cljs.core", :row 2118} {:arglist-strs ["[coll]"], :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :end-row 2136, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "empty?", :ns "cljs.core", :row 2132} {:arglist-strs ["[x]"], :doc "Returns true if x satisfies ICollection", :end-row 2143, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "coll?", :ns "cljs.core", :row 2138} {:arglist-strs ["[x]"], :doc "Returns true if x satisfies ISet", :end-row 2150, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set?", :ns "cljs.core", :row 2145} {:arglist-strs ["[x]"], :doc "Returns true if coll implements IAssociative", :end-row 2154, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "associative?", :ns "cljs.core", :row 2152} {:arglist-strs ["[x]"], :doc "Returns true if coll implements IFind", :end-row 2158, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ifind?", :ns "cljs.core", :row 2156} {:arglist-strs ["[x]"], :doc "Returns true if coll satisfies ISequential", :end-row 2162, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "sequential?", :ns "cljs.core", :row 2160} {:arglist-strs ["[x]"], :doc "Returns true if coll satisfies ISorted", :end-row 2166, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "sorted?", :ns "cljs.core", :row 2164} {:arglist-strs ["[x]"], :doc "Returns true if coll satisfies IReduce", :end-row 2170, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reduceable?", :ns "cljs.core", :row 2168} {:arglist-strs ["[x]"], :doc "Return true if x satisfies IMap", :end-row 2177, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "map?", :ns "cljs.core", :row 2172} {:arglist-strs ["[x]"], :doc "Return true if x satisfies IRecord", :end-row 2182, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "record?", :ns "cljs.core", :row 2179} {:arglist-strs ["[x]"], :doc "Return true if x satisfies IVector", :end-row 2186, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "vector?", :ns "cljs.core", :row 2184} {:end-row 2188, :filename "cljs/core.cljs", :name "ChunkedCons", :ns "cljs.core", :row 2188} {:end-row 2188, :filename "cljs/core.cljs", :name "ChunkedSeq", :ns "cljs.core", :row 2188} {:arglist-strs ["[x]"], :doc "Return true if x satisfies IChunkedSeq.", :end-row 2192, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunked-seq?", :ns "cljs.core", :row 2190} {:arglist-strs ["[]" "[& keyvals]"], :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :end-row 2201, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "js-obj", :ns "cljs.core", :row 2195} {:arglist-strs ["[obj]"], :doc "Return the JavaScript keys for an object.", :end-row 2206, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js-keys", :ns "cljs.core", :row 2203} {:arglist-strs ["[obj key]"], :doc "Delete a property from a JavaScript object.\n  Returns true upon success, false otherwise.", :end-row 2212, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "js-delete", :ns "cljs.core", :row 2208} {:arglist-strs ["[from i to j len]"], :end-row 2220, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "array-copy", :ns "cljs.core", :private true, :row 2214} {:arglist-strs ["[from i to j len]"], :end-row 2228, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "array-copy-downward", :ns "cljs.core", :private true, :row 2222} {:end-row 2232, :filename "cljs/core.cljs", :name "lookup-sentinel", :ns "cljs.core", :private true, :row 2232} {:arglist-strs ["[x]"], :doc "Returns true if x is the value false, false otherwise.", :end-row 2236, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "false?", :ns "cljs.core", :row 2234} {:arglist-strs ["[x]"], :doc "Returns true if x is the value true, false otherwise.", :end-row 2240, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "true?", :ns "cljs.core", :row 2238} {:arglist-strs ["[x]"], :doc "Return true if x is a Boolean", :end-row 2244, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "boolean?", :ns "cljs.core", :row 2242} {:arglist-strs ["[x]"], :doc "Returns true if x identical to the JavaScript undefined value.", :end-row 2249, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "undefined?", :ns "cljs.core", :row 2246} {:arglist-strs ["[s]"], :doc "Return true if s satisfies ISeq", :end-row 2256, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seq?", :ns "cljs.core", :row 2251} {:arglist-strs ["[s]"], :doc "Return true if the seq function is supported for s", :end-row 2265, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seqable?", :ns "cljs.core", :row 2258} {:arglist-strs ["[x]"], :doc "Coerce to boolean", :end-row 2273, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "boolean", :ns "cljs.core", :row 2267} {:arglist-strs ["[f]"], :doc "Returns true if f returns true for fn? or satisfies IFn.", :end-row 2278, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ifn?", :ns "cljs.core", :row 2275} {:arglist-strs ["[n]"], :doc "Returns true if n is a JavaScript number with no decimal part.", :end-row 2286, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "integer?", :ns "cljs.core", :row 2280} {:doc "INTERNAL: do not use", :end-row 2290, :filename "cljs/core.cljs", :name "LongImpl", :ns "cljs.core", :row 2288} {:arglist-strs ["[x]"], :doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long.", :end-row 2298, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "int?", :ns "cljs.core", :row 2292} {:arglist-strs ["[x]"], :doc "Return true if x satisfies int? and is positive.", :end-row 2314, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pos-int?", :ns "cljs.core", :row 2300} {:arglist-strs ["[x]"], :doc "Return true if x satisfies int? and is negative.", :end-row 2328, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "neg-int?", :ns "cljs.core", :row 2316} {:arglist-strs ["[x]"], :doc "Return true if x satisfies int? and is a natural integer value.", :end-row 2343, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "nat-int?", :ns "cljs.core", :row 2330} {:arglist-strs ["[x]"], :doc "Returns true for JavaScript numbers, false otherwise.", :end-row 2348, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "float?", :ns "cljs.core", :row 2345} {:arglist-strs ["[x]"], :doc "Returns true for JavaScript numbers, false otherwise.", :end-row 2353, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "double?", :ns "cljs.core", :row 2350} {:arglist-strs ["[x]"], :doc "Returns true for Infinity and -Infinity values.", :end-row 2359, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "infinite?", :ns "cljs.core", :row 2355} {:arglist-strs ["[coll v]"], :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :end-row 2379, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "contains?", :ns "cljs.core", :row 2361} {:arglist-strs ["[coll k]"], :doc "Returns the map entry for key, or nil if key not present.", :end-row 2389, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "find", :ns "cljs.core", :row 2381} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns true if no two of the arguments are =", :end-row 2405, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "distinct?", :ns "cljs.core", :row 2391} {:arglist-strs ["[x y]"], :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :end-row 2433, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "compare", :ns "cljs.core", :row 2409} {:fixed-arities #{4 2}, :end-row 2449, :private true, :ns "cljs.core", :name "compare-indexed", :filename "cljs/core.cljs", :arglist-strs ["[xs ys]" "[xs ys len n]"], :doc "Compare indexed collection.", :row 2435} {:fixed-arities #{1}, :end-row 2463, :private true, :ns "cljs.core", :name "fn->comparator", :filename "cljs/core.cljs", :arglist-strs ["[f]"], :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator.", :row 2451} {:end-row 2465, :filename "cljs/core.cljs", :name "to-array", :ns "cljs.core", :row 2465} {:arglist-strs ["[coll]" "[comp coll]"], :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :end-row 2479, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "sort", :ns "cljs.core", :row 2467} {:arglist-strs ["[keyfn coll]" "[keyfn comp coll]"], :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :end-row 2489, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "sort-by", :ns "cljs.core", :row 2481} {:arglist-strs ["[f coll]" "[f val coll]"], :end-row 2504, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "seq-reduce", :ns "cljs.core", :private true, :row 2492} {:end-row 2506, :filename "cljs/core.cljs", :name "vec", :ns "cljs.core", :row 2506} {:arglist-strs ["[coll]"], :doc "Return a random permutation of coll", :end-row 2513, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "shuffle", :ns "cljs.core", :row 2508} {:arglist-strs ["[coll f]" "[coll f init]"], :end-row 2536, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "iter-reduce", :ns "cljs.core", :private true, :row 2515} {:arglist-strs ["[f coll]" "[f val coll]"], :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :end-row 2585, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "reduce", :ns "cljs.core", :row 2538} {:arglist-strs ["[f init coll]"], :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :end-row 2597, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "reduce-kv", :ns "cljs.core", :row 2587} {:arglist-strs ["[x]"], :doc "Returns its argument.", :end-row 2601, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "identity", :ns "cljs.core", :row 2599} {:arglist-strs ["[f]" "[f cf]"], :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :end-row 2612, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "completing", :ns "cljs.core", :row 2603} {:arglist-strs ["[xform f coll]" "[xform f init coll]"], :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :end-row 2627, :filename "cljs/core.cljs", :fixed-arities #{4 3}, :name "transduce", :ns "cljs.core", :row 2614} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the sum of nums. (+) returns 0.", :end-row 2638, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "+", :ns "cljs.core", :row 2632} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :end-row 2645, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "-", :ns "cljs.core", :row 2640} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the product of nums. (*) returns 1.", :end-row 2652, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "*", :ns "cljs.core", :row 2647} {:end-row 2654, :filename "cljs/core.cljs", :name "divide", :ns "cljs.core", :row 2654} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :end-row 2661, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "/", :ns "cljs.core", :row 2656} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :end-row 2673, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "<", :ns "cljs.core", :row 2663} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :end-row 2685, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "<=", :ns "cljs.core", :row 2675} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :end-row 2697, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name ">", :ns "cljs.core", :row 2687} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :end-row 2709, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name ">=", :ns "cljs.core", :row 2699} {:arglist-strs ["[x]"], :doc "Returns a number one less than num.", :end-row 2713, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "dec", :ns "cljs.core", :row 2711} {:arglist-strs ["[a]"], :doc "Returns the absolute value of a.", :end-row 2718, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "abs", :ns "cljs.core", :row 2715} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns the greatest of the nums.", :end-row 2725, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "max", :ns "cljs.core", :row 2720} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns the least of the nums.", :end-row 2732, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "min", :ns "cljs.core", :row 2727} {:arglist-strs ["[x]"], :end-row 2734, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "byte", :ns "cljs.core", :row 2734} {:arglist-strs ["[x]"], :doc "Coerce to char", :end-row 2742, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "char", :ns "cljs.core", :row 2736} {:arglist-strs ["[x]"], :end-row 2744, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "short", :ns "cljs.core", :row 2744} {:arglist-strs ["[x]"], :end-row 2745, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "float", :ns "cljs.core", :row 2745} {:arglist-strs ["[x]"], :end-row 2746, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "double", :ns "cljs.core", :row 2746} {:arglist-strs ["[x]"], :end-row 2748, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-byte", :ns "cljs.core", :row 2748} {:arglist-strs ["[x]"], :end-row 2749, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-char", :ns "cljs.core", :row 2749} {:arglist-strs ["[x]"], :end-row 2750, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-short", :ns "cljs.core", :row 2750} {:arglist-strs ["[x]"], :end-row 2751, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-float", :ns "cljs.core", :row 2751} {:arglist-strs ["[x]"], :end-row 2752, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-double", :ns "cljs.core", :row 2752} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the sum of nums. (+) returns 0.", :end-row 2759, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "unchecked-add", :ns "cljs.core", :row 2754} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the sum of nums. (+) returns 0.", :end-row 2766, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "unchecked-add-int", :ns "cljs.core", :row 2761} {:arglist-strs ["[x]"], :doc "Returns a number one less than x, an int.", :end-row 2771, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-dec", :ns "cljs.core", :row 2768} {:arglist-strs ["[x]"], :doc "Returns a number one less than x, an int.", :end-row 2776, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-dec-int", :ns "cljs.core", :row 2773} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :end-row 2783, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "unchecked-divide-int", :ns "cljs.core", :row 2778} {:arglist-strs ["[x]"], :end-row 2786, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-inc", :ns "cljs.core", :row 2785} {:arglist-strs ["[x]"], :end-row 2789, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-inc-int", :ns "cljs.core", :row 2788} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the product of nums. (*) returns 1.", :end-row 2796, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "unchecked-multiply", :ns "cljs.core", :row 2791} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the product of nums. (*) returns 1.", :end-row 2803, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "unchecked-multiply-int", :ns "cljs.core", :row 2798} {:arglist-strs ["[x]"], :end-row 2806, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-negate", :ns "cljs.core", :row 2805} {:arglist-strs ["[x]"], :end-row 2809, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-negate-int", :ns "cljs.core", :row 2808} {:end-row 2811, :filename "cljs/core.cljs", :name "mod", :ns "cljs.core", :row 2811} {:arglist-strs ["[x n]"], :end-row 2814, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "unchecked-remainder-int", :ns "cljs.core", :row 2813} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :end-row 2821, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "unchecked-subtract", :ns "cljs.core", :row 2816} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :end-row 2828, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "unchecked-subtract-int", :ns "cljs.core", :row 2823} {:arglist-strs ["[q]"], :end-row 2833, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "fix", :ns "cljs.core", :private true, :row 2830} {:arglist-strs ["[x]"], :doc "Coerce to int by stripping decimal places.", :end-row 2838, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "int", :ns "cljs.core", :row 2835} {:arglist-strs ["[x]"], :doc "Coerce to int by stripping decimal places.", :end-row 2843, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-int", :ns "cljs.core", :row 2840} {:arglist-strs ["[x]"], :doc "Coerce to long by stripping decimal places. Identical to `int'.", :end-row 2848, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "long", :ns "cljs.core", :row 2845} {:arglist-strs ["[x]"], :doc "Coerce to long by stripping decimal places. Identical to `int'.", :end-row 2853, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-long", :ns "cljs.core", :row 2850} {:arglist-strs ["[x]"], :end-row 2855, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "booleans", :ns "cljs.core", :row 2855} {:arglist-strs ["[x]"], :end-row 2856, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "bytes", :ns "cljs.core", :row 2856} {:arglist-strs ["[x]"], :end-row 2857, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chars", :ns "cljs.core", :row 2857} {:arglist-strs ["[x]"], :end-row 2858, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "shorts", :ns "cljs.core", :row 2858} {:arglist-strs ["[x]"], :end-row 2859, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ints", :ns "cljs.core", :row 2859} {:arglist-strs ["[x]"], :end-row 2860, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "floats", :ns "cljs.core", :row 2860} {:arglist-strs ["[x]"], :end-row 2861, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "doubles", :ns "cljs.core", :row 2861} {:arglist-strs ["[x]"], :end-row 2862, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "longs", :ns "cljs.core", :row 2862} {:arglist-strs ["[n d]"], :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :end-row 2867, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "js-mod", :ns "cljs.core", :row 2864} {:arglist-strs ["[n d]"], :doc "Modulus of num and div. Truncates toward negative infinity.", :end-row 2872, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "mod", :ns "cljs.core", :row 2869} {:arglist-strs ["[n d]"], :doc "quot[ient] of dividing numerator by denominator.", :end-row 2878, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "quot", :ns "cljs.core", :row 2874} {:arglist-strs ["[n d]"], :doc "remainder of dividing numerator by denominator.", :end-row 2884, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "rem", :ns "cljs.core", :row 2880} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise exclusive or", :end-row 2890, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-xor", :ns "cljs.core", :row 2886} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise and", :end-row 2896, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-and", :ns "cljs.core", :row 2892} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise or", :end-row 2902, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-or", :ns "cljs.core", :row 2898} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise and with complement", :end-row 2908, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-and-not", :ns "cljs.core", :row 2904} {:arglist-strs ["[x n]"], :doc "Clear bit at index n", :end-row 2913, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-clear", :ns "cljs.core", :row 2910} {:arglist-strs ["[x n]"], :doc "Flip bit at index n", :end-row 2918, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-flip", :ns "cljs.core", :row 2915} {:arglist-strs ["[x]"], :doc "Bitwise complement", :end-row 2922, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "bit-not", :ns "cljs.core", :row 2920} {:arglist-strs ["[x n]"], :doc "Set bit at index n", :end-row 2927, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-set", :ns "cljs.core", :row 2924} {:arglist-strs ["[x n]"], :doc "Test bit at index n", :end-row 2932, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-test", :ns "cljs.core", :row 2929} {:arglist-strs ["[x n]"], :doc "Bitwise shift left", :end-row 2936, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-shift-left", :ns "cljs.core", :row 2934} {:arglist-strs ["[x n]"], :doc "Bitwise shift right", :end-row 2940, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-shift-right", :ns "cljs.core", :row 2938} {:arglist-strs ["[x n]"], :doc "DEPRECATED: Bitwise shift right with zero fill", :end-row 2944, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-shift-right-zero-fill", :ns "cljs.core", :row 2942} {:arglist-strs ["[x n]"], :doc "Bitwise shift right with zero fill", :end-row 2948, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "unsigned-bit-shift-right", :ns "cljs.core", :row 2946} {:arglist-strs ["[v]"], :doc "Counts the number of bits set in n", :end-row 2955, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "bit-count", :ns "cljs.core", :row 2950} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :end-row 2968, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "==", :ns "cljs.core", :row 2957} {:arglist-strs ["[x]"], :doc "Returns true if num is greater than zero, else false", :end-row 2972, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pos?", :ns "cljs.core", :row 2970} {:arglist-strs ["[x]"], :doc "Returns true if num is zero, else false", :end-row 2977, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "zero?", :ns "cljs.core", :row 2974} {:arglist-strs ["[x]"], :doc "Returns true if num is less than zero, else false", :end-row 2981, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "neg?", :ns "cljs.core", :row 2979} {:arglist-strs ["[coll n]"], :doc "Returns the nth next of coll, (seq coll) when n is 0.", :end-row 2991, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "nthnext", :ns "cljs.core", :row 2985} {:arglist-strs ["[]" "[x]" "[x & ys]"], :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :end-row 3007, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "str", :ns "cljs.core", :row 2995} {:arglist-strs ["[s start]" "[s start end]"], :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :end-row 3013, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "subs", :ns "cljs.core", :row 3009} {:end-row 3015, :filename "cljs/core.cljs", :name "map", :ns "cljs.core", :row 3015} {:end-row 3015, :filename "cljs/core.cljs", :name "name", :ns "cljs.core", :row 3015} {:fixed-arities #{2}, :end-row 3030, :private true, :ns "cljs.core", :name "equiv-sequential", :filename "cljs/core.cljs", :arglist-strs ["[x y]"], :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false.", :row 3017} {:arglist-strs ["[coll]"], :end-row 3038, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-coll", :ns "cljs.core", :private true, :row 3032} {:end-row 3040, :filename "cljs/core.cljs", :name "key", :ns "cljs.core", :row 3040} {:end-row 3040, :filename "cljs/core.cljs", :name "val", :ns "cljs.core", :row 3040} {:arglist-strs ["[m]"], :end-row 3050, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-imap", :ns "cljs.core", :private true, :row 3042} {:arglist-strs ["[s]"], :end-row 3059, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-iset", :ns "cljs.core", :private true, :row 3052} {:end-row 3061, :filename "cljs/core.cljs", :name "name", :ns "cljs.core", :row 3061} {:end-row 3061, :filename "cljs/core.cljs", :name "chunk-first", :ns "cljs.core", :row 3061} {:end-row 3061, :filename "cljs/core.cljs", :name "chunk-rest", :ns "cljs.core", :row 3061} {:fixed-arities #{2}, :end-row 3072, :private true, :ns "cljs.core", :name "extend-object!", :filename "cljs/core.cljs", :arglist-strs ["[obj fn-map]"], :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached.", :row 3063} {:end-row 3143, :filename "cljs/core.cljs", :name "List", :ns "cljs.core", :row 3075} {:arglist-strs ["[meta first rest count __hash]"], :end-row 3143, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->List", :ns "cljs.core", :row 3075} {:arglist-strs ["[x]"], :doc "Returns true if x implements IList", :end-row 3148, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "list?", :ns "cljs.core", :row 3145} {:end-row 3217, :filename "cljs/core.cljs", :name "EmptyList", :ns "cljs.core", :row 3152} {:arglist-strs ["[meta]"], :end-row 3217, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->EmptyList", :ns "cljs.core", :row 3152} {:arglist-strs ["[coll]"], :doc "Returns true if coll satisfies? IReversible.", :end-row 3226, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reversible?", :ns "cljs.core", :row 3223} {:arglist-strs ["[rev]"], :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :end-row 3232, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "rseq", :ns "cljs.core", :row 3228} {:arglist-strs ["[coll]"], :doc "Returns a seq of the items in coll in reverse order. Not lazy.", :end-row 3239, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reverse", :ns "cljs.core", :row 3234} {:arglist-strs ["[& xs]"], :doc "Creates a new list containing the items.", :end-row 3256, :filename "cljs/core.cljs", :name "list", :ns "cljs.core", :row 3241} {:end-row 3314, :filename "cljs/core.cljs", :name "Cons", :ns "cljs.core", :row 3258} {:arglist-strs ["[meta first rest __hash]"], :end-row 3314, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->Cons", :ns "cljs.core", :row 3258} {:arglist-strs ["[x coll]"], :doc "Returns a new seq where x is the first element and coll is the rest.", :end-row 3324, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "cons", :ns "cljs.core", :row 3318} {:arglist-strs ["[k]"], :end-row 3327, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-keyword", :ns "cljs.core", :row 3326} {:arglist-strs ["[a b]"], :end-row 3339, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "compare-keywords", :ns "cljs.core", :private true, :row 3329} {:end-row 3367, :filename "cljs/core.cljs", :name "Keyword", :ns "cljs.core", :row 3341} {:arglist-strs ["[ns name fqn _hash]"], :end-row 3367, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->Keyword", :ns "cljs.core", :row 3341} {:arglist-strs ["[x]"], :doc "Return true if x is a Keyword", :end-row 3372, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "keyword?", :ns "cljs.core", :row 3369} {:arglist-strs ["[x y]"], :doc "Efficient test to determine that two keywords are identical.", :end-row 3381, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "keyword-identical?", :ns "cljs.core", :row 3374} {:arglist-strs ["[x y]"], :doc "Efficient test to determine that two symbols are identical.", :end-row 3390, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "symbol-identical?", :ns "cljs.core", :row 3383} {:arglist-strs ["[x]"], :doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :end-row 3397, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "namespace", :ns "cljs.core", :row 3392} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol or keyword", :end-row 3401, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ident?", :ns "cljs.core", :row 3399} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol or keyword without a namespace", :end-row 3405, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "simple-ident?", :ns "cljs.core", :row 3403} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol or keyword with a namespace", :end-row 3409, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "qualified-ident?", :ns "cljs.core", :row 3407} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol without a namespace", :end-row 3413, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "simple-symbol?", :ns "cljs.core", :row 3411} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol with a namespace", :end-row 3417, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "qualified-symbol?", :ns "cljs.core", :row 3415} {:arglist-strs ["[x]"], :doc "Return true if x is a keyword without a namespace", :end-row 3421, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "simple-keyword?", :ns "cljs.core", :row 3419} {:arglist-strs ["[x]"], :doc "Return true if x is a keyword with a namespace", :end-row 3425, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "qualified-keyword?", :ns "cljs.core", :row 3423} {:arglist-strs ["[name]" "[ns name]"], :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :end-row 3449, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "keyword", :ns "cljs.core", :row 3427} {:end-row 3529, :filename "cljs/core.cljs", :name "LazySeq", :ns "cljs.core", :row 3452} {:arglist-strs ["[meta fn s __hash]"], :end-row 3529, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->LazySeq", :ns "cljs.core", :row 3452} {:end-row 3533, :filename "cljs/core.cljs", :name "ArrayChunk", :ns "cljs.core", :row 3533} {:end-row 3547, :filename "cljs/core.cljs", :name "ChunkBuffer", :ns "cljs.core", :row 3535} {:arglist-strs ["[buf end]"], :end-row 3547, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->ChunkBuffer", :ns "cljs.core", :row 3535} {:arglist-strs ["[capacity]"], :end-row 3550, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk-buffer", :ns "cljs.core", :row 3549} {:end-row 3574, :filename "cljs/core.cljs", :name "ArrayChunk", :ns "cljs.core", :row 3552} {:arglist-strs ["[arr off end]"], :end-row 3574, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->ArrayChunk", :ns "cljs.core", :row 3552} {:arglist-strs ["[arr]" "[arr off]" "[arr off end]"], :end-row 3582, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "array-chunk", :ns "cljs.core", :row 3576} {:end-row 3653, :filename "cljs/core.cljs", :name "ChunkedCons", :ns "cljs.core", :row 3584} {:arglist-strs ["[chunk more meta __hash]"], :end-row 3653, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->ChunkedCons", :ns "cljs.core", :row 3584} {:arglist-strs ["[chunk rest]"], :end-row 3660, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "chunk-cons", :ns "cljs.core", :row 3657} {:arglist-strs ["[b x]"], :end-row 3663, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "chunk-append", :ns "cljs.core", :row 3662} {:arglist-strs ["[b]"], :end-row 3666, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk", :ns "cljs.core", :row 3665} {:arglist-strs ["[s]"], :end-row 3669, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk-first", :ns "cljs.core", :row 3668} {:arglist-strs ["[s]"], :end-row 3672, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk-rest", :ns "cljs.core", :row 3671} {:arglist-strs ["[s]"], :end-row 3677, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk-next", :ns "cljs.core", :row 3674} {:arglist-strs ["[coll]"], :doc "Returns an array containing the contents of coll.", :end-row 3689, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "to-array", :ns "cljs.core", :row 3681} {:arglist-strs ["[coll]"], :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :end-row 3700, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "to-array-2d", :ns "cljs.core", :row 3691} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :end-row 3722, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "int-array", :ns "cljs.core", :row 3702} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :end-row 3744, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "long-array", :ns "cljs.core", :row 3724} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :end-row 3766, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "double-array", :ns "cljs.core", :row 3746} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :end-row 3788, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "object-array", :ns "cljs.core", :row 3768} {:arglist-strs ["[n coll]"], :doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :end-row 3800, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bounded-count", :ns "cljs.core", :row 3790} {:arglist-strs ["[arglist]"], :end-row 3809, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "spread", :ns "cljs.core", :row 3802} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & zs]"], :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :end-row 3834, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "concat", :ns "cljs.core", :row 3811} {:arglist-strs ["[args]" "[a args]" "[a b args]" "[a b c args]" "[a b c d & more]"], :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :end-row 3844, :filename "cljs/core.cljs", :fixed-arities #{1 4 3 2}, :name "list*", :ns "cljs.core", :row 3836} {:arglist-strs ["[coll]"], :doc "Returns a new, transient version of the collection, in constant time.", :end-row 3852, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "transient", :ns "cljs.core", :row 3849} {:arglist-strs ["[tcoll]"], :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :end-row 3859, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "persistent!", :ns "cljs.core", :row 3854} {:arglist-strs ["[]" "[tcoll]" "[tcoll val]" "[tcoll val & vals]"], :doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :end-row 3872, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "conj!", :ns "cljs.core", :row 3861} {:arglist-strs ["[tcoll key val]" "[tcoll key val & kvs]"], :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :end-row 3884, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "assoc!", :ns "cljs.core", :row 3874} {:arglist-strs ["[tcoll key]" "[tcoll key & ks]"], :doc "Returns a transient map that doesn't contain a mapping for key(s).", :end-row 3894, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "dissoc!", :ns "cljs.core", :row 3886} {:arglist-strs ["[tcoll]"], :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll", :end-row 3900, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pop!", :ns "cljs.core", :row 3896} {:arglist-strs ["[tcoll val]" "[tcoll val & vals]"], :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :end-row 3911, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "disj!", :ns "cljs.core", :row 3902} {:fixed-arities #{1}, :end-row 3926, :private true, :ns "cljs.core", :name "next*", :filename "cljs/core.cljs", :arglist-strs ["[coll]"], :doc "Internal. DO NOT USE! Next without the nil? check.", :row 3921} {:fixed-arities #{4 6 3 2 5}, :end-row 3960, :private true, :ns "cljs.core", :name "apply-to-simple", :filename "cljs/core.cljs", :arglist-strs ["[f args]" "[f a0 args]" "[f a0 a1 args]" "[f a0 a1 a2 args]" "[f a0 a1 a2 a3 args]"], :doc "Internal. DO NOT USE!\n  Assumes args was already called with seq beforehand!", :row 3928} {:arglist-strs ["[f args]" "[f x args]" "[f x y args]" "[f x y z args]" "[f a b c d & args]"], :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :end-row 4008, :filename "cljs/core.cljs", :fixed-arities #{4 3 2 5}, :name "apply", :ns "cljs.core", :row 3962} {:arglist-strs ["[gmap]"], :end-row 4021, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "--destructure-map", :ns "cljs.core", :row 4014} {:arglist-strs ["[obj f]" "[obj f a]" "[obj f a b]" "[obj f a b c]" "[obj f a b c d]" "[obj f a b c d & args]"], :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :end-row 4037, :filename "cljs/core.cljs", :fixed-arities #{4 6 3 2 5}, :name "vary-meta", :ns "cljs.core", :row 4023} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Same as (not (= obj1 obj2))", :end-row 4044, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "not=", :ns "cljs.core", :row 4039} {:arglist-strs ["[coll]"], :doc "If coll is empty, returns nil, else coll", :end-row 4048, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "not-empty", :ns "cljs.core", :row 4046} {:arglist-strs ["[]"], :end-row 4055, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "nil-iter", :ns "cljs.core", :row 4050} {:end-row 4064, :filename "cljs/core.cljs", :name "StringIter", :ns "cljs.core", :row 4057} {:arglist-strs ["[s i]"], :end-row 4064, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->StringIter", :ns "cljs.core", :row 4057} {:arglist-strs ["[x]"], :end-row 4067, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "string-iter", :ns "cljs.core", :row 4066} {:end-row 4076, :filename "cljs/core.cljs", :name "ArrayIter", :ns "cljs.core", :row 4069} {:arglist-strs ["[arr i]"], :end-row 4076, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->ArrayIter", :ns "cljs.core", :row 4069} {:arglist-strs ["[x]"], :end-row 4079, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "array-iter", :ns "cljs.core", :row 4078} {:end-row 4081, :filename "cljs/core.cljs", :name "INIT", :ns "cljs.core", :row 4081} {:end-row 4082, :filename "cljs/core.cljs", :name "START", :ns "cljs.core", :row 4082} {:end-row 4100, :filename "cljs/core.cljs", :name "SeqIter", :ns "cljs.core", :row 4084} {:arglist-strs ["[_seq _next]"], :end-row 4100, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->SeqIter", :ns "cljs.core", :row 4084} {:arglist-strs ["[coll]"], :end-row 4103, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seq-iter", :ns "cljs.core", :row 4102} {:arglist-strs ["[coll]"], :end-row 4112, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "iter", :ns "cljs.core", :row 4105} {:end-row 4124, :filename "cljs/core.cljs", :name "Many", :ns "cljs.core", :row 4114} {:arglist-strs ["[vals]"], :end-row 4124, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Many", :ns "cljs.core", :row 4114} {:end-row 4126, :filename "cljs/core.cljs", :name "NONE", :ns "cljs.core", :private true, :row 4126} {:end-row 4145, :filename "cljs/core.cljs", :name "Single", :ns "cljs.core", :row 4128} {:arglist-strs ["[val]"], :end-row 4145, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Single", :ns "cljs.core", :row 4128} {:end-row 4156, :filename "cljs/core.cljs", :name "Empty", :ns "cljs.core", :row 4147} {:arglist-strs ["[]"], :end-row 4156, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "->Empty", :ns "cljs.core", :row 4147} {:end-row 4158, :filename "cljs/core.cljs", :name "EMPTY", :ns "cljs.core", :private true, :row 4158} {:end-row 4174, :filename "cljs/core.cljs", :name "MultiIterator", :ns "cljs.core", :row 4160} {:arglist-strs ["[iters]"], :end-row 4174, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->MultiIterator", :ns "cljs.core", :row 4160} {:arglist-strs ["[iter]"], :end-row 4185, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunkIteratorSeq", :ns "cljs.core", :private true, :row 4176} {:end-row 4222, :filename "cljs/core.cljs", :name "TransformerIterator", :ns "cljs.core", :row 4187} {:arglist-strs ["[buffer _next completed xf sourceIter multi]"], :end-row 4222, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->TransformerIterator", :ns "cljs.core", :row 4187} {:arglist-strs ["[xform sourceIter multi]"], :end-row 4236, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "transformer-iterator", :ns "cljs.core", :row 4226} {:arglist-strs ["[coll]" "[xform coll]" "[xform coll & colls]"], :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :end-row 4266, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "sequence", :ns "cljs.core", :row 4246} {:arglist-strs ["[pred coll]"], :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :end-row 4275, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "every?", :ns "cljs.core", :row 4268} {:arglist-strs ["[pred coll]"], :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :end-row 4280, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "not-every?", :ns "cljs.core", :row 4277} {:arglist-strs ["[pred coll]"], :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :end-row 4289, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "some", :ns "cljs.core", :row 4282} {:arglist-strs ["[pred coll]"], :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :end-row 4294, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "not-any?", :ns "cljs.core", :row 4291} {:arglist-strs ["[n]"], :doc "Returns true if n is even, throws an exception if n is not an integer", :end-row 4300, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "even?", :ns "cljs.core", :row 4296} {:arglist-strs ["[n]"], :doc "Returns true if n is odd, throws an exception if n is not an integer", :end-row 4304, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "odd?", :ns "cljs.core", :row 4302} {:arglist-strs ["[f]"], :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :end-row 4314, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "complement", :ns "cljs.core", :row 4306} {:arglist-strs ["[x]"], :doc "Returns a function that takes any number of arguments and returns x.", :end-row 4318, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "constantly", :ns "cljs.core", :row 4316} {:arglist-strs ["[]" "[f]" "[f g]" "[f g h]" "[f1 f2 f3 & fs]"], :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :end-row 4347, :filename "cljs/core.cljs", :fixed-arities #{0 1 3 2}, :name "comp", :ns "cljs.core", :row 4320} {:arglist-strs ["[f]" "[f arg1]" "[f arg1 arg2]" "[f arg1 arg2 arg3]" "[f arg1 arg2 arg3 & more]"], :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :end-row 4376, :filename "cljs/core.cljs", :fixed-arities #{1 4 3 2}, :name "partial", :ns "cljs.core", :row 4349} {:arglist-strs ["[f x]" "[f x y]" "[f x y z]"], :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :end-row 4399, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "fnil", :ns "cljs.core", :row 4378} {:end-row 4401, :filename "cljs/core.cljs", :name "volatile!", :ns "cljs.core", :row 4401} {:arglist-strs ["[f]" "[f coll]"], :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :end-row 4429, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "map-indexed", :ns "cljs.core", :row 4403} {:arglist-strs ["[f]" "[f coll]"], :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :end-row 4460, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "keep", :ns "cljs.core", :row 4431} {:end-row 4492, :filename "cljs/core.cljs", :name "Atom", :ns "cljs.core", :row 4465} {:arglist-strs ["[state meta validator watches]"], :end-row 4492, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->Atom", :ns "cljs.core", :row 4465} {:arglist-strs ["[x]" "[x & {:keys [meta validator]}]"], :doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :end-row 4509, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "atom", :ns "cljs.core", :row 4494} {:end-row 4511, :filename "cljs/core.cljs", :name "pr-str", :ns "cljs.core", :row 4511} {:arglist-strs ["[a new-value]"], :doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value.", :end-row 4527, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "reset!", :ns "cljs.core", :row 4513} {:arglist-strs ["[a new-value]"], :doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :end-row 4542, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "reset-vals!", :ns "cljs.core", :row 4529} {:arglist-strs ["[a f]" "[a f x]" "[a f x y]" "[a f x y & more]"], :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :end-row 4564, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "swap!", :ns "cljs.core", :row 4544} {:arglist-strs ["[a f]" "[a f x]" "[a f x y]" "[a f x y & more]"], :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :end-row 4579, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "swap-vals!", :ns "cljs.core", :row 4566} {:arglist-strs ["[a oldval newval]"], :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :end-row 4588, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "compare-and-set!", :ns "cljs.core", :row 4581} {:arglist-strs ["[iref val]"], :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :end-row 4601, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "set-validator!", :ns "cljs.core", :row 4590} {:arglist-strs ["[iref]"], :doc "Gets the validator-fn for a var/ref/agent/atom.", :end-row 4606, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "get-validator", :ns "cljs.core", :row 4603} {:end-row 4614, :filename "cljs/core.cljs", :name "Volatile", :ns "cljs.core", :row 4608} {:arglist-strs ["[state]"], :end-row 4614, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Volatile", :ns "cljs.core", :row 4608} {:arglist-strs ["[val]"], :doc "Creates and returns a Volatile with an initial value of val.", :end-row 4619, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "volatile!", :ns "cljs.core", :row 4616} {:arglist-strs ["[x]"], :doc "Returns true if x is a volatile.", :end-row 4623, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "volatile?", :ns "cljs.core", :row 4621} {:arglist-strs ["[vol newval]"], :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :end-row 4628, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "vreset!", :ns "cljs.core", :row 4625} {:arglist-strs ["[f]" "[f coll]"], :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :end-row 4664, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "keep-indexed", :ns "cljs.core", :row 4630} {:arglist-strs ["[p]" "[p1 p2]" "[p1 p2 p3]" "[p1 p2 p3 & ps]"], :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :end-row 4703, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "every-pred", :ns "cljs.core", :row 4666} {:arglist-strs ["[p]" "[p1 p2]" "[p1 p2 p3]" "[p1 p2 p3 & ps]"], :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :end-row 4742, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "some-fn", :ns "cljs.core", :row 4705} {:arglist-strs ["[f]" "[f coll]" "[f c1 c2]" "[f c1 c2 c3]" "[f c1 c2 c3 & colls]"], :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :end-row 4789, :filename "cljs/core.cljs", :fixed-arities #{1 4 3 2}, :name "map", :ns "cljs.core", :row 4744} {:arglist-strs ["[n]" "[n coll]"], :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :end-row 4816, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "take", :ns "cljs.core", :row 4791} {:arglist-strs ["[n]" "[n coll]"], :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :end-row 4841, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "drop", :ns "cljs.core", :row 4818} {:arglist-strs ["[s]" "[n s]"], :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :end-row 4846, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "drop-last", :ns "cljs.core", :row 4843} {:arglist-strs ["[n coll]"], :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :end-row 4855, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "take-last", :ns "cljs.core", :row 4848} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :end-row 4880, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "drop-while", :ns "cljs.core", :row 4857} {:end-row 4941, :filename "cljs/core.cljs", :name "Cycle", :ns "cljs.core", :row 4882} {:arglist-strs ["[meta all prev current _next]"], :end-row 4941, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Cycle", :ns "cljs.core", :row 4882} {:arglist-strs ["[coll]"], :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :end-row 4947, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "cycle", :ns "cljs.core", :row 4943} {:arglist-strs ["[n coll]"], :doc "Returns a vector of [(take n coll) (drop n coll)]", :end-row 4952, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "split-at", :ns "cljs.core", :row 4949} {:end-row 5049, :filename "cljs/core.cljs", :name "Repeat", :ns "cljs.core", :row 4954} {:arglist-strs ["[meta count val next __hash]"], :end-row 5049, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Repeat", :ns "cljs.core", :row 4954} {:arglist-strs ["[x]" "[n x]"], :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :end-row 5056, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "repeat", :ns "cljs.core", :row 5051} {:arglist-strs ["[n x]"], :doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs.", :end-row 5061, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "replicate", :ns "cljs.core", :row 5058} {:arglist-strs ["[f]" "[n f]"], :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :end-row 5068, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "repeatedly", :ns "cljs.core", :row 5063} {:end-row 5070, :filename "cljs/core.cljs", :name "UNREALIZED-SEED", :ns "cljs.core", :private true, :row 5070} {:end-row 5129, :filename "cljs/core.cljs", :name "Iterate", :ns "cljs.core", :row 5072} {:arglist-strs ["[meta f prev-seed seed next]"], :end-row 5129, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Iterate", :ns "cljs.core", :row 5072} {:arglist-strs ["[f x]"], :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :end-row 5134, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "iterate", :ns "cljs.core", :row 5131} {:arglist-strs ["[]" "[c1]" "[c1 c2]" "[c1 c2 & colls]"], :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :end-row 5150, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "interleave", :ns "cljs.core", :row 5136} {:arglist-strs ["[sep]" "[sep coll]"], :doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :end-row 5170, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "interpose", :ns "cljs.core", :row 5152} {:fixed-arities #{1}, :end-row 5184, :private true, :ns "cljs.core", :name "flatten1", :filename "cljs/core.cljs", :arglist-strs ["[colls]"], :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection", :row 5174} {:end-row 5186, :filename "cljs/core.cljs", :name "cat", :ns "cljs.core", :row 5186} {:arglist-strs ["[f]" "[f & colls]"], :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :end-row 5196, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "mapcat", :ns "cljs.core", :row 5188} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-row 5225, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "filter", :ns "cljs.core", :row 5198} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-row 5233, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "remove", :ns "cljs.core", :row 5227} {:arglist-strs ["[branch? children root]"], :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree.", :end-row 5248, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "tree-seq", :ns "cljs.core", :row 5235} {:arglist-strs ["[x]"], :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :end-row 5256, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "flatten", :ns "cljs.core", :row 5250} {:arglist-strs ["[]" "[to]" "[to from]" "[to xform from]"], :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :end-row 5276, :filename "cljs/core.cljs", :fixed-arities #{0 1 3 2}, :name "into", :ns "cljs.core", :row 5258} {:arglist-strs ["[f coll]" "[f c1 c2]" "[f c1 c2 c3]" "[f c1 c2 c3 & colls]"], :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :end-row 5292, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "mapv", :ns "cljs.core", :row 5278} {:arglist-strs ["[pred coll]"], :doc "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.", :end-row 5301, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "filterv", :ns "cljs.core", :row 5294} {:arglist-strs ["[n coll]" "[n step coll]" "[n step pad coll]"], :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :end-row 5323, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "partition", :ns "cljs.core", :row 5303} {:arglist-strs ["[m ks]" "[m ks not-found]"], :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :end-row 5342, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "get-in", :ns "cljs.core", :row 5325} {:arglist-strs ["[m [k & ks] v]"], :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :end-row 5351, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "assoc-in", :ns "cljs.core", :row 5344} {:arglist-strs ["[m [k & ks] f]" "[m [k & ks] f a]" "[m [k & ks] f a b]" "[m [k & ks] f a b c]" "[m [k & ks] f a b c & args]"], :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :end-row 5378, :filename "cljs/core.cljs", :fixed-arities #{4 6 3 5}, :name "update-in", :ns "cljs.core", :row 5353} {:arglist-strs ["[m k f]" "[m k f x]" "[m k f x y]" "[m k f x y z]" "[m k f x y z & more]"], :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :end-row 5394, :filename "cljs/core.cljs", :fixed-arities #{4 6 3 5}, :name "update", :ns "cljs.core", :row 5380} {:end-row 5398, :filename "cljs/core.cljs", :name "VectorNode", :ns "cljs.core", :row 5398} {:arglist-strs ["[edit arr]"], :end-row 5398, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->VectorNode", :ns "cljs.core", :row 5398} {:arglist-strs ["[edit]"], :end-row 5401, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pv-fresh-node", :ns "cljs.core", :private true, :row 5400} {:arglist-strs ["[node idx]"], :end-row 5404, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "pv-aget", :ns "cljs.core", :private true, :row 5403} {:arglist-strs ["[node idx val]"], :end-row 5407, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pv-aset", :ns "cljs.core", :private true, :row 5406} {:arglist-strs ["[node]"], :end-row 5410, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pv-clone-node", :ns "cljs.core", :private true, :row 5409} {:arglist-strs ["[pv]"], :end-row 5416, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tail-off", :ns "cljs.core", :private true, :row 5412} {:arglist-strs ["[edit level node]"], :end-row 5426, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "new-path", :ns "cljs.core", :private true, :row 5418} {:arglist-strs ["[pv level parent tailnode]"], :end-row 5442, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "push-tail", :ns "cljs.core", :private true, :row 5428} {:arglist-strs ["[i cnt]"], :end-row 5445, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "vector-index-out-of-bounds", :ns "cljs.core", :private true, :row 5444} {:arglist-strs ["[pv]"], :end-row 5453, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "first-array-for-longvec", :ns "cljs.core", :private true, :row 5447} {:arglist-strs ["[pv i]"], :end-row 5464, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "unchecked-array-for", :ns "cljs.core", :private true, :row 5455} {:arglist-strs ["[pv i]"], :end-row 5469, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-for", :ns "cljs.core", :private true, :row 5466} {:arglist-strs ["[pv level node i val]"], :end-row 5479, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "do-assoc", :ns "cljs.core", :private true, :row 5471} {:arglist-strs ["[pv level node]"], :end-row 5493, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pop-tail", :ns "cljs.core", :private true, :row 5481} {:end-row 5505, :filename "cljs/core.cljs", :name "RangedIterator", :ns "cljs.core", :row 5495} {:arglist-strs ["[i base arr v start end]"], :end-row 5505, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->RangedIterator", :ns "cljs.core", :row 5495} {:arglist-strs ["[v start end]"], :end-row 5512, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "ranged-iterator", :ns "cljs.core", :row 5507} {:arglist-strs ["[pv f start end]" "[pv f init start end]"], :end-row 5528, :filename "cljs/core.cljs", :fixed-arities #{4 5}, :name "pv-reduce", :ns "cljs.core", :private true, :row 5514} {:end-row 5531, :filename "cljs/core.cljs", :name "tv-editable-root", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "tv-editable-tail", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "TransientVector", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "deref", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "pr-sequential-writer", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "pr-writer", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "chunked-seq", :ns "cljs.core", :row 5530} {:doc "Marker protocol", :end-row 5534, :filename "cljs/core.cljs", :name "APersistentVector", :ns "cljs.core", :row 5533} {:end-row 5731, :filename "cljs/core.cljs", :name "PersistentVector", :ns "cljs.core", :row 5536} {:arglist-strs ["[meta cnt shift root tail __hash]"], :end-row 5731, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->PersistentVector", :ns "cljs.core", :row 5536} {:end-row 5753, :filename "cljs/core.cljs", :name "map-entry?", :ns "cljs.core", :row 5753} {:arglist-strs ["[coll]"], :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.", :end-row 5773, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "vec", :ns "cljs.core", :row 5755} {:arglist-strs ["[& args]"], :doc "Creates a new vector containing the args.", :end-row 5780, :filename "cljs/core.cljs", :name "vector", :ns "cljs.core", :row 5775} {:end-row 5782, :filename "cljs/core.cljs", :name "subvec", :ns "cljs.core", :row 5782} {:end-row 5866, :filename "cljs/core.cljs", :name "ChunkedSeq", :ns "cljs.core", :row 5784} {:arglist-strs ["[vec node i off meta __hash]"], :end-row 5866, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->ChunkedSeq", :ns "cljs.core", :row 5784} {:arglist-strs ["[vec i off]" "[vec node i off]" "[vec node i off meta]"], :end-row 5874, :filename "cljs/core.cljs", :fixed-arities #{4 3 5}, :name "chunked-seq", :ns "cljs.core", :row 5870} {:end-row 5876, :filename "cljs/core.cljs", :name "build-subvec", :ns "cljs.core", :row 5876} {:end-row 6015, :filename "cljs/core.cljs", :name "Subvec", :ns "cljs.core", :row 5878} {:arglist-strs ["[meta v start end __hash]"], :end-row 6015, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Subvec", :ns "cljs.core", :row 5878} {:arglist-strs ["[meta v start end __hash]"], :end-row 6029, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "build-subvec", :ns "cljs.core", :private true, :row 6019} {:arglist-strs ["[v start]" "[v start end]"], :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :end-row 6041, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "subvec", :ns "cljs.core", :row 6031} {:arglist-strs ["[edit node]"], :end-row 6046, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "tv-ensure-editable", :ns "cljs.core", :private true, :row 6043} {:arglist-strs ["[node]"], :end-row 6049, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tv-editable-root", :ns "cljs.core", :private true, :row 6048} {:arglist-strs ["[tl]"], :end-row 6054, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tv-editable-tail", :ns "cljs.core", :private true, :row 6051} {:arglist-strs ["[tv level parent tail-node]"], :end-row 6066, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "tv-push-tail", :ns "cljs.core", :private true, :row 6056} {:arglist-strs ["[tv level node]"], :end-row 6080, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "tv-pop-tail", :ns "cljs.core", :private true, :row 6068} {:arglist-strs ["[tv i]"], :end-row 6096, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "unchecked-editable-array-for", :ns "cljs.core", :private true, :row 6082} {:end-row 6229, :filename "cljs/core.cljs", :name "TransientVector", :ns "cljs.core", :row 6098} {:arglist-strs ["[cnt shift root tail]"], :end-row 6229, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->TransientVector", :ns "cljs.core", :row 6098} {:end-row 6246, :filename "cljs/core.cljs", :name "PersistentQueueIter", :ns "cljs.core", :row 6233} {:arglist-strs ["[fseq riter]"], :end-row 6246, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->PersistentQueueIter", :ns "cljs.core", :row 6233} {:end-row 6302, :filename "cljs/core.cljs", :name "PersistentQueueSeq", :ns "cljs.core", :row 6248} {:arglist-strs ["[meta front rear __hash]"], :end-row 6302, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->PersistentQueueSeq", :ns "cljs.core", :row 6248} {:end-row 6373, :filename "cljs/core.cljs", :name "PersistentQueue", :ns "cljs.core", :row 6306} {:arglist-strs ["[meta count front rear __hash]"], :end-row 6373, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->PersistentQueue", :ns "cljs.core", :row 6306} {:end-row 6384, :filename "cljs/core.cljs", :name "NeverEquiv", :ns "cljs.core", :row 6379} {:arglist-strs ["[]"], :end-row 6384, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "->NeverEquiv", :ns "cljs.core", :row 6379} {:end-row 6386, :filename "cljs/core.cljs", :name "never-equiv", :ns "cljs.core", :private true, :row 6386} {:arglist-strs ["[x y]"], :doc "Test map equivalence. Returns true if x equals y, otherwise returns false.", :end-row 6405, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "equiv-map", :ns "cljs.core", :row 6388} {:arglist-strs ["[incr k array]"], :end-row 6414, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "scan-array", :ns "cljs.core", :private true, :row 6408} {:arglist-strs ["[a b]"], :end-row 6428, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "obj-map-compare-keys", :ns "cljs.core", :private true, :row 6422} {:arglist-strs ["[m k v]"], :end-row 6440, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "obj-map->hash-map", :ns "cljs.core", :private true, :row 6430} {:arglist-strs ["[obj ks]"], :end-row 6452, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "obj-clone", :ns "cljs.core", :private true, :row 6444} {:end-row 6565, :filename "cljs/core.cljs", :name "ObjMap", :ns "cljs.core", :row 6454} {:arglist-strs ["[meta keys strobj update-count __hash]"], :end-row 6565, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->ObjMap", :ns "cljs.core", :row 6454} {:end-row 6584, :filename "cljs/core.cljs", :name "RecordIter", :ns "cljs.core", :row 6574} {:arglist-strs ["[i record base-count fields ext-map-iter]"], :end-row 6584, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->RecordIter", :ns "cljs.core", :row 6574} {:end-row 6594, :filename "cljs/core.cljs", :name "ES6EntriesIterator", :ns "cljs.core", :row 6587} {:arglist-strs ["[s]"], :end-row 6594, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->ES6EntriesIterator", :ns "cljs.core", :row 6587} {:arglist-strs ["[coll]"], :end-row 6597, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "es6-entries-iterator", :ns "cljs.core", :row 6596} {:end-row 6607, :filename "cljs/core.cljs", :name "ES6SetEntriesIterator", :ns "cljs.core", :row 6600} {:arglist-strs ["[s]"], :end-row 6607, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->ES6SetEntriesIterator", :ns "cljs.core", :row 6600} {:arglist-strs ["[coll]"], :end-row 6610, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "es6-set-entries-iterator", :ns "cljs.core", :row 6609} {:arglist-strs ["[arr]"], :end-row 6620, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "array-index-of-nil?", :ns "cljs.core", :private true, :row 6614} {:arglist-strs ["[arr k]"], :end-row 6630, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of-keyword?", :ns "cljs.core", :private true, :row 6622} {:arglist-strs ["[arr k]"], :end-row 6640, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of-symbol?", :ns "cljs.core", :private true, :row 6632} {:arglist-strs ["[arr k]"], :end-row 6648, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of-identical?", :ns "cljs.core", :private true, :row 6642} {:arglist-strs ["[arr k]"], :end-row 6656, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of-equiv?", :ns "cljs.core", :private true, :row 6650} {:arglist-strs ["[arr k]"], :end-row 6670, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of", :ns "cljs.core", :row 6658} {:arglist-strs ["[m k]"], :end-row 6673, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-map-index-of", :ns "cljs.core", :private true, :row 6672} {:arglist-strs ["[arr k v]"], :end-row 6684, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "array-extend-kv", :ns "cljs.core", :private true, :row 6675} {:arglist-strs ["[m k v]"], :end-row 6687, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "array-map-extend-kv", :ns "cljs.core", :private true, :row 6686} {:end-row 6689, :filename "cljs/core.cljs", :name "TransientArrayMap", :ns "cljs.core", :row 6689} {:end-row 6784, :filename "cljs/core.cljs", :name "MapEntry", :ns "cljs.core", :row 6691} {:arglist-strs ["[key val __hash]"], :end-row 6784, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->MapEntry", :ns "cljs.core", :row 6691} {:arglist-strs ["[x]"], :doc "Returns true if x satisfies IMapEntry", :end-row 6789, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "map-entry?", :ns "cljs.core", :row 6786} {:end-row 6852, :filename "cljs/core.cljs", :name "PersistentArrayMapSeq", :ns "cljs.core", :row 6791} {:arglist-strs ["[arr i _meta]"], :end-row 6852, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->PersistentArrayMapSeq", :ns "cljs.core", :row 6791} {:arglist-strs ["[arr i _meta]"], :end-row 6858, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "persistent-array-map-seq", :ns "cljs.core", :row 6856} {:end-row 6860, :filename "cljs/core.cljs", :name "keys", :ns "cljs.core", :row 6860} {:end-row 6860, :filename "cljs/core.cljs", :name "vals", :ns "cljs.core", :row 6860} {:end-row 6869, :filename "cljs/core.cljs", :name "PersistentArrayMapIterator", :ns "cljs.core", :row 6862} {:arglist-strs ["[arr i cnt]"], :end-row 6869, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->PersistentArrayMapIterator", :ns "cljs.core", :row 6862} {:end-row 7036, :filename "cljs/core.cljs", :name "PersistentArrayMap", :ns "cljs.core", :row 6871} {:arglist-strs ["[meta cnt arr __hash]"], :end-row 7036, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->PersistentArrayMap", :ns "cljs.core", :row 6871} {:arglist-strs ["[key other]"], :end-row 7080, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "key-test", :ns "cljs.core", :row 7076} {:arglist-strs ["[arr]"], :end-row 7092, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pam-dupes?", :ns "cljs.core", :private true, :row 7082} {:arglist-strs ["[arr]"], :end-row 7104, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pam-new-size", :ns "cljs.core", :private true, :row 7094} {:arglist-strs ["[seed trailing]"], :end-row 7117, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "pam-grow-seed-array", :ns "cljs.core", :private true, :row 7106} {:end-row 7164, :filename "cljs/core.cljs", :name "array->transient-hash-map", :ns "cljs.core", :row 7164} {:end-row 7244, :filename "cljs/core.cljs", :name "TransientArrayMap", :ns "cljs.core", :row 7166} {:arglist-strs ["[editable? len arr]"], :end-row 7244, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->TransientArrayMap", :ns "cljs.core", :row 7166} {:end-row 7246, :filename "cljs/core.cljs", :name "TransientHashMap", :ns "cljs.core", :row 7246} {:arglist-strs ["[len arr]"], :end-row 7253, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array->transient-hash-map", :ns "cljs.core", :private true, :row 7248} {:end-row 7257, :filename "cljs/core.cljs", :name "Box", :ns "cljs.core", :row 7257} {:arglist-strs ["[val]"], :end-row 7257, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Box", :ns "cljs.core", :row 7257} {:end-row 7259, :filename "cljs/core.cljs", :name "create-inode-seq", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "create-array-node-seq", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "reset!", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "create-node", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "atom", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "deref", :ns "cljs.core", :row 7259} {:arglist-strs ["[hash shift]"], :end-row 7262, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "mask", :ns "cljs.core", :private true, :row 7261} {:arglist-strs ["[arr i a]" "[arr i a j b]"], :end-row 7271, :filename "cljs/core.cljs", :fixed-arities #{3 5}, :name "clone-and-set", :ns "cljs.core", :private true, :row 7264} {:arglist-strs ["[arr i]"], :end-row 7277, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "remove-pair", :ns "cljs.core", :private true, :row 7273} {:arglist-strs ["[bitmap bit]"], :end-row 7280, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bitmap-indexed-node-index", :ns "cljs.core", :private true, :row 7279} {:arglist-strs ["[hash shift]"], :end-row 7283, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bitpos", :ns "cljs.core", :private true, :row 7282} {:arglist-strs ["[inode edit i a]" "[inode edit i a j b]"], :end-row 7294, :filename "cljs/core.cljs", :fixed-arities #{4 6}, :name "edit-and-set", :ns "cljs.core", :private true, :row 7285} {:arglist-strs ["[arr f init]"], :end-row 7310, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "inode-kv-reduce", :ns "cljs.core", :private true, :row 7296} {:end-row 7312, :filename "cljs/core.cljs", :name "ArrayNode", :ns "cljs.core", :row 7312} {:end-row 7350, :filename "cljs/core.cljs", :name "NodeIterator", :ns "cljs.core", :row 7314} {:arglist-strs ["[arr i next-entry next-iter]"], :end-row 7350, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->NodeIterator", :ns "cljs.core", :row 7314} {:end-row 7552, :filename "cljs/core.cljs", :name "BitmapIndexedNode", :ns "cljs.core", :row 7352} {:arglist-strs ["[edit bitmap arr]"], :end-row 7552, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->BitmapIndexedNode", :ns "cljs.core", :row 7352} {:arglist-strs ["[array-node edit idx]"], :end-row 7567, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pack-array-node", :ns "cljs.core", :private true, :row 7556} {:end-row 7587, :filename "cljs/core.cljs", :name "ArrayNodeIterator", :ns "cljs.core", :row 7569} {:arglist-strs ["[arr i next-iter]"], :end-row 7587, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->ArrayNodeIterator", :ns "cljs.core", :row 7569} {:end-row 7688, :filename "cljs/core.cljs", :name "ArrayNode", :ns "cljs.core", :row 7589} {:arglist-strs ["[edit cnt arr]"], :end-row 7688, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->ArrayNode", :ns "cljs.core", :row 7589} {:arglist-strs ["[arr cnt key]"], :end-row 7697, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "hash-collision-node-find-index", :ns "cljs.core", :private true, :row 7690} {:end-row 7799, :filename "cljs/core.cljs", :name "HashCollisionNode", :ns "cljs.core", :row 7699} {:arglist-strs ["[edit collision-hash cnt arr]"], :end-row 7799, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->HashCollisionNode", :ns "cljs.core", :row 7699} {:arglist-strs ["[shift key1 val1 key2hash key2 val2]" "[edit shift key1 val1 key2hash key2 val2]"], :end-row 7817, :filename "cljs/core.cljs", :fixed-arities #{7 6}, :name "create-node", :ns "cljs.core", :private true, :row 7801} {:end-row 7879, :filename "cljs/core.cljs", :name "NodeSeq", :ns "cljs.core", :row 7819} {:arglist-strs ["[meta nodes i s __hash]"], :end-row 7879, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->NodeSeq", :ns "cljs.core", :row 7819} {:arglist-strs ["[nodes]" "[nodes i s]"], :end-row 7898, :filename "cljs/core.cljs", :fixed-arities #{1 3}, :name "create-inode-seq", :ns "cljs.core", :private true, :row 7883} {:end-row 7952, :filename "cljs/core.cljs", :name "ArrayNodeSeq", :ns "cljs.core", :row 7900} {:arglist-strs ["[meta nodes i s __hash]"], :end-row 7952, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->ArrayNodeSeq", :ns "cljs.core", :row 7900} {:arglist-strs ["[nodes]" "[nodes i s]"], :end-row 7968, :filename "cljs/core.cljs", :fixed-arities #{1 3}, :name "create-array-node-seq", :ns "cljs.core", :private true, :row 7956} {:end-row 7980, :filename "cljs/core.cljs", :name "HashMapIter", :ns "cljs.core", :row 7970} {:arglist-strs ["[nil-val root-iter seen]"], :end-row 7980, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->HashMapIter", :ns "cljs.core", :row 7970} {:end-row 8124, :filename "cljs/core.cljs", :name "PersistentHashMap", :ns "cljs.core", :row 7982} {:arglist-strs ["[meta cnt root has-nil? nil-val __hash]"], :end-row 8124, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->PersistentHashMap", :ns "cljs.core", :row 7982} {:end-row 8275, :filename "cljs/core.cljs", :name "TransientHashMap", :ns "cljs.core", :row 8162} {:arglist-strs ["[edit root count has-nil? nil-val]"], :end-row 8275, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->TransientHashMap", :ns "cljs.core", :row 8162} {:arglist-strs ["[node stack ascending?]"], :end-row 8284, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "tree-map-seq-push", :ns "cljs.core", :private true, :row 8279} {:end-row 8353, :filename "cljs/core.cljs", :name "PersistentTreeMapSeq", :ns "cljs.core", :row 8286} {:arglist-strs ["[meta stack ascending? cnt __hash]"], :end-row 8353, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->PersistentTreeMapSeq", :ns "cljs.core", :row 8286} {:arglist-strs ["[tree ascending? cnt]"], :end-row 8358, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "create-tree-map-seq", :ns "cljs.core", :private true, :row 8357} {:end-row 8360, :filename "cljs/core.cljs", :name "RedNode", :ns "cljs.core", :row 8360} {:end-row 8360, :filename "cljs/core.cljs", :name "BlackNode", :ns "cljs.core", :row 8360} {:arglist-strs ["[key val ins right]"], :end-row 8385, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "balance-left", :ns "cljs.core", :private true, :row 8362} {:arglist-strs ["[key val left ins]"], :end-row 8407, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "balance-right", :ns "cljs.core", :private true, :row 8387} {:arglist-strs ["[key val del right]"], :end-row 8426, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "balance-left-del", :ns "cljs.core", :private true, :row 8409} {:arglist-strs ["[key val left del]"], :end-row 8445, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "balance-right-del", :ns "cljs.core", :private true, :row 8428} {:arglist-strs ["[node f init]"], :end-row 8458, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "tree-map-kv-reduce", :ns "cljs.core", :private true, :row 8447} {:end-row 8581, :filename "cljs/core.cljs", :name "BlackNode", :ns "cljs.core", :row 8460} {:arglist-strs ["[key val left right __hash]"], :end-row 8581, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->BlackNode", :ns "cljs.core", :row 8460} {:end-row 8745, :filename "cljs/core.cljs", :name "RedNode", :ns "cljs.core", :row 8585} {:arglist-strs ["[key val left right __hash]"], :end-row 8745, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->RedNode", :ns "cljs.core", :row 8585} {:arglist-strs ["[comp tree k v found]"], :end-row 8766, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "tree-map-add", :ns "cljs.core", :private true, :row 8749} {:arglist-strs ["[left right]"], :end-row 8823, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "tree-map-append", :ns "cljs.core", :private true, :row 8768} {:arglist-strs ["[comp tree k found]"], :end-row 8845, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "tree-map-remove", :ns "cljs.core", :private true, :row 8825} {:arglist-strs ["[comp tree k v]"], :end-row 8852, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "tree-map-replace", :ns "cljs.core", :private true, :row 8847} {:end-row 8854, :filename "cljs/core.cljs", :name "key", :ns "cljs.core", :row 8854} {:end-row 9007, :filename "cljs/core.cljs", :name "PersistentTreeMap", :ns "cljs.core", :row 8856} {:arglist-strs ["[comp tree cnt meta __hash]"], :end-row 9007, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->PersistentTreeMap", :ns "cljs.core", :row 8856} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :end-row 9023, :filename "cljs/core.cljs", :name "hash-map", :ns "cljs.core", :row 9013} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :end-row 9034, :filename "cljs/core.cljs", :name "array-map", :ns "cljs.core", :row 9025} {:arglist-strs ["[s]"], :doc "Builds a map from a seq as described in\n  https://clojure.org/reference/special_forms#keyword-arguments", :end-row 9042, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seq-to-map-for-destructuring", :ns "cljs.core", :row 9036} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :end-row 9055, :filename "cljs/core.cljs", :name "obj-map", :ns "cljs.core", :row 9044} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :end-row 9064, :filename "cljs/core.cljs", :name "sorted-map", :ns "cljs.core", :row 9057} {:arglist-strs ["[comparator & keyvals]"], :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :end-row 9074, :filename "cljs/core.cljs", :name "sorted-map-by", :ns "cljs.core", :row 9066} {:end-row 9140, :filename "cljs/core.cljs", :name "KeySeq", :ns "cljs.core", :row 9076} {:arglist-strs ["[mseq _meta]"], :end-row 9140, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->KeySeq", :ns "cljs.core", :row 9076} {:arglist-strs ["[map]"], :doc "Returns a sequence of the map's keys, in the same order as (seq map).", :end-row 9148, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "keys", :ns "cljs.core", :row 9144} {:arglist-strs ["[map-entry]"], :doc "Returns the key of the map entry.", :end-row 9153, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "key", :ns "cljs.core", :row 9150} {:end-row 9219, :filename "cljs/core.cljs", :name "ValSeq", :ns "cljs.core", :row 9155} {:arglist-strs ["[mseq _meta]"], :end-row 9219, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->ValSeq", :ns "cljs.core", :row 9155} {:arglist-strs ["[map]"], :doc "Returns a sequence of the map's values, in the same order as (seq map).", :end-row 9227, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "vals", :ns "cljs.core", :row 9223} {:arglist-strs ["[map-entry]"], :doc "Returns the value in the map entry.", :end-row 9232, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "val", :ns "cljs.core", :row 9229} {:arglist-strs ["[& maps]"], :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :end-row 9240, :filename "cljs/core.cljs", :name "merge", :ns "cljs.core", :row 9234} {:arglist-strs ["[f & maps]"], :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :end-row 9256, :filename "cljs/core.cljs", :name "merge-with", :ns "cljs.core", :row 9242} {:arglist-strs ["[map keyseq]"], :doc "Returns a map containing only those entries in map whose key is in keys", :end-row 9270, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "select-keys", :ns "cljs.core", :row 9258} {:end-row 9274, :filename "cljs/core.cljs", :name "TransientHashSet", :ns "cljs.core", :row 9274} {:end-row 9284, :filename "cljs/core.cljs", :name "HashSetIter", :ns "cljs.core", :row 9276} {:arglist-strs ["[iter]"], :end-row 9284, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->HashSetIter", :ns "cljs.core", :row 9276} {:end-row 9370, :filename "cljs/core.cljs", :name "PersistentHashSet", :ns "cljs.core", :row 9286} {:arglist-strs ["[meta hash-map __hash]"], :end-row 9370, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->PersistentHashSet", :ns "cljs.core", :row 9286} {:end-row 9445, :filename "cljs/core.cljs", :name "TransientHashSet", :ns "cljs.core", :row 9410} {:arglist-strs ["[transient-map]"], :end-row 9445, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->TransientHashSet", :ns "cljs.core", :row 9410} {:end-row 9541, :filename "cljs/core.cljs", :name "PersistentTreeSet", :ns "cljs.core", :row 9447} {:arglist-strs ["[meta tree-map __hash]"], :end-row 9541, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->PersistentTreeSet", :ns "cljs.core", :row 9447} {:arglist-strs ["[iseq]"], :end-row 9552, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set-from-indexed-seq", :ns "cljs.core", :row 9548} {:arglist-strs ["[coll]"], :doc "Returns a set of the distinct elements of coll.", :end-row 9571, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set", :ns "cljs.core", :row 9554} {:arglist-strs ["[]" "[& keys]"], :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :end-row 9577, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "hash-set", :ns "cljs.core", :row 9573} {:arglist-strs ["[& keys]"], :doc "Returns a new sorted set with supplied keys.", :end-row 9582, :filename "cljs/core.cljs", :name "sorted-set", :ns "cljs.core", :row 9579} {:arglist-strs ["[comparator & keys]"], :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :end-row 9589, :filename "cljs/core.cljs", :name "sorted-set-by", :ns "cljs.core", :row 9584} {:arglist-strs ["[smap]" "[smap coll]"], :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :end-row 9606, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "replace", :ns "cljs.core", :row 9591} {:arglist-strs ["[]" "[coll]"], :doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", :end-row 9631, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "distinct", :ns "cljs.core", :row 9608} {:arglist-strs ["[s]"], :doc "Return a seq of all but the last item in coll, in linear time", :end-row 9640, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "butlast", :ns "cljs.core", :row 9634} {:arglist-strs ["[x]"], :doc "Returns the name String of a string, symbol or keyword.", :end-row 9649, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "name", :ns "cljs.core", :row 9642} {:arglist-strs ["[keys vals]"], :doc "Returns a map with the keys mapped to the corresponding vals.", :end-row 9661, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "zipmap", :ns "cljs.core", :row 9651} {:arglist-strs ["[k x]" "[k x y]" "[k x y & more]"], :doc "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned.", :end-row 9670, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "max-key", :ns "cljs.core", :row 9663} {:arglist-strs ["[k x]" "[k x y]" "[k x y & more]"], :doc "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.", :end-row 9679, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "min-key", :ns "cljs.core", :row 9672} {:end-row 9687, :filename "cljs/core.cljs", :name "ArrayList", :ns "cljs.core", :row 9681} {:arglist-strs ["[arr]"], :end-row 9687, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->ArrayList", :ns "cljs.core", :row 9681} {:arglist-strs ["[]"], :end-row 9690, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "array-list", :ns "cljs.core", :row 9689} {:arglist-strs ["[n]" "[n coll]" "[n step coll]"], :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :end-row 9721, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "partition-all", :ns "cljs.core", :row 9692} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-row 9740, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "take-while", :ns "cljs.core", :row 9723} {:arglist-strs ["[sc test key]"], :end-row 9746, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "mk-bound-fn", :ns "cljs.core", :row 9742} {:arglist-strs ["[sc test key]" "[sc start-test start-key end-test end-key]"], :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :end-row 9761, :filename "cljs/core.cljs", :fixed-arities #{3 5}, :name "subseq", :ns "cljs.core", :row 9748} {:arglist-strs ["[sc test key]" "[sc start-test start-key end-test end-key]"], :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :end-row 9776, :filename "cljs/core.cljs", :fixed-arities #{3 5}, :name "rsubseq", :ns "cljs.core", :row 9763} {:end-row 9797, :filename "cljs/core.cljs", :name "IntegerRangeChunk", :ns "cljs.core", :row 9778} {:arglist-strs ["[start step count]"], :end-row 9797, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->IntegerRangeChunk", :ns "cljs.core", :row 9778} {:end-row 9808, :filename "cljs/core.cljs", :name "RangeIterator", :ns "cljs.core", :row 9799} {:arglist-strs ["[i end step]"], :end-row 9808, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->RangeIterator", :ns "cljs.core", :row 9799} {:end-row 9922, :filename "cljs/core.cljs", :name "IntegerRange", :ns "cljs.core", :row 9810} {:arglist-strs ["[meta start end step chunk chunk-next __hash]"], :end-row 9922, :filename "cljs/core.cljs", :fixed-arities #{7}, :name "->IntegerRange", :ns "cljs.core", :row 9810} {:end-row 10029, :filename "cljs/core.cljs", :name "Range", :ns "cljs.core", :row 9926} {:arglist-strs ["[meta start end step chunk chunk-next __hash]"], :end-row 10029, :filename "cljs/core.cljs", :fixed-arities #{7}, :name "->Range", :ns "cljs.core", :row 9926} {:arglist-strs ["[]" "[end]" "[start end]" "[start end step]"], :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :end-row 10059, :filename "cljs/core.cljs", :fixed-arities #{0 1 3 2}, :name "range", :ns "cljs.core", :row 10033} {:arglist-strs ["[n]" "[n coll]"], :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :end-row 10080, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "take-nth", :ns "cljs.core", :row 10061} {:arglist-strs ["[pred coll]"], :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", :end-row 10085, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "split-with", :ns "cljs.core", :row 10082} {:arglist-strs ["[f]" "[f coll]"], :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :end-row 10126, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "partition-by", :ns "cljs.core", :row 10087} {:arglist-strs ["[coll]"], :doc "Returns a map from distinct items in coll to the number of times\n  they appear.", :end-row 10135, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "frequencies", :ns "cljs.core", :row 10128} {:arglist-strs ["[f coll]" "[f init coll]"], :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :end-row 10151, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "reductions", :ns "cljs.core", :row 10137} {:arglist-strs ["[f]" "[f g]" "[f g h]" "[f g h & fs]"], :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :end-row 10187, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "juxt", :ns "cljs.core", :row 10153} {:arglist-strs ["[coll]" "[n coll]"], :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :end-row 10200, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "dorun", :ns "cljs.core", :row 10189} {:arglist-strs ["[coll]" "[n coll]"], :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :end-row 10214, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "doall", :ns "cljs.core", :row 10202} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript RegExp instance.", :end-row 10221, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "regexp?", :ns "cljs.core", :row 10218} {:arglist-strs ["[re s]"], :doc "Returns the result of (re-find re s) if re fully matches s.", :end-row 10233, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "re-matches", :ns "cljs.core", :row 10223} {:arglist-strs ["[re s]"], :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups.", :end-row 10248, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "re-find", :ns "cljs.core", :row 10236} {:arglist-strs ["[re s]"], :end-row 10261, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "re-seq*", :ns "cljs.core", :private true, :row 10250} {:arglist-strs ["[re s]"], :doc "Returns a lazy sequence of successive matches of re in s.", :end-row 10268, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "re-seq", :ns "cljs.core", :row 10263} {:arglist-strs ["[s]"], :doc "Returns an instance of RegExp which has compiled the provided string.", :end-row 10279, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "re-pattern", :ns "cljs.core", :row 10270} {:arglist-strs ["[writer print-one begin sep end opts coll]"], :end-row 10304, :filename "cljs/core.cljs", :fixed-arities #{7}, :name "pr-sequential-writer", :ns "cljs.core", :row 10283} {:arglist-strs ["[writer & ss]"], :end-row 10308, :filename "cljs/core.cljs", :name "write-all", :ns "cljs.core", :row 10306} {:arglist-strs ["[x]"], :end-row 10314, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "string-print", :ns "cljs.core", :row 10310} {:arglist-strs ["[]"], :end-row 10317, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "flush", :ns "cljs.core", :row 10316} {:end-row 10327, :filename "cljs/core.cljs", :name "char-escapes", :ns "cljs.core", :private true, :row 10319} {:arglist-strs ["[s]"], :end-row 10334, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "quote-string", :ns "cljs.core", :private true, :row 10329} {:end-row 10336, :filename "cljs/core.cljs", :name "print-map", :ns "cljs.core", :row 10336} {:arglist-strs ["[opts obj]"], :end-row 10341, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "print-meta?", :ns "cljs.core", :row 10338} {:arglist-strs ["[obj writer opts]"], :end-row 10433, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pr-writer-impl", :ns "cljs.core", :private true, :row 10343} {:fixed-arities #{3}, :end-row 10442, :private true, :ns "cljs.core", :name "pr-writer", :filename "cljs/core.cljs", :arglist-strs ["[obj writer opts]"], :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer.", :row 10435} {:arglist-strs ["[objs writer opts]"], :end-row 10448, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pr-seq-writer", :ns "cljs.core", :row 10444} {:arglist-strs ["[objs opts]"], :end-row 10455, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "pr-sb-with-opts", :ns "cljs.core", :private true, :row 10450} {:arglist-strs ["[objs opts]"], :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts", :end-row 10463, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "pr-str-with-opts", :ns "cljs.core", :row 10457} {:arglist-strs ["[objs opts]"], :doc "Same as pr-str-with-opts followed by (newline)", :end-row 10472, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "prn-str-with-opts", :ns "cljs.core", :row 10465} {:fixed-arities #{2}, :end-row 10478, :private true, :ns "cljs.core", :name "pr-with-opts", :filename "cljs/core.cljs", :arglist-strs ["[objs opts]"], :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts", :row 10474} {:arglist-strs ["[]" "[opts]"], :doc "Prints a newline using *print-fn*", :end-row 10486, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "newline", :ns "cljs.core", :row 10480} {:arglist-strs ["[& objs]"], :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :end-row 10491, :filename "cljs/core.cljs", :name "pr-str", :ns "cljs.core", :row 10488} {:arglist-strs ["[& objs]"], :doc "Same as pr-str followed by (newline)", :end-row 10496, :filename "cljs/core.cljs", :name "prn-str", :ns "cljs.core", :row 10493} {:arglist-strs ["[& objs]"], :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :end-row 10504, :filename "cljs/core.cljs", :name "pr", :ns "cljs.core", :row 10498} {:arglist-strs ["[& objs]"], :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption.", :end-row 10511, :filename "cljs/core.cljs", :fixed-arities #{}, :name "print", :ns "cljs.core", :row 10506} {:arglist-strs ["[& objs]"], :doc "print to a string, returning it", :end-row 10516, :filename "cljs/core.cljs", :name "print-str", :ns "cljs.core", :row 10513} {:arglist-strs ["[& objs]"], :doc "Same as print followed by (newline)", :end-row 10523, :filename "cljs/core.cljs", :name "println", :ns "cljs.core", :row 10518} {:arglist-strs ["[& objs]"], :doc "println to a string, returning it", :end-row 10528, :filename "cljs/core.cljs", :name "println-str", :ns "cljs.core", :row 10525} {:arglist-strs ["[& objs]"], :doc "Same as pr followed by (newline).", :end-row 10535, :filename "cljs/core.cljs", :name "prn", :ns "cljs.core", :row 10530} {:arglist-strs ["[named]"], :end-row 10541, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "strip-ns", :ns "cljs.core", :private true, :row 10537} {:fixed-arities #{1}, :end-row 10557, :private true, :ns "cljs.core", :name "lift-ns", :filename "cljs/core.cljs", :arglist-strs ["[m]"], :doc "Returns [lifted-ns lifted-map] or nil if m can't be lifted.", :row 10543} {:arglist-strs ["[prefix m print-one writer opts]"], :end-row 10567, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "print-prefix-map", :ns "cljs.core", :row 10559} {:arglist-strs ["[m print-one writer opts]"], :end-row 10574, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "print-map", :ns "cljs.core", :row 10569} {:arglist-strs ["[iref f & args]"], :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :end-row 10753, :filename "cljs/core.cljs", :name "alter-meta!", :ns "cljs.core", :row 10746} {:arglist-strs ["[iref m]"], :doc "Atomically resets the metadata for an atom", :end-row 10758, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "reset-meta!", :ns "cljs.core", :row 10755} {:arglist-strs ["[iref key f]"], :doc "Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1", :end-row 10781, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "add-watch", :ns "cljs.core", :row 10760} {:arglist-strs ["[iref key]"], :doc "Removes a watch (set by add-watch) from a reference", :end-row 10787, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "remove-watch", :ns "cljs.core", :row 10783} {:end-row 10793, :filename "cljs/core.cljs", :name "gensym_counter", :ns "cljs.core", :row 10791} {:arglist-strs ["[]" "[prefix-string]"], :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :end-row 10803, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "gensym", :ns "cljs.core", :row 10795} {:end-row 10823, :filename "cljs/core.cljs", :name "Delay", :ns "cljs.core", :row 10807} {:arglist-strs ["[f value]"], :end-row 10823, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->Delay", :ns "cljs.core", :row 10807} {:arglist-strs ["[x]"], :doc "returns true if x is a Delay created with delay", :end-row 10827, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "delay?", :ns "cljs.core", :row 10825} {:arglist-strs ["[x]"], :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", :end-row 10834, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "force", :ns "cljs.core", :row 10829} {:arglist-strs ["[x]"], :doc "Returns true if a value has been produced for a delay or lazy sequence.", :end-row 10839, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "realized?", :ns "cljs.core", :row 10836} {:arglist-strs ["[rf]"], :end-row 10846, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "preserving-reduced", :ns "cljs.core", :private true, :row 10841} {:arglist-strs ["[rf]"], :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :end-row 10858, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "cat", :ns "cljs.core", :row 10848} {:arglist-strs ["[pred]" "[pred retf]"], :doc "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", :end-row 10882, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "halt-when", :ns "cljs.core", :row 10860} {:arglist-strs ["[]" "[coll]"], :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :end-row 10899, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "dedupe", :ns "cljs.core", :row 10884} {:end-row 10901, :filename "cljs/core.cljs", :name "rand", :ns "cljs.core", :row 10901} {:arglist-strs ["[prob]" "[prob coll]"], :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :end-row 10909, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "random-sample", :ns "cljs.core", :row 10903} {:end-row 10937, :filename "cljs/core.cljs", :name "Eduction", :ns "cljs.core", :row 10911} {:arglist-strs ["[xform coll]"], :end-row 10937, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->Eduction", :ns "cljs.core", :row 10911} {:arglist-strs ["[& xforms]"], :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.", :end-row 10948, :filename "cljs/core.cljs", :name "eduction", :ns "cljs.core", :row 10941} {:arglist-strs ["[proc coll]"], :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", :end-row 10955, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "run!", :ns "cljs.core", :row 10950} {:arglist-strs ["[step & {:keys [somef vf kf initk] :or {vf identity kf identity somef some? initk nil}}]"], :doc "Creates a seqable/reducible via repeated calls to step,\n  a function of some (continuation token) 'k'. The first call to step\n  will be passed initk, returning 'ret'. Iff (somef ret) is true,\n  (vf ret) will be included in the iteration, else iteration will\n  terminate and vf/kf will not be called. If (kf ret) is non-nil it\n  will be passed to the next step call, else iteration will terminate.\n  This can be used e.g. to consume APIs that return paginated or batched data.\n   step - (possibly impure) fn of 'k' -> 'ret'\n   :somef - fn of 'ret' -> logical true/false, default 'some?'\n   :vf - fn of 'ret' -> 'v', a value produced by the iteration, default 'identity'\n   :kf - fn of 'ret' -> 'next-k' or nil (signaling 'do not continue'), default 'identity'\n   :initk - the first value passed to step, default 'nil'\n  It is presumed that step with non-initk is unreproducible/non-idempotent.\n  If step with initk is unreproducible it is on the consumer to not consume twice.", :end-row 10998, :filename "cljs/core.cljs", :name "iteration", :ns "cljs.core", :row 10957} {:end-row 11003, :filename "cljs/core.cljs", :name "IEncodeJS", :ns "cljs.core", :row 11000} {:arglist-strs ["[x]"], :doc "Recursively transforms clj values to JavaScript", :end-row 11001, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-clj->js", :ns "cljs.core", :row 11001} {:arglist-strs ["[x]"], :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)", :end-row 11003, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-key->js", :ns "cljs.core", :row 11002} {:end-row 11005, :filename "cljs/core.cljs", :name "clj->js", :ns "cljs.core", :row 11005} {:arglist-strs ["[k]" "[k primitive-fn]"], :end-row 11016, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "key->js", :ns "cljs.core", :row 11007} {:arglist-strs ["[x & {:keys [keyword-fn] :or {keyword-fn name} :as options}]"], :doc "Recursively transforms ClojureScript values to JavaScript.\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n  Maps become Objects. Arbitrary keys are encoded to by `key->js`.\n  Options is a key-value pair, where the only valid key is\n  :keyword-fn, which should point to a single-argument function to be\n  called on keyword keys. Default to `name`.", :end-row 11043, :filename "cljs/core.cljs", :name "clj->js", :ns "cljs.core", :row 11018} {:end-row 11047, :filename "cljs/core.cljs", :name "IEncodeClojure", :ns "cljs.core", :row 11046} {:arglist-strs ["[x options]"], :doc "Transforms JavaScript values to Clojure", :end-row 11047, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-js->clj", :ns "cljs.core", :row 11047} {:arglist-strs ["[x]" "[x & opts]"], :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :end-row 11082, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js->clj", :ns "cljs.core", :row 11049} {:arglist-strs ["[f]"], :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", :end-row 11097, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "memoize", :ns "cljs.core", :row 11084} {:arglist-strs ["[f]" "[f & args]"], :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :end-row 11113, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "trampoline", :ns "cljs.core", :row 11099} {:arglist-strs ["[]" "[n]"], :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :end-row 11119, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "rand", :ns "cljs.core", :row 11115} {:arglist-strs ["[n]"], :doc "Returns a random integer between 0 (inclusive) and n (exclusive).", :end-row 11123, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "rand-int", :ns "cljs.core", :row 11121} {:arglist-strs ["[coll]"], :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", :end-row 11130, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "rand-nth", :ns "cljs.core", :row 11125} {:arglist-strs ["[f coll]"], :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", :end-row 11142, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "group-by", :ns "cljs.core", :row 11132} {:arglist-strs ["[]"], :doc "Creates a hierarchy object for use with derive, isa? etc.", :end-row 11146, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "make-hierarchy", :ns "cljs.core", :row 11144} {:end-row 11151, :filename "cljs/core.cljs", :name "-global-hierarchy", :ns "cljs.core", :private true, :row 11148} {:arglist-strs ["[]"], :end-row 11156, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "get-global-hierarchy", :ns "cljs.core", :private true, :row 11153} {:arglist-strs ["[f & args]"], :end-row 11159, :filename "cljs/core.cljs", :name "swap-global-hierarchy!", :ns "cljs.core", :private true, :row 11158} {:arglist-strs ["[child parent]" "[h child parent]"], :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :end-row 11179, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "isa?", :ns "cljs.core", :row 11161} {:arglist-strs ["[tag]" "[h tag]"], :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :end-row 11187, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "parents", :ns "cljs.core", :row 11181} {:arglist-strs ["[tag]" "[h tag]"], :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :end-row 11195, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "ancestors", :ns "cljs.core", :row 11189} {:arglist-strs ["[tag]" "[h tag]"], :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :end-row 11204, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "descendants", :ns "cljs.core", :row 11197} {:arglist-strs ["[tag parent]" "[h tag parent]"], :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :end-row 11238, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "derive", :ns "cljs.core", :row 11206} {:arglist-strs ["[tag parent]" "[h tag parent]"], :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :end-row 11259, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "underive", :ns "cljs.core", :row 11240} {:arglist-strs ["[method-cache method-table cached-hierarchy hierarchy]"], :end-row 11264, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "reset-cache", :ns "cljs.core", :private true, :row 11261} {:arglist-strs ["[x y prefer-table]"], :end-row 11282, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "prefers*", :ns "cljs.core", :private true, :row 11266} {:arglist-strs ["[x y prefer-table hierarchy]"], :end-row 11286, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "dominates", :ns "cljs.core", :private true, :row 11284} {:arglist-strs ["[name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy default-dispatch-val]"], :end-row 11314, :filename "cljs/core.cljs", :fixed-arities #{8}, :name "find-and-cache-best-method", :ns "cljs.core", :private true, :row 11288} {:end-row 11325, :filename "cljs/core.cljs", :name "IMultiFn", :ns "cljs.core", :row 11316} {:arglist-strs ["[mf]"], :end-row 11317, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-reset", :ns "cljs.core", :row 11317} {:arglist-strs ["[mf dispatch-val method]"], :end-row 11318, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-add-method", :ns "cljs.core", :row 11318} {:arglist-strs ["[mf dispatch-val]"], :end-row 11319, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-remove-method", :ns "cljs.core", :row 11319} {:arglist-strs ["[mf dispatch-val dispatch-val-y]"], :end-row 11320, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-prefer-method", :ns "cljs.core", :row 11320} {:arglist-strs ["[mf dispatch-val]"], :end-row 11321, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-get-method", :ns "cljs.core", :row 11321} {:arglist-strs ["[mf]"], :end-row 11322, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-methods", :ns "cljs.core", :row 11322} {:arglist-strs ["[mf]"], :end-row 11323, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-prefers", :ns "cljs.core", :row 11323} {:arglist-strs ["[mf]"], :end-row 11324, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-default-dispatch-val", :ns "cljs.core", :row 11324} {:arglist-strs ["[mf]"], :end-row 11325, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-dispatch-fn", :ns "cljs.core", :row 11325} {:arglist-strs ["[name dispatch-val]"], :end-row 11328, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "throw-no-method-error", :ns "cljs.core", :private true, :row 11327} {:end-row 11513, :filename "cljs/core.cljs", :name "MultiFn", :ns "cljs.core", :row 11330} {:arglist-strs ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"], :end-row 11513, :filename "cljs/core.cljs", :fixed-arities #{8}, :name "->MultiFn", :ns "cljs.core", :row 11330} {:arglist-strs ["[multifn]"], :doc "Removes all of the methods of multimethod.", :end-row 11518, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "remove-all-methods", :ns "cljs.core", :row 11515} {:arglist-strs ["[multifn dispatch-val]"], :doc "Removes the method of multimethod associated with dispatch-value.", :end-row 11523, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "remove-method", :ns "cljs.core", :row 11520} {:arglist-strs ["[multifn dispatch-val-x dispatch-val-y]"], :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict", :end-row 11529, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "prefer-method", :ns "cljs.core", :row 11525} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns", :end-row 11533, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "methods", :ns "cljs.core", :row 11531} {:arglist-strs ["[multifn dispatch-val]"], :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", :end-row 11538, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "get-method", :ns "cljs.core", :row 11535} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, returns a map of preferred value -> set of other values", :end-row 11542, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "prefers", :ns "cljs.core", :row 11540} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, return its default-dispatch-val.", :end-row 11546, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "default-dispatch-val", :ns "cljs.core", :row 11544} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, return its dispatch-fn.", :end-row 11550, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "dispatch-fn", :ns "cljs.core", :row 11548} {:doc "A marker protocol for UUIDs", :end-row 11553, :filename "cljs/core.cljs", :name "IUUID", :ns "cljs.core", :row 11553} {:end-row 11581, :filename "cljs/core.cljs", :name "UUID", :ns "cljs.core", :row 11555} {:arglist-strs ["[uuid __hash]"], :end-row 11581, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->UUID", :ns "cljs.core", :row 11555} {:arglist-strs ["[s]"], :doc "Returns a UUID consistent with the string s.", :end-row 11587, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "uuid", :ns "cljs.core", :row 11583} {:arglist-strs ["[]"], :doc "Returns a pseudo-randomly generated UUID instance (i.e. type 4).", :end-row 11602, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "random-uuid", :ns "cljs.core", :row 11589} {:arglist-strs ["[x]"], :doc "Return true if x is a UUID.", :end-row 11606, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "uuid?", :ns "cljs.core", :row 11604} {:arglist-strs ["[obj writer opts]"], :end-row 11619, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pr-writer-ex-info", :ns "cljs.core", :private true, :row 11610} {:arglist-strs ["[message data cause]"], :end-row 11637, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "ExceptionInfo", :ns "cljs.core", :row 11621} {:arglist-strs ["[msg data]" "[msg data cause]"], :doc "Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :end-row 11655, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "ex-info", :ns "cljs.core", :row 11650} {:arglist-strs ["[ex]"], :doc "Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil.", :end-row 11662, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ex-data", :ns "cljs.core", :row 11657} {:arglist-strs ["[ex]"], :doc "Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil.", :end-row 11669, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ex-message", :ns "cljs.core", :row 11664} {:arglist-strs ["[ex]"], :doc "Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil.", :end-row 11677, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ex-cause", :ns "cljs.core", :row 11671} {:arglist-strs ["[pred]"], :doc "Returns an JavaScript compatible comparator based upon pred.", :end-row 11683, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "comparator", :ns "cljs.core", :row 11679} {:arglist-strs ["[x]"], :doc "Returns true if x names a special form", :end-row 11691, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "special-symbol?", :ns "cljs.core", :row 11685} {:arglist-strs ["[v]"], :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", :end-row 11700, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "test", :ns "cljs.core", :row 11693} {:end-row 11731, :filename "cljs/core.cljs", :name "TaggedLiteral", :ns "cljs.core", :row 11703} {:arglist-strs ["[tag form]"], :end-row 11731, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->TaggedLiteral", :ns "cljs.core", :row 11703} {:arglist-strs ["[value]"], :doc "Return true if the value is the data representation of a tagged literal", :end-row 11736, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tagged-literal?", :ns "cljs.core", :row 11733} {:arglist-strs ["[tag form]"], :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form.", :end-row 11743, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "tagged-literal", :ns "cljs.core", :row 11738} {:end-row 11761, :filename "cljs/core.cljs", :name "js-reserved-arr", :ns "cljs.core", :private true, :row 11745} {:end-row 11765, :filename "cljs/core.cljs", :name "js-reserved", :ns "cljs.core", :row 11763} {:arglist-strs ["[x]"], :end-row 11772, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js-reserved?", :ns "cljs.core", :private true, :row 11767} {:arglist-strs ["[]"], :end-row 11788, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "demunge-pattern", :ns "cljs.core", :private true, :row 11774} {:arglist-strs ["[name]"], :end-row 11800, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "munge-str", :ns "cljs.core", :private true, :row 11790} {:arglist-strs ["[name]"], :end-row 11810, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "munge", :ns "cljs.core", :row 11802} {:arglist-strs ["[munged-name]"], :end-row 11827, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "demunge-str", :ns "cljs.core", :private true, :row 11812} {:arglist-strs ["[name]"], :end-row 11834, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "demunge", :ns "cljs.core", :row 11829} {:end-row 11837, :filename "cljs/core.cljs", :name "tapset", :ns "cljs.core", :private true, :row 11836} {:arglist-strs ["[]"], :end-row 11841, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "maybe-init-tapset", :ns "cljs.core", :private true, :row 11839} {:arglist-strs ["[f]"], :doc "Adds f, a fn of one argument, to the tap set. This function will be called with\n  anything sent via tap>. Remember f in order to remove-tap", :end-row 11849, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "add-tap", :ns "cljs.core", :row 11843} {:arglist-strs ["[f]"], :doc "Remove f from the tap set.", :end-row 11856, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "remove-tap", :ns "cljs.core", :row 11851} {:arglist-strs ["[x]"], :doc "Sends x to any taps. Returns the result of *exec-tap-fn*, a Boolean value.", :end-row 11867, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tap>", :ns "cljs.core", :row 11858} {:arglist-strs ["[m f]"], :doc "m f => {k (f v) ...}\n  Given a map m and a function f of 1-argument, returns a new map where the keys of m\n  are mapped to result of applying f to the corresponding values of m.", :end-row 11882, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "update-vals", :ns "cljs.core", :row 11869} {:arglist-strs ["[m f]"], :doc "m f => {(f k) v ...}\n  Given a map m and a function f of 1-argument, returns a new map whose\n  keys are the result of applying f to the keys of m, mapped to the\n  corresponding values of m.\n  f must return a unique key for each key of m, else the behavior is undefined.", :end-row 11896, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "update-keys", :ns "cljs.core", :row 11884} {:fixed-arities #{2}, :end-row 11904, :private true, :ns "cljs.core", :name "ns-lookup", :filename "cljs/core.cljs", :arglist-strs ["[ns-obj k]"], :doc "Bootstrap only.", :row 11901} {:end-row 11925, :filename "cljs/core.cljs", :name "Namespace", :ns "cljs.core", :row 11907} {:arglist-strs ["[obj name]"], :end-row 11925, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->Namespace", :ns "cljs.core", :row 11907} {:doc "Bootstrap only.", :end-row 11929, :filename "cljs/core.cljs", :name "NS_CACHE", :ns "cljs.core", :row 11927} {:fixed-arities #{2}, :end-row 11937, :private true, :ns "cljs.core", :name "find-ns-obj*", :filename "cljs/core.cljs", :arglist-strs ["[ctxt xs]"], :doc "Bootstrap only.", :row 11931} {:arglist-strs ["[ns]"], :doc "Bootstrap only.", :end-row 11960, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "find-ns-obj", :ns "cljs.core", :row 11939} {:arglist-strs ["[sym]"], :doc "Returns a map of the intern mappings for the namespace.\n  Bootstrap only.", :end-row 11973, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ns-interns*", :ns "cljs.core", :row 11962} {:arglist-strs ["[sym]" "[sym ns-obj]"], :doc "Create a new namespace named by the symbol. Bootstrap only.", :end-row 11980, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "create-ns", :ns "cljs.core", :row 11975} {:arglist-strs ["[ns]"], :doc "Returns the namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only.", :end-row 11995, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "find-ns", :ns "cljs.core", :row 11982} {:arglist-strs ["[ns]"], :doc "Returns the macros namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only.", :end-row 12014, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "find-macros-ns", :ns "cljs.core", :row 11997} {:arglist-strs ["[ns-obj]"], :doc "Returns the name of the namespace, a Namespace object.\n  Bootstrap only.", :end-row 12020, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ns-name", :ns "cljs.core", :row 12016} {:arglist-strs ["[x]"], :doc "Returns true x is a goog.Uri instance.", :end-row 12026, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "uri?", :ns "cljs.core", :row 12022} {:arglist-strs ["[val]"], :doc "Returns true if num is NaN, else false", :end-row 12031, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "NaN?", :ns "cljs.core", :row 12028} {:fixed-arities #{1}, :end-row 12036, :private true, :ns "cljs.core", :name "parsing-err", :filename "cljs/core.cljs", :arglist-strs ["[val]"], :doc "Construct message for parsing for non-string parsing error", :row 12033} {:arglist-strs ["[s]"], :doc "Parse string of decimal digits with optional leading -/+ and return an\n  integer value, or nil if parse fails", :end-row 12048, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "parse-long", :ns "cljs.core", :row 12038} {:arglist-strs ["[s]"], :doc "Parse string with floating point components and return a floating point value,\n  or nil if parse fails.\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String-", :end-row 12062, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "parse-double", :ns "cljs.core", :row 12050} {:end-row 12065, :filename "cljs/core.cljs", :name "uuid-regex", :ns "cljs.core", :private true, :row 12064} {:arglist-strs ["[s]"], :doc "Parse a string representing a UUID and return a UUID instance,\n  or nil if parse fails.\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#toString--", :end-row 12075, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "parse-uuid", :ns "cljs.core", :row 12067} {:arglist-strs ["[s]"], :doc "Parse strings \"true\" or \"false\" and return a boolean, or nil if invalid. Note that this explicitly\n  excludes strings with different cases, or space characters.", :end-row 12086, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "parse-boolean", :ns "cljs.core", :row 12077} {:arglist-strs ["[]"], :end-row 12106, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "maybe-enable-print!", :ns "cljs.core", :private true, :row 12088} {:doc "Runtime environments may provide a way to evaluate ClojureScript\n  forms. Whatever function *eval* is bound to will be passed any forms which\n  should be evaluated.", :end-row 12116, :filename "cljs/core.cljs", :name "*eval*", :ns "cljs.core", :row 12110} {:arglist-strs ["[form]"], :doc "Evaluates the form data structure (not text!) and returns the result.\n  Delegates to cljs.core/*eval*. Intended for use in self-hosted ClojureScript,\n  which sets up an implementation of cljs.core/*eval* for that environment.", :end-row 12123, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "eval", :ns "cljs.core", :row 12118}]} {:end-row 58, :filename "cljs/core.cljc", :lang :cljs, :name "cljs.core", :row 9, :ns nil, :var-definitions [{:fixed-arities #{2}, :end-row 90, :ns "cljs.core", :name "import-macros", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[ns [& vars]]"], :row 64} {:end-row 192, :ns "cljs.core", :name "doto", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x & forms]"], :doc "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new js/Map) (.set \"a\" 1) (.set \"b\" 2))", :row 178} {:end-row 389, :ns "cljs.core", :name "memfn", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & args]"], :doc "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a JavaScript\n  method as a first-class fn.", :row 380} {:fixed-arities #{1}, :end-row 590, :private true, :ns "cljs.core", :name "assert-valid-fdecl", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :doc "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.", :row 553} {:fixed-arities #{1}, :end-row 617, :private true, :ns "cljs.core", :name "sigs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 592} {:fixed-arities #{2}, :end-row 627, :ns "cljs.core", :name "defonce", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x init]"], :doc "defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated", :row 619} {:arglist-strs ["[bindings]"], :end-row 730, :filename "cljs/core.cljc", :fixed-arities #{1}, :lang :clj, :name "destructure", :ns "cljs.core", :row 629} {:end-row 736, :private true, :ns "cljs.core", :name "return-first", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :row 732} {:fixed-arities #{2}, :end-row 770, :ns "cljs.core", :name "goog-define", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[sym default]"], :doc "Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n    or\n    :closure-defines {your-app.core/DEBUG! true}", :row 738} {:end-row 787, :ns "cljs.core", :name "let", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => binding-form init-expr\n  binding-form => name, or destructuring-form\n  destructuring-form => map-destructure-form, or seq-destructure-form\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\n\n  See https://clojure.org/reference/special_forms#binding-forms for\n  more information about destructuring.", :row 772} {:end-row 811, :ns "cljs.core", :name "loop", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", :row 789} {:doc "protocol fqn -> [partition number, bit]", :end-row 829, :filename "cljs/core.cljc", :lang :clj, :name "fast-path-protocols", :ns "cljs.core", :row 813} {:doc "total number of partitions", :end-row 837, :filename "cljs/core.cljc", :lang :clj, :name "fast-path-protocol-partitions-count", :ns "cljs.core", :row 831} {:fixed-arities #{2}, :end-row 842, :private true, :ns "cljs.core", :name "compatible?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[inferred-tag allowed-tags]"], :row 839} {:fixed-arities #{3}, :end-row 847, :private true, :ns "cljs.core", :name "typed-expr?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env form allowed-tags]"], :row 844} {:fixed-arities #{1}, :end-row 850, :private true, :ns "cljs.core", :name "string-expr", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[e]"], :row 849} {:fixed-arities #{0 1}, :end-row 867, :ns "cljs.core", :name "str", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & ys]"], :row 852} {:fixed-arities #{1}, :end-row 870, :private true, :ns "cljs.core", :name "bool-expr", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[e]"], :row 869} {:fixed-arities #{2}, :end-row 875, :private true, :ns "cljs.core", :name "simple-test-expr?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env ast]"], :row 872} {:fixed-arities #{0 1}, :end-row 886, :ns "cljs.core", :name "and", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", :row 877} {:fixed-arities #{0 1}, :end-row 897, :ns "cljs.core", :name "or", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", :row 888} {:fixed-arities #{1}, :end-row 900, :ns "cljs.core", :name "nil?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 899} {:fixed-arities #{1}, :end-row 903, :ns "cljs.core", :name "some?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 902} {:fixed-arities #{1}, :end-row 906, :ns "cljs.core", :name "coercive-not", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 905} {:fixed-arities #{2}, :end-row 909, :ns "cljs.core", :name "coercive-not=", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]"], :row 908} {:fixed-arities #{2}, :end-row 912, :ns "cljs.core", :name "coercive-=", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]"], :row 911} {:fixed-arities #{1}, :end-row 916, :ns "cljs.core", :name "coercive-boolean", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 914} {:fixed-arities #{1}, :end-row 921, :ns "cljs.core", :name "truth_", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 919} {:fixed-arities #{0}, :end-row 924, :ns "cljs.core", :name "js-arguments", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 923} {:fixed-arities #{2}, :end-row 927, :ns "cljs.core", :name "js-delete", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key]"], :row 926} {:fixed-arities #{2}, :end-row 930, :ns "cljs.core", :name "js-in", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[key obj]"], :row 929} {:fixed-arities #{0}, :end-row 937, :ns "cljs.core", :name "js-debugger", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :doc "Emit JavaScript \"debugger;\" statement", :row 932} {:fixed-arities #{1}, :end-row 951, :ns "cljs.core", :name "js-comment", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[comment]"], :doc "Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline", :row 939} {:fixed-arities #{2}, :end-row 957, :ns "cljs.core", :name "unsafe-cast", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[t x]"], :doc "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type.", :row 953} {:fixed-arities #{1}, :end-row 962, :ns "cljs.core", :name "js-inline-comment", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[comment]"], :doc "Emit an inline JavaScript comment.", :row 959} {:fixed-arities #{1}, :end-row 965, :ns "cljs.core", :name "true?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 964} {:fixed-arities #{1}, :end-row 968, :ns "cljs.core", :name "false?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 967} {:fixed-arities #{1}, :end-row 971, :ns "cljs.core", :name "string?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 970} {:fixed-arities #{1}, :end-row 974, :ns "cljs.core", :name "js-fn?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 973} {:fixed-arities #{1}, :end-row 991, :ns "cljs.core", :name "exists?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :doc "Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript.", :row 976} {:fixed-arities #{1}, :end-row 996, :ns "cljs.core", :name "undefined?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :doc "Return true if argument is identical to the JavaScript undefined value.", :row 993} {:fixed-arities #{2}, :end-row 999, :ns "cljs.core", :name "identical?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a b]"], :row 998} {:fixed-arities #{2}, :end-row 1008, :ns "cljs.core", :name "instance?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[c x]"], :row 1001} {:fixed-arities #{1}, :end-row 1011, :ns "cljs.core", :name "number?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1010} {:fixed-arities #{1}, :end-row 1014, :ns "cljs.core", :name "symbol?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1013} {:fixed-arities #{1}, :end-row 1017, :ns "cljs.core", :name "keyword?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1016} {:fixed-arities #{2}, :end-row 1030, :ns "cljs.core", :name "aget", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[array idx]" "[array idx & idxs]"], :row 1019} {:fixed-arities #{3}, :end-row 1044, :ns "cljs.core", :name "aset", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :row 1032} {:fixed-arities #{2}, :end-row 1051, :ns "cljs.core", :name "unchecked-get", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key]"], :doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :row 1046} {:fixed-arities #{3}, :end-row 1058, :ns "cljs.core", :name "unchecked-set", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key val]"], :doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :row 1053} {:fixed-arities #{0 1 2}, :end-row 1064, :ns "cljs.core", :name "+", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :row 1060} {:fixed-arities #{1}, :end-row 1066, :ns "cljs.core", :name "byte", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1066} {:fixed-arities #{1}, :end-row 1067, :ns "cljs.core", :name "short", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1067} {:fixed-arities #{1}, :end-row 1068, :ns "cljs.core", :name "float", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1068} {:fixed-arities #{1}, :end-row 1069, :ns "cljs.core", :name "double", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1069} {:fixed-arities #{1}, :end-row 1071, :ns "cljs.core", :name "unchecked-byte", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1071} {:fixed-arities #{1}, :end-row 1072, :ns "cljs.core", :name "unchecked-char", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1072} {:fixed-arities #{1}, :end-row 1073, :ns "cljs.core", :name "unchecked-short", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1073} {:fixed-arities #{1}, :end-row 1074, :ns "cljs.core", :name "unchecked-float", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1074} {:fixed-arities #{1}, :end-row 1075, :ns "cljs.core", :name "unchecked-double", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1075} {:arglist-strs ["[& xs]"], :end-row 1078, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-add", :ns "cljs.core", :row 1077} {:arglist-strs ["[& xs]"], :end-row 1081, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-add-int", :ns "cljs.core", :row 1080} {:fixed-arities #{1}, :end-row 1084, :ns "cljs.core", :name "unchecked-dec", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1083} {:fixed-arities #{1}, :end-row 1087, :ns "cljs.core", :name "unchecked-dec-int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1086} {:arglist-strs ["[& xs]"], :end-row 1090, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-divide-int", :ns "cljs.core", :row 1089} {:fixed-arities #{1}, :end-row 1093, :ns "cljs.core", :name "unchecked-inc", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1092} {:fixed-arities #{1}, :end-row 1096, :ns "cljs.core", :name "unchecked-inc-int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1095} {:arglist-strs ["[& xs]"], :end-row 1099, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-multiply", :ns "cljs.core", :row 1098} {:arglist-strs ["[& xs]"], :end-row 1102, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-multiply-int", :ns "cljs.core", :row 1101} {:fixed-arities #{1}, :end-row 1105, :ns "cljs.core", :name "unchecked-negate", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1104} {:fixed-arities #{1}, :end-row 1108, :ns "cljs.core", :name "unchecked-negate-int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1107} {:fixed-arities #{2}, :end-row 1111, :ns "cljs.core", :name "unchecked-remainder-int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1110} {:arglist-strs ["[& xs]"], :end-row 1114, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-subtract", :ns "cljs.core", :row 1113} {:arglist-strs ["[& xs]"], :end-row 1117, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-subtract-int", :ns "cljs.core", :row 1116} {:fixed-arities #{1 2}, :end-row 1122, :ns "cljs.core", :name "-", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1119} {:fixed-arities #{0 1 2}, :end-row 1128, :ns "cljs.core", :name "*", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :row 1124} {:fixed-arities #{1 2}, :end-row 1133, :ns "cljs.core", :name "/", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1130} {:fixed-arities #{1 2}, :end-row 1138, :ns "cljs.core", :name "divide", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1135} {:fixed-arities #{1 2}, :end-row 1143, :ns "cljs.core", :name "<", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1140} {:fixed-arities #{1 2}, :end-row 1148, :ns "cljs.core", :name "<=", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1145} {:fixed-arities #{1 2}, :end-row 1153, :ns "cljs.core", :name ">", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1150} {:fixed-arities #{1 2}, :end-row 1158, :ns "cljs.core", :name ">=", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1155} {:fixed-arities #{1 2}, :end-row 1163, :ns "cljs.core", :name "==", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1160} {:fixed-arities #{1}, :end-row 1166, :ns "cljs.core", :name "dec", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1165} {:fixed-arities #{1}, :end-row 1169, :ns "cljs.core", :name "inc", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1168} {:fixed-arities #{1}, :end-row 1172, :ns "cljs.core", :name "zero?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1171} {:fixed-arities #{1}, :end-row 1175, :ns "cljs.core", :name "pos?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1174} {:fixed-arities #{1}, :end-row 1178, :ns "cljs.core", :name "neg?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1177} {:fixed-arities #{1 2}, :end-row 1184, :ns "cljs.core", :name "max", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1180} {:fixed-arities #{1 2}, :end-row 1190, :ns "cljs.core", :name "min", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1186} {:fixed-arities #{2}, :end-row 1193, :ns "cljs.core", :name "js-mod", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[num div]"], :row 1192} {:fixed-arities #{1}, :end-row 1196, :ns "cljs.core", :name "bit-not", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1195} {:fixed-arities #{2}, :end-row 1200, :ns "cljs.core", :name "bit-and", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1198} {:fixed-arities #{2}, :end-row 1205, :ns "cljs.core", :name "unsafe-bit-and", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1203} {:fixed-arities #{2}, :end-row 1209, :ns "cljs.core", :name "bit-or", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1207} {:fixed-arities #{1}, :end-row 1212, :ns "cljs.core", :name "int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1211} {:fixed-arities #{2}, :end-row 1216, :ns "cljs.core", :name "bit-xor", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1214} {:fixed-arities #{2}, :end-row 1220, :ns "cljs.core", :name "bit-and-not", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1218} {:fixed-arities #{2}, :end-row 1223, :ns "cljs.core", :name "bit-clear", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1222} {:fixed-arities #{2}, :end-row 1226, :ns "cljs.core", :name "bit-flip", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1225} {:fixed-arities #{2}, :end-row 1229, :ns "cljs.core", :name "bit-test", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1228} {:fixed-arities #{2}, :end-row 1232, :ns "cljs.core", :name "bit-shift-left", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1231} {:fixed-arities #{2}, :end-row 1235, :ns "cljs.core", :name "bit-shift-right", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1234} {:fixed-arities #{2}, :end-row 1238, :ns "cljs.core", :name "bit-shift-right-zero-fill", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1237} {:fixed-arities #{2}, :end-row 1241, :ns "cljs.core", :name "unsigned-bit-shift-right", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1240} {:fixed-arities #{2}, :end-row 1244, :ns "cljs.core", :name "bit-set", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1243} {:fixed-arities #{2}, :end-row 1248, :ns "cljs.core", :name "mask", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[hash shift]"], :row 1247} {:fixed-arities #{2}, :end-row 1252, :ns "cljs.core", :name "bitpos", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[hash shift]"], :row 1251} {:fixed-arities #{3}, :end-row 1262, :ns "cljs.core", :name "caching-hash", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[coll hash-fn hash-key]"], :row 1255} {:fixed-arities #{5}, :end-row 1271, :private true, :ns "cljs.core", :name "do-curried", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[name doc meta args body]"], :row 1266} {:end-row 1277, :private true, :ns "cljs.core", :name "defcurried", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name doc meta args & body]"], :doc "Builds another arity of the fn that returns a fn awaiting the last\n  param", :row 1273} {:fixed-arities #{3}, :end-row 1288, :private true, :ns "cljs.core", :name "do-rfn", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[f1 k fkv]"], :row 1279} {:fixed-arities #{2}, :end-row 1293, :private true, :ns "cljs.core", :name "rfn", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[[f1 k] fkv]"], :doc "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.", :row 1290} {:fixed-arities #{1}, :end-row 1301, :private true, :ns "cljs.core", :name "protocol-prefix", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[psym]"], :row 1297} {:end-row 1311, :filename "cljs/core.cljc", :lang :clj, :name "base-type", :ns "cljs.core", :private true, :row 1303} {:end-row 1319, :filename "cljs/core.cljc", :lang :clj, :name "js-base-type", :ns "cljs.core", :private true, :row 1313} {:end-row 1380, :ns "cljs.core", :name "reify", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& impls]"], :doc "reify creates an object implementing a protocol.\n  reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \"foo\"]\n       (reify Object\n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"]\n       (reify ISeqable\n         (-seq [this] (seq f)))))\n  == (\"f\" \"o\" \"o\"))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", :row 1321} {:end-row 1388, :ns "cljs.core", :name "specify!", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & impls]"], :doc "Identical to reify but mutates its first argument.", :row 1382} {:end-row 1395, :ns "cljs.core", :name "specify", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & impls]"], :doc "Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance.", :row 1390} {:fixed-arities #{0}, :end-row 1398, :private true, :ns "cljs.core", :name "js-this", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 1397} {:end-row 1404, :ns "cljs.core", :name "this-as", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & body]"], :doc "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.", :row 1400} {:fixed-arities #{1}, :end-row 1407, :private true, :ns "cljs.core", :name "to-property", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[sym]"], :row 1406} {:fixed-arities #{3}, :end-row 1425, :private true, :ns "cljs.core", :name "update-protocol-var", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[p type env]"], :row 1409} {:fixed-arities #{2}, :end-row 1430, :private true, :ns "cljs.core", :name "resolve-var", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env sym]"], :row 1427} {:fixed-arities #{1}, :end-row 1437, :private true, :ns "cljs.core", :name "->impl-map", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[impls]"], :row 1432} {:fixed-arities #{5}, :end-row 1448, :private true, :ns "cljs.core", :name "base-assign-impls", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env resolve tsym type [p sigs]]"], :row 1439} {:end-row 1450, :filename "cljs/core.cljc", :lang :clj, :name "extend-prefix", :ns "cljs.core", :private true, :row 1450} {:fixed-arities #{2}, :end-row 1461, :private true, :ns "cljs.core", :name "adapt-obj-params", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1459} {:fixed-arities #{2}, :end-row 1468, :private true, :ns "cljs.core", :name "adapt-ifn-params", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1463} {:fixed-arities #{2}, :end-row 1474, :private true, :ns "cljs.core", :name "adapt-ifn-invoke-params", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1471} {:fixed-arities #{2}, :end-row 1480, :private true, :ns "cljs.core", :name "adapt-proto-params", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1476} {:fixed-arities #{3}, :end-row 1489, :private true, :ns "cljs.core", :name "add-obj-methods", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym sigs]"], :row 1482} {:fixed-arities #{3}, :end-row 1497, :private true, :ns "cljs.core", :name "ifn-invoke-methods", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym [f & meths :as form]]"], :row 1491} {:fixed-arities #{3}, :end-row 1518, :private true, :ns "cljs.core", :name "add-ifn-methods", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym [f & meths :as form]]"], :row 1499} {:fixed-arities #{4}, :end-row 1530, :private true, :ns "cljs.core", :name "add-proto-methods*", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[pprefix type type-sym [f & meths :as form]]"], :row 1520} {:fixed-arities #{5}, :end-row 1547, :private true, :ns "cljs.core", :name "proto-assign-impls", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env resolve type-sym type [p sigs]]"], :row 1532} {:fixed-arities #{3}, :end-row 1577, :private true, :ns "cljs.core", :name "validate-impl-sigs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env p method]"], :row 1549} {:fixed-arities #{2}, :end-row 1595, :private true, :ns "cljs.core", :name "validate-impls", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env impls]"], :row 1579} {:fixed-arities #{2}, :end-row 1599, :private true, :ns "cljs.core", :name "type-hint-first-arg", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym argv]"], :row 1597} {:fixed-arities #{2}, :end-row 1603, :private true, :ns "cljs.core", :name "type-hint-single-arity-sig", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1601} {:fixed-arities #{2}, :end-row 1607, :private true, :ns "cljs.core", :name "type-hint-multi-arity-sig", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1605} {:fixed-arities #{2}, :end-row 1611, :private true, :ns "cljs.core", :name "type-hint-multi-arity-sigs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sigs]"], :row 1609} {:fixed-arities #{2}, :end-row 1617, :private true, :ns "cljs.core", :name "type-hint-sigs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1613} {:fixed-arities #{2}, :end-row 1623, :private true, :ns "cljs.core", :name "type-hint-impl-map", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym impl-map]"], :row 1619} {:end-row 1665, :ns "cljs.core", :name "extend-type", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[type-sym & impls]"], :doc "Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y] ...) ...)", :row 1625} {:fixed-arities #{2}, :end-row 1687, :private true, :ns "cljs.core", :name "prepare-protocol-masks", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env impls]"], :row 1667} {:fixed-arities #{3}, :end-row 1692, :private true, :ns "cljs.core", :name "annotate-specs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[annots v [f sigs]]"], :row 1689} {:arglist-strs ["[type specs fields]" "[type specs fields inline]"], :end-row 1709, :filename "cljs/core.cljc", :fixed-arities #{4 3}, :lang :clj, :name "dt->et", :ns "cljs.core", :row 1694} {:fixed-arities #{2}, :end-row 1715, :private true, :ns "cljs.core", :name "collect-protocols", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[impls env]"], :row 1711} {:fixed-arities #{3}, :end-row 1726, :private true, :ns "cljs.core", :name "build-positional-factory", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[rsym rname fields]"], :row 1717} {:fixed-arities #{3}, :end-row 1733, :private true, :ns "cljs.core", :name "validate-fields", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[case name fields]"], :row 1728} {:end-row 1803, :ns "cljs.core", :name "deftype", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[t fields & impls]"], :doc "(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", :row 1735} {:fixed-arities #{5}, :end-row 1910, :private true, :ns "cljs.core", :name "emit-defrecord", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env tagname rname fields impls]"], :doc "Do not use this directly - use defrecord", :row 1805} {:fixed-arities #{3}, :end-row 1922, :private true, :ns "cljs.core", :name "build-map-factory", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[rsym rname fields]"], :row 1912} {:end-row 1991, :ns "cljs.core", :name "defrecord", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[rsym fields & impls]"], :doc "(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", :row 1924} {:end-row 2177, :ns "cljs.core", :name "defprotocol", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym & doc+methods]"], :doc "A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", :row 1993} {:fixed-arities #{2}, :end-row 2203, :ns "cljs.core", :name "implements?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym x]"], :doc "EXPERIMENTAL", :row 2179} {:fixed-arities #{2}, :end-row 2235, :ns "cljs.core", :name "satisfies?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym x]"], :doc "Returns true if x satisfies the protocol", :row 2205} {:end-row 2243, :ns "cljs.core", :name "lazy-seq", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls.", :row 2237} {:end-row 2251, :ns "cljs.core", :name "delay", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.", :row 2245} {:end-row 2275, :ns "cljs.core", :name "with-redefs", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing.", :row 2253} {:end-row 2288, :ns "cljs.core", :name "binding", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", :row 2277} {:end-row 2329, :ns "cljs.core", :name "condp", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[pred expr & clauses]"], :doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an Error is thrown.", :row 2290} {:fixed-arities #{4}, :end-row 2346, :private true, :ns "cljs.core", :name "assoc-test", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[m test expr env]"], :row 2331} {:fixed-arities #{2}, :end-row 2351, :private true, :ns "cljs.core", :name "const?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env x]"], :row 2348} {:end-row 2422, :ns "cljs.core", :name "case", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[e & clauses]"], :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", :row 2353} {:fixed-arities #{1}, :end-row 2425, :private true, :ns "cljs.core", :name "when-assert", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 2424} {:fixed-arities #{1 2}, :end-row 2438, :ns "cljs.core", :name "assert", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x message]"], :doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.", :row 2427} {:fixed-arities #{2}, :end-row 2525, :ns "cljs.core", :name "for", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[seq-exprs body-expr]"], :doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))", :row 2440} {:end-row 2581, :ns "cljs.core", :name "doseq", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[seq-exprs & body]"], :doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", :row 2527} {:arglist-strs ["[& rest]"], :end-row 2590, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "array", :ns "cljs.core", :row 2583} {:fixed-arities #{1 2}, :end-row 2608, :ns "cljs.core", :name "make-array", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[size]" "[type size]" "[type size & more-sizes]"], :row 2592} {:fixed-arities #{0 1}, :end-row 2617, :ns "cljs.core", :name "list", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & xs]"], :row 2610} {:fixed-arities #{0}, :end-row 2628, :ns "cljs.core", :name "vector", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& xs]"], :row 2619} {:fixed-arities #{0}, :end-row 2638, :ns "cljs.core", :name "array-map", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& kvs]"], :row 2630} {:fixed-arities #{0}, :end-row 2651, :ns "cljs.core", :name "hash-map", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& kvs]"], :row 2640} {:fixed-arities #{0}, :end-row 2665, :ns "cljs.core", :name "hash-set", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& xs]"], :row 2653} {:fixed-arities #{1}, :end-row 2674, :private true, :ns "cljs.core", :name "js-obj*", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[kvs]"], :row 2667} {:arglist-strs ["[& rest]"], :end-row 2694, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "js-obj", :ns "cljs.core", :row 2676} {:fixed-arities #{1}, :end-row 2699, :ns "cljs.core", :name "alength", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a]"], :row 2696} {:fixed-arities #{4}, :end-row 2715, :ns "cljs.core", :name "amap", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a idx ret expr]"], :doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret.", :row 2701} {:fixed-arities #{5}, :end-row 2727, :ns "cljs.core", :name "areduce", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a idx ret init expr]"], :doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret.", :row 2717} {:end-row 2741, :ns "cljs.core", :name "dotimes", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", :row 2729} {:end-row 2751, :private true, :ns "cljs.core", :name "check-valid-options", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[options & valid-keys]"], :doc "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", :row 2743} {:end-row 2798, :ns "cljs.core", :name "defmulti", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[mm-name & options]"], :doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy", :row 2753} {:end-row 2803, :ns "cljs.core", :name "defmethod", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[multifn dispatch-val & fn-tail]"], :doc "Creates and installs a new method of multimethod associated with dispatch-value. ", :row 2800} {:fixed-arities #{1}, :end-row 2813, :ns "cljs.core", :name "time", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr]"], :doc "Evaluates expr and prints the time it took. Returns the value of expr.", :row 2805} {:end-row 2831, :ns "cljs.core", :name "simple-benchmark", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]"], :doc "Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case.", :row 2815} {:end-row 2833, :filename "cljs/core.cljc", :lang :clj, :name "cs", :ns "cljs.core", :private true, :row 2833} {:fixed-arities #{0 1}, :end-row 2844, :private true, :ns "cljs.core", :name "gen-apply-to-helper", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[]" "[n]"], :row 2835} {:fixed-arities #{0}, :end-row 2854, :ns "cljs.core", :name "gen-apply-to", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 2846} {:fixed-arities #{3}, :end-row 2878, :private true, :ns "cljs.core", :name "gen-apply-to-simple-helper", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[f num-args args]"], :row 2856} {:fixed-arities #{3}, :end-row 2882, :ns "cljs.core", :name "gen-apply-to-simple", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[f num-args args]"], :row 2880} {:end-row 2893, :ns "cljs.core", :name "with-out-str", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls.", :row 2884} {:end-row 2902, :ns "cljs.core", :name "lazy-cat", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& colls]"], :doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", :row 2895} {:fixed-arities #{1}, :end-row 2905, :ns "cljs.core", :name "js-str", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[s]"], :row 2904} {:fixed-arities #{1}, :end-row 2911, :ns "cljs.core", :name "es6-iterable", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[ty]"], :row 2907} {:fixed-arities #{1}, :end-row 2927, :ns "cljs.core", :name "ns-publics", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the public intern mappings for the namespace.", :row 2913} {:fixed-arities #{1}, :end-row 2941, :ns "cljs.core", :name "ns-imports", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the import mappings for the namespace.", :row 2929} {:fixed-arities #{1}, :end-row 2955, :ns "cljs.core", :name "ns-interns", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the intern mappings for the namespace.", :row 2943} {:fixed-arities #{2}, :end-row 2967, :ns "cljs.core", :name "ns-unmap", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns quoted-sym]"], :doc "Removes the mappings for the symbol from the namespace.", :row 2957} {:end-row 2974, :ns "cljs.core", :name "vswap!", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[vol f & args]"], :doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", :row 2969} {:arglist-strs ["[x & forms]"], :end-row 2978, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "locking", :ns "cljs.core", :row 2976} {:fixed-arities #{0}, :end-row 2981, :private true, :ns "cljs.core", :name "ns-special-form", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 2981} {:end-row 3036, :ns "cljs.core", :name "require", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib's name also locates its root directory\n  within classpath using Java's package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace.\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n  :rename specifies a map from referred var names to different\n    symbols (and can be used to prevent clashes)\n\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require '[clojure.string :as string])", :row 2983} {:end-row 3041, :ns "cljs.core", :name "require-macros", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Similar to require but only for macros.", :row 3038} {:end-row 3054, :ns "cljs.core", :name "use", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Like require, but referring vars specified by the mandatory\n  :only option.\n\n  Example:\n\n  The following would load the library clojure.set while referring\n  the intersection var.\n\n  (use '[clojure.set :only [intersection]])", :row 3043} {:end-row 3059, :ns "cljs.core", :name "use-macros", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Similar to use but only for macros.", :row 3056} {:end-row 3068, :ns "cljs.core", :name "import", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& import-symbols-or-lists]"], :doc "import-list => (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", :row 3061} {:end-row 3081, :ns "cljs.core", :name "refer-clojure", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Refers to all the public vars of `cljs.core`, subject to\n  filters.\n  Filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  Filters can be used to select a subset, via exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent clashes.", :row 3070} {:fixed-arities #{1}, :end-row 3085, :ns "cljs.core", :name "load-file*", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[f]"], :row 3084} {:fixed-arities #{1}, :end-row 3096, :ns "cljs.core", :name "macroexpand-1", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted]"], :doc "If form represents a macro form, returns its expansion,\n  else returns form.", :row 3087} {:fixed-arities #{1}, :end-row 3112, :ns "cljs.core", :name "macroexpand", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted]"], :doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", :row 3098} {:fixed-arities #{1}, :end-row 3115, :private true, :ns "cljs.core", :name "multi-arity-fn?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 3114} {:fixed-arities #{1}, :end-row 3119, :private true, :ns "cljs.core", :name "variadic-fn?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 3117} {:fixed-arities #{3 2}, :end-row 3155, :private true, :ns "cljs.core", :name "variadic-fn*", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[sym method]" "[sym [arglist & body :as method] solo]"], :row 3121} {:fixed-arities #{1}, :end-row 3162, :ns "cljs.core", :name "copy-arguments", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[dest]"], :row 3157} {:fixed-arities #{1}, :end-row 3169, :private true, :ns "cljs.core", :name "elide-implicit-macro-args", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[arglists]"], :row 3164} {:fixed-arities #{4}, :end-row 3199, :private true, :ns "cljs.core", :name "variadic-fn", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[name meta [[arglist & body :as method] :as fdecl] emit-var?]"], :row 3171} {:fixed-arities #{4}, :end-row 3286, :private true, :ns "cljs.core", :name "multi-arity-fn", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[name meta fdecl emit-var?]"], :row 3209} {:doc "Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", :end-row 3368, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "defn", :ns "cljs.core", :row 3297} {:end-row 3414, :ns "cljs.core", :name "defmacro", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[&form &env name & args]"], :doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", :row 3373} {:fixed-arities #{1}, :end-row 3435, :ns "cljs.core", :name "resolve", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-sym]"], :doc "Returns the var to which a symbol will be resolved in the namespace else nil.", :row 3419} {:end-row 117, :ns "cljs.core", :name "->", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x & forms]"], :doc "Threads the expr through the forms. Inserts x as the\n     second item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     second item in second form, etc.", :row 104} {:end-row 133, :ns "cljs.core", :name "->>", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x & forms]"], :doc "Threads the expr through the forms. Inserts x as the\n     last item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     last item in second form, etc.", :row 120} {:fixed-arities #{2}, :end-row 151, :ns "cljs.core", :name "..", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x form]" "[x form & more]"], :doc "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n     Expands into a member access (.) of the first member on the first\n     argument, followed by the next member on the result, etc. For\n     instance:\n\n     (.. System (getProperties) (get \"os.name\"))\n\n     expands to:\n\n     (. (. System (getProperties)) (get \"os.name\"))\n\n     but is easier to write, read, and understand.", :row 136} {:end-row 156, :ns "cljs.core", :name "comment", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Ignores body, yields nil", :row 154} {:end-row 171, :ns "cljs.core", :name "cond", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& clauses]"], :doc "Takes a set of test/expr pairs. It evaluates each test one at a\n     time.  If a test returns logical true, cond evaluates and returns\n     the value of the corresponding expr and doesn't evaluate any of the\n     other tests or exprs. (cond) returns nil.", :row 159} {:end-row 176, :ns "cljs.core", :name "declare", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& names]"], :doc "defs the supplied var names with no bindings, useful for making forward declarations.", :row 174} {:end-row 192, :ns "cljs.core", :name "doto", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x & forms]"], :doc "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new js/Map) (.set \"a\" 1) (.set \"b\" 2))", :row 178} {:fixed-arities #{1}, :end-row 200, :private true, :ns "cljs.core", :name "parse-impls", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[specs]"], :row 195} {:fixed-arities #{2}, :end-row 208, :private true, :ns "cljs.core", :name "emit-extend-protocol", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[p specs]"], :row 203} {:end-row 247, :ns "cljs.core", :name "extend-protocol", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[p & specs]"], :doc "Useful when you want to provide several implementations of the same\n     protocol all at once. Takes a single protocol and the implementation\n     of that protocol for one or more types. Expands into calls to\n     extend-type:\n\n     (extend-protocol Protocol\n       AType\n         (foo [x] ...)\n         (bar [x y] ...)\n       BType\n         (foo [x] ...)\n         (bar [x y] ...)\n       AClass\n         (foo [x] ...)\n         (bar [x y] ...)\n       nil\n         (foo [x] ...)\n         (bar [x y] ...))\n\n     expands into:\n\n     (do\n      (clojure.core/extend-type AType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type BType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type AClass Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type nil Protocol\n        (foo [x] ...)\n        (bar [x y] ...)))", :row 211} {:fixed-arities #{2}, :end-row 266, :private true, :ns "cljs.core", :name "maybe-destructured", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[params body]"], :row 250} {:end-row 330, :ns "cljs.core", :name "fn", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& sigs]"], :doc "params => positional-params* , or positional-params* & rest-param\n     positional-param => binding-form\n     rest-param => binding-form\n     binding-form => name, or destructuring-form\n\n     Defines a function\n\n     See https://clojure.org/reference/special_forms#fn for more information", :row 269} {:end-row 336, :ns "cljs.core", :name "defn-", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & decls]"], :doc "same as defn, yielding non-public def", :row 333} {:fixed-arities #{3 2}, :end-row 356, :ns "cljs.core", :name "if-let", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings then]" "[bindings then else & oldform]"], :doc "bindings => binding-form test\n\n     If test is true, evaluates then with binding-form bound to the value of\n     test, if not, yields else", :row 339} {:fixed-arities #{3 2}, :end-row 364, :ns "cljs.core", :name "if-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[test then]" "[test then else]"], :doc "Evaluates test. If logical false, evaluates and returns then expr,\n     otherwise else expr, if supplied, else nil.", :row 359} {:end-row 378, :ns "cljs.core", :name "letfn", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[fnspecs & body]"], :doc "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n     Takes a vector of function specs and a body, and generates a set of\n     bindings of functions to their names. All of the names are available\n     in all of the definitions of the functions, as well as the body.", :row 367} {:end-row 389, :ns "cljs.core", :name "memfn", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & args]"], :doc "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a JavaScript\n  method as a first-class fn.", :row 380} {:end-row 395, :ns "cljs.core", :name "when", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[test & body]"], :doc "Evaluates test. If logical true, evaluates body in an implicit do.", :row 392} {:end-row 409, :ns "cljs.core", :name "when-first", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => x xs\n\n     Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", :row 398} {:end-row 424, :ns "cljs.core", :name "when-let", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => binding-form test\n\n     When test is true, evaluates body with binding-form bound to the value of test", :row 412} {:end-row 430, :ns "cljs.core", :name "when-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[test & body]"], :doc "Evaluates test. If logical false, evaluates body in an implicit do.", :row 427} {:end-row 440, :ns "cljs.core", :name "while", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[test & body]"], :doc "Repeatedly executes body while test expression is true. Presumes\n     some side-effect will cause test to become false/nil. Returns nil", :row 433} {:end-row 457, :ns "cljs.core", :name "cond->", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & clauses]"], :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n     through each form for which the corresponding test\n     expression is true. Note that, unlike cond branching, cond-> threading does\n     not short circuit after the first true test expression.", :row 443} {:end-row 474, :ns "cljs.core", :name "cond->>", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & clauses]"], :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n     through each form for which the corresponding test expression\n     is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n     after the first true test expression.", :row 460} {:end-row 486, :ns "cljs.core", :name "as->", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr name & forms]"], :doc "Binds name to expr, evaluates the first form in the lexical context\n     of that binding, then binds name to that result, repeating for each\n     successive form, returning the result of the last form.", :row 477} {:end-row 500, :ns "cljs.core", :name "some->", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & forms]"], :doc "When expr is not nil, threads it into the first form (via ->),\n     and when that result is not nil, through the next etc", :row 489} {:end-row 514, :ns "cljs.core", :name "some->>", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & forms]"], :doc "When expr is not nil, threads it into the first form (via ->>),\n     and when that result is not nil, through the next etc", :row 503} {:fixed-arities #{3 2}, :end-row 534, :ns "cljs.core", :name "if-some", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings then]" "[bindings then else & oldform]"], :doc "bindings => binding-form test\n\n      If test is not nil, evaluates then with binding-form bound to the\n      value of test, if not, yields else", :row 517} {:end-row 551, :ns "cljs.core", :name "when-some", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => binding-form test\n\n      When test is not nil, evaluates body with binding-form bound to the\n      value of test", :row 537} {:fixed-arities #{1}, :end-row 590, :private true, :ns "cljs.core", :name "assert-valid-fdecl", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :doc "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.", :row 553} {:fixed-arities #{1}, :end-row 617, :private true, :ns "cljs.core", :name "sigs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 592} {:fixed-arities #{2}, :end-row 627, :ns "cljs.core", :name "defonce", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x init]"], :doc "defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated", :row 619} {:arglist-strs ["[bindings]"], :end-row 730, :filename "cljs/core.cljc", :fixed-arities #{1}, :lang :cljs, :name "destructure", :ns "cljs.core", :row 629} {:end-row 736, :private true, :ns "cljs.core", :name "return-first", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :row 732} {:fixed-arities #{2}, :end-row 770, :ns "cljs.core", :name "goog-define", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[sym default]"], :doc "Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n    or\n    :closure-defines {your-app.core/DEBUG! true}", :row 738} {:end-row 787, :ns "cljs.core", :name "let", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => binding-form init-expr\n  binding-form => name, or destructuring-form\n  destructuring-form => map-destructure-form, or seq-destructure-form\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\n\n  See https://clojure.org/reference/special_forms#binding-forms for\n  more information about destructuring.", :row 772} {:end-row 811, :ns "cljs.core", :name "loop", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", :row 789} {:doc "protocol fqn -> [partition number, bit]", :end-row 829, :filename "cljs/core.cljc", :lang :cljs, :name "fast-path-protocols", :ns "cljs.core", :row 813} {:doc "total number of partitions", :end-row 837, :filename "cljs/core.cljc", :lang :cljs, :name "fast-path-protocol-partitions-count", :ns "cljs.core", :row 831} {:fixed-arities #{2}, :end-row 842, :private true, :ns "cljs.core", :name "compatible?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[inferred-tag allowed-tags]"], :row 839} {:fixed-arities #{3}, :end-row 847, :private true, :ns "cljs.core", :name "typed-expr?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env form allowed-tags]"], :row 844} {:fixed-arities #{1}, :end-row 850, :private true, :ns "cljs.core", :name "string-expr", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[e]"], :row 849} {:fixed-arities #{0 1}, :end-row 867, :ns "cljs.core", :name "str", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & ys]"], :row 852} {:fixed-arities #{1}, :end-row 870, :private true, :ns "cljs.core", :name "bool-expr", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[e]"], :row 869} {:fixed-arities #{2}, :end-row 875, :private true, :ns "cljs.core", :name "simple-test-expr?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env ast]"], :row 872} {:fixed-arities #{0 1}, :end-row 886, :ns "cljs.core", :name "and", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", :row 877} {:fixed-arities #{0 1}, :end-row 897, :ns "cljs.core", :name "or", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", :row 888} {:fixed-arities #{1}, :end-row 900, :ns "cljs.core", :name "nil?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 899} {:fixed-arities #{1}, :end-row 903, :ns "cljs.core", :name "some?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 902} {:fixed-arities #{1}, :end-row 906, :ns "cljs.core", :name "coercive-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 905} {:fixed-arities #{2}, :end-row 909, :ns "cljs.core", :name "coercive-not=", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]"], :row 908} {:fixed-arities #{2}, :end-row 912, :ns "cljs.core", :name "coercive-=", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]"], :row 911} {:fixed-arities #{1}, :end-row 916, :ns "cljs.core", :name "coercive-boolean", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 914} {:fixed-arities #{1}, :end-row 921, :ns "cljs.core", :name "truth_", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 919} {:fixed-arities #{0}, :end-row 924, :ns "cljs.core", :name "js-arguments", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 923} {:fixed-arities #{2}, :end-row 927, :ns "cljs.core", :name "js-delete", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key]"], :row 926} {:fixed-arities #{2}, :end-row 930, :ns "cljs.core", :name "js-in", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[key obj]"], :row 929} {:fixed-arities #{0}, :end-row 937, :ns "cljs.core", :name "js-debugger", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :doc "Emit JavaScript \"debugger;\" statement", :row 932} {:fixed-arities #{1}, :end-row 951, :ns "cljs.core", :name "js-comment", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[comment]"], :doc "Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline", :row 939} {:fixed-arities #{2}, :end-row 957, :ns "cljs.core", :name "unsafe-cast", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[t x]"], :doc "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type.", :row 953} {:fixed-arities #{1}, :end-row 962, :ns "cljs.core", :name "js-inline-comment", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[comment]"], :doc "Emit an inline JavaScript comment.", :row 959} {:fixed-arities #{1}, :end-row 965, :ns "cljs.core", :name "true?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 964} {:fixed-arities #{1}, :end-row 968, :ns "cljs.core", :name "false?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 967} {:fixed-arities #{1}, :end-row 971, :ns "cljs.core", :name "string?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 970} {:fixed-arities #{1}, :end-row 974, :ns "cljs.core", :name "js-fn?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 973} {:fixed-arities #{1}, :end-row 991, :ns "cljs.core", :name "exists?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :doc "Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript.", :row 976} {:fixed-arities #{1}, :end-row 996, :ns "cljs.core", :name "undefined?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :doc "Return true if argument is identical to the JavaScript undefined value.", :row 993} {:fixed-arities #{2}, :end-row 999, :ns "cljs.core", :name "identical?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a b]"], :row 998} {:fixed-arities #{2}, :end-row 1008, :ns "cljs.core", :name "instance?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[c x]"], :row 1001} {:fixed-arities #{1}, :end-row 1011, :ns "cljs.core", :name "number?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1010} {:fixed-arities #{1}, :end-row 1014, :ns "cljs.core", :name "symbol?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1013} {:fixed-arities #{1}, :end-row 1017, :ns "cljs.core", :name "keyword?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1016} {:fixed-arities #{2}, :end-row 1030, :ns "cljs.core", :name "aget", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[array idx]" "[array idx & idxs]"], :row 1019} {:fixed-arities #{3}, :end-row 1044, :ns "cljs.core", :name "aset", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :row 1032} {:fixed-arities #{2}, :end-row 1051, :ns "cljs.core", :name "unchecked-get", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key]"], :doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :row 1046} {:fixed-arities #{3}, :end-row 1058, :ns "cljs.core", :name "unchecked-set", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key val]"], :doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :row 1053} {:fixed-arities #{0 1 2}, :end-row 1064, :ns "cljs.core", :name "+", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :row 1060} {:fixed-arities #{1}, :end-row 1066, :ns "cljs.core", :name "byte", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1066} {:fixed-arities #{1}, :end-row 1067, :ns "cljs.core", :name "short", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1067} {:fixed-arities #{1}, :end-row 1068, :ns "cljs.core", :name "float", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1068} {:fixed-arities #{1}, :end-row 1069, :ns "cljs.core", :name "double", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1069} {:fixed-arities #{1}, :end-row 1071, :ns "cljs.core", :name "unchecked-byte", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1071} {:fixed-arities #{1}, :end-row 1072, :ns "cljs.core", :name "unchecked-char", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1072} {:fixed-arities #{1}, :end-row 1073, :ns "cljs.core", :name "unchecked-short", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1073} {:fixed-arities #{1}, :end-row 1074, :ns "cljs.core", :name "unchecked-float", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1074} {:fixed-arities #{1}, :end-row 1075, :ns "cljs.core", :name "unchecked-double", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1075} {:arglist-strs ["[& xs]"], :end-row 1078, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-add", :ns "cljs.core", :row 1077} {:arglist-strs ["[& xs]"], :end-row 1081, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-add-int", :ns "cljs.core", :row 1080} {:fixed-arities #{1}, :end-row 1084, :ns "cljs.core", :name "unchecked-dec", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1083} {:fixed-arities #{1}, :end-row 1087, :ns "cljs.core", :name "unchecked-dec-int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1086} {:arglist-strs ["[& xs]"], :end-row 1090, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-divide-int", :ns "cljs.core", :row 1089} {:fixed-arities #{1}, :end-row 1093, :ns "cljs.core", :name "unchecked-inc", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1092} {:fixed-arities #{1}, :end-row 1096, :ns "cljs.core", :name "unchecked-inc-int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1095} {:arglist-strs ["[& xs]"], :end-row 1099, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-multiply", :ns "cljs.core", :row 1098} {:arglist-strs ["[& xs]"], :end-row 1102, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-multiply-int", :ns "cljs.core", :row 1101} {:fixed-arities #{1}, :end-row 1105, :ns "cljs.core", :name "unchecked-negate", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1104} {:fixed-arities #{1}, :end-row 1108, :ns "cljs.core", :name "unchecked-negate-int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1107} {:fixed-arities #{2}, :end-row 1111, :ns "cljs.core", :name "unchecked-remainder-int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1110} {:arglist-strs ["[& xs]"], :end-row 1114, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-subtract", :ns "cljs.core", :row 1113} {:arglist-strs ["[& xs]"], :end-row 1117, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-subtract-int", :ns "cljs.core", :row 1116} {:fixed-arities #{1 2}, :end-row 1122, :ns "cljs.core", :name "-", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1119} {:fixed-arities #{0 1 2}, :end-row 1128, :ns "cljs.core", :name "*", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :row 1124} {:fixed-arities #{1 2}, :end-row 1133, :ns "cljs.core", :name "/", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1130} {:fixed-arities #{1 2}, :end-row 1138, :ns "cljs.core", :name "divide", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1135} {:fixed-arities #{1 2}, :end-row 1143, :ns "cljs.core", :name "<", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1140} {:fixed-arities #{1 2}, :end-row 1148, :ns "cljs.core", :name "<=", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1145} {:fixed-arities #{1 2}, :end-row 1153, :ns "cljs.core", :name ">", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1150} {:fixed-arities #{1 2}, :end-row 1158, :ns "cljs.core", :name ">=", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1155} {:fixed-arities #{1 2}, :end-row 1163, :ns "cljs.core", :name "==", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1160} {:fixed-arities #{1}, :end-row 1166, :ns "cljs.core", :name "dec", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1165} {:fixed-arities #{1}, :end-row 1169, :ns "cljs.core", :name "inc", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1168} {:fixed-arities #{1}, :end-row 1172, :ns "cljs.core", :name "zero?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1171} {:fixed-arities #{1}, :end-row 1175, :ns "cljs.core", :name "pos?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1174} {:fixed-arities #{1}, :end-row 1178, :ns "cljs.core", :name "neg?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1177} {:fixed-arities #{1 2}, :end-row 1184, :ns "cljs.core", :name "max", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1180} {:fixed-arities #{1 2}, :end-row 1190, :ns "cljs.core", :name "min", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1186} {:fixed-arities #{2}, :end-row 1193, :ns "cljs.core", :name "js-mod", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[num div]"], :row 1192} {:fixed-arities #{1}, :end-row 1196, :ns "cljs.core", :name "bit-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1195} {:fixed-arities #{2}, :end-row 1200, :ns "cljs.core", :name "bit-and", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1198} {:fixed-arities #{2}, :end-row 1205, :ns "cljs.core", :name "unsafe-bit-and", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1203} {:fixed-arities #{2}, :end-row 1209, :ns "cljs.core", :name "bit-or", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1207} {:fixed-arities #{1}, :end-row 1212, :ns "cljs.core", :name "int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1211} {:fixed-arities #{2}, :end-row 1216, :ns "cljs.core", :name "bit-xor", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1214} {:fixed-arities #{2}, :end-row 1220, :ns "cljs.core", :name "bit-and-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1218} {:fixed-arities #{2}, :end-row 1223, :ns "cljs.core", :name "bit-clear", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1222} {:fixed-arities #{2}, :end-row 1226, :ns "cljs.core", :name "bit-flip", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1225} {:fixed-arities #{2}, :end-row 1229, :ns "cljs.core", :name "bit-test", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1228} {:fixed-arities #{2}, :end-row 1232, :ns "cljs.core", :name "bit-shift-left", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1231} {:fixed-arities #{2}, :end-row 1235, :ns "cljs.core", :name "bit-shift-right", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1234} {:fixed-arities #{2}, :end-row 1238, :ns "cljs.core", :name "bit-shift-right-zero-fill", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1237} {:fixed-arities #{2}, :end-row 1241, :ns "cljs.core", :name "unsigned-bit-shift-right", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1240} {:fixed-arities #{2}, :end-row 1244, :ns "cljs.core", :name "bit-set", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1243} {:fixed-arities #{2}, :end-row 1248, :ns "cljs.core", :name "mask", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[hash shift]"], :row 1247} {:fixed-arities #{2}, :end-row 1252, :ns "cljs.core", :name "bitpos", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[hash shift]"], :row 1251} {:fixed-arities #{3}, :end-row 1262, :ns "cljs.core", :name "caching-hash", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[coll hash-fn hash-key]"], :row 1255} {:fixed-arities #{5}, :end-row 1271, :private true, :ns "cljs.core", :name "do-curried", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[name doc meta args body]"], :row 1266} {:end-row 1277, :private true, :ns "cljs.core", :name "defcurried", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name doc meta args & body]"], :doc "Builds another arity of the fn that returns a fn awaiting the last\n  param", :row 1273} {:fixed-arities #{3}, :end-row 1288, :private true, :ns "cljs.core", :name "do-rfn", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[f1 k fkv]"], :row 1279} {:fixed-arities #{2}, :end-row 1293, :private true, :ns "cljs.core", :name "rfn", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[[f1 k] fkv]"], :doc "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.", :row 1290} {:fixed-arities #{1}, :end-row 1301, :private true, :ns "cljs.core", :name "protocol-prefix", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[psym]"], :row 1297} {:end-row 1311, :filename "cljs/core.cljc", :lang :cljs, :name "base-type", :ns "cljs.core", :private true, :row 1303} {:end-row 1319, :filename "cljs/core.cljc", :lang :cljs, :name "js-base-type", :ns "cljs.core", :private true, :row 1313} {:end-row 1380, :ns "cljs.core", :name "reify", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& impls]"], :doc "reify creates an object implementing a protocol.\n  reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \"foo\"]\n       (reify Object\n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"]\n       (reify ISeqable\n         (-seq [this] (seq f)))))\n  == (\"f\" \"o\" \"o\"))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", :row 1321} {:end-row 1388, :ns "cljs.core", :name "specify!", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & impls]"], :doc "Identical to reify but mutates its first argument.", :row 1382} {:end-row 1395, :ns "cljs.core", :name "specify", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & impls]"], :doc "Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance.", :row 1390} {:fixed-arities #{0}, :end-row 1398, :private true, :ns "cljs.core", :name "js-this", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 1397} {:end-row 1404, :ns "cljs.core", :name "this-as", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & body]"], :doc "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.", :row 1400} {:fixed-arities #{1}, :end-row 1407, :private true, :ns "cljs.core", :name "to-property", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[sym]"], :row 1406} {:fixed-arities #{3}, :end-row 1425, :private true, :ns "cljs.core", :name "update-protocol-var", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[p type env]"], :row 1409} {:fixed-arities #{2}, :end-row 1430, :private true, :ns "cljs.core", :name "resolve-var", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env sym]"], :row 1427} {:fixed-arities #{1}, :end-row 1437, :private true, :ns "cljs.core", :name "->impl-map", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[impls]"], :row 1432} {:fixed-arities #{5}, :end-row 1448, :private true, :ns "cljs.core", :name "base-assign-impls", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env resolve tsym type [p sigs]]"], :row 1439} {:end-row 1450, :filename "cljs/core.cljc", :lang :cljs, :name "extend-prefix", :ns "cljs.core", :private true, :row 1450} {:fixed-arities #{2}, :end-row 1461, :private true, :ns "cljs.core", :name "adapt-obj-params", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1459} {:fixed-arities #{2}, :end-row 1468, :private true, :ns "cljs.core", :name "adapt-ifn-params", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1463} {:fixed-arities #{2}, :end-row 1474, :private true, :ns "cljs.core", :name "adapt-ifn-invoke-params", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1471} {:fixed-arities #{2}, :end-row 1480, :private true, :ns "cljs.core", :name "adapt-proto-params", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1476} {:fixed-arities #{3}, :end-row 1489, :private true, :ns "cljs.core", :name "add-obj-methods", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym sigs]"], :row 1482} {:fixed-arities #{3}, :end-row 1497, :private true, :ns "cljs.core", :name "ifn-invoke-methods", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym [f & meths :as form]]"], :row 1491} {:fixed-arities #{3}, :end-row 1518, :private true, :ns "cljs.core", :name "add-ifn-methods", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym [f & meths :as form]]"], :row 1499} {:fixed-arities #{4}, :end-row 1530, :private true, :ns "cljs.core", :name "add-proto-methods*", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[pprefix type type-sym [f & meths :as form]]"], :row 1520} {:fixed-arities #{5}, :end-row 1547, :private true, :ns "cljs.core", :name "proto-assign-impls", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env resolve type-sym type [p sigs]]"], :row 1532} {:fixed-arities #{3}, :end-row 1577, :private true, :ns "cljs.core", :name "validate-impl-sigs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env p method]"], :row 1549} {:fixed-arities #{2}, :end-row 1595, :private true, :ns "cljs.core", :name "validate-impls", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env impls]"], :row 1579} {:fixed-arities #{2}, :end-row 1599, :private true, :ns "cljs.core", :name "type-hint-first-arg", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym argv]"], :row 1597} {:fixed-arities #{2}, :end-row 1603, :private true, :ns "cljs.core", :name "type-hint-single-arity-sig", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1601} {:fixed-arities #{2}, :end-row 1607, :private true, :ns "cljs.core", :name "type-hint-multi-arity-sig", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1605} {:fixed-arities #{2}, :end-row 1611, :private true, :ns "cljs.core", :name "type-hint-multi-arity-sigs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sigs]"], :row 1609} {:fixed-arities #{2}, :end-row 1617, :private true, :ns "cljs.core", :name "type-hint-sigs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1613} {:fixed-arities #{2}, :end-row 1623, :private true, :ns "cljs.core", :name "type-hint-impl-map", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym impl-map]"], :row 1619} {:end-row 1665, :ns "cljs.core", :name "extend-type", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[type-sym & impls]"], :doc "Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y] ...) ...)", :row 1625} {:fixed-arities #{2}, :end-row 1687, :private true, :ns "cljs.core", :name "prepare-protocol-masks", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env impls]"], :row 1667} {:fixed-arities #{3}, :end-row 1692, :private true, :ns "cljs.core", :name "annotate-specs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[annots v [f sigs]]"], :row 1689} {:arglist-strs ["[type specs fields]" "[type specs fields inline]"], :end-row 1709, :filename "cljs/core.cljc", :fixed-arities #{4 3}, :lang :cljs, :name "dt->et", :ns "cljs.core", :row 1694} {:fixed-arities #{2}, :end-row 1715, :private true, :ns "cljs.core", :name "collect-protocols", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[impls env]"], :row 1711} {:fixed-arities #{3}, :end-row 1726, :private true, :ns "cljs.core", :name "build-positional-factory", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[rsym rname fields]"], :row 1717} {:fixed-arities #{3}, :end-row 1733, :private true, :ns "cljs.core", :name "validate-fields", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[case name fields]"], :row 1728} {:end-row 1803, :ns "cljs.core", :name "deftype", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[t fields & impls]"], :doc "(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", :row 1735} {:fixed-arities #{5}, :end-row 1910, :private true, :ns "cljs.core", :name "emit-defrecord", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env tagname rname fields impls]"], :doc "Do not use this directly - use defrecord", :row 1805} {:fixed-arities #{3}, :end-row 1922, :private true, :ns "cljs.core", :name "build-map-factory", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[rsym rname fields]"], :row 1912} {:end-row 1991, :ns "cljs.core", :name "defrecord", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[rsym fields & impls]"], :doc "(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", :row 1924} {:end-row 2177, :ns "cljs.core", :name "defprotocol", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym & doc+methods]"], :doc "A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", :row 1993} {:fixed-arities #{2}, :end-row 2203, :ns "cljs.core", :name "implements?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym x]"], :doc "EXPERIMENTAL", :row 2179} {:fixed-arities #{2}, :end-row 2235, :ns "cljs.core", :name "satisfies?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym x]"], :doc "Returns true if x satisfies the protocol", :row 2205} {:end-row 2243, :ns "cljs.core", :name "lazy-seq", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls.", :row 2237} {:end-row 2251, :ns "cljs.core", :name "delay", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.", :row 2245} {:end-row 2275, :ns "cljs.core", :name "with-redefs", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing.", :row 2253} {:end-row 2288, :ns "cljs.core", :name "binding", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", :row 2277} {:end-row 2329, :ns "cljs.core", :name "condp", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[pred expr & clauses]"], :doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an Error is thrown.", :row 2290} {:fixed-arities #{4}, :end-row 2346, :private true, :ns "cljs.core", :name "assoc-test", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[m test expr env]"], :row 2331} {:fixed-arities #{2}, :end-row 2351, :private true, :ns "cljs.core", :name "const?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env x]"], :row 2348} {:end-row 2422, :ns "cljs.core", :name "case", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[e & clauses]"], :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", :row 2353} {:fixed-arities #{1}, :end-row 2425, :private true, :ns "cljs.core", :name "when-assert", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 2424} {:fixed-arities #{1 2}, :end-row 2438, :ns "cljs.core", :name "assert", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x message]"], :doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.", :row 2427} {:fixed-arities #{2}, :end-row 2525, :ns "cljs.core", :name "for", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[seq-exprs body-expr]"], :doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))", :row 2440} {:end-row 2581, :ns "cljs.core", :name "doseq", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[seq-exprs & body]"], :doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", :row 2527} {:arglist-strs ["[& rest]"], :end-row 2590, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "array", :ns "cljs.core", :row 2583} {:fixed-arities #{1 2}, :end-row 2608, :ns "cljs.core", :name "make-array", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[size]" "[type size]" "[type size & more-sizes]"], :row 2592} {:fixed-arities #{0 1}, :end-row 2617, :ns "cljs.core", :name "list", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & xs]"], :row 2610} {:fixed-arities #{0}, :end-row 2628, :ns "cljs.core", :name "vector", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& xs]"], :row 2619} {:fixed-arities #{0}, :end-row 2638, :ns "cljs.core", :name "array-map", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& kvs]"], :row 2630} {:fixed-arities #{0}, :end-row 2651, :ns "cljs.core", :name "hash-map", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& kvs]"], :row 2640} {:fixed-arities #{0}, :end-row 2665, :ns "cljs.core", :name "hash-set", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& xs]"], :row 2653} {:fixed-arities #{1}, :end-row 2674, :private true, :ns "cljs.core", :name "js-obj*", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[kvs]"], :row 2667} {:arglist-strs ["[& rest]"], :end-row 2694, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "js-obj", :ns "cljs.core", :row 2676} {:fixed-arities #{1}, :end-row 2699, :ns "cljs.core", :name "alength", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a]"], :row 2696} {:fixed-arities #{4}, :end-row 2715, :ns "cljs.core", :name "amap", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a idx ret expr]"], :doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret.", :row 2701} {:fixed-arities #{5}, :end-row 2727, :ns "cljs.core", :name "areduce", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a idx ret init expr]"], :doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret.", :row 2717} {:end-row 2741, :ns "cljs.core", :name "dotimes", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", :row 2729} {:end-row 2751, :private true, :ns "cljs.core", :name "check-valid-options", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[options & valid-keys]"], :doc "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", :row 2743} {:end-row 2798, :ns "cljs.core", :name "defmulti", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[mm-name & options]"], :doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy", :row 2753} {:end-row 2803, :ns "cljs.core", :name "defmethod", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[multifn dispatch-val & fn-tail]"], :doc "Creates and installs a new method of multimethod associated with dispatch-value. ", :row 2800} {:fixed-arities #{1}, :end-row 2813, :ns "cljs.core", :name "time", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr]"], :doc "Evaluates expr and prints the time it took. Returns the value of expr.", :row 2805} {:end-row 2831, :ns "cljs.core", :name "simple-benchmark", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]"], :doc "Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case.", :row 2815} {:end-row 2833, :filename "cljs/core.cljc", :lang :cljs, :name "cs", :ns "cljs.core", :private true, :row 2833} {:fixed-arities #{0 1}, :end-row 2844, :private true, :ns "cljs.core", :name "gen-apply-to-helper", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[]" "[n]"], :row 2835} {:fixed-arities #{0}, :end-row 2854, :ns "cljs.core", :name "gen-apply-to", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 2846} {:fixed-arities #{3}, :end-row 2878, :private true, :ns "cljs.core", :name "gen-apply-to-simple-helper", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[f num-args args]"], :row 2856} {:fixed-arities #{3}, :end-row 2882, :ns "cljs.core", :name "gen-apply-to-simple", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[f num-args args]"], :row 2880} {:end-row 2893, :ns "cljs.core", :name "with-out-str", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls.", :row 2884} {:end-row 2902, :ns "cljs.core", :name "lazy-cat", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& colls]"], :doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", :row 2895} {:fixed-arities #{1}, :end-row 2905, :ns "cljs.core", :name "js-str", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[s]"], :row 2904} {:fixed-arities #{1}, :end-row 2911, :ns "cljs.core", :name "es6-iterable", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[ty]"], :row 2907} {:fixed-arities #{1}, :end-row 2927, :ns "cljs.core", :name "ns-publics", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the public intern mappings for the namespace.", :row 2913} {:fixed-arities #{1}, :end-row 2941, :ns "cljs.core", :name "ns-imports", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the import mappings for the namespace.", :row 2929} {:fixed-arities #{1}, :end-row 2955, :ns "cljs.core", :name "ns-interns", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the intern mappings for the namespace.", :row 2943} {:fixed-arities #{2}, :end-row 2967, :ns "cljs.core", :name "ns-unmap", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns quoted-sym]"], :doc "Removes the mappings for the symbol from the namespace.", :row 2957} {:end-row 2974, :ns "cljs.core", :name "vswap!", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[vol f & args]"], :doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", :row 2969} {:arglist-strs ["[x & forms]"], :end-row 2978, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "locking", :ns "cljs.core", :row 2976} {:fixed-arities #{0}, :end-row 2981, :private true, :ns "cljs.core", :name "ns-special-form", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 2981} {:end-row 3036, :ns "cljs.core", :name "require", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib's name also locates its root directory\n  within classpath using Java's package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace.\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n  :rename specifies a map from referred var names to different\n    symbols (and can be used to prevent clashes)\n\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require '[clojure.string :as string])", :row 2983} {:end-row 3041, :ns "cljs.core", :name "require-macros", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Similar to require but only for macros.", :row 3038} {:end-row 3054, :ns "cljs.core", :name "use", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Like require, but referring vars specified by the mandatory\n  :only option.\n\n  Example:\n\n  The following would load the library clojure.set while referring\n  the intersection var.\n\n  (use '[clojure.set :only [intersection]])", :row 3043} {:end-row 3059, :ns "cljs.core", :name "use-macros", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Similar to use but only for macros.", :row 3056} {:end-row 3068, :ns "cljs.core", :name "import", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& import-symbols-or-lists]"], :doc "import-list => (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", :row 3061} {:end-row 3081, :ns "cljs.core", :name "refer-clojure", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Refers to all the public vars of `cljs.core`, subject to\n  filters.\n  Filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  Filters can be used to select a subset, via exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent clashes.", :row 3070} {:fixed-arities #{1}, :end-row 3085, :ns "cljs.core", :name "load-file*", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[f]"], :row 3084} {:fixed-arities #{1}, :end-row 3096, :ns "cljs.core", :name "macroexpand-1", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted]"], :doc "If form represents a macro form, returns its expansion,\n  else returns form.", :row 3087} {:fixed-arities #{1}, :end-row 3112, :ns "cljs.core", :name "macroexpand", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted]"], :doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", :row 3098} {:fixed-arities #{1}, :end-row 3115, :private true, :ns "cljs.core", :name "multi-arity-fn?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 3114} {:fixed-arities #{1}, :end-row 3119, :private true, :ns "cljs.core", :name "variadic-fn?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 3117} {:fixed-arities #{3 2}, :end-row 3155, :private true, :ns "cljs.core", :name "variadic-fn*", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[sym method]" "[sym [arglist & body :as method] solo]"], :row 3121} {:fixed-arities #{1}, :end-row 3162, :ns "cljs.core", :name "copy-arguments", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[dest]"], :row 3157} {:fixed-arities #{1}, :end-row 3169, :private true, :ns "cljs.core", :name "elide-implicit-macro-args", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[arglists]"], :row 3164} {:fixed-arities #{4}, :end-row 3199, :private true, :ns "cljs.core", :name "variadic-fn", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[name meta [[arglist & body :as method] :as fdecl] emit-var?]"], :row 3171} {:fixed-arities #{4}, :end-row 3286, :private true, :ns "cljs.core", :name "multi-arity-fn", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[name meta fdecl emit-var?]"], :row 3209} {:doc "Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", :end-row 3368, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "defn", :ns "cljs.core", :row 3297} {:end-row 3414, :ns "cljs.core", :name "defmacro", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[&form &env name & args]"], :doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", :row 3373} {:fixed-arities #{1}, :end-row 3435, :ns "cljs.core", :name "resolve", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-sym]"], :doc "Returns the var to which a symbol will be resolved in the namespace else nil.", :row 3419} {:end-row 19, :filename "cljs/core.cljs", :name "*clojurescript-version*", :ns "cljs.core", :row 19} {:end-row 26, :filename "cljs/core.cljs", :name "*unchecked-if*", :ns "cljs.core", :row 26} {:end-row 30, :filename "cljs/core.cljs", :name "*unchecked-arrays*", :ns "cljs.core", :row 30} {:end-row 33, :filename "cljs/core.cljs", :name "*warn-on-infer*", :ns "cljs.core", :row 33} {:end-row 37, :filename "cljs/core.cljs", :name "PROTOCOL_SENTINEL", :ns "cljs.core", :row 37} {:end-row 39, :filename "cljs/core.cljs", :name "MODULE_URIS", :ns "cljs.core", :row 39} {:end-row 40, :filename "cljs/core.cljs", :name "MODULE_INFOS", :ns "cljs.core", :row 40} {:doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :end-row 48, :filename "cljs/core.cljs", :name "*target*", :ns "cljs.core", :row 42} {:doc "Manually set the JavaScript global context. Only \"window\", \"self\"\n  , and \"global\" supported. ", :end-row 54, :filename "cljs/core.cljs", :name "*global*", :ns "cljs.core", :row 50} {:doc "Var bound to the current namespace. Only used for bootstrapping.", :end-row 60, :filename "cljs/core.cljs", :name "*ns*", :ns "cljs.core", :row 56} {:end-row 65, :filename "cljs/core.cljs", :name "*out*", :ns "cljs.core", :row 62} {:end-row 69, :filename "cljs/core.cljs", :name "*assert*", :ns "cljs.core", :row 67} {:doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :end-row 75, :filename "cljs/core.cljs", :name "*print-fn*", :ns "cljs.core", :row 71} {:end-row 77, :filename "cljs/core.cljs", :name "boolean", :ns "cljs.core", :row 77} {:arglist-strs ["[f]"], :doc "Arranges to have tap functions executed via the supplied f, a\n  function of no arguments. Returns true if successful, false otherwise.", :end-row 86, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "*exec-tap-fn*", :ns "cljs.core", :row 79} {:doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed.", :end-row 92, :filename "cljs/core.cljs", :name "*print-err-fn*", :ns "cljs.core", :row 88} {:arglist-strs ["[f]"], :doc "Set *print-fn* to f.", :end-row 96, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set-print-fn!", :ns "cljs.core", :row 94} {:arglist-strs ["[f]"], :doc "Set *print-err-fn* to f.", :end-row 100, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set-print-err-fn!", :ns "cljs.core", :row 98} {:doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", :end-row 107, :filename "cljs/core.cljs", :name "*flush-on-newline*", :ns "cljs.core", :row 102} {:doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects.", :end-row 114, :filename "cljs/core.cljs", :name "*print-newline*", :ns "cljs.core", :row 109} {:doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", :end-row 122, :filename "cljs/core.cljs", :name "*print-readably*", :ns "cljs.core", :row 116} {:doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", :end-row 130, :filename "cljs/core.cljs", :name "*print-meta*", :ns "cljs.core", :row 124} {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :end-row 138, :filename "cljs/core.cljs", :name "*print-dup*", :ns "cljs.core", :row 132} {:doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true.", :end-row 146, :filename "cljs/core.cljs", :name "*print-namespace-maps*", :ns "cljs.core", :row 140} {:doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", :end-row 158, :filename "cljs/core.cljs", :name "*print-length*", :ns "cljs.core", :row 148} {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :end-row 171, :filename "cljs/core.cljs", :name "*print-level*", :ns "cljs.core", :row 160} {:doc "*print-fns-bodies* controls whether functions print their source or\n    only their names.", :end-row 177, :filename "cljs/core.cljs", :name "*print-fn-bodies*", :ns "cljs.core", :row 173} {:end-row 182, :filename "cljs/core.cljs", :name "*loaded-libs*", :ns "cljs.core", :row 179} {:arglist-strs ["[]"], :end-row 189, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "pr-opts", :ns "cljs.core", :private true, :row 184} {:end-row 191, :filename "cljs/core.cljs", :name "into-array", :ns "cljs.core", :row 191} {:arglist-strs ["[]"], :doc "Set *print-fn* to console.log", :end-row 205, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "enable-console-print!", :ns "cljs.core", :row 193} {:doc "bound in a repl thread to the most recent value printed", :end-row 209, :filename "cljs/core.cljs", :name "*1", :ns "cljs.core", :row 207} {:doc "bound in a repl thread to the second most recent value printed", :end-row 213, :filename "cljs/core.cljs", :name "*2", :ns "cljs.core", :row 211} {:doc "bound in a repl thread to the third most recent value printed", :end-row 217, :filename "cljs/core.cljs", :name "*3", :ns "cljs.core", :row 215} {:doc "bound in a repl thread to the most recent exception caught by the repl", :end-row 221, :filename "cljs/core.cljs", :name "*e", :ns "cljs.core", :row 219} {:arglist-strs ["[x]"], :doc "Internal - do not use!", :end-row 226, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "truth_", :ns "cljs.core", :row 223} {:end-row 228, :filename "cljs/core.cljs", :name "not-native", :ns "cljs.core", :row 228} {:end-row 230, :filename "cljs/core.cljs", :name "instance?", :ns "cljs.core", :row 230} {:end-row 230, :filename "cljs/core.cljs", :name "Keyword", :ns "cljs.core", :row 230} {:arglist-strs ["[x y]"], :doc "Tests if 2 arguments are the same object", :end-row 235, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "identical?", :ns "cljs.core", :row 232} {:arglist-strs ["[x]"], :doc "Returns true if x is nil, false otherwise.", :end-row 240, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "nil?", :ns "cljs.core", :row 237} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript array.", :end-row 247, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "array?", :ns "cljs.core", :row 242} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript number.", :end-row 252, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "number?", :ns "cljs.core", :row 249} {:arglist-strs ["[x]"], :doc "Returns true if x is logical false, false otherwise.", :end-row 260, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "not", :ns "cljs.core", :row 254} {:arglist-strs ["[x]"], :doc "Returns true if x is not nil, false otherwise.", :end-row 264, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "some?", :ns "cljs.core", :row 262} {:arglist-strs ["[x]"], :doc "Returns true if x's constructor is Object", :end-row 271, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "object?", :ns "cljs.core", :row 266} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript string.", :end-row 276, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "string?", :ns "cljs.core", :row 273} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript string of length one.", :end-row 281, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "char?", :ns "cljs.core", :row 278} {:arglist-strs ["[x]"], :doc "Returns true if given any argument.", :end-row 285, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "any?", :ns "cljs.core", :row 283} {:arglist-strs ["[p x]"], :doc "Internal - do not use!", :end-row 295, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "native-satisfies?", :ns "cljs.core", :row 288} {:arglist-strs ["[x]"], :end-row 300, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "is_proto_", :ns "cljs.core", :row 298} {:doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments", :end-row 306, :filename "cljs/core.cljs", :name "*main-cli-fn*", :ns "cljs.core", :row 302} {:doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied", :end-row 311, :filename "cljs/core.cljs", :name "*command-line-args*", :ns "cljs.core", :row 308} {:arglist-strs ["[x]"], :doc "Return x's constructor.", :end-row 317, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "type", :ns "cljs.core", :row 313} {:arglist-strs ["[proto obj]"], :end-row 326, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "missing-protocol", :ns "cljs.core", :row 319} {:arglist-strs ["[ty]"], :end-row 331, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "type->str", :ns "cljs.core", :row 328} {:arglist-strs ["[file]"], :end-row 336, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "load-file", :ns "cljs.core", :row 334} {:end-row 340, :filename "cljs/core.cljs", :name "ITER_SYMBOL", :ns "cljs.core", :row 340} {:end-row 341, :filename "cljs/core.cljs", :name "ITER_SYMBOL", :ns "cljs.core", :row 341} {:end-row 368, :filename "cljs/core.cljs", :name "CHAR_MAP", :ns "cljs.core", :row 343} {:end-row 395, :filename "cljs/core.cljs", :name "DEMUNGE_MAP", :ns "cljs.core", :row 370} {:end-row 397, :filename "cljs/core.cljs", :name "DEMUNGE_PATTERN", :ns "cljs.core", :row 397} {:arglist-strs ["[]"], :doc "Returns highest resolution time offered by host in milliseconds.", :end-row 412, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "system-time", :ns "cljs.core", :row 399} {:end-row 416, :filename "cljs/core.cljs", :name "apply", :ns "cljs.core", :row 416} {:arglist-strs ["[size]" "[type size]" "[type size & more-sizes]"], :doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :end-row 432, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "make-array", :ns "cljs.core", :row 418} {:arglist-strs ["[arr]"], :doc "Returns a javascript array, cloned from the passed in array", :end-row 441, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "aclone", :ns "cljs.core", :row 434} {:arglist-strs ["[var-args]"], :doc "Creates a new javascript array.\n@param {...*} var_args", :end-row 453, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "array", :ns "cljs.core", :row 443} {:arglist-strs ["[e]"], :end-row 458, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "maybe-warn", :ns "cljs.core", :private true, :row 455} {:arglist-strs ["[array idx]" "[array idx & idxs]"], :end-row 472, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "checked-aget", :ns "cljs.core", :private true, :row 460} {:arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :end-row 486, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "checked-aset", :ns "cljs.core", :private true, :row 474} {:arglist-strs ["[array idx]" "[array idx & idxs]"], :end-row 494, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "checked-aget'", :ns "cljs.core", :private true, :row 488} {:arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :end-row 502, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "checked-aset'", :ns "cljs.core", :private true, :row 496} {:arglist-strs ["[array idx]" "[array idx & idxs]"], :doc "Returns the value at the index/indices. Works on JavaScript arrays.", :end-row 509, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "aget", :ns "cljs.core", :row 504} {:arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.", :end-row 517, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "aset", :ns "cljs.core", :row 511} {:arglist-strs ["[array]"], :doc "Returns the length of the array. Works on arrays of all types.", :end-row 522, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "alength", :ns "cljs.core", :row 519} {:end-row 524, :filename "cljs/core.cljs", :name "reduce", :ns "cljs.core", :row 524} {:arglist-strs ["[aseq]" "[type aseq]"], :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :end-row 532, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "into-array", :ns "cljs.core", :row 526} {:arglist-strs ["[obj s & args]"], :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :end-row 538, :filename "cljs/core.cljs", :name "js-invoke", :ns "cljs.core", :row 534} {:arglist-strs ["[x]"], :doc "Returns true if x is an instance of Symbol", :end-row 545, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js-symbol?", :ns "cljs.core", :row 540} {:doc "Marker protocol", :end-row 550, :filename "cljs/core.cljs", :name "Fn", :ns "cljs.core", :row 549} {:doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :end-row 578, :filename "cljs/core.cljs", :name "IFn", :ns "cljs.core", :row 552} {:arglist-strs ["[this]" "[this a]" "[this a b]" "[this a b c]" "[this a b c d]" "[this a b c d e]" "[this a b c d e f]" "[this a b c d e f g]" "[this a b c d e f g h]" "[this a b c d e f g h i]" "[this a b c d e f g h i j]" "[this a b c d e f g h i j k]" "[this a b c d e f g h i j k l]" "[this a b c d e f g h i j k l m]" "[this a b c d e f g h i j k l m n]" "[this a b c d e f g h i j k l m n o]" "[this a b c d e f g h i j k l m n o p]" "[this a b c d e f g h i j k l m n o p q]" "[this a b c d e f g h i j k l m n o p q r]" "[this a b c d e f g h i j k l m n o p q r s]" "[this a b c d e f g h i j k l m n o p q r s t]" "[this a b c d e f g h i j k l m n o p q r s t rest]"], :end-row 578, :filename "cljs/core.cljs", :fixed-arities #{7 20 1 4 15 21 13 22 6 17 3 12 2 19 11 9 5 14 16 10 18 8}, :name "-invoke", :ns "cljs.core", :row 556} {:doc "Protocol for cloning a value.", :end-row 583, :filename "cljs/core.cljs", :name "ICloneable", :ns "cljs.core", :row 580} {:arglist-strs ["[value]"], :doc "Creates a clone of value.", :end-row 583, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-clone", :ns "cljs.core", :row 582} {:doc "Protocol for adding the ability to count a collection in constant time.", :end-row 588, :filename "cljs/core.cljs", :name "ICounted", :ns "cljs.core", :row 585} {:arglist-strs ["[coll]"], :doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :end-row 588, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-count", :ns "cljs.core", :row 587} {:doc "Protocol for creating an empty collection.", :end-row 594, :filename "cljs/core.cljs", :name "IEmptyableCollection", :ns "cljs.core", :row 590} {:arglist-strs ["[coll]"], :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :end-row 594, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-empty", :ns "cljs.core", :row 592} {:doc "Protocol for adding to a collection.", :end-row 602, :filename "cljs/core.cljs", :name "ICollection", :ns "cljs.core", :row 596} {:arglist-strs ["[coll o]"], :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :end-row 602, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-conj", :ns "cljs.core", :row 598} {:doc "Protocol for collections to provide indexed-based access to their items.", :end-row 611, :filename "cljs/core.cljs", :name "IIndexed", :ns "cljs.core", :row 607} {:arglist-strs ["[coll n]" "[coll n not-found]"], :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :end-row 611, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-nth", :ns "cljs.core", :row 609} {:doc "Marker protocol indicating an array sequence.", :end-row 614, :filename "cljs/core.cljs", :name "ASeq", :ns "cljs.core", :row 613} {:doc "Protocol for collections to provide access to their items as sequences.", :end-row 624, :filename "cljs/core.cljs", :name "ISeq", :ns "cljs.core", :row 616} {:arglist-strs ["[coll]"], :doc "Returns the first item in the collection coll. Used by cljs.core/first.", :end-row 619, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-first", :ns "cljs.core", :row 618} {:arglist-strs ["[coll]"], :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :end-row 624, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-rest", :ns "cljs.core", :row 620} {:doc "Protocol for accessing the next items of a collection.", :end-row 632, :filename "cljs/core.cljs", :name "INext", :ns "cljs.core", :row 626} {:arglist-strs ["[coll]"], :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :end-row 632, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-next", :ns "cljs.core", :row 628} {:doc "Protocol for looking up a value in a data structure.", :end-row 638, :filename "cljs/core.cljs", :name "ILookup", :ns "cljs.core", :row 634} {:arglist-strs ["[o k]" "[o k not-found]"], :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :end-row 638, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-lookup", :ns "cljs.core", :row 636} {:doc "Protocol for adding associativity to collections.", :end-row 647, :filename "cljs/core.cljs", :name "IAssociative", :ns "cljs.core", :row 640} {:arglist-strs ["[coll k]"], :doc "Returns true if k is a key in coll.", :end-row 643, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-contains-key?", :ns "cljs.core", :row 642} {:arglist-strs ["[coll k v]"], :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :end-row 647, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-assoc", :ns "cljs.core", :row 645} {:doc "Protocol for implementing entry finding in collections.", :end-row 651, :filename "cljs/core.cljs", :name "IFind", :ns "cljs.core", :row 649} {:arglist-strs ["[coll k]"], :doc "Returns the map entry for key, or nil if key not present.", :end-row 651, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-find", :ns "cljs.core", :row 651} {:doc "Protocol for adding mapping functionality to collections.", :end-row 657, :filename "cljs/core.cljs", :name "IMap", :ns "cljs.core", :row 653} {:arglist-strs ["[coll k]"], :doc "Returns a new collection of coll without the mapping for key k.", :end-row 657, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-dissoc", :ns "cljs.core", :row 656} {:doc "Protocol for examining a map entry.", :end-row 664, :filename "cljs/core.cljs", :name "IMapEntry", :ns "cljs.core", :row 659} {:arglist-strs ["[coll]"], :doc "Returns the key of the map entry.", :end-row 662, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-key", :ns "cljs.core", :row 661} {:arglist-strs ["[coll]"], :doc "Returns the value of the map entry.", :end-row 664, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-val", :ns "cljs.core", :row 663} {:doc "Protocol for adding set functionality to a collection.", :end-row 669, :filename "cljs/core.cljs", :name "ISet", :ns "cljs.core", :row 666} {:arglist-strs ["[coll v]"], :doc "Returns a new collection of coll that does not contain v.", :end-row 669, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-disjoin", :ns "cljs.core", :row 668} {:doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :end-row 679, :filename "cljs/core.cljs", :name "IStack", :ns "cljs.core", :row 671} {:arglist-strs ["[coll]"], :doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :end-row 676, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-peek", :ns "cljs.core", :row 675} {:arglist-strs ["[coll]"], :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :end-row 679, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-pop", :ns "cljs.core", :row 677} {:doc "Protocol for adding vector functionality to collections.", :end-row 684, :filename "cljs/core.cljs", :name "IVector", :ns "cljs.core", :row 681} {:arglist-strs ["[coll n val]"], :doc "Returns a new vector with value val added at position n.", :end-row 684, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-assoc-n", :ns "cljs.core", :row 683} {:doc "Protocol for adding dereference functionality to a reference.", :end-row 689, :filename "cljs/core.cljs", :name "IDeref", :ns "cljs.core", :row 686} {:arglist-strs ["[o]"], :doc "Returns the value of the reference o.", :end-row 689, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-deref", :ns "cljs.core", :row 688} {:end-row 692, :filename "cljs/core.cljs", :name "IDerefWithTimeout", :ns "cljs.core", :row 691} {:arglist-strs ["[o msec timeout-val]"], :end-row 692, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-deref-with-timeout", :ns "cljs.core", :row 692} {:doc "Protocol for accessing the metadata of an object.", :end-row 697, :filename "cljs/core.cljs", :name "IMeta", :ns "cljs.core", :row 694} {:arglist-strs ["[o]"], :doc "Returns the metadata of object o.", :end-row 697, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-meta", :ns "cljs.core", :row 696} {:doc "Protocol for adding metadata to an object.", :end-row 702, :filename "cljs/core.cljs", :name "IWithMeta", :ns "cljs.core", :row 699} {:arglist-strs ["[o meta]"], :doc "Returns a new object with value of o and metadata meta added to it.", :end-row 702, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-with-meta", :ns "cljs.core", :row 701} {:doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :end-row 710, :filename "cljs/core.cljs", :name "IReduce", :ns "cljs.core", :row 704} {:arglist-strs ["[coll f]" "[coll f start]"], :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :end-row 710, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-reduce", :ns "cljs.core", :row 707} {:doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :end-row 717, :filename "cljs/core.cljs", :name "IKVReduce", :ns "cljs.core", :row 712} {:arglist-strs ["[coll f init]"], :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :end-row 717, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-kv-reduce", :ns "cljs.core", :row 715} {:doc "Protocol for adding value comparison functionality to a type.", :end-row 722, :filename "cljs/core.cljs", :name "IEquiv", :ns "cljs.core", :row 719} {:arglist-strs ["[o other]"], :doc "Returns true if o and other are equal, false otherwise.", :end-row 722, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-equiv", :ns "cljs.core", :row 721} {:doc "Protocol for adding hashing functionality to a type.", :end-row 727, :filename "cljs/core.cljs", :name "IHash", :ns "cljs.core", :row 724} {:arglist-strs ["[o]"], :doc "Returns the hash code of o.", :end-row 727, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-hash", :ns "cljs.core", :row 726} {:doc "Protocol for adding the ability to a type to be transformed into a sequence.", :end-row 732, :filename "cljs/core.cljs", :name "ISeqable", :ns "cljs.core", :row 729} {:arglist-strs ["[o]"], :doc "Returns a seq of o, or nil if o is empty.", :end-row 732, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-seq", :ns "cljs.core", :row 731} {:doc "Marker interface indicating a persistent collection of sequential items", :end-row 735, :filename "cljs/core.cljs", :name "ISequential", :ns "cljs.core", :row 734} {:doc "Marker interface indicating a persistent list", :end-row 738, :filename "cljs/core.cljs", :name "IList", :ns "cljs.core", :row 737} {:doc "Marker interface indicating a record object", :end-row 741, :filename "cljs/core.cljs", :name "IRecord", :ns "cljs.core", :row 740} {:doc "Protocol for reversing a seq.", :end-row 746, :filename "cljs/core.cljs", :name "IReversible", :ns "cljs.core", :row 743} {:arglist-strs ["[coll]"], :doc "Returns a seq of the items in coll in reversed order.", :end-row 746, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-rseq", :ns "cljs.core", :row 745} {:doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :end-row 763, :filename "cljs/core.cljs", :name "ISorted", :ns "cljs.core", :row 748} {:arglist-strs ["[coll ascending?]"], :doc "Returns a sorted seq from coll in either ascending or descending order.", :end-row 752, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-sorted-seq", :ns "cljs.core", :row 751} {:arglist-strs ["[coll k ascending?]"], :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :end-row 759, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-sorted-seq-from", :ns "cljs.core", :row 753} {:arglist-strs ["[coll entry]"], :doc "Returns the key for entry.", :end-row 761, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-entry-key", :ns "cljs.core", :row 760} {:arglist-strs ["[coll]"], :doc "Returns the comparator for coll.", :end-row 763, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-comparator", :ns "cljs.core", :row 762} {:doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :end-row 770, :filename "cljs/core.cljs", :name "IWriter", :ns "cljs.core", :row 765} {:arglist-strs ["[writer s]"], :doc "Writes s with writer and returns the result.", :end-row 768, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-write", :ns "cljs.core", :row 767} {:arglist-strs ["[writer]"], :doc "Flush writer.", :end-row 770, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-flush", :ns "cljs.core", :row 769} {:doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :end-row 778, :filename "cljs/core.cljs", :name "IPrintWithWriter", :ns "cljs.core", :row 772} {:arglist-strs ["[o writer opts]"], :end-row 778, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-pr-writer", :ns "cljs.core", :row 778} {:doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq.", :end-row 784, :filename "cljs/core.cljs", :name "IPending", :ns "cljs.core", :row 780} {:arglist-strs ["[x]"], :doc "Returns true if a value for x has been produced, false otherwise.", :end-row 784, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-realized?", :ns "cljs.core", :row 783} {:doc "Protocol for types that can be watched. Currently only implemented by Atom.", :end-row 794, :filename "cljs/core.cljs", :name "IWatchable", :ns "cljs.core", :row 786} {:arglist-strs ["[this oldval newval]"], :doc "Calls all watchers with this, oldval and newval.", :end-row 789, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-notify-watches", :ns "cljs.core", :row 788} {:arglist-strs ["[this key f]"], :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :end-row 792, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-add-watch", :ns "cljs.core", :row 790} {:arglist-strs ["[this key]"], :doc "Removes watcher that corresponds to key from this.", :end-row 794, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-remove-watch", :ns "cljs.core", :row 793} {:doc "Protocol for collections which can transformed to transients.", :end-row 799, :filename "cljs/core.cljs", :name "IEditableCollection", :ns "cljs.core", :row 796} {:arglist-strs ["[coll]"], :doc "Returns a new, transient version of the collection, in constant time.", :end-row 799, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-as-transient", :ns "cljs.core", :row 798} {:doc "Protocol for adding basic functionality to transient collections.", :end-row 806, :filename "cljs/core.cljs", :name "ITransientCollection", :ns "cljs.core", :row 801} {:arglist-strs ["[tcoll val]"], :doc "Adds value val to tcoll and returns tcoll.", :end-row 804, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-conj!", :ns "cljs.core", :row 803} {:arglist-strs ["[tcoll]"], :doc "Creates a persistent data structure from tcoll and returns it.", :end-row 806, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-persistent!", :ns "cljs.core", :row 805} {:doc "Protocol for adding associativity to transient collections.", :end-row 812, :filename "cljs/core.cljs", :name "ITransientAssociative", :ns "cljs.core", :row 808} {:arglist-strs ["[tcoll key val]"], :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :end-row 812, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-assoc!", :ns "cljs.core", :row 810} {:doc "Protocol for adding mapping functionality to transient collections.", :end-row 817, :filename "cljs/core.cljs", :name "ITransientMap", :ns "cljs.core", :row 814} {:arglist-strs ["[tcoll key]"], :doc "Returns a new transient collection of tcoll without the mapping for key.", :end-row 817, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-dissoc!", :ns "cljs.core", :row 816} {:doc "Protocol for adding vector functionality to transient collections.", :end-row 824, :filename "cljs/core.cljs", :name "ITransientVector", :ns "cljs.core", :row 819} {:arglist-strs ["[tcoll n val]"], :doc "Returns tcoll with value val added at position n.", :end-row 822, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-assoc-n!", :ns "cljs.core", :row 821} {:arglist-strs ["[tcoll]"], :doc "Returns tcoll with the last item removed from it.", :end-row 824, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-pop!", :ns "cljs.core", :row 823} {:doc "Protocol for adding set functionality to a transient collection.", :end-row 829, :filename "cljs/core.cljs", :name "ITransientSet", :ns "cljs.core", :row 826} {:arglist-strs ["[tcoll v]"], :doc "Returns tcoll without v.", :end-row 829, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-disjoin!", :ns "cljs.core", :row 828} {:doc "Protocol for values that can be compared.", :end-row 835, :filename "cljs/core.cljs", :name "IComparable", :ns "cljs.core", :row 831} {:arglist-strs ["[x y]"], :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :end-row 835, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-compare", :ns "cljs.core", :row 833} {:doc "Protocol for accessing the items of a chunk.", :end-row 840, :filename "cljs/core.cljs", :name "IChunk", :ns "cljs.core", :row 837} {:arglist-strs ["[coll]"], :doc "Return a new chunk of coll with the first item removed.", :end-row 840, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-drop-first", :ns "cljs.core", :row 839} {:doc "Protocol for accessing a collection as sequential chunks.", :end-row 847, :filename "cljs/core.cljs", :name "IChunkedSeq", :ns "cljs.core", :row 842} {:arglist-strs ["[coll]"], :doc "Returns the first chunk in coll.", :end-row 845, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-chunked-first", :ns "cljs.core", :row 844} {:arglist-strs ["[coll]"], :doc "Return a new collection of coll with the first chunk removed.", :end-row 847, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-chunked-rest", :ns "cljs.core", :row 846} {:doc "Protocol for accessing the chunks of a collection.", :end-row 852, :filename "cljs/core.cljs", :name "IChunkedNext", :ns "cljs.core", :row 849} {:arglist-strs ["[coll]"], :doc "Returns a new collection of coll without the first chunk.", :end-row 852, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-chunked-next", :ns "cljs.core", :row 851} {:doc "Protocol for adding a name.", :end-row 859, :filename "cljs/core.cljs", :name "INamed", :ns "cljs.core", :row 854} {:arglist-strs ["[x]"], :doc "Returns the name String of x.", :end-row 857, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-name", :ns "cljs.core", :row 856} {:arglist-strs ["[x]"], :doc "Returns the namespace String of x.", :end-row 859, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-namespace", :ns "cljs.core", :row 858} {:doc "Marker protocol indicating an atom.", :end-row 862, :filename "cljs/core.cljs", :name "IAtom", :ns "cljs.core", :row 861} {:doc "Protocol for adding resetting functionality.", :end-row 867, :filename "cljs/core.cljs", :name "IReset", :ns "cljs.core", :row 864} {:arglist-strs ["[o new-value]"], :doc "Sets the value of o to new-value.", :end-row 867, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-reset!", :ns "cljs.core", :row 866} {:doc "Protocol for adding swapping functionality.", :end-row 872, :filename "cljs/core.cljs", :name "ISwap", :ns "cljs.core", :row 869} {:arglist-strs ["[o f]" "[o f a]" "[o f a b]" "[o f a b xs]"], :doc "Swaps the value of o to be (apply f current-value-of-atom args).", :end-row 872, :filename "cljs/core.cljs", :fixed-arities #{4 3 2 5}, :name "-swap!", :ns "cljs.core", :row 871} {:doc "Protocol for adding volatile functionality.", :end-row 878, :filename "cljs/core.cljs", :name "IVolatile", :ns "cljs.core", :row 874} {:arglist-strs ["[o new-value]"], :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :end-row 878, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-vreset!", :ns "cljs.core", :row 876} {:doc "Protocol for iterating over a collection.", :end-row 883, :filename "cljs/core.cljs", :name "IIterable", :ns "cljs.core", :row 880} {:arglist-strs ["[coll]"], :doc "Returns an iterator for coll.", :end-row 883, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-iterator", :ns "cljs.core", :row 882} {:end-row 890, :filename "cljs/core.cljs", :name "StringBufferWriter", :ns "cljs.core", :row 887} {:arglist-strs ["[sb]"], :end-row 890, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->StringBufferWriter", :ns "cljs.core", :row 887} {:arglist-strs ["[obj]"], :doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :end-row 900, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pr-str*", :ns "cljs.core", :row 892} {:arglist-strs ["[x n]"], :end-row 908, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "int-rotate-left", :ns "cljs.core", :row 905} {:arglist-strs ["[a b]"], :end-row 913, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "imul", :ns "cljs.core", :row 913} {:arglist-strs ["[a b]"], :end-row 922, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "imul", :ns "cljs.core", :row 914} {:end-row 925, :filename "cljs/core.cljs", :name "m3-seed", :ns "cljs.core", :row 925} {:end-row 926, :filename "cljs/core.cljs", :name "m3-C1", :ns "cljs.core", :row 926} {:end-row 927, :filename "cljs/core.cljs", :name "m3-C2", :ns "cljs.core", :row 927} {:arglist-strs ["[k1]"], :end-row 930, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "m3-mix-K1", :ns "cljs.core", :row 929} {:arglist-strs ["[h1 k1]"], :end-row 933, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "m3-mix-H1", :ns "cljs.core", :row 932} {:arglist-strs ["[h1 len]"], :end-row 942, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "m3-fmix", :ns "cljs.core", :row 935} {:arglist-strs ["[in]"], :end-row 949, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "m3-hash-int", :ns "cljs.core", :row 944} {:arglist-strs ["[in]"], :end-row 963, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "m3-hash-unencoded-chars", :ns "cljs.core", :row 951} {:end-row 967, :filename "cljs/core.cljs", :name "list", :ns "cljs.core", :row 967} {:end-row 967, :filename "cljs/core.cljs", :name "Symbol", :ns "cljs.core", :row 967} {:end-row 967, :filename "cljs/core.cljs", :name "=", :ns "cljs.core", :row 967} {:end-row 967, :filename "cljs/core.cljs", :name "compare", :ns "cljs.core", :row 967} {:end-row 970, :filename "cljs/core.cljs", :name "string-hash-cache", :ns "cljs.core", :row 970} {:end-row 971, :filename "cljs/core.cljs", :name "string-hash-cache-count", :ns "cljs.core", :row 971} {:arglist-strs ["[s]"], :end-row 983, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-string*", :ns "cljs.core", :row 974} {:arglist-strs ["[k]"], :end-row 989, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "add-to-string-hash-cache", :ns "cljs.core", :row 985} {:arglist-strs ["[k]"], :end-row 1000, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-string", :ns "cljs.core", :row 991} {:arglist-strs ["[o]"], :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =.", :end-row 1036, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash", :ns "cljs.core", :row 1002} {:arglist-strs ["[seed hash]"], :end-row 1043, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "hash-combine", :ns "cljs.core", :row 1038} {:arglist-strs ["[c x]"], :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false", :end-row 1049, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "instance?", :ns "cljs.core", :row 1045} {:arglist-strs ["[x]"], :doc "Return true if x is a Symbol", :end-row 1054, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "symbol?", :ns "cljs.core", :row 1051} {:arglist-strs ["[sym]"], :end-row 1059, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-symbol", :ns "cljs.core", :private true, :row 1056} {:arglist-strs ["[a b]"], :end-row 1071, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "compare-symbols", :ns "cljs.core", :private true, :row 1061} {:end-row 1073, :filename "cljs/core.cljs", :name "get", :ns "cljs.core", :row 1073} {:end-row 1107, :filename "cljs/core.cljs", :name "Symbol", :ns "cljs.core", :row 1075} {:arglist-strs ["[ns name str _hash _meta]"], :end-row 1107, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Symbol", :ns "cljs.core", :row 1075} {:arglist-strs ["[v]"], :doc "Returns true if v is of type cljs.core.Var", :end-row 1112, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "var?", :ns "cljs.core", :row 1109} {:arglist-strs ["[name]" "[ns name]"], :doc "Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars.", :end-row 1131, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "symbol", :ns "cljs.core", :row 1114} {:end-row 1199, :filename "cljs/core.cljs", :name "Var", :ns "cljs.core", :row 1133} {:arglist-strs ["[val sym _meta]"], :end-row 1199, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->Var", :ns "cljs.core", :row 1133} {:end-row 1203, :filename "cljs/core.cljs", :name "array-seq", :ns "cljs.core", :row 1203} {:end-row 1203, :filename "cljs/core.cljs", :name "prim-seq", :ns "cljs.core", :row 1203} {:end-row 1203, :filename "cljs/core.cljs", :name "IndexedSeq", :ns "cljs.core", :row 1203} {:arglist-strs ["[x]"], :doc "Return true if x implements IIterable protocol.", :end-row 1208, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "iterable?", :ns "cljs.core", :row 1205} {:arglist-strs ["[x]"], :doc "Return true if x has a JavaScript iterator property", :end-row 1214, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js-iterable?", :ns "cljs.core", :row 1210} {:arglist-strs ["[value]"], :doc "Clone the supplied value which must implement ICloneable.", :end-row 1219, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "clone", :ns "cljs.core", :row 1216} {:arglist-strs ["[value]"], :doc "Return true if x implements ICloneable protocol.", :end-row 1224, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "cloneable?", :ns "cljs.core", :row 1221} {:end-row 1226, :filename "cljs/core.cljs", :name "es6-iterator-seq", :ns "cljs.core", :row 1226} {:arglist-strs ["[coll]"], :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :end-row 1253, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seq", :ns "cljs.core", :row 1228} {:arglist-strs ["[coll]"], :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :end-row 1264, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "first", :ns "cljs.core", :row 1255} {:arglist-strs ["[coll]"], :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :end-row 1277, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "rest", :ns "cljs.core", :row 1266} {:arglist-strs ["[coll]"], :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :end-row 1286, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "next", :ns "cljs.core", :row 1279} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :end-row 1304, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "=", :ns "cljs.core", :row 1288} {:end-row 1314, :filename "cljs/core.cljs", :name "ES6Iterator", :ns "cljs.core", :row 1307} {:arglist-strs ["[s]"], :end-row 1314, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->ES6Iterator", :ns "cljs.core", :row 1307} {:arglist-strs ["[coll]"], :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll.", :end-row 1319, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "es6-iterator", :ns "cljs.core", :row 1316} {:end-row 1329, :filename "cljs/core.cljs", :name "ES6IteratorSeq", :ns "cljs.core", :row 1321} {:arglist-strs ["[value iter _rest]"], :end-row 1329, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->ES6IteratorSeq", :ns "cljs.core", :row 1321} {:arglist-strs ["[iter]"], :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.", :end-row 1337, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "es6-iterator-seq", :ns "cljs.core", :row 1331} {:arglist-strs ["[hash-basis count]"], :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :end-row 1351, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "mix-collection-hash", :ns "cljs.core", :row 1341} {:arglist-strs ["[coll]"], :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :end-row 1362, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-ordered-coll", :ns "cljs.core", :row 1353} {:end-row 1365, :filename "cljs/core.cljs", :name "empty-ordered-hash", :ns "cljs.core", :private true, :row 1364} {:arglist-strs ["[coll]"], :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :end-row 1377, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-unordered-coll", :ns "cljs.core", :row 1367} {:end-row 1380, :filename "cljs/core.cljs", :name "empty-unordered-hash", :ns "cljs.core", :private true, :row 1379} {:end-row 1383, :filename "cljs/core.cljs", :name "hash-map", :ns "cljs.core", :row 1383} {:end-row 1383, :filename "cljs/core.cljs", :name "list", :ns "cljs.core", :row 1383} {:end-row 1383, :filename "cljs/core.cljs", :name "equiv-sequential", :ns "cljs.core", :row 1383} {:end-row 1406, :filename "cljs/core.cljs", :name "Inst", :ns "cljs.core", :row 1405} {:arglist-strs ["[inst]"], :end-row 1406, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "inst-ms*", :ns "cljs.core", :row 1406} {:arglist-strs ["[inst]"], :doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", :end-row 1415, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "inst-ms", :ns "cljs.core", :row 1412} {:arglist-strs ["[x]"], :doc "Return true if x satisfies Inst", :end-row 1420, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "inst?", :ns "cljs.core", :row 1417} {:end-row 1426, :filename "cljs/core.cljs", :name "with-meta", :ns "cljs.core", :row 1426} {:arglist-strs ["[x]"], :doc "Returns a number one greater than num.", :end-row 1441, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "inc", :ns "cljs.core", :row 1439} {:end-row 1443, :filename "cljs/core.cljs", :name "deref", :ns "cljs.core", :row 1443} {:end-row 1447, :filename "cljs/core.cljs", :name "Reduced", :ns "cljs.core", :row 1445} {:arglist-strs ["[val]"], :end-row 1447, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Reduced", :ns "cljs.core", :row 1445} {:arglist-strs ["[x]"], :doc "Wraps x in a way such that a reduce will terminate with the value x", :end-row 1452, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reduced", :ns "cljs.core", :row 1449} {:arglist-strs ["[r]"], :doc "Returns true if x is the result of a call to reduced", :end-row 1457, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reduced?", :ns "cljs.core", :row 1454} {:arglist-strs ["[x]"], :doc "If x is already reduced?, returns it, else returns (reduced x)", :end-row 1462, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ensure-reduced", :ns "cljs.core", :row 1459} {:arglist-strs ["[x]"], :doc "If x is reduced?, returns (deref x), else returns x", :end-row 1467, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unreduced", :ns "cljs.core", :row 1464} {:arglist-strs ["[o]"], :doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?.", :end-row 1477, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "deref", :ns "cljs.core", :row 1471} {:fixed-arities #{3 2}, :end-row 1501, :private true, :ns "cljs.core", :name "ci-reduce", :filename "cljs/core.cljs", :arglist-strs ["[cicoll f]" "[cicoll f val]"], :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :row 1479} {:arglist-strs ["[arr f]" "[arr f val]" "[arr f val idx]"], :end-row 1532, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "array-reduce", :ns "cljs.core", :private true, :row 1503} {:end-row 1534, :filename "cljs/core.cljs", :name "hash-coll", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "cons", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "drop", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "count", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "nth", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "RSeq", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "List", :ns "cljs.core", :row 1534} {:arglist-strs ["[x]"], :doc "Returns true if coll implements count in constant time", :end-row 1538, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "counted?", :ns "cljs.core", :row 1536} {:arglist-strs ["[x]"], :doc "Returns true if coll implements nth in constant time", :end-row 1542, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "indexed?", :ns "cljs.core", :row 1540} {:arglist-strs ["[coll x]" "[coll x start]"], :end-row 1559, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-indexOf", :ns "cljs.core", :private true, :row 1544} {:arglist-strs ["[coll x]" "[coll x start]"], :end-row 1576, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-lastIndexOf", :ns "cljs.core", :private true, :row 1561} {:end-row 1585, :filename "cljs/core.cljs", :name "IndexedSeqIterator", :ns "cljs.core", :row 1578} {:arglist-strs ["[arr i]"], :end-row 1585, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->IndexedSeqIterator", :ns "cljs.core", :row 1578} {:end-row 1673, :filename "cljs/core.cljs", :name "IndexedSeq", :ns "cljs.core", :row 1587} {:arglist-strs ["[arr i meta]"], :end-row 1673, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->IndexedSeq", :ns "cljs.core", :row 1587} {:arglist-strs ["[prim]" "[prim i]"], :doc "Create seq from a primitive JavaScript Array-like.", :end-row 1683, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "prim-seq", :ns "cljs.core", :row 1677} {:arglist-strs ["[array]" "[array i]"], :doc "Create a seq from a JavaScript array.", :end-row 1690, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "array-seq", :ns "cljs.core", :row 1685} {:end-row 1692, :filename "cljs/core.cljs", :name "with-meta", :ns "cljs.core", :row 1692} {:end-row 1692, :filename "cljs/core.cljs", :name "seq-reduce", :ns "cljs.core", :row 1692} {:end-row 1755, :filename "cljs/core.cljs", :name "RSeq", :ns "cljs.core", :row 1694} {:arglist-strs ["[ci i meta]"], :end-row 1755, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->RSeq", :ns "cljs.core", :row 1694} {:arglist-strs ["[coll]"], :doc "Same as (first (next x))", :end-row 1762, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "second", :ns "cljs.core", :row 1759} {:arglist-strs ["[coll]"], :doc "Same as (first (first x))", :end-row 1767, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ffirst", :ns "cljs.core", :row 1764} {:arglist-strs ["[coll]"], :doc "Same as (next (first x))", :end-row 1772, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "nfirst", :ns "cljs.core", :row 1769} {:arglist-strs ["[coll]"], :doc "Same as (first (next x))", :end-row 1777, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "fnext", :ns "cljs.core", :row 1774} {:arglist-strs ["[coll]"], :doc "Same as (next (next x))", :end-row 1782, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "nnext", :ns "cljs.core", :row 1779} {:arglist-strs ["[s]"], :doc "Return the last item in coll, in linear time", :end-row 1790, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "last", :ns "cljs.core", :row 1784} {:arglist-strs ["[]" "[coll]" "[coll x]" "[coll x & xs]"], :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).\n  (conj coll) returns coll. (conj) returns [].\n  The 'addition' may happen at different 'places' depending\n  on the concrete type.", :end-row 1811, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "conj", :ns "cljs.core", :row 1796} {:arglist-strs ["[coll]"], :doc "Returns an empty collection of the same category as coll, or nil", :end-row 1824, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "empty", :ns "cljs.core", :row 1813} {:arglist-strs ["[coll]"], :end-row 1830, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "accumulating-seq-count", :ns "cljs.core", :private true, :row 1826} {:arglist-strs ["[coll]"], :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :end-row 1851, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "count", :ns "cljs.core", :row 1832} {:arglist-strs ["[coll n]" "[coll n not-found]"], :end-row 1871, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "linear-traversal-nth", :ns "cljs.core", :private true, :row 1853} {:arglist-strs ["[coll n]" "[coll n not-found]"], :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :end-row 1943, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "nth", :ns "cljs.core", :row 1873} {:arglist-strs ["[coll n]"], :doc "Returns the nth rest of coll, coll when n is 0.", :end-row 1951, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "nthrest", :ns "cljs.core", :row 1945} {:arglist-strs ["[o k]" "[o k not-found]"], :doc "Returns the value mapped to key, not-found or nil if key not present\n  in associative collection, set, string, array, or ILookup instance.", :end-row 1994, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "get", :ns "cljs.core", :row 1953} {:end-row 1996, :filename "cljs/core.cljs", :name "PersistentHashMap", :ns "cljs.core", :row 1996} {:end-row 1996, :filename "cljs/core.cljs", :name "PersistentArrayMap", :ns "cljs.core", :row 1996} {:end-row 1996, :filename "cljs/core.cljs", :name "MapEntry", :ns "cljs.core", :row 1996} {:arglist-strs ["[coll k v]" "[coll k v & kvs]"], :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index. Note - index must be <= (count vector).", :end-row 2013, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "assoc", :ns "cljs.core", :row 1998} {:arglist-strs ["[coll]" "[coll k]" "[coll k & ks]"], :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :end-row 2027, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "dissoc", :ns "cljs.core", :row 2015} {:arglist-strs ["[f]"], :doc "Return true if f is a JavaScript function or satisfies the Fn protocol.", :end-row 2032, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "fn?", :ns "cljs.core", :row 2029} {:end-row 2085, :filename "cljs/core.cljs", :name "MetaFn", :ns "cljs.core", :row 2034} {:arglist-strs ["[afn meta]"], :end-row 2085, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->MetaFn", :ns "cljs.core", :row 2034} {:arglist-strs ["[o meta]"], :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :end-row 2094, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "with-meta", :ns "cljs.core", :row 2087} {:arglist-strs ["[o]"], :doc "Returns the metadata of obj, returns nil if there is no metadata.", :end-row 2101, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "meta", :ns "cljs.core", :row 2096} {:arglist-strs ["[coll]"], :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :end-row 2108, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "peek", :ns "cljs.core", :row 2103} {:arglist-strs ["[coll]"], :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :end-row 2116, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pop", :ns "cljs.core", :row 2110} {:arglist-strs ["[coll]" "[coll k]" "[coll k & ks]"], :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :end-row 2130, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "disj", :ns "cljs.core", :row 2118} {:arglist-strs ["[coll]"], :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :end-row 2136, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "empty?", :ns "cljs.core", :row 2132} {:arglist-strs ["[x]"], :doc "Returns true if x satisfies ICollection", :end-row 2143, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "coll?", :ns "cljs.core", :row 2138} {:arglist-strs ["[x]"], :doc "Returns true if x satisfies ISet", :end-row 2150, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set?", :ns "cljs.core", :row 2145} {:arglist-strs ["[x]"], :doc "Returns true if coll implements IAssociative", :end-row 2154, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "associative?", :ns "cljs.core", :row 2152} {:arglist-strs ["[x]"], :doc "Returns true if coll implements IFind", :end-row 2158, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ifind?", :ns "cljs.core", :row 2156} {:arglist-strs ["[x]"], :doc "Returns true if coll satisfies ISequential", :end-row 2162, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "sequential?", :ns "cljs.core", :row 2160} {:arglist-strs ["[x]"], :doc "Returns true if coll satisfies ISorted", :end-row 2166, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "sorted?", :ns "cljs.core", :row 2164} {:arglist-strs ["[x]"], :doc "Returns true if coll satisfies IReduce", :end-row 2170, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reduceable?", :ns "cljs.core", :row 2168} {:arglist-strs ["[x]"], :doc "Return true if x satisfies IMap", :end-row 2177, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "map?", :ns "cljs.core", :row 2172} {:arglist-strs ["[x]"], :doc "Return true if x satisfies IRecord", :end-row 2182, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "record?", :ns "cljs.core", :row 2179} {:arglist-strs ["[x]"], :doc "Return true if x satisfies IVector", :end-row 2186, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "vector?", :ns "cljs.core", :row 2184} {:end-row 2188, :filename "cljs/core.cljs", :name "ChunkedCons", :ns "cljs.core", :row 2188} {:end-row 2188, :filename "cljs/core.cljs", :name "ChunkedSeq", :ns "cljs.core", :row 2188} {:arglist-strs ["[x]"], :doc "Return true if x satisfies IChunkedSeq.", :end-row 2192, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunked-seq?", :ns "cljs.core", :row 2190} {:arglist-strs ["[]" "[& keyvals]"], :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :end-row 2201, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "js-obj", :ns "cljs.core", :row 2195} {:arglist-strs ["[obj]"], :doc "Return the JavaScript keys for an object.", :end-row 2206, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js-keys", :ns "cljs.core", :row 2203} {:arglist-strs ["[obj key]"], :doc "Delete a property from a JavaScript object.\n  Returns true upon success, false otherwise.", :end-row 2212, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "js-delete", :ns "cljs.core", :row 2208} {:arglist-strs ["[from i to j len]"], :end-row 2220, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "array-copy", :ns "cljs.core", :private true, :row 2214} {:arglist-strs ["[from i to j len]"], :end-row 2228, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "array-copy-downward", :ns "cljs.core", :private true, :row 2222} {:end-row 2232, :filename "cljs/core.cljs", :name "lookup-sentinel", :ns "cljs.core", :private true, :row 2232} {:arglist-strs ["[x]"], :doc "Returns true if x is the value false, false otherwise.", :end-row 2236, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "false?", :ns "cljs.core", :row 2234} {:arglist-strs ["[x]"], :doc "Returns true if x is the value true, false otherwise.", :end-row 2240, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "true?", :ns "cljs.core", :row 2238} {:arglist-strs ["[x]"], :doc "Return true if x is a Boolean", :end-row 2244, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "boolean?", :ns "cljs.core", :row 2242} {:arglist-strs ["[x]"], :doc "Returns true if x identical to the JavaScript undefined value.", :end-row 2249, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "undefined?", :ns "cljs.core", :row 2246} {:arglist-strs ["[s]"], :doc "Return true if s satisfies ISeq", :end-row 2256, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seq?", :ns "cljs.core", :row 2251} {:arglist-strs ["[s]"], :doc "Return true if the seq function is supported for s", :end-row 2265, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seqable?", :ns "cljs.core", :row 2258} {:arglist-strs ["[x]"], :doc "Coerce to boolean", :end-row 2273, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "boolean", :ns "cljs.core", :row 2267} {:arglist-strs ["[f]"], :doc "Returns true if f returns true for fn? or satisfies IFn.", :end-row 2278, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ifn?", :ns "cljs.core", :row 2275} {:arglist-strs ["[n]"], :doc "Returns true if n is a JavaScript number with no decimal part.", :end-row 2286, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "integer?", :ns "cljs.core", :row 2280} {:doc "INTERNAL: do not use", :end-row 2290, :filename "cljs/core.cljs", :name "LongImpl", :ns "cljs.core", :row 2288} {:arglist-strs ["[x]"], :doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long.", :end-row 2298, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "int?", :ns "cljs.core", :row 2292} {:arglist-strs ["[x]"], :doc "Return true if x satisfies int? and is positive.", :end-row 2314, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pos-int?", :ns "cljs.core", :row 2300} {:arglist-strs ["[x]"], :doc "Return true if x satisfies int? and is negative.", :end-row 2328, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "neg-int?", :ns "cljs.core", :row 2316} {:arglist-strs ["[x]"], :doc "Return true if x satisfies int? and is a natural integer value.", :end-row 2343, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "nat-int?", :ns "cljs.core", :row 2330} {:arglist-strs ["[x]"], :doc "Returns true for JavaScript numbers, false otherwise.", :end-row 2348, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "float?", :ns "cljs.core", :row 2345} {:arglist-strs ["[x]"], :doc "Returns true for JavaScript numbers, false otherwise.", :end-row 2353, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "double?", :ns "cljs.core", :row 2350} {:arglist-strs ["[x]"], :doc "Returns true for Infinity and -Infinity values.", :end-row 2359, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "infinite?", :ns "cljs.core", :row 2355} {:arglist-strs ["[coll v]"], :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :end-row 2379, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "contains?", :ns "cljs.core", :row 2361} {:arglist-strs ["[coll k]"], :doc "Returns the map entry for key, or nil if key not present.", :end-row 2389, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "find", :ns "cljs.core", :row 2381} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns true if no two of the arguments are =", :end-row 2405, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "distinct?", :ns "cljs.core", :row 2391} {:arglist-strs ["[x y]"], :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :end-row 2433, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "compare", :ns "cljs.core", :row 2409} {:fixed-arities #{4 2}, :end-row 2449, :private true, :ns "cljs.core", :name "compare-indexed", :filename "cljs/core.cljs", :arglist-strs ["[xs ys]" "[xs ys len n]"], :doc "Compare indexed collection.", :row 2435} {:fixed-arities #{1}, :end-row 2463, :private true, :ns "cljs.core", :name "fn->comparator", :filename "cljs/core.cljs", :arglist-strs ["[f]"], :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator.", :row 2451} {:end-row 2465, :filename "cljs/core.cljs", :name "to-array", :ns "cljs.core", :row 2465} {:arglist-strs ["[coll]" "[comp coll]"], :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :end-row 2479, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "sort", :ns "cljs.core", :row 2467} {:arglist-strs ["[keyfn coll]" "[keyfn comp coll]"], :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :end-row 2489, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "sort-by", :ns "cljs.core", :row 2481} {:arglist-strs ["[f coll]" "[f val coll]"], :end-row 2504, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "seq-reduce", :ns "cljs.core", :private true, :row 2492} {:end-row 2506, :filename "cljs/core.cljs", :name "vec", :ns "cljs.core", :row 2506} {:arglist-strs ["[coll]"], :doc "Return a random permutation of coll", :end-row 2513, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "shuffle", :ns "cljs.core", :row 2508} {:arglist-strs ["[coll f]" "[coll f init]"], :end-row 2536, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "iter-reduce", :ns "cljs.core", :private true, :row 2515} {:arglist-strs ["[f coll]" "[f val coll]"], :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :end-row 2585, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "reduce", :ns "cljs.core", :row 2538} {:arglist-strs ["[f init coll]"], :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :end-row 2597, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "reduce-kv", :ns "cljs.core", :row 2587} {:arglist-strs ["[x]"], :doc "Returns its argument.", :end-row 2601, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "identity", :ns "cljs.core", :row 2599} {:arglist-strs ["[f]" "[f cf]"], :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :end-row 2612, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "completing", :ns "cljs.core", :row 2603} {:arglist-strs ["[xform f coll]" "[xform f init coll]"], :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :end-row 2627, :filename "cljs/core.cljs", :fixed-arities #{4 3}, :name "transduce", :ns "cljs.core", :row 2614} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the sum of nums. (+) returns 0.", :end-row 2638, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "+", :ns "cljs.core", :row 2632} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :end-row 2645, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "-", :ns "cljs.core", :row 2640} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the product of nums. (*) returns 1.", :end-row 2652, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "*", :ns "cljs.core", :row 2647} {:end-row 2654, :filename "cljs/core.cljs", :name "divide", :ns "cljs.core", :row 2654} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :end-row 2661, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "/", :ns "cljs.core", :row 2656} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :end-row 2673, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "<", :ns "cljs.core", :row 2663} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :end-row 2685, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "<=", :ns "cljs.core", :row 2675} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :end-row 2697, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name ">", :ns "cljs.core", :row 2687} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :end-row 2709, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name ">=", :ns "cljs.core", :row 2699} {:arglist-strs ["[x]"], :doc "Returns a number one less than num.", :end-row 2713, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "dec", :ns "cljs.core", :row 2711} {:arglist-strs ["[a]"], :doc "Returns the absolute value of a.", :end-row 2718, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "abs", :ns "cljs.core", :row 2715} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns the greatest of the nums.", :end-row 2725, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "max", :ns "cljs.core", :row 2720} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns the least of the nums.", :end-row 2732, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "min", :ns "cljs.core", :row 2727} {:arglist-strs ["[x]"], :end-row 2734, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "byte", :ns "cljs.core", :row 2734} {:arglist-strs ["[x]"], :doc "Coerce to char", :end-row 2742, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "char", :ns "cljs.core", :row 2736} {:arglist-strs ["[x]"], :end-row 2744, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "short", :ns "cljs.core", :row 2744} {:arglist-strs ["[x]"], :end-row 2745, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "float", :ns "cljs.core", :row 2745} {:arglist-strs ["[x]"], :end-row 2746, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "double", :ns "cljs.core", :row 2746} {:arglist-strs ["[x]"], :end-row 2748, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-byte", :ns "cljs.core", :row 2748} {:arglist-strs ["[x]"], :end-row 2749, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-char", :ns "cljs.core", :row 2749} {:arglist-strs ["[x]"], :end-row 2750, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-short", :ns "cljs.core", :row 2750} {:arglist-strs ["[x]"], :end-row 2751, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-float", :ns "cljs.core", :row 2751} {:arglist-strs ["[x]"], :end-row 2752, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-double", :ns "cljs.core", :row 2752} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the sum of nums. (+) returns 0.", :end-row 2759, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "unchecked-add", :ns "cljs.core", :row 2754} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the sum of nums. (+) returns 0.", :end-row 2766, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "unchecked-add-int", :ns "cljs.core", :row 2761} {:arglist-strs ["[x]"], :doc "Returns a number one less than x, an int.", :end-row 2771, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-dec", :ns "cljs.core", :row 2768} {:arglist-strs ["[x]"], :doc "Returns a number one less than x, an int.", :end-row 2776, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-dec-int", :ns "cljs.core", :row 2773} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :end-row 2783, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "unchecked-divide-int", :ns "cljs.core", :row 2778} {:arglist-strs ["[x]"], :end-row 2786, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-inc", :ns "cljs.core", :row 2785} {:arglist-strs ["[x]"], :end-row 2789, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-inc-int", :ns "cljs.core", :row 2788} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the product of nums. (*) returns 1.", :end-row 2796, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "unchecked-multiply", :ns "cljs.core", :row 2791} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the product of nums. (*) returns 1.", :end-row 2803, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "unchecked-multiply-int", :ns "cljs.core", :row 2798} {:arglist-strs ["[x]"], :end-row 2806, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-negate", :ns "cljs.core", :row 2805} {:arglist-strs ["[x]"], :end-row 2809, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-negate-int", :ns "cljs.core", :row 2808} {:end-row 2811, :filename "cljs/core.cljs", :name "mod", :ns "cljs.core", :row 2811} {:arglist-strs ["[x n]"], :end-row 2814, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "unchecked-remainder-int", :ns "cljs.core", :row 2813} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :end-row 2821, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "unchecked-subtract", :ns "cljs.core", :row 2816} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :end-row 2828, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "unchecked-subtract-int", :ns "cljs.core", :row 2823} {:arglist-strs ["[q]"], :end-row 2833, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "fix", :ns "cljs.core", :private true, :row 2830} {:arglist-strs ["[x]"], :doc "Coerce to int by stripping decimal places.", :end-row 2838, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "int", :ns "cljs.core", :row 2835} {:arglist-strs ["[x]"], :doc "Coerce to int by stripping decimal places.", :end-row 2843, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-int", :ns "cljs.core", :row 2840} {:arglist-strs ["[x]"], :doc "Coerce to long by stripping decimal places. Identical to `int'.", :end-row 2848, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "long", :ns "cljs.core", :row 2845} {:arglist-strs ["[x]"], :doc "Coerce to long by stripping decimal places. Identical to `int'.", :end-row 2853, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-long", :ns "cljs.core", :row 2850} {:arglist-strs ["[x]"], :end-row 2855, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "booleans", :ns "cljs.core", :row 2855} {:arglist-strs ["[x]"], :end-row 2856, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "bytes", :ns "cljs.core", :row 2856} {:arglist-strs ["[x]"], :end-row 2857, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chars", :ns "cljs.core", :row 2857} {:arglist-strs ["[x]"], :end-row 2858, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "shorts", :ns "cljs.core", :row 2858} {:arglist-strs ["[x]"], :end-row 2859, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ints", :ns "cljs.core", :row 2859} {:arglist-strs ["[x]"], :end-row 2860, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "floats", :ns "cljs.core", :row 2860} {:arglist-strs ["[x]"], :end-row 2861, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "doubles", :ns "cljs.core", :row 2861} {:arglist-strs ["[x]"], :end-row 2862, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "longs", :ns "cljs.core", :row 2862} {:arglist-strs ["[n d]"], :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :end-row 2867, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "js-mod", :ns "cljs.core", :row 2864} {:arglist-strs ["[n d]"], :doc "Modulus of num and div. Truncates toward negative infinity.", :end-row 2872, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "mod", :ns "cljs.core", :row 2869} {:arglist-strs ["[n d]"], :doc "quot[ient] of dividing numerator by denominator.", :end-row 2878, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "quot", :ns "cljs.core", :row 2874} {:arglist-strs ["[n d]"], :doc "remainder of dividing numerator by denominator.", :end-row 2884, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "rem", :ns "cljs.core", :row 2880} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise exclusive or", :end-row 2890, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-xor", :ns "cljs.core", :row 2886} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise and", :end-row 2896, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-and", :ns "cljs.core", :row 2892} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise or", :end-row 2902, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-or", :ns "cljs.core", :row 2898} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise and with complement", :end-row 2908, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-and-not", :ns "cljs.core", :row 2904} {:arglist-strs ["[x n]"], :doc "Clear bit at index n", :end-row 2913, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-clear", :ns "cljs.core", :row 2910} {:arglist-strs ["[x n]"], :doc "Flip bit at index n", :end-row 2918, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-flip", :ns "cljs.core", :row 2915} {:arglist-strs ["[x]"], :doc "Bitwise complement", :end-row 2922, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "bit-not", :ns "cljs.core", :row 2920} {:arglist-strs ["[x n]"], :doc "Set bit at index n", :end-row 2927, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-set", :ns "cljs.core", :row 2924} {:arglist-strs ["[x n]"], :doc "Test bit at index n", :end-row 2932, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-test", :ns "cljs.core", :row 2929} {:arglist-strs ["[x n]"], :doc "Bitwise shift left", :end-row 2936, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-shift-left", :ns "cljs.core", :row 2934} {:arglist-strs ["[x n]"], :doc "Bitwise shift right", :end-row 2940, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-shift-right", :ns "cljs.core", :row 2938} {:arglist-strs ["[x n]"], :doc "DEPRECATED: Bitwise shift right with zero fill", :end-row 2944, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-shift-right-zero-fill", :ns "cljs.core", :row 2942} {:arglist-strs ["[x n]"], :doc "Bitwise shift right with zero fill", :end-row 2948, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "unsigned-bit-shift-right", :ns "cljs.core", :row 2946} {:arglist-strs ["[v]"], :doc "Counts the number of bits set in n", :end-row 2955, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "bit-count", :ns "cljs.core", :row 2950} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :end-row 2968, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "==", :ns "cljs.core", :row 2957} {:arglist-strs ["[x]"], :doc "Returns true if num is greater than zero, else false", :end-row 2972, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pos?", :ns "cljs.core", :row 2970} {:arglist-strs ["[x]"], :doc "Returns true if num is zero, else false", :end-row 2977, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "zero?", :ns "cljs.core", :row 2974} {:arglist-strs ["[x]"], :doc "Returns true if num is less than zero, else false", :end-row 2981, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "neg?", :ns "cljs.core", :row 2979} {:arglist-strs ["[coll n]"], :doc "Returns the nth next of coll, (seq coll) when n is 0.", :end-row 2991, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "nthnext", :ns "cljs.core", :row 2985} {:arglist-strs ["[]" "[x]" "[x & ys]"], :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :end-row 3007, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "str", :ns "cljs.core", :row 2995} {:arglist-strs ["[s start]" "[s start end]"], :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :end-row 3013, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "subs", :ns "cljs.core", :row 3009} {:end-row 3015, :filename "cljs/core.cljs", :name "map", :ns "cljs.core", :row 3015} {:end-row 3015, :filename "cljs/core.cljs", :name "name", :ns "cljs.core", :row 3015} {:fixed-arities #{2}, :end-row 3030, :private true, :ns "cljs.core", :name "equiv-sequential", :filename "cljs/core.cljs", :arglist-strs ["[x y]"], :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false.", :row 3017} {:arglist-strs ["[coll]"], :end-row 3038, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-coll", :ns "cljs.core", :private true, :row 3032} {:end-row 3040, :filename "cljs/core.cljs", :name "key", :ns "cljs.core", :row 3040} {:end-row 3040, :filename "cljs/core.cljs", :name "val", :ns "cljs.core", :row 3040} {:arglist-strs ["[m]"], :end-row 3050, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-imap", :ns "cljs.core", :private true, :row 3042} {:arglist-strs ["[s]"], :end-row 3059, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-iset", :ns "cljs.core", :private true, :row 3052} {:end-row 3061, :filename "cljs/core.cljs", :name "name", :ns "cljs.core", :row 3061} {:end-row 3061, :filename "cljs/core.cljs", :name "chunk-first", :ns "cljs.core", :row 3061} {:end-row 3061, :filename "cljs/core.cljs", :name "chunk-rest", :ns "cljs.core", :row 3061} {:fixed-arities #{2}, :end-row 3072, :private true, :ns "cljs.core", :name "extend-object!", :filename "cljs/core.cljs", :arglist-strs ["[obj fn-map]"], :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached.", :row 3063} {:end-row 3143, :filename "cljs/core.cljs", :name "List", :ns "cljs.core", :row 3075} {:arglist-strs ["[meta first rest count __hash]"], :end-row 3143, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->List", :ns "cljs.core", :row 3075} {:arglist-strs ["[x]"], :doc "Returns true if x implements IList", :end-row 3148, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "list?", :ns "cljs.core", :row 3145} {:end-row 3217, :filename "cljs/core.cljs", :name "EmptyList", :ns "cljs.core", :row 3152} {:arglist-strs ["[meta]"], :end-row 3217, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->EmptyList", :ns "cljs.core", :row 3152} {:arglist-strs ["[coll]"], :doc "Returns true if coll satisfies? IReversible.", :end-row 3226, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reversible?", :ns "cljs.core", :row 3223} {:arglist-strs ["[rev]"], :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :end-row 3232, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "rseq", :ns "cljs.core", :row 3228} {:arglist-strs ["[coll]"], :doc "Returns a seq of the items in coll in reverse order. Not lazy.", :end-row 3239, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reverse", :ns "cljs.core", :row 3234} {:arglist-strs ["[& xs]"], :doc "Creates a new list containing the items.", :end-row 3256, :filename "cljs/core.cljs", :name "list", :ns "cljs.core", :row 3241} {:end-row 3314, :filename "cljs/core.cljs", :name "Cons", :ns "cljs.core", :row 3258} {:arglist-strs ["[meta first rest __hash]"], :end-row 3314, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->Cons", :ns "cljs.core", :row 3258} {:arglist-strs ["[x coll]"], :doc "Returns a new seq where x is the first element and coll is the rest.", :end-row 3324, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "cons", :ns "cljs.core", :row 3318} {:arglist-strs ["[k]"], :end-row 3327, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-keyword", :ns "cljs.core", :row 3326} {:arglist-strs ["[a b]"], :end-row 3339, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "compare-keywords", :ns "cljs.core", :private true, :row 3329} {:end-row 3367, :filename "cljs/core.cljs", :name "Keyword", :ns "cljs.core", :row 3341} {:arglist-strs ["[ns name fqn _hash]"], :end-row 3367, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->Keyword", :ns "cljs.core", :row 3341} {:arglist-strs ["[x]"], :doc "Return true if x is a Keyword", :end-row 3372, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "keyword?", :ns "cljs.core", :row 3369} {:arglist-strs ["[x y]"], :doc "Efficient test to determine that two keywords are identical.", :end-row 3381, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "keyword-identical?", :ns "cljs.core", :row 3374} {:arglist-strs ["[x y]"], :doc "Efficient test to determine that two symbols are identical.", :end-row 3390, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "symbol-identical?", :ns "cljs.core", :row 3383} {:arglist-strs ["[x]"], :doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :end-row 3397, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "namespace", :ns "cljs.core", :row 3392} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol or keyword", :end-row 3401, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ident?", :ns "cljs.core", :row 3399} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol or keyword without a namespace", :end-row 3405, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "simple-ident?", :ns "cljs.core", :row 3403} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol or keyword with a namespace", :end-row 3409, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "qualified-ident?", :ns "cljs.core", :row 3407} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol without a namespace", :end-row 3413, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "simple-symbol?", :ns "cljs.core", :row 3411} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol with a namespace", :end-row 3417, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "qualified-symbol?", :ns "cljs.core", :row 3415} {:arglist-strs ["[x]"], :doc "Return true if x is a keyword without a namespace", :end-row 3421, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "simple-keyword?", :ns "cljs.core", :row 3419} {:arglist-strs ["[x]"], :doc "Return true if x is a keyword with a namespace", :end-row 3425, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "qualified-keyword?", :ns "cljs.core", :row 3423} {:arglist-strs ["[name]" "[ns name]"], :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :end-row 3449, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "keyword", :ns "cljs.core", :row 3427} {:end-row 3529, :filename "cljs/core.cljs", :name "LazySeq", :ns "cljs.core", :row 3452} {:arglist-strs ["[meta fn s __hash]"], :end-row 3529, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->LazySeq", :ns "cljs.core", :row 3452} {:end-row 3533, :filename "cljs/core.cljs", :name "ArrayChunk", :ns "cljs.core", :row 3533} {:end-row 3547, :filename "cljs/core.cljs", :name "ChunkBuffer", :ns "cljs.core", :row 3535} {:arglist-strs ["[buf end]"], :end-row 3547, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->ChunkBuffer", :ns "cljs.core", :row 3535} {:arglist-strs ["[capacity]"], :end-row 3550, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk-buffer", :ns "cljs.core", :row 3549} {:end-row 3574, :filename "cljs/core.cljs", :name "ArrayChunk", :ns "cljs.core", :row 3552} {:arglist-strs ["[arr off end]"], :end-row 3574, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->ArrayChunk", :ns "cljs.core", :row 3552} {:arglist-strs ["[arr]" "[arr off]" "[arr off end]"], :end-row 3582, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "array-chunk", :ns "cljs.core", :row 3576} {:end-row 3653, :filename "cljs/core.cljs", :name "ChunkedCons", :ns "cljs.core", :row 3584} {:arglist-strs ["[chunk more meta __hash]"], :end-row 3653, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->ChunkedCons", :ns "cljs.core", :row 3584} {:arglist-strs ["[chunk rest]"], :end-row 3660, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "chunk-cons", :ns "cljs.core", :row 3657} {:arglist-strs ["[b x]"], :end-row 3663, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "chunk-append", :ns "cljs.core", :row 3662} {:arglist-strs ["[b]"], :end-row 3666, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk", :ns "cljs.core", :row 3665} {:arglist-strs ["[s]"], :end-row 3669, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk-first", :ns "cljs.core", :row 3668} {:arglist-strs ["[s]"], :end-row 3672, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk-rest", :ns "cljs.core", :row 3671} {:arglist-strs ["[s]"], :end-row 3677, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk-next", :ns "cljs.core", :row 3674} {:arglist-strs ["[coll]"], :doc "Returns an array containing the contents of coll.", :end-row 3689, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "to-array", :ns "cljs.core", :row 3681} {:arglist-strs ["[coll]"], :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :end-row 3700, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "to-array-2d", :ns "cljs.core", :row 3691} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :end-row 3722, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "int-array", :ns "cljs.core", :row 3702} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :end-row 3744, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "long-array", :ns "cljs.core", :row 3724} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :end-row 3766, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "double-array", :ns "cljs.core", :row 3746} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :end-row 3788, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "object-array", :ns "cljs.core", :row 3768} {:arglist-strs ["[n coll]"], :doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :end-row 3800, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bounded-count", :ns "cljs.core", :row 3790} {:arglist-strs ["[arglist]"], :end-row 3809, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "spread", :ns "cljs.core", :row 3802} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & zs]"], :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :end-row 3834, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "concat", :ns "cljs.core", :row 3811} {:arglist-strs ["[args]" "[a args]" "[a b args]" "[a b c args]" "[a b c d & more]"], :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :end-row 3844, :filename "cljs/core.cljs", :fixed-arities #{1 4 3 2}, :name "list*", :ns "cljs.core", :row 3836} {:arglist-strs ["[coll]"], :doc "Returns a new, transient version of the collection, in constant time.", :end-row 3852, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "transient", :ns "cljs.core", :row 3849} {:arglist-strs ["[tcoll]"], :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :end-row 3859, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "persistent!", :ns "cljs.core", :row 3854} {:arglist-strs ["[]" "[tcoll]" "[tcoll val]" "[tcoll val & vals]"], :doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :end-row 3872, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "conj!", :ns "cljs.core", :row 3861} {:arglist-strs ["[tcoll key val]" "[tcoll key val & kvs]"], :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :end-row 3884, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "assoc!", :ns "cljs.core", :row 3874} {:arglist-strs ["[tcoll key]" "[tcoll key & ks]"], :doc "Returns a transient map that doesn't contain a mapping for key(s).", :end-row 3894, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "dissoc!", :ns "cljs.core", :row 3886} {:arglist-strs ["[tcoll]"], :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll", :end-row 3900, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pop!", :ns "cljs.core", :row 3896} {:arglist-strs ["[tcoll val]" "[tcoll val & vals]"], :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :end-row 3911, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "disj!", :ns "cljs.core", :row 3902} {:fixed-arities #{1}, :end-row 3926, :private true, :ns "cljs.core", :name "next*", :filename "cljs/core.cljs", :arglist-strs ["[coll]"], :doc "Internal. DO NOT USE! Next without the nil? check.", :row 3921} {:fixed-arities #{4 6 3 2 5}, :end-row 3960, :private true, :ns "cljs.core", :name "apply-to-simple", :filename "cljs/core.cljs", :arglist-strs ["[f args]" "[f a0 args]" "[f a0 a1 args]" "[f a0 a1 a2 args]" "[f a0 a1 a2 a3 args]"], :doc "Internal. DO NOT USE!\n  Assumes args was already called with seq beforehand!", :row 3928} {:arglist-strs ["[f args]" "[f x args]" "[f x y args]" "[f x y z args]" "[f a b c d & args]"], :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :end-row 4008, :filename "cljs/core.cljs", :fixed-arities #{4 3 2 5}, :name "apply", :ns "cljs.core", :row 3962} {:arglist-strs ["[gmap]"], :end-row 4021, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "--destructure-map", :ns "cljs.core", :row 4014} {:arglist-strs ["[obj f]" "[obj f a]" "[obj f a b]" "[obj f a b c]" "[obj f a b c d]" "[obj f a b c d & args]"], :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :end-row 4037, :filename "cljs/core.cljs", :fixed-arities #{4 6 3 2 5}, :name "vary-meta", :ns "cljs.core", :row 4023} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Same as (not (= obj1 obj2))", :end-row 4044, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "not=", :ns "cljs.core", :row 4039} {:arglist-strs ["[coll]"], :doc "If coll is empty, returns nil, else coll", :end-row 4048, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "not-empty", :ns "cljs.core", :row 4046} {:arglist-strs ["[]"], :end-row 4055, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "nil-iter", :ns "cljs.core", :row 4050} {:end-row 4064, :filename "cljs/core.cljs", :name "StringIter", :ns "cljs.core", :row 4057} {:arglist-strs ["[s i]"], :end-row 4064, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->StringIter", :ns "cljs.core", :row 4057} {:arglist-strs ["[x]"], :end-row 4067, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "string-iter", :ns "cljs.core", :row 4066} {:end-row 4076, :filename "cljs/core.cljs", :name "ArrayIter", :ns "cljs.core", :row 4069} {:arglist-strs ["[arr i]"], :end-row 4076, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->ArrayIter", :ns "cljs.core", :row 4069} {:arglist-strs ["[x]"], :end-row 4079, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "array-iter", :ns "cljs.core", :row 4078} {:end-row 4081, :filename "cljs/core.cljs", :name "INIT", :ns "cljs.core", :row 4081} {:end-row 4082, :filename "cljs/core.cljs", :name "START", :ns "cljs.core", :row 4082} {:end-row 4100, :filename "cljs/core.cljs", :name "SeqIter", :ns "cljs.core", :row 4084} {:arglist-strs ["[_seq _next]"], :end-row 4100, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->SeqIter", :ns "cljs.core", :row 4084} {:arglist-strs ["[coll]"], :end-row 4103, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seq-iter", :ns "cljs.core", :row 4102} {:arglist-strs ["[coll]"], :end-row 4112, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "iter", :ns "cljs.core", :row 4105} {:end-row 4124, :filename "cljs/core.cljs", :name "Many", :ns "cljs.core", :row 4114} {:arglist-strs ["[vals]"], :end-row 4124, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Many", :ns "cljs.core", :row 4114} {:end-row 4126, :filename "cljs/core.cljs", :name "NONE", :ns "cljs.core", :private true, :row 4126} {:end-row 4145, :filename "cljs/core.cljs", :name "Single", :ns "cljs.core", :row 4128} {:arglist-strs ["[val]"], :end-row 4145, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Single", :ns "cljs.core", :row 4128} {:end-row 4156, :filename "cljs/core.cljs", :name "Empty", :ns "cljs.core", :row 4147} {:arglist-strs ["[]"], :end-row 4156, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "->Empty", :ns "cljs.core", :row 4147} {:end-row 4158, :filename "cljs/core.cljs", :name "EMPTY", :ns "cljs.core", :private true, :row 4158} {:end-row 4174, :filename "cljs/core.cljs", :name "MultiIterator", :ns "cljs.core", :row 4160} {:arglist-strs ["[iters]"], :end-row 4174, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->MultiIterator", :ns "cljs.core", :row 4160} {:arglist-strs ["[iter]"], :end-row 4185, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunkIteratorSeq", :ns "cljs.core", :private true, :row 4176} {:end-row 4222, :filename "cljs/core.cljs", :name "TransformerIterator", :ns "cljs.core", :row 4187} {:arglist-strs ["[buffer _next completed xf sourceIter multi]"], :end-row 4222, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->TransformerIterator", :ns "cljs.core", :row 4187} {:arglist-strs ["[xform sourceIter multi]"], :end-row 4236, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "transformer-iterator", :ns "cljs.core", :row 4226} {:arglist-strs ["[coll]" "[xform coll]" "[xform coll & colls]"], :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :end-row 4266, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "sequence", :ns "cljs.core", :row 4246} {:arglist-strs ["[pred coll]"], :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :end-row 4275, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "every?", :ns "cljs.core", :row 4268} {:arglist-strs ["[pred coll]"], :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :end-row 4280, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "not-every?", :ns "cljs.core", :row 4277} {:arglist-strs ["[pred coll]"], :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :end-row 4289, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "some", :ns "cljs.core", :row 4282} {:arglist-strs ["[pred coll]"], :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :end-row 4294, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "not-any?", :ns "cljs.core", :row 4291} {:arglist-strs ["[n]"], :doc "Returns true if n is even, throws an exception if n is not an integer", :end-row 4300, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "even?", :ns "cljs.core", :row 4296} {:arglist-strs ["[n]"], :doc "Returns true if n is odd, throws an exception if n is not an integer", :end-row 4304, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "odd?", :ns "cljs.core", :row 4302} {:arglist-strs ["[f]"], :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :end-row 4314, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "complement", :ns "cljs.core", :row 4306} {:arglist-strs ["[x]"], :doc "Returns a function that takes any number of arguments and returns x.", :end-row 4318, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "constantly", :ns "cljs.core", :row 4316} {:arglist-strs ["[]" "[f]" "[f g]" "[f g h]" "[f1 f2 f3 & fs]"], :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :end-row 4347, :filename "cljs/core.cljs", :fixed-arities #{0 1 3 2}, :name "comp", :ns "cljs.core", :row 4320} {:arglist-strs ["[f]" "[f arg1]" "[f arg1 arg2]" "[f arg1 arg2 arg3]" "[f arg1 arg2 arg3 & more]"], :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :end-row 4376, :filename "cljs/core.cljs", :fixed-arities #{1 4 3 2}, :name "partial", :ns "cljs.core", :row 4349} {:arglist-strs ["[f x]" "[f x y]" "[f x y z]"], :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :end-row 4399, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "fnil", :ns "cljs.core", :row 4378} {:end-row 4401, :filename "cljs/core.cljs", :name "volatile!", :ns "cljs.core", :row 4401} {:arglist-strs ["[f]" "[f coll]"], :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :end-row 4429, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "map-indexed", :ns "cljs.core", :row 4403} {:arglist-strs ["[f]" "[f coll]"], :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :end-row 4460, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "keep", :ns "cljs.core", :row 4431} {:end-row 4492, :filename "cljs/core.cljs", :name "Atom", :ns "cljs.core", :row 4465} {:arglist-strs ["[state meta validator watches]"], :end-row 4492, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->Atom", :ns "cljs.core", :row 4465} {:arglist-strs ["[x]" "[x & {:keys [meta validator]}]"], :doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :end-row 4509, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "atom", :ns "cljs.core", :row 4494} {:end-row 4511, :filename "cljs/core.cljs", :name "pr-str", :ns "cljs.core", :row 4511} {:arglist-strs ["[a new-value]"], :doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value.", :end-row 4527, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "reset!", :ns "cljs.core", :row 4513} {:arglist-strs ["[a new-value]"], :doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :end-row 4542, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "reset-vals!", :ns "cljs.core", :row 4529} {:arglist-strs ["[a f]" "[a f x]" "[a f x y]" "[a f x y & more]"], :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :end-row 4564, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "swap!", :ns "cljs.core", :row 4544} {:arglist-strs ["[a f]" "[a f x]" "[a f x y]" "[a f x y & more]"], :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :end-row 4579, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "swap-vals!", :ns "cljs.core", :row 4566} {:arglist-strs ["[a oldval newval]"], :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :end-row 4588, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "compare-and-set!", :ns "cljs.core", :row 4581} {:arglist-strs ["[iref val]"], :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :end-row 4601, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "set-validator!", :ns "cljs.core", :row 4590} {:arglist-strs ["[iref]"], :doc "Gets the validator-fn for a var/ref/agent/atom.", :end-row 4606, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "get-validator", :ns "cljs.core", :row 4603} {:end-row 4614, :filename "cljs/core.cljs", :name "Volatile", :ns "cljs.core", :row 4608} {:arglist-strs ["[state]"], :end-row 4614, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Volatile", :ns "cljs.core", :row 4608} {:arglist-strs ["[val]"], :doc "Creates and returns a Volatile with an initial value of val.", :end-row 4619, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "volatile!", :ns "cljs.core", :row 4616} {:arglist-strs ["[x]"], :doc "Returns true if x is a volatile.", :end-row 4623, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "volatile?", :ns "cljs.core", :row 4621} {:arglist-strs ["[vol newval]"], :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :end-row 4628, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "vreset!", :ns "cljs.core", :row 4625} {:arglist-strs ["[f]" "[f coll]"], :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :end-row 4664, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "keep-indexed", :ns "cljs.core", :row 4630} {:arglist-strs ["[p]" "[p1 p2]" "[p1 p2 p3]" "[p1 p2 p3 & ps]"], :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :end-row 4703, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "every-pred", :ns "cljs.core", :row 4666} {:arglist-strs ["[p]" "[p1 p2]" "[p1 p2 p3]" "[p1 p2 p3 & ps]"], :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :end-row 4742, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "some-fn", :ns "cljs.core", :row 4705} {:arglist-strs ["[f]" "[f coll]" "[f c1 c2]" "[f c1 c2 c3]" "[f c1 c2 c3 & colls]"], :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :end-row 4789, :filename "cljs/core.cljs", :fixed-arities #{1 4 3 2}, :name "map", :ns "cljs.core", :row 4744} {:arglist-strs ["[n]" "[n coll]"], :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :end-row 4816, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "take", :ns "cljs.core", :row 4791} {:arglist-strs ["[n]" "[n coll]"], :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :end-row 4841, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "drop", :ns "cljs.core", :row 4818} {:arglist-strs ["[s]" "[n s]"], :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :end-row 4846, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "drop-last", :ns "cljs.core", :row 4843} {:arglist-strs ["[n coll]"], :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :end-row 4855, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "take-last", :ns "cljs.core", :row 4848} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :end-row 4880, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "drop-while", :ns "cljs.core", :row 4857} {:end-row 4941, :filename "cljs/core.cljs", :name "Cycle", :ns "cljs.core", :row 4882} {:arglist-strs ["[meta all prev current _next]"], :end-row 4941, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Cycle", :ns "cljs.core", :row 4882} {:arglist-strs ["[coll]"], :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :end-row 4947, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "cycle", :ns "cljs.core", :row 4943} {:arglist-strs ["[n coll]"], :doc "Returns a vector of [(take n coll) (drop n coll)]", :end-row 4952, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "split-at", :ns "cljs.core", :row 4949} {:end-row 5049, :filename "cljs/core.cljs", :name "Repeat", :ns "cljs.core", :row 4954} {:arglist-strs ["[meta count val next __hash]"], :end-row 5049, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Repeat", :ns "cljs.core", :row 4954} {:arglist-strs ["[x]" "[n x]"], :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :end-row 5056, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "repeat", :ns "cljs.core", :row 5051} {:arglist-strs ["[n x]"], :doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs.", :end-row 5061, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "replicate", :ns "cljs.core", :row 5058} {:arglist-strs ["[f]" "[n f]"], :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :end-row 5068, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "repeatedly", :ns "cljs.core", :row 5063} {:end-row 5070, :filename "cljs/core.cljs", :name "UNREALIZED-SEED", :ns "cljs.core", :private true, :row 5070} {:end-row 5129, :filename "cljs/core.cljs", :name "Iterate", :ns "cljs.core", :row 5072} {:arglist-strs ["[meta f prev-seed seed next]"], :end-row 5129, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Iterate", :ns "cljs.core", :row 5072} {:arglist-strs ["[f x]"], :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :end-row 5134, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "iterate", :ns "cljs.core", :row 5131} {:arglist-strs ["[]" "[c1]" "[c1 c2]" "[c1 c2 & colls]"], :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :end-row 5150, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "interleave", :ns "cljs.core", :row 5136} {:arglist-strs ["[sep]" "[sep coll]"], :doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :end-row 5170, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "interpose", :ns "cljs.core", :row 5152} {:fixed-arities #{1}, :end-row 5184, :private true, :ns "cljs.core", :name "flatten1", :filename "cljs/core.cljs", :arglist-strs ["[colls]"], :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection", :row 5174} {:end-row 5186, :filename "cljs/core.cljs", :name "cat", :ns "cljs.core", :row 5186} {:arglist-strs ["[f]" "[f & colls]"], :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :end-row 5196, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "mapcat", :ns "cljs.core", :row 5188} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-row 5225, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "filter", :ns "cljs.core", :row 5198} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-row 5233, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "remove", :ns "cljs.core", :row 5227} {:arglist-strs ["[branch? children root]"], :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree.", :end-row 5248, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "tree-seq", :ns "cljs.core", :row 5235} {:arglist-strs ["[x]"], :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :end-row 5256, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "flatten", :ns "cljs.core", :row 5250} {:arglist-strs ["[]" "[to]" "[to from]" "[to xform from]"], :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :end-row 5276, :filename "cljs/core.cljs", :fixed-arities #{0 1 3 2}, :name "into", :ns "cljs.core", :row 5258} {:arglist-strs ["[f coll]" "[f c1 c2]" "[f c1 c2 c3]" "[f c1 c2 c3 & colls]"], :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :end-row 5292, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "mapv", :ns "cljs.core", :row 5278} {:arglist-strs ["[pred coll]"], :doc "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.", :end-row 5301, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "filterv", :ns "cljs.core", :row 5294} {:arglist-strs ["[n coll]" "[n step coll]" "[n step pad coll]"], :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :end-row 5323, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "partition", :ns "cljs.core", :row 5303} {:arglist-strs ["[m ks]" "[m ks not-found]"], :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :end-row 5342, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "get-in", :ns "cljs.core", :row 5325} {:arglist-strs ["[m [k & ks] v]"], :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :end-row 5351, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "assoc-in", :ns "cljs.core", :row 5344} {:arglist-strs ["[m [k & ks] f]" "[m [k & ks] f a]" "[m [k & ks] f a b]" "[m [k & ks] f a b c]" "[m [k & ks] f a b c & args]"], :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :end-row 5378, :filename "cljs/core.cljs", :fixed-arities #{4 6 3 5}, :name "update-in", :ns "cljs.core", :row 5353} {:arglist-strs ["[m k f]" "[m k f x]" "[m k f x y]" "[m k f x y z]" "[m k f x y z & more]"], :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :end-row 5394, :filename "cljs/core.cljs", :fixed-arities #{4 6 3 5}, :name "update", :ns "cljs.core", :row 5380} {:end-row 5398, :filename "cljs/core.cljs", :name "VectorNode", :ns "cljs.core", :row 5398} {:arglist-strs ["[edit arr]"], :end-row 5398, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->VectorNode", :ns "cljs.core", :row 5398} {:arglist-strs ["[edit]"], :end-row 5401, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pv-fresh-node", :ns "cljs.core", :private true, :row 5400} {:arglist-strs ["[node idx]"], :end-row 5404, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "pv-aget", :ns "cljs.core", :private true, :row 5403} {:arglist-strs ["[node idx val]"], :end-row 5407, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pv-aset", :ns "cljs.core", :private true, :row 5406} {:arglist-strs ["[node]"], :end-row 5410, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pv-clone-node", :ns "cljs.core", :private true, :row 5409} {:arglist-strs ["[pv]"], :end-row 5416, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tail-off", :ns "cljs.core", :private true, :row 5412} {:arglist-strs ["[edit level node]"], :end-row 5426, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "new-path", :ns "cljs.core", :private true, :row 5418} {:arglist-strs ["[pv level parent tailnode]"], :end-row 5442, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "push-tail", :ns "cljs.core", :private true, :row 5428} {:arglist-strs ["[i cnt]"], :end-row 5445, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "vector-index-out-of-bounds", :ns "cljs.core", :private true, :row 5444} {:arglist-strs ["[pv]"], :end-row 5453, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "first-array-for-longvec", :ns "cljs.core", :private true, :row 5447} {:arglist-strs ["[pv i]"], :end-row 5464, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "unchecked-array-for", :ns "cljs.core", :private true, :row 5455} {:arglist-strs ["[pv i]"], :end-row 5469, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-for", :ns "cljs.core", :private true, :row 5466} {:arglist-strs ["[pv level node i val]"], :end-row 5479, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "do-assoc", :ns "cljs.core", :private true, :row 5471} {:arglist-strs ["[pv level node]"], :end-row 5493, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pop-tail", :ns "cljs.core", :private true, :row 5481} {:end-row 5505, :filename "cljs/core.cljs", :name "RangedIterator", :ns "cljs.core", :row 5495} {:arglist-strs ["[i base arr v start end]"], :end-row 5505, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->RangedIterator", :ns "cljs.core", :row 5495} {:arglist-strs ["[v start end]"], :end-row 5512, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "ranged-iterator", :ns "cljs.core", :row 5507} {:arglist-strs ["[pv f start end]" "[pv f init start end]"], :end-row 5528, :filename "cljs/core.cljs", :fixed-arities #{4 5}, :name "pv-reduce", :ns "cljs.core", :private true, :row 5514} {:end-row 5531, :filename "cljs/core.cljs", :name "tv-editable-root", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "tv-editable-tail", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "TransientVector", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "deref", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "pr-sequential-writer", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "pr-writer", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "chunked-seq", :ns "cljs.core", :row 5530} {:doc "Marker protocol", :end-row 5534, :filename "cljs/core.cljs", :name "APersistentVector", :ns "cljs.core", :row 5533} {:end-row 5731, :filename "cljs/core.cljs", :name "PersistentVector", :ns "cljs.core", :row 5536} {:arglist-strs ["[meta cnt shift root tail __hash]"], :end-row 5731, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->PersistentVector", :ns "cljs.core", :row 5536} {:end-row 5753, :filename "cljs/core.cljs", :name "map-entry?", :ns "cljs.core", :row 5753} {:arglist-strs ["[coll]"], :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.", :end-row 5773, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "vec", :ns "cljs.core", :row 5755} {:arglist-strs ["[& args]"], :doc "Creates a new vector containing the args.", :end-row 5780, :filename "cljs/core.cljs", :name "vector", :ns "cljs.core", :row 5775} {:end-row 5782, :filename "cljs/core.cljs", :name "subvec", :ns "cljs.core", :row 5782} {:end-row 5866, :filename "cljs/core.cljs", :name "ChunkedSeq", :ns "cljs.core", :row 5784} {:arglist-strs ["[vec node i off meta __hash]"], :end-row 5866, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->ChunkedSeq", :ns "cljs.core", :row 5784} {:arglist-strs ["[vec i off]" "[vec node i off]" "[vec node i off meta]"], :end-row 5874, :filename "cljs/core.cljs", :fixed-arities #{4 3 5}, :name "chunked-seq", :ns "cljs.core", :row 5870} {:end-row 5876, :filename "cljs/core.cljs", :name "build-subvec", :ns "cljs.core", :row 5876} {:end-row 6015, :filename "cljs/core.cljs", :name "Subvec", :ns "cljs.core", :row 5878} {:arglist-strs ["[meta v start end __hash]"], :end-row 6015, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Subvec", :ns "cljs.core", :row 5878} {:arglist-strs ["[meta v start end __hash]"], :end-row 6029, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "build-subvec", :ns "cljs.core", :private true, :row 6019} {:arglist-strs ["[v start]" "[v start end]"], :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :end-row 6041, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "subvec", :ns "cljs.core", :row 6031} {:arglist-strs ["[edit node]"], :end-row 6046, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "tv-ensure-editable", :ns "cljs.core", :private true, :row 6043} {:arglist-strs ["[node]"], :end-row 6049, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tv-editable-root", :ns "cljs.core", :private true, :row 6048} {:arglist-strs ["[tl]"], :end-row 6054, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tv-editable-tail", :ns "cljs.core", :private true, :row 6051} {:arglist-strs ["[tv level parent tail-node]"], :end-row 6066, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "tv-push-tail", :ns "cljs.core", :private true, :row 6056} {:arglist-strs ["[tv level node]"], :end-row 6080, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "tv-pop-tail", :ns "cljs.core", :private true, :row 6068} {:arglist-strs ["[tv i]"], :end-row 6096, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "unchecked-editable-array-for", :ns "cljs.core", :private true, :row 6082} {:end-row 6229, :filename "cljs/core.cljs", :name "TransientVector", :ns "cljs.core", :row 6098} {:arglist-strs ["[cnt shift root tail]"], :end-row 6229, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->TransientVector", :ns "cljs.core", :row 6098} {:end-row 6246, :filename "cljs/core.cljs", :name "PersistentQueueIter", :ns "cljs.core", :row 6233} {:arglist-strs ["[fseq riter]"], :end-row 6246, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->PersistentQueueIter", :ns "cljs.core", :row 6233} {:end-row 6302, :filename "cljs/core.cljs", :name "PersistentQueueSeq", :ns "cljs.core", :row 6248} {:arglist-strs ["[meta front rear __hash]"], :end-row 6302, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->PersistentQueueSeq", :ns "cljs.core", :row 6248} {:end-row 6373, :filename "cljs/core.cljs", :name "PersistentQueue", :ns "cljs.core", :row 6306} {:arglist-strs ["[meta count front rear __hash]"], :end-row 6373, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->PersistentQueue", :ns "cljs.core", :row 6306} {:end-row 6384, :filename "cljs/core.cljs", :name "NeverEquiv", :ns "cljs.core", :row 6379} {:arglist-strs ["[]"], :end-row 6384, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "->NeverEquiv", :ns "cljs.core", :row 6379} {:end-row 6386, :filename "cljs/core.cljs", :name "never-equiv", :ns "cljs.core", :private true, :row 6386} {:arglist-strs ["[x y]"], :doc "Test map equivalence. Returns true if x equals y, otherwise returns false.", :end-row 6405, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "equiv-map", :ns "cljs.core", :row 6388} {:arglist-strs ["[incr k array]"], :end-row 6414, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "scan-array", :ns "cljs.core", :private true, :row 6408} {:arglist-strs ["[a b]"], :end-row 6428, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "obj-map-compare-keys", :ns "cljs.core", :private true, :row 6422} {:arglist-strs ["[m k v]"], :end-row 6440, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "obj-map->hash-map", :ns "cljs.core", :private true, :row 6430} {:arglist-strs ["[obj ks]"], :end-row 6452, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "obj-clone", :ns "cljs.core", :private true, :row 6444} {:end-row 6565, :filename "cljs/core.cljs", :name "ObjMap", :ns "cljs.core", :row 6454} {:arglist-strs ["[meta keys strobj update-count __hash]"], :end-row 6565, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->ObjMap", :ns "cljs.core", :row 6454} {:end-row 6584, :filename "cljs/core.cljs", :name "RecordIter", :ns "cljs.core", :row 6574} {:arglist-strs ["[i record base-count fields ext-map-iter]"], :end-row 6584, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->RecordIter", :ns "cljs.core", :row 6574} {:end-row 6594, :filename "cljs/core.cljs", :name "ES6EntriesIterator", :ns "cljs.core", :row 6587} {:arglist-strs ["[s]"], :end-row 6594, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->ES6EntriesIterator", :ns "cljs.core", :row 6587} {:arglist-strs ["[coll]"], :end-row 6597, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "es6-entries-iterator", :ns "cljs.core", :row 6596} {:end-row 6607, :filename "cljs/core.cljs", :name "ES6SetEntriesIterator", :ns "cljs.core", :row 6600} {:arglist-strs ["[s]"], :end-row 6607, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->ES6SetEntriesIterator", :ns "cljs.core", :row 6600} {:arglist-strs ["[coll]"], :end-row 6610, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "es6-set-entries-iterator", :ns "cljs.core", :row 6609} {:arglist-strs ["[arr]"], :end-row 6620, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "array-index-of-nil?", :ns "cljs.core", :private true, :row 6614} {:arglist-strs ["[arr k]"], :end-row 6630, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of-keyword?", :ns "cljs.core", :private true, :row 6622} {:arglist-strs ["[arr k]"], :end-row 6640, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of-symbol?", :ns "cljs.core", :private true, :row 6632} {:arglist-strs ["[arr k]"], :end-row 6648, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of-identical?", :ns "cljs.core", :private true, :row 6642} {:arglist-strs ["[arr k]"], :end-row 6656, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of-equiv?", :ns "cljs.core", :private true, :row 6650} {:arglist-strs ["[arr k]"], :end-row 6670, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of", :ns "cljs.core", :row 6658} {:arglist-strs ["[m k]"], :end-row 6673, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-map-index-of", :ns "cljs.core", :private true, :row 6672} {:arglist-strs ["[arr k v]"], :end-row 6684, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "array-extend-kv", :ns "cljs.core", :private true, :row 6675} {:arglist-strs ["[m k v]"], :end-row 6687, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "array-map-extend-kv", :ns "cljs.core", :private true, :row 6686} {:end-row 6689, :filename "cljs/core.cljs", :name "TransientArrayMap", :ns "cljs.core", :row 6689} {:end-row 6784, :filename "cljs/core.cljs", :name "MapEntry", :ns "cljs.core", :row 6691} {:arglist-strs ["[key val __hash]"], :end-row 6784, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->MapEntry", :ns "cljs.core", :row 6691} {:arglist-strs ["[x]"], :doc "Returns true if x satisfies IMapEntry", :end-row 6789, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "map-entry?", :ns "cljs.core", :row 6786} {:end-row 6852, :filename "cljs/core.cljs", :name "PersistentArrayMapSeq", :ns "cljs.core", :row 6791} {:arglist-strs ["[arr i _meta]"], :end-row 6852, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->PersistentArrayMapSeq", :ns "cljs.core", :row 6791} {:arglist-strs ["[arr i _meta]"], :end-row 6858, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "persistent-array-map-seq", :ns "cljs.core", :row 6856} {:end-row 6860, :filename "cljs/core.cljs", :name "keys", :ns "cljs.core", :row 6860} {:end-row 6860, :filename "cljs/core.cljs", :name "vals", :ns "cljs.core", :row 6860} {:end-row 6869, :filename "cljs/core.cljs", :name "PersistentArrayMapIterator", :ns "cljs.core", :row 6862} {:arglist-strs ["[arr i cnt]"], :end-row 6869, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->PersistentArrayMapIterator", :ns "cljs.core", :row 6862} {:end-row 7036, :filename "cljs/core.cljs", :name "PersistentArrayMap", :ns "cljs.core", :row 6871} {:arglist-strs ["[meta cnt arr __hash]"], :end-row 7036, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->PersistentArrayMap", :ns "cljs.core", :row 6871} {:arglist-strs ["[key other]"], :end-row 7080, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "key-test", :ns "cljs.core", :row 7076} {:arglist-strs ["[arr]"], :end-row 7092, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pam-dupes?", :ns "cljs.core", :private true, :row 7082} {:arglist-strs ["[arr]"], :end-row 7104, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pam-new-size", :ns "cljs.core", :private true, :row 7094} {:arglist-strs ["[seed trailing]"], :end-row 7117, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "pam-grow-seed-array", :ns "cljs.core", :private true, :row 7106} {:end-row 7164, :filename "cljs/core.cljs", :name "array->transient-hash-map", :ns "cljs.core", :row 7164} {:end-row 7244, :filename "cljs/core.cljs", :name "TransientArrayMap", :ns "cljs.core", :row 7166} {:arglist-strs ["[editable? len arr]"], :end-row 7244, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->TransientArrayMap", :ns "cljs.core", :row 7166} {:end-row 7246, :filename "cljs/core.cljs", :name "TransientHashMap", :ns "cljs.core", :row 7246} {:arglist-strs ["[len arr]"], :end-row 7253, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array->transient-hash-map", :ns "cljs.core", :private true, :row 7248} {:end-row 7257, :filename "cljs/core.cljs", :name "Box", :ns "cljs.core", :row 7257} {:arglist-strs ["[val]"], :end-row 7257, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Box", :ns "cljs.core", :row 7257} {:end-row 7259, :filename "cljs/core.cljs", :name "create-inode-seq", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "create-array-node-seq", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "reset!", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "create-node", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "atom", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "deref", :ns "cljs.core", :row 7259} {:arglist-strs ["[hash shift]"], :end-row 7262, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "mask", :ns "cljs.core", :private true, :row 7261} {:arglist-strs ["[arr i a]" "[arr i a j b]"], :end-row 7271, :filename "cljs/core.cljs", :fixed-arities #{3 5}, :name "clone-and-set", :ns "cljs.core", :private true, :row 7264} {:arglist-strs ["[arr i]"], :end-row 7277, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "remove-pair", :ns "cljs.core", :private true, :row 7273} {:arglist-strs ["[bitmap bit]"], :end-row 7280, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bitmap-indexed-node-index", :ns "cljs.core", :private true, :row 7279} {:arglist-strs ["[hash shift]"], :end-row 7283, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bitpos", :ns "cljs.core", :private true, :row 7282} {:arglist-strs ["[inode edit i a]" "[inode edit i a j b]"], :end-row 7294, :filename "cljs/core.cljs", :fixed-arities #{4 6}, :name "edit-and-set", :ns "cljs.core", :private true, :row 7285} {:arglist-strs ["[arr f init]"], :end-row 7310, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "inode-kv-reduce", :ns "cljs.core", :private true, :row 7296} {:end-row 7312, :filename "cljs/core.cljs", :name "ArrayNode", :ns "cljs.core", :row 7312} {:end-row 7350, :filename "cljs/core.cljs", :name "NodeIterator", :ns "cljs.core", :row 7314} {:arglist-strs ["[arr i next-entry next-iter]"], :end-row 7350, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->NodeIterator", :ns "cljs.core", :row 7314} {:end-row 7552, :filename "cljs/core.cljs", :name "BitmapIndexedNode", :ns "cljs.core", :row 7352} {:arglist-strs ["[edit bitmap arr]"], :end-row 7552, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->BitmapIndexedNode", :ns "cljs.core", :row 7352} {:arglist-strs ["[array-node edit idx]"], :end-row 7567, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pack-array-node", :ns "cljs.core", :private true, :row 7556} {:end-row 7587, :filename "cljs/core.cljs", :name "ArrayNodeIterator", :ns "cljs.core", :row 7569} {:arglist-strs ["[arr i next-iter]"], :end-row 7587, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->ArrayNodeIterator", :ns "cljs.core", :row 7569} {:end-row 7688, :filename "cljs/core.cljs", :name "ArrayNode", :ns "cljs.core", :row 7589} {:arglist-strs ["[edit cnt arr]"], :end-row 7688, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->ArrayNode", :ns "cljs.core", :row 7589} {:arglist-strs ["[arr cnt key]"], :end-row 7697, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "hash-collision-node-find-index", :ns "cljs.core", :private true, :row 7690} {:end-row 7799, :filename "cljs/core.cljs", :name "HashCollisionNode", :ns "cljs.core", :row 7699} {:arglist-strs ["[edit collision-hash cnt arr]"], :end-row 7799, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->HashCollisionNode", :ns "cljs.core", :row 7699} {:arglist-strs ["[shift key1 val1 key2hash key2 val2]" "[edit shift key1 val1 key2hash key2 val2]"], :end-row 7817, :filename "cljs/core.cljs", :fixed-arities #{7 6}, :name "create-node", :ns "cljs.core", :private true, :row 7801} {:end-row 7879, :filename "cljs/core.cljs", :name "NodeSeq", :ns "cljs.core", :row 7819} {:arglist-strs ["[meta nodes i s __hash]"], :end-row 7879, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->NodeSeq", :ns "cljs.core", :row 7819} {:arglist-strs ["[nodes]" "[nodes i s]"], :end-row 7898, :filename "cljs/core.cljs", :fixed-arities #{1 3}, :name "create-inode-seq", :ns "cljs.core", :private true, :row 7883} {:end-row 7952, :filename "cljs/core.cljs", :name "ArrayNodeSeq", :ns "cljs.core", :row 7900} {:arglist-strs ["[meta nodes i s __hash]"], :end-row 7952, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->ArrayNodeSeq", :ns "cljs.core", :row 7900} {:arglist-strs ["[nodes]" "[nodes i s]"], :end-row 7968, :filename "cljs/core.cljs", :fixed-arities #{1 3}, :name "create-array-node-seq", :ns "cljs.core", :private true, :row 7956} {:end-row 7980, :filename "cljs/core.cljs", :name "HashMapIter", :ns "cljs.core", :row 7970} {:arglist-strs ["[nil-val root-iter seen]"], :end-row 7980, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->HashMapIter", :ns "cljs.core", :row 7970} {:end-row 8124, :filename "cljs/core.cljs", :name "PersistentHashMap", :ns "cljs.core", :row 7982} {:arglist-strs ["[meta cnt root has-nil? nil-val __hash]"], :end-row 8124, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->PersistentHashMap", :ns "cljs.core", :row 7982} {:end-row 8275, :filename "cljs/core.cljs", :name "TransientHashMap", :ns "cljs.core", :row 8162} {:arglist-strs ["[edit root count has-nil? nil-val]"], :end-row 8275, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->TransientHashMap", :ns "cljs.core", :row 8162} {:arglist-strs ["[node stack ascending?]"], :end-row 8284, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "tree-map-seq-push", :ns "cljs.core", :private true, :row 8279} {:end-row 8353, :filename "cljs/core.cljs", :name "PersistentTreeMapSeq", :ns "cljs.core", :row 8286} {:arglist-strs ["[meta stack ascending? cnt __hash]"], :end-row 8353, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->PersistentTreeMapSeq", :ns "cljs.core", :row 8286} {:arglist-strs ["[tree ascending? cnt]"], :end-row 8358, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "create-tree-map-seq", :ns "cljs.core", :private true, :row 8357} {:end-row 8360, :filename "cljs/core.cljs", :name "RedNode", :ns "cljs.core", :row 8360} {:end-row 8360, :filename "cljs/core.cljs", :name "BlackNode", :ns "cljs.core", :row 8360} {:arglist-strs ["[key val ins right]"], :end-row 8385, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "balance-left", :ns "cljs.core", :private true, :row 8362} {:arglist-strs ["[key val left ins]"], :end-row 8407, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "balance-right", :ns "cljs.core", :private true, :row 8387} {:arglist-strs ["[key val del right]"], :end-row 8426, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "balance-left-del", :ns "cljs.core", :private true, :row 8409} {:arglist-strs ["[key val left del]"], :end-row 8445, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "balance-right-del", :ns "cljs.core", :private true, :row 8428} {:arglist-strs ["[node f init]"], :end-row 8458, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "tree-map-kv-reduce", :ns "cljs.core", :private true, :row 8447} {:end-row 8581, :filename "cljs/core.cljs", :name "BlackNode", :ns "cljs.core", :row 8460} {:arglist-strs ["[key val left right __hash]"], :end-row 8581, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->BlackNode", :ns "cljs.core", :row 8460} {:end-row 8745, :filename "cljs/core.cljs", :name "RedNode", :ns "cljs.core", :row 8585} {:arglist-strs ["[key val left right __hash]"], :end-row 8745, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->RedNode", :ns "cljs.core", :row 8585} {:arglist-strs ["[comp tree k v found]"], :end-row 8766, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "tree-map-add", :ns "cljs.core", :private true, :row 8749} {:arglist-strs ["[left right]"], :end-row 8823, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "tree-map-append", :ns "cljs.core", :private true, :row 8768} {:arglist-strs ["[comp tree k found]"], :end-row 8845, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "tree-map-remove", :ns "cljs.core", :private true, :row 8825} {:arglist-strs ["[comp tree k v]"], :end-row 8852, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "tree-map-replace", :ns "cljs.core", :private true, :row 8847} {:end-row 8854, :filename "cljs/core.cljs", :name "key", :ns "cljs.core", :row 8854} {:end-row 9007, :filename "cljs/core.cljs", :name "PersistentTreeMap", :ns "cljs.core", :row 8856} {:arglist-strs ["[comp tree cnt meta __hash]"], :end-row 9007, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->PersistentTreeMap", :ns "cljs.core", :row 8856} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :end-row 9023, :filename "cljs/core.cljs", :name "hash-map", :ns "cljs.core", :row 9013} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :end-row 9034, :filename "cljs/core.cljs", :name "array-map", :ns "cljs.core", :row 9025} {:arglist-strs ["[s]"], :doc "Builds a map from a seq as described in\n  https://clojure.org/reference/special_forms#keyword-arguments", :end-row 9042, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seq-to-map-for-destructuring", :ns "cljs.core", :row 9036} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :end-row 9055, :filename "cljs/core.cljs", :name "obj-map", :ns "cljs.core", :row 9044} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :end-row 9064, :filename "cljs/core.cljs", :name "sorted-map", :ns "cljs.core", :row 9057} {:arglist-strs ["[comparator & keyvals]"], :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :end-row 9074, :filename "cljs/core.cljs", :name "sorted-map-by", :ns "cljs.core", :row 9066} {:end-row 9140, :filename "cljs/core.cljs", :name "KeySeq", :ns "cljs.core", :row 9076} {:arglist-strs ["[mseq _meta]"], :end-row 9140, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->KeySeq", :ns "cljs.core", :row 9076} {:arglist-strs ["[map]"], :doc "Returns a sequence of the map's keys, in the same order as (seq map).", :end-row 9148, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "keys", :ns "cljs.core", :row 9144} {:arglist-strs ["[map-entry]"], :doc "Returns the key of the map entry.", :end-row 9153, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "key", :ns "cljs.core", :row 9150} {:end-row 9219, :filename "cljs/core.cljs", :name "ValSeq", :ns "cljs.core", :row 9155} {:arglist-strs ["[mseq _meta]"], :end-row 9219, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->ValSeq", :ns "cljs.core", :row 9155} {:arglist-strs ["[map]"], :doc "Returns a sequence of the map's values, in the same order as (seq map).", :end-row 9227, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "vals", :ns "cljs.core", :row 9223} {:arglist-strs ["[map-entry]"], :doc "Returns the value in the map entry.", :end-row 9232, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "val", :ns "cljs.core", :row 9229} {:arglist-strs ["[& maps]"], :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :end-row 9240, :filename "cljs/core.cljs", :name "merge", :ns "cljs.core", :row 9234} {:arglist-strs ["[f & maps]"], :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :end-row 9256, :filename "cljs/core.cljs", :name "merge-with", :ns "cljs.core", :row 9242} {:arglist-strs ["[map keyseq]"], :doc "Returns a map containing only those entries in map whose key is in keys", :end-row 9270, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "select-keys", :ns "cljs.core", :row 9258} {:end-row 9274, :filename "cljs/core.cljs", :name "TransientHashSet", :ns "cljs.core", :row 9274} {:end-row 9284, :filename "cljs/core.cljs", :name "HashSetIter", :ns "cljs.core", :row 9276} {:arglist-strs ["[iter]"], :end-row 9284, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->HashSetIter", :ns "cljs.core", :row 9276} {:end-row 9370, :filename "cljs/core.cljs", :name "PersistentHashSet", :ns "cljs.core", :row 9286} {:arglist-strs ["[meta hash-map __hash]"], :end-row 9370, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->PersistentHashSet", :ns "cljs.core", :row 9286} {:end-row 9445, :filename "cljs/core.cljs", :name "TransientHashSet", :ns "cljs.core", :row 9410} {:arglist-strs ["[transient-map]"], :end-row 9445, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->TransientHashSet", :ns "cljs.core", :row 9410} {:end-row 9541, :filename "cljs/core.cljs", :name "PersistentTreeSet", :ns "cljs.core", :row 9447} {:arglist-strs ["[meta tree-map __hash]"], :end-row 9541, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->PersistentTreeSet", :ns "cljs.core", :row 9447} {:arglist-strs ["[iseq]"], :end-row 9552, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set-from-indexed-seq", :ns "cljs.core", :row 9548} {:arglist-strs ["[coll]"], :doc "Returns a set of the distinct elements of coll.", :end-row 9571, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set", :ns "cljs.core", :row 9554} {:arglist-strs ["[]" "[& keys]"], :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :end-row 9577, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "hash-set", :ns "cljs.core", :row 9573} {:arglist-strs ["[& keys]"], :doc "Returns a new sorted set with supplied keys.", :end-row 9582, :filename "cljs/core.cljs", :name "sorted-set", :ns "cljs.core", :row 9579} {:arglist-strs ["[comparator & keys]"], :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :end-row 9589, :filename "cljs/core.cljs", :name "sorted-set-by", :ns "cljs.core", :row 9584} {:arglist-strs ["[smap]" "[smap coll]"], :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :end-row 9606, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "replace", :ns "cljs.core", :row 9591} {:arglist-strs ["[]" "[coll]"], :doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", :end-row 9631, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "distinct", :ns "cljs.core", :row 9608} {:arglist-strs ["[s]"], :doc "Return a seq of all but the last item in coll, in linear time", :end-row 9640, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "butlast", :ns "cljs.core", :row 9634} {:arglist-strs ["[x]"], :doc "Returns the name String of a string, symbol or keyword.", :end-row 9649, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "name", :ns "cljs.core", :row 9642} {:arglist-strs ["[keys vals]"], :doc "Returns a map with the keys mapped to the corresponding vals.", :end-row 9661, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "zipmap", :ns "cljs.core", :row 9651} {:arglist-strs ["[k x]" "[k x y]" "[k x y & more]"], :doc "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned.", :end-row 9670, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "max-key", :ns "cljs.core", :row 9663} {:arglist-strs ["[k x]" "[k x y]" "[k x y & more]"], :doc "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.", :end-row 9679, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "min-key", :ns "cljs.core", :row 9672} {:end-row 9687, :filename "cljs/core.cljs", :name "ArrayList", :ns "cljs.core", :row 9681} {:arglist-strs ["[arr]"], :end-row 9687, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->ArrayList", :ns "cljs.core", :row 9681} {:arglist-strs ["[]"], :end-row 9690, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "array-list", :ns "cljs.core", :row 9689} {:arglist-strs ["[n]" "[n coll]" "[n step coll]"], :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :end-row 9721, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "partition-all", :ns "cljs.core", :row 9692} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-row 9740, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "take-while", :ns "cljs.core", :row 9723} {:arglist-strs ["[sc test key]"], :end-row 9746, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "mk-bound-fn", :ns "cljs.core", :row 9742} {:arglist-strs ["[sc test key]" "[sc start-test start-key end-test end-key]"], :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :end-row 9761, :filename "cljs/core.cljs", :fixed-arities #{3 5}, :name "subseq", :ns "cljs.core", :row 9748} {:arglist-strs ["[sc test key]" "[sc start-test start-key end-test end-key]"], :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :end-row 9776, :filename "cljs/core.cljs", :fixed-arities #{3 5}, :name "rsubseq", :ns "cljs.core", :row 9763} {:end-row 9797, :filename "cljs/core.cljs", :name "IntegerRangeChunk", :ns "cljs.core", :row 9778} {:arglist-strs ["[start step count]"], :end-row 9797, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->IntegerRangeChunk", :ns "cljs.core", :row 9778} {:end-row 9808, :filename "cljs/core.cljs", :name "RangeIterator", :ns "cljs.core", :row 9799} {:arglist-strs ["[i end step]"], :end-row 9808, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->RangeIterator", :ns "cljs.core", :row 9799} {:end-row 9922, :filename "cljs/core.cljs", :name "IntegerRange", :ns "cljs.core", :row 9810} {:arglist-strs ["[meta start end step chunk chunk-next __hash]"], :end-row 9922, :filename "cljs/core.cljs", :fixed-arities #{7}, :name "->IntegerRange", :ns "cljs.core", :row 9810} {:end-row 10029, :filename "cljs/core.cljs", :name "Range", :ns "cljs.core", :row 9926} {:arglist-strs ["[meta start end step chunk chunk-next __hash]"], :end-row 10029, :filename "cljs/core.cljs", :fixed-arities #{7}, :name "->Range", :ns "cljs.core", :row 9926} {:arglist-strs ["[]" "[end]" "[start end]" "[start end step]"], :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :end-row 10059, :filename "cljs/core.cljs", :fixed-arities #{0 1 3 2}, :name "range", :ns "cljs.core", :row 10033} {:arglist-strs ["[n]" "[n coll]"], :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :end-row 10080, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "take-nth", :ns "cljs.core", :row 10061} {:arglist-strs ["[pred coll]"], :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", :end-row 10085, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "split-with", :ns "cljs.core", :row 10082} {:arglist-strs ["[f]" "[f coll]"], :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :end-row 10126, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "partition-by", :ns "cljs.core", :row 10087} {:arglist-strs ["[coll]"], :doc "Returns a map from distinct items in coll to the number of times\n  they appear.", :end-row 10135, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "frequencies", :ns "cljs.core", :row 10128} {:arglist-strs ["[f coll]" "[f init coll]"], :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :end-row 10151, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "reductions", :ns "cljs.core", :row 10137} {:arglist-strs ["[f]" "[f g]" "[f g h]" "[f g h & fs]"], :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :end-row 10187, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "juxt", :ns "cljs.core", :row 10153} {:arglist-strs ["[coll]" "[n coll]"], :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :end-row 10200, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "dorun", :ns "cljs.core", :row 10189} {:arglist-strs ["[coll]" "[n coll]"], :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :end-row 10214, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "doall", :ns "cljs.core", :row 10202} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript RegExp instance.", :end-row 10221, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "regexp?", :ns "cljs.core", :row 10218} {:arglist-strs ["[re s]"], :doc "Returns the result of (re-find re s) if re fully matches s.", :end-row 10233, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "re-matches", :ns "cljs.core", :row 10223} {:arglist-strs ["[re s]"], :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups.", :end-row 10248, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "re-find", :ns "cljs.core", :row 10236} {:arglist-strs ["[re s]"], :end-row 10261, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "re-seq*", :ns "cljs.core", :private true, :row 10250} {:arglist-strs ["[re s]"], :doc "Returns a lazy sequence of successive matches of re in s.", :end-row 10268, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "re-seq", :ns "cljs.core", :row 10263} {:arglist-strs ["[s]"], :doc "Returns an instance of RegExp which has compiled the provided string.", :end-row 10279, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "re-pattern", :ns "cljs.core", :row 10270} {:arglist-strs ["[writer print-one begin sep end opts coll]"], :end-row 10304, :filename "cljs/core.cljs", :fixed-arities #{7}, :name "pr-sequential-writer", :ns "cljs.core", :row 10283} {:arglist-strs ["[writer & ss]"], :end-row 10308, :filename "cljs/core.cljs", :name "write-all", :ns "cljs.core", :row 10306} {:arglist-strs ["[x]"], :end-row 10314, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "string-print", :ns "cljs.core", :row 10310} {:arglist-strs ["[]"], :end-row 10317, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "flush", :ns "cljs.core", :row 10316} {:end-row 10327, :filename "cljs/core.cljs", :name "char-escapes", :ns "cljs.core", :private true, :row 10319} {:arglist-strs ["[s]"], :end-row 10334, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "quote-string", :ns "cljs.core", :private true, :row 10329} {:end-row 10336, :filename "cljs/core.cljs", :name "print-map", :ns "cljs.core", :row 10336} {:arglist-strs ["[opts obj]"], :end-row 10341, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "print-meta?", :ns "cljs.core", :row 10338} {:arglist-strs ["[obj writer opts]"], :end-row 10433, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pr-writer-impl", :ns "cljs.core", :private true, :row 10343} {:fixed-arities #{3}, :end-row 10442, :private true, :ns "cljs.core", :name "pr-writer", :filename "cljs/core.cljs", :arglist-strs ["[obj writer opts]"], :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer.", :row 10435} {:arglist-strs ["[objs writer opts]"], :end-row 10448, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pr-seq-writer", :ns "cljs.core", :row 10444} {:arglist-strs ["[objs opts]"], :end-row 10455, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "pr-sb-with-opts", :ns "cljs.core", :private true, :row 10450} {:arglist-strs ["[objs opts]"], :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts", :end-row 10463, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "pr-str-with-opts", :ns "cljs.core", :row 10457} {:arglist-strs ["[objs opts]"], :doc "Same as pr-str-with-opts followed by (newline)", :end-row 10472, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "prn-str-with-opts", :ns "cljs.core", :row 10465} {:fixed-arities #{2}, :end-row 10478, :private true, :ns "cljs.core", :name "pr-with-opts", :filename "cljs/core.cljs", :arglist-strs ["[objs opts]"], :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts", :row 10474} {:arglist-strs ["[]" "[opts]"], :doc "Prints a newline using *print-fn*", :end-row 10486, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "newline", :ns "cljs.core", :row 10480} {:arglist-strs ["[& objs]"], :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :end-row 10491, :filename "cljs/core.cljs", :name "pr-str", :ns "cljs.core", :row 10488} {:arglist-strs ["[& objs]"], :doc "Same as pr-str followed by (newline)", :end-row 10496, :filename "cljs/core.cljs", :name "prn-str", :ns "cljs.core", :row 10493} {:arglist-strs ["[& objs]"], :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :end-row 10504, :filename "cljs/core.cljs", :name "pr", :ns "cljs.core", :row 10498} {:arglist-strs ["[& objs]"], :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption.", :end-row 10511, :filename "cljs/core.cljs", :fixed-arities #{}, :name "print", :ns "cljs.core", :row 10506} {:arglist-strs ["[& objs]"], :doc "print to a string, returning it", :end-row 10516, :filename "cljs/core.cljs", :name "print-str", :ns "cljs.core", :row 10513} {:arglist-strs ["[& objs]"], :doc "Same as print followed by (newline)", :end-row 10523, :filename "cljs/core.cljs", :name "println", :ns "cljs.core", :row 10518} {:arglist-strs ["[& objs]"], :doc "println to a string, returning it", :end-row 10528, :filename "cljs/core.cljs", :name "println-str", :ns "cljs.core", :row 10525} {:arglist-strs ["[& objs]"], :doc "Same as pr followed by (newline).", :end-row 10535, :filename "cljs/core.cljs", :name "prn", :ns "cljs.core", :row 10530} {:arglist-strs ["[named]"], :end-row 10541, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "strip-ns", :ns "cljs.core", :private true, :row 10537} {:fixed-arities #{1}, :end-row 10557, :private true, :ns "cljs.core", :name "lift-ns", :filename "cljs/core.cljs", :arglist-strs ["[m]"], :doc "Returns [lifted-ns lifted-map] or nil if m can't be lifted.", :row 10543} {:arglist-strs ["[prefix m print-one writer opts]"], :end-row 10567, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "print-prefix-map", :ns "cljs.core", :row 10559} {:arglist-strs ["[m print-one writer opts]"], :end-row 10574, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "print-map", :ns "cljs.core", :row 10569} {:arglist-strs ["[iref f & args]"], :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :end-row 10753, :filename "cljs/core.cljs", :name "alter-meta!", :ns "cljs.core", :row 10746} {:arglist-strs ["[iref m]"], :doc "Atomically resets the metadata for an atom", :end-row 10758, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "reset-meta!", :ns "cljs.core", :row 10755} {:arglist-strs ["[iref key f]"], :doc "Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1", :end-row 10781, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "add-watch", :ns "cljs.core", :row 10760} {:arglist-strs ["[iref key]"], :doc "Removes a watch (set by add-watch) from a reference", :end-row 10787, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "remove-watch", :ns "cljs.core", :row 10783} {:end-row 10793, :filename "cljs/core.cljs", :name "gensym_counter", :ns "cljs.core", :row 10791} {:arglist-strs ["[]" "[prefix-string]"], :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :end-row 10803, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "gensym", :ns "cljs.core", :row 10795} {:end-row 10823, :filename "cljs/core.cljs", :name "Delay", :ns "cljs.core", :row 10807} {:arglist-strs ["[f value]"], :end-row 10823, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->Delay", :ns "cljs.core", :row 10807} {:arglist-strs ["[x]"], :doc "returns true if x is a Delay created with delay", :end-row 10827, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "delay?", :ns "cljs.core", :row 10825} {:arglist-strs ["[x]"], :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", :end-row 10834, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "force", :ns "cljs.core", :row 10829} {:arglist-strs ["[x]"], :doc "Returns true if a value has been produced for a delay or lazy sequence.", :end-row 10839, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "realized?", :ns "cljs.core", :row 10836} {:arglist-strs ["[rf]"], :end-row 10846, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "preserving-reduced", :ns "cljs.core", :private true, :row 10841} {:arglist-strs ["[rf]"], :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :end-row 10858, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "cat", :ns "cljs.core", :row 10848} {:arglist-strs ["[pred]" "[pred retf]"], :doc "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", :end-row 10882, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "halt-when", :ns "cljs.core", :row 10860} {:arglist-strs ["[]" "[coll]"], :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :end-row 10899, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "dedupe", :ns "cljs.core", :row 10884} {:end-row 10901, :filename "cljs/core.cljs", :name "rand", :ns "cljs.core", :row 10901} {:arglist-strs ["[prob]" "[prob coll]"], :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :end-row 10909, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "random-sample", :ns "cljs.core", :row 10903} {:end-row 10937, :filename "cljs/core.cljs", :name "Eduction", :ns "cljs.core", :row 10911} {:arglist-strs ["[xform coll]"], :end-row 10937, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->Eduction", :ns "cljs.core", :row 10911} {:arglist-strs ["[& xforms]"], :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.", :end-row 10948, :filename "cljs/core.cljs", :name "eduction", :ns "cljs.core", :row 10941} {:arglist-strs ["[proc coll]"], :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", :end-row 10955, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "run!", :ns "cljs.core", :row 10950} {:arglist-strs ["[step & {:keys [somef vf kf initk] :or {vf identity kf identity somef some? initk nil}}]"], :doc "Creates a seqable/reducible via repeated calls to step,\n  a function of some (continuation token) 'k'. The first call to step\n  will be passed initk, returning 'ret'. Iff (somef ret) is true,\n  (vf ret) will be included in the iteration, else iteration will\n  terminate and vf/kf will not be called. If (kf ret) is non-nil it\n  will be passed to the next step call, else iteration will terminate.\n  This can be used e.g. to consume APIs that return paginated or batched data.\n   step - (possibly impure) fn of 'k' -> 'ret'\n   :somef - fn of 'ret' -> logical true/false, default 'some?'\n   :vf - fn of 'ret' -> 'v', a value produced by the iteration, default 'identity'\n   :kf - fn of 'ret' -> 'next-k' or nil (signaling 'do not continue'), default 'identity'\n   :initk - the first value passed to step, default 'nil'\n  It is presumed that step with non-initk is unreproducible/non-idempotent.\n  If step with initk is unreproducible it is on the consumer to not consume twice.", :end-row 10998, :filename "cljs/core.cljs", :name "iteration", :ns "cljs.core", :row 10957} {:end-row 11003, :filename "cljs/core.cljs", :name "IEncodeJS", :ns "cljs.core", :row 11000} {:arglist-strs ["[x]"], :doc "Recursively transforms clj values to JavaScript", :end-row 11001, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-clj->js", :ns "cljs.core", :row 11001} {:arglist-strs ["[x]"], :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)", :end-row 11003, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-key->js", :ns "cljs.core", :row 11002} {:end-row 11005, :filename "cljs/core.cljs", :name "clj->js", :ns "cljs.core", :row 11005} {:arglist-strs ["[k]" "[k primitive-fn]"], :end-row 11016, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "key->js", :ns "cljs.core", :row 11007} {:arglist-strs ["[x & {:keys [keyword-fn] :or {keyword-fn name} :as options}]"], :doc "Recursively transforms ClojureScript values to JavaScript.\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n  Maps become Objects. Arbitrary keys are encoded to by `key->js`.\n  Options is a key-value pair, where the only valid key is\n  :keyword-fn, which should point to a single-argument function to be\n  called on keyword keys. Default to `name`.", :end-row 11043, :filename "cljs/core.cljs", :name "clj->js", :ns "cljs.core", :row 11018} {:end-row 11047, :filename "cljs/core.cljs", :name "IEncodeClojure", :ns "cljs.core", :row 11046} {:arglist-strs ["[x options]"], :doc "Transforms JavaScript values to Clojure", :end-row 11047, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-js->clj", :ns "cljs.core", :row 11047} {:arglist-strs ["[x]" "[x & opts]"], :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :end-row 11082, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js->clj", :ns "cljs.core", :row 11049} {:arglist-strs ["[f]"], :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", :end-row 11097, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "memoize", :ns "cljs.core", :row 11084} {:arglist-strs ["[f]" "[f & args]"], :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :end-row 11113, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "trampoline", :ns "cljs.core", :row 11099} {:arglist-strs ["[]" "[n]"], :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :end-row 11119, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "rand", :ns "cljs.core", :row 11115} {:arglist-strs ["[n]"], :doc "Returns a random integer between 0 (inclusive) and n (exclusive).", :end-row 11123, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "rand-int", :ns "cljs.core", :row 11121} {:arglist-strs ["[coll]"], :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", :end-row 11130, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "rand-nth", :ns "cljs.core", :row 11125} {:arglist-strs ["[f coll]"], :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", :end-row 11142, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "group-by", :ns "cljs.core", :row 11132} {:arglist-strs ["[]"], :doc "Creates a hierarchy object for use with derive, isa? etc.", :end-row 11146, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "make-hierarchy", :ns "cljs.core", :row 11144} {:end-row 11151, :filename "cljs/core.cljs", :name "-global-hierarchy", :ns "cljs.core", :private true, :row 11148} {:arglist-strs ["[]"], :end-row 11156, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "get-global-hierarchy", :ns "cljs.core", :private true, :row 11153} {:arglist-strs ["[f & args]"], :end-row 11159, :filename "cljs/core.cljs", :name "swap-global-hierarchy!", :ns "cljs.core", :private true, :row 11158} {:arglist-strs ["[child parent]" "[h child parent]"], :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :end-row 11179, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "isa?", :ns "cljs.core", :row 11161} {:arglist-strs ["[tag]" "[h tag]"], :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :end-row 11187, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "parents", :ns "cljs.core", :row 11181} {:arglist-strs ["[tag]" "[h tag]"], :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :end-row 11195, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "ancestors", :ns "cljs.core", :row 11189} {:arglist-strs ["[tag]" "[h tag]"], :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :end-row 11204, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "descendants", :ns "cljs.core", :row 11197} {:arglist-strs ["[tag parent]" "[h tag parent]"], :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :end-row 11238, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "derive", :ns "cljs.core", :row 11206} {:arglist-strs ["[tag parent]" "[h tag parent]"], :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :end-row 11259, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "underive", :ns "cljs.core", :row 11240} {:arglist-strs ["[method-cache method-table cached-hierarchy hierarchy]"], :end-row 11264, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "reset-cache", :ns "cljs.core", :private true, :row 11261} {:arglist-strs ["[x y prefer-table]"], :end-row 11282, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "prefers*", :ns "cljs.core", :private true, :row 11266} {:arglist-strs ["[x y prefer-table hierarchy]"], :end-row 11286, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "dominates", :ns "cljs.core", :private true, :row 11284} {:arglist-strs ["[name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy default-dispatch-val]"], :end-row 11314, :filename "cljs/core.cljs", :fixed-arities #{8}, :name "find-and-cache-best-method", :ns "cljs.core", :private true, :row 11288} {:end-row 11325, :filename "cljs/core.cljs", :name "IMultiFn", :ns "cljs.core", :row 11316} {:arglist-strs ["[mf]"], :end-row 11317, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-reset", :ns "cljs.core", :row 11317} {:arglist-strs ["[mf dispatch-val method]"], :end-row 11318, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-add-method", :ns "cljs.core", :row 11318} {:arglist-strs ["[mf dispatch-val]"], :end-row 11319, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-remove-method", :ns "cljs.core", :row 11319} {:arglist-strs ["[mf dispatch-val dispatch-val-y]"], :end-row 11320, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-prefer-method", :ns "cljs.core", :row 11320} {:arglist-strs ["[mf dispatch-val]"], :end-row 11321, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-get-method", :ns "cljs.core", :row 11321} {:arglist-strs ["[mf]"], :end-row 11322, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-methods", :ns "cljs.core", :row 11322} {:arglist-strs ["[mf]"], :end-row 11323, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-prefers", :ns "cljs.core", :row 11323} {:arglist-strs ["[mf]"], :end-row 11324, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-default-dispatch-val", :ns "cljs.core", :row 11324} {:arglist-strs ["[mf]"], :end-row 11325, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-dispatch-fn", :ns "cljs.core", :row 11325} {:arglist-strs ["[name dispatch-val]"], :end-row 11328, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "throw-no-method-error", :ns "cljs.core", :private true, :row 11327} {:end-row 11513, :filename "cljs/core.cljs", :name "MultiFn", :ns "cljs.core", :row 11330} {:arglist-strs ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"], :end-row 11513, :filename "cljs/core.cljs", :fixed-arities #{8}, :name "->MultiFn", :ns "cljs.core", :row 11330} {:arglist-strs ["[multifn]"], :doc "Removes all of the methods of multimethod.", :end-row 11518, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "remove-all-methods", :ns "cljs.core", :row 11515} {:arglist-strs ["[multifn dispatch-val]"], :doc "Removes the method of multimethod associated with dispatch-value.", :end-row 11523, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "remove-method", :ns "cljs.core", :row 11520} {:arglist-strs ["[multifn dispatch-val-x dispatch-val-y]"], :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict", :end-row 11529, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "prefer-method", :ns "cljs.core", :row 11525} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns", :end-row 11533, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "methods", :ns "cljs.core", :row 11531} {:arglist-strs ["[multifn dispatch-val]"], :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", :end-row 11538, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "get-method", :ns "cljs.core", :row 11535} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, returns a map of preferred value -> set of other values", :end-row 11542, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "prefers", :ns "cljs.core", :row 11540} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, return its default-dispatch-val.", :end-row 11546, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "default-dispatch-val", :ns "cljs.core", :row 11544} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, return its dispatch-fn.", :end-row 11550, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "dispatch-fn", :ns "cljs.core", :row 11548} {:doc "A marker protocol for UUIDs", :end-row 11553, :filename "cljs/core.cljs", :name "IUUID", :ns "cljs.core", :row 11553} {:end-row 11581, :filename "cljs/core.cljs", :name "UUID", :ns "cljs.core", :row 11555} {:arglist-strs ["[uuid __hash]"], :end-row 11581, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->UUID", :ns "cljs.core", :row 11555} {:arglist-strs ["[s]"], :doc "Returns a UUID consistent with the string s.", :end-row 11587, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "uuid", :ns "cljs.core", :row 11583} {:arglist-strs ["[]"], :doc "Returns a pseudo-randomly generated UUID instance (i.e. type 4).", :end-row 11602, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "random-uuid", :ns "cljs.core", :row 11589} {:arglist-strs ["[x]"], :doc "Return true if x is a UUID.", :end-row 11606, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "uuid?", :ns "cljs.core", :row 11604} {:arglist-strs ["[obj writer opts]"], :end-row 11619, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pr-writer-ex-info", :ns "cljs.core", :private true, :row 11610} {:arglist-strs ["[message data cause]"], :end-row 11637, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "ExceptionInfo", :ns "cljs.core", :row 11621} {:arglist-strs ["[msg data]" "[msg data cause]"], :doc "Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :end-row 11655, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "ex-info", :ns "cljs.core", :row 11650} {:arglist-strs ["[ex]"], :doc "Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil.", :end-row 11662, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ex-data", :ns "cljs.core", :row 11657} {:arglist-strs ["[ex]"], :doc "Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil.", :end-row 11669, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ex-message", :ns "cljs.core", :row 11664} {:arglist-strs ["[ex]"], :doc "Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil.", :end-row 11677, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ex-cause", :ns "cljs.core", :row 11671} {:arglist-strs ["[pred]"], :doc "Returns an JavaScript compatible comparator based upon pred.", :end-row 11683, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "comparator", :ns "cljs.core", :row 11679} {:arglist-strs ["[x]"], :doc "Returns true if x names a special form", :end-row 11691, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "special-symbol?", :ns "cljs.core", :row 11685} {:arglist-strs ["[v]"], :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", :end-row 11700, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "test", :ns "cljs.core", :row 11693} {:end-row 11731, :filename "cljs/core.cljs", :name "TaggedLiteral", :ns "cljs.core", :row 11703} {:arglist-strs ["[tag form]"], :end-row 11731, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->TaggedLiteral", :ns "cljs.core", :row 11703} {:arglist-strs ["[value]"], :doc "Return true if the value is the data representation of a tagged literal", :end-row 11736, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tagged-literal?", :ns "cljs.core", :row 11733} {:arglist-strs ["[tag form]"], :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form.", :end-row 11743, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "tagged-literal", :ns "cljs.core", :row 11738} {:end-row 11761, :filename "cljs/core.cljs", :name "js-reserved-arr", :ns "cljs.core", :private true, :row 11745} {:end-row 11765, :filename "cljs/core.cljs", :name "js-reserved", :ns "cljs.core", :row 11763} {:arglist-strs ["[x]"], :end-row 11772, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js-reserved?", :ns "cljs.core", :private true, :row 11767} {:arglist-strs ["[]"], :end-row 11788, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "demunge-pattern", :ns "cljs.core", :private true, :row 11774} {:arglist-strs ["[name]"], :end-row 11800, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "munge-str", :ns "cljs.core", :private true, :row 11790} {:arglist-strs ["[name]"], :end-row 11810, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "munge", :ns "cljs.core", :row 11802} {:arglist-strs ["[munged-name]"], :end-row 11827, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "demunge-str", :ns "cljs.core", :private true, :row 11812} {:arglist-strs ["[name]"], :end-row 11834, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "demunge", :ns "cljs.core", :row 11829} {:end-row 11837, :filename "cljs/core.cljs", :name "tapset", :ns "cljs.core", :private true, :row 11836} {:arglist-strs ["[]"], :end-row 11841, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "maybe-init-tapset", :ns "cljs.core", :private true, :row 11839} {:arglist-strs ["[f]"], :doc "Adds f, a fn of one argument, to the tap set. This function will be called with\n  anything sent via tap>. Remember f in order to remove-tap", :end-row 11849, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "add-tap", :ns "cljs.core", :row 11843} {:arglist-strs ["[f]"], :doc "Remove f from the tap set.", :end-row 11856, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "remove-tap", :ns "cljs.core", :row 11851} {:arglist-strs ["[x]"], :doc "Sends x to any taps. Returns the result of *exec-tap-fn*, a Boolean value.", :end-row 11867, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tap>", :ns "cljs.core", :row 11858} {:arglist-strs ["[m f]"], :doc "m f => {k (f v) ...}\n  Given a map m and a function f of 1-argument, returns a new map where the keys of m\n  are mapped to result of applying f to the corresponding values of m.", :end-row 11882, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "update-vals", :ns "cljs.core", :row 11869} {:arglist-strs ["[m f]"], :doc "m f => {(f k) v ...}\n  Given a map m and a function f of 1-argument, returns a new map whose\n  keys are the result of applying f to the keys of m, mapped to the\n  corresponding values of m.\n  f must return a unique key for each key of m, else the behavior is undefined.", :end-row 11896, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "update-keys", :ns "cljs.core", :row 11884} {:fixed-arities #{2}, :end-row 11904, :private true, :ns "cljs.core", :name "ns-lookup", :filename "cljs/core.cljs", :arglist-strs ["[ns-obj k]"], :doc "Bootstrap only.", :row 11901} {:end-row 11925, :filename "cljs/core.cljs", :name "Namespace", :ns "cljs.core", :row 11907} {:arglist-strs ["[obj name]"], :end-row 11925, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->Namespace", :ns "cljs.core", :row 11907} {:doc "Bootstrap only.", :end-row 11929, :filename "cljs/core.cljs", :name "NS_CACHE", :ns "cljs.core", :row 11927} {:fixed-arities #{2}, :end-row 11937, :private true, :ns "cljs.core", :name "find-ns-obj*", :filename "cljs/core.cljs", :arglist-strs ["[ctxt xs]"], :doc "Bootstrap only.", :row 11931} {:arglist-strs ["[ns]"], :doc "Bootstrap only.", :end-row 11960, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "find-ns-obj", :ns "cljs.core", :row 11939} {:arglist-strs ["[sym]"], :doc "Returns a map of the intern mappings for the namespace.\n  Bootstrap only.", :end-row 11973, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ns-interns*", :ns "cljs.core", :row 11962} {:arglist-strs ["[sym]" "[sym ns-obj]"], :doc "Create a new namespace named by the symbol. Bootstrap only.", :end-row 11980, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "create-ns", :ns "cljs.core", :row 11975} {:arglist-strs ["[ns]"], :doc "Returns the namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only.", :end-row 11995, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "find-ns", :ns "cljs.core", :row 11982} {:arglist-strs ["[ns]"], :doc "Returns the macros namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only.", :end-row 12014, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "find-macros-ns", :ns "cljs.core", :row 11997} {:arglist-strs ["[ns-obj]"], :doc "Returns the name of the namespace, a Namespace object.\n  Bootstrap only.", :end-row 12020, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ns-name", :ns "cljs.core", :row 12016} {:arglist-strs ["[x]"], :doc "Returns true x is a goog.Uri instance.", :end-row 12026, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "uri?", :ns "cljs.core", :row 12022} {:arglist-strs ["[val]"], :doc "Returns true if num is NaN, else false", :end-row 12031, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "NaN?", :ns "cljs.core", :row 12028} {:fixed-arities #{1}, :end-row 12036, :private true, :ns "cljs.core", :name "parsing-err", :filename "cljs/core.cljs", :arglist-strs ["[val]"], :doc "Construct message for parsing for non-string parsing error", :row 12033} {:arglist-strs ["[s]"], :doc "Parse string of decimal digits with optional leading -/+ and return an\n  integer value, or nil if parse fails", :end-row 12048, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "parse-long", :ns "cljs.core", :row 12038} {:arglist-strs ["[s]"], :doc "Parse string with floating point components and return a floating point value,\n  or nil if parse fails.\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String-", :end-row 12062, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "parse-double", :ns "cljs.core", :row 12050} {:end-row 12065, :filename "cljs/core.cljs", :name "uuid-regex", :ns "cljs.core", :private true, :row 12064} {:arglist-strs ["[s]"], :doc "Parse a string representing a UUID and return a UUID instance,\n  or nil if parse fails.\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#toString--", :end-row 12075, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "parse-uuid", :ns "cljs.core", :row 12067} {:arglist-strs ["[s]"], :doc "Parse strings \"true\" or \"false\" and return a boolean, or nil if invalid. Note that this explicitly\n  excludes strings with different cases, or space characters.", :end-row 12086, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "parse-boolean", :ns "cljs.core", :row 12077} {:arglist-strs ["[]"], :end-row 12106, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "maybe-enable-print!", :ns "cljs.core", :private true, :row 12088} {:doc "Runtime environments may provide a way to evaluate ClojureScript\n  forms. Whatever function *eval* is bound to will be passed any forms which\n  should be evaluated.", :end-row 12116, :filename "cljs/core.cljs", :name "*eval*", :ns "cljs.core", :row 12110} {:arglist-strs ["[form]"], :doc "Evaluates the form data structure (not text!) and returns the result.\n  Delegates to cljs.core/*eval*. Intended for use in self-hosted ClojureScript,\n  which sets up an implementation of cljs.core/*eval* for that environment.", :end-row 12123, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "eval", :ns "cljs.core", :row 12118}]} {:end-row 17, :filename "cljs/util.cljc", :lang :clj, :name "cljs.util", :row 9, :ns nil, :var-definitions [{:end-row 20, :filename "cljs/util.cljc", :lang :clj, :name "*clojurescript-version*", :ns "cljs.util", :row 20} {:arglist-strs ["[cause]"], :end-row 23, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "compilation-error", :ns "cljs.util", :row 22} {:fixed-arities #{0}, :end-row 29, :private true, :ns "cljs.util", :name "main-src-directory", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[]"], :row 25} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.util", :name "file-hash", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[file]"], :row 31} {:end-row 36, :filename "cljs/util.cljc", :lang :clj, :name "synthethetic-version-prefix", :ns "cljs.util", :private true, :row 36} {:end-row 44, :filename "cljs/util.cljc", :lang :clj, :name "synthetic-clojurescript-version", :ns "cljs.util", :private true, :row 38} {:fixed-arities #{0}, :end-row 60, :ns "cljs.util", :name "clojurescript-version", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[]"], :doc "Returns clojurescript version as a printable string.", :row 46} {:fixed-arities #{0}, :end-row 66, :ns "cljs.util", :name "synthetic-version?", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[]"], :doc "Returns true if clojurescript-version returns a synthetically-generated\n   version.", :row 62} {:fixed-arities #{0}, :end-row 71, :ns "cljs.util", :name "cljs-built-dep?", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[]"], :doc "Returns true if ClojureScript itself is a built dep.", :row 68} {:arglist-strs ["[f]"], :end-row 77, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "compiled-by-version", :ns "cljs.util", :row 73} {:arglist-strs ["[f]"], :end-row 83, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "build-options", :ns "cljs.util", :row 79} {:arglist-strs ["[ss]"], :end-row 86, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "munge-path", :ns "cljs.util", :row 85} {:fixed-arities #{1 3 2}, :end-row 96, :ns "cljs.util", :name "ns->relpath", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[ns]" "[ns ext]" "[ns ext sep]"], :doc "Given a namespace as a symbol return the relative path. May optionally\n  provide the file extension, defaults to :cljs.", :row 88} {:fixed-arities #{1}, :end-row 102, :ns "cljs.util", :name "ns->source", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[ns]"], :doc "Given a namespace as a symbol return the corresponding resource if it exists.", :row 98} {:arglist-strs ["[file-str]"], :end-row 109, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "path-seq", :ns "cljs.util", :row 104} {:arglist-strs ["[parts]" "[parts sep]"], :end-row 115, :filename "cljs/util.cljc", :fixed-arities #{1 2}, :lang :clj, :name "to-path", :ns "cljs.util", :row 111} {:arglist-strs ["[paths-str]"], :end-row 119, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "split-paths", :ns "cljs.util", :row 117} {:end-row 121, :filename "cljs/util.cljc", :lang :clj, :name "ext", :ns "cljs.util", :row 121} {:arglist-strs ["[target-dir ns-info]" "[target-dir {:keys [ns source-file] :as ns-info} ext]"], :end-row 139, :filename "cljs/util.cljc", :fixed-arities #{3 2}, :lang :clj, :name "to-target-file", :ns "cljs.util", :row 123} {:fixed-arities #{1}, :end-row 144, :ns "cljs.util", :name "mkdirs", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[f]"], :doc "Create all parent directories for the passed file.", :row 141} {:arglist-strs ["[opts]" "[opts default]"], :end-row 150, :filename "cljs/util.cljc", :fixed-arities #{1 2}, :lang :clj, :name "output-directory", :ns "cljs.util", :row 146} {:end-row 153, :filename "cljs/util.cljc", :lang :clj, :name "windows?", :ns "cljs.util", :row 152} {:arglist-strs ["[f]"], :end-row 156, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "file?", :ns "cljs.util", :row 155} {:arglist-strs ["[f]"], :end-row 159, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "url?", :ns "cljs.util", :row 158} {:arglist-strs ["[f]"], :end-row 162, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "filename", :ns "cljs.util", :row 161} {:arglist-strs ["[x]"], :end-row 170, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "normalize-path", :ns "cljs.util", :row 166} {:arglist-strs ["[x]"], :end-row 180, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "path", :ns "cljs.util", :row 172} {:fixed-arities #{1}, :end-row 190, :ns "cljs.util", :name "ext", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[x]"], :doc "Given a file, url or string return the file extension.", :row 182} {:fixed-arities #{1}, :end-row 198, :ns "cljs.util", :name "get-name", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[x]"], :doc "Given a file or url return the last component of the path.", :row 192} {:fixed-arities #{1}, :end-row 217, :ns "cljs.util", :name "relative-name", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[x]"], :doc "Given a file return a path relative to the working directory. Given a\n   URL return the JAR relative path of the resource.", :row 200} {:arglist-strs ["[src]"], :end-row 232, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "last-modified", :ns "cljs.util", :row 219} {:arglist-strs ["[a b]"], :end-row 235, :filename "cljs/util.cljc", :fixed-arities #{2}, :lang :clj, :name "changed?", :ns "cljs.util", :row 234} {:arglist-strs ["[s]"], :end-row 239, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "file-or-resource", :ns "cljs.util", :row 237} {:arglist-strs ["[x get-deps]" "[x depth state memo-get-deps]"], :end-row 252, :filename "cljs/util.cljc", :fixed-arities #{4 2}, :lang :clj, :name "topo-sort", :ns "cljs.util", :row 241} {:arglist-strs ["[s]"], :end-row 255, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "valid-js-id-start?", :ns "cljs.util", :row 254} {:end-row 257, :filename "cljs/util.cljc", :lang :clj, :name "debug-prn-mutex", :ns "cljs.util", :row 257} {:arglist-strs ["[& args]"], :end-row 264, :filename "cljs/util.cljc", :lang :clj, :name "debug-prn", :ns "cljs.util", :row 259} {:fixed-arities #{3 2}, :end-row 276, :ns "cljs.util", :name "measure", :lang :clj, :filename "cljs/util.cljc", :macro true, :arglist-strs ["[msg expr]" "[enable msg expr]"], :doc "Like cljs.core/time but toggleable and takes a message string.", :row 266} {:fixed-arities #{3 2}, :end-row 284, :ns "cljs.util", :name "compile-if", :lang :clj, :filename "cljs/util.cljc", :macro true, :arglist-strs ["[exp then]" "[exp then else]"], :row 278} {:fixed-arities #{2}, :end-row 288, :ns "cljs.util", :name "compile-when", :lang :clj, :filename "cljs/util.cljc", :macro true, :arglist-strs ["[exp then]"], :row 286} {:arglist-strs ["[x]"], :end-row 291, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "boolean?", :ns "cljs.util", :row 290} {:fixed-arities #{2}, :end-row 308, :ns "cljs.util", :name "levenshtein-distance", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[s t]"], :doc "The the minimum number of single-element edits needed to\n  transform s in to t.", :row 293} {:fixed-arities #{3}, :end-row 319, :ns "cljs.util", :name "suggestion", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[threshold unknown knowns]"], :doc "Provides a best suggestion for an unknown, taken from knowns,\n  minimizing the Levenshtein distance, returning nil if threshold\n  cannot be satisfied.", :row 310} {:fixed-arities #{2}, :end-row 330, :ns "cljs.util", :name "unknown-opts", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[passed knowns]"], :doc "Takes a set of passed opt keys and known opt keys and for each\n  unknown opt key returns a vector of the key and its (potentially\n  nil) suggestion.", :row 321} {:arglist-strs ["[f coll]"], :end-row 343, :filename "cljs/util.cljc", :fixed-arities #{2}, :lang :clj, :name "distinct-by", :ns "cljs.util", :row 332} {:end-row 345, :filename "cljs/util.cljc", :lang :clj, :name "hex-digits", :ns "cljs.util", :private true, :row 345} {:fixed-arities #{1}, :end-row 357, :private true, :ns "cljs.util", :name "bytes-to-hex-str", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[bytes]"], :doc "Convert an array of bytes into a hex encoded string.", :row 347} {:arglist-strs ["[s]" "[s n]"], :end-row 369, :filename "cljs/util.cljc", :fixed-arities #{1 2}, :lang :clj, :name "content-sha", :ns "cljs.util", :row 359} {:arglist-strs ["[a b]"], :end-row 383, :filename "cljs/util.cljc", :fixed-arities #{2}, :lang :clj, :name "map-merge", :ns "cljs.util", :row 371} {:arglist-strs ["[xs]"], :end-row 390, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "conjunction-str", :ns "cljs.util", :row 385} {:fixed-arities #{0 1}, :end-row 412, :ns "cljs.util", :name "module-file-seq", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[]" "[dir]"], :doc "Return a seq of all files in `node_modules` ending in `.js` or `.json` that are\n   not in an internally nested `node_modules` dir.", :row 392} {:end-row 20, :filename "cljs/util.cljc", :lang :cljs, :name "*clojurescript-version*", :ns "cljs.util", :row 20} {:arglist-strs ["[cause]"], :end-row 23, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "compilation-error", :ns "cljs.util", :row 22} {:fixed-arities #{0}, :end-row 29, :private true, :ns "cljs.util", :name "main-src-directory", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[]"], :row 25} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.util", :name "file-hash", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[file]"], :row 31} {:end-row 36, :filename "cljs/util.cljc", :lang :cljs, :name "synthethetic-version-prefix", :ns "cljs.util", :private true, :row 36} {:end-row 44, :filename "cljs/util.cljc", :lang :cljs, :name "synthetic-clojurescript-version", :ns "cljs.util", :private true, :row 38} {:fixed-arities #{0}, :end-row 60, :ns "cljs.util", :name "clojurescript-version", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[]"], :doc "Returns clojurescript version as a printable string.", :row 46} {:fixed-arities #{0}, :end-row 66, :ns "cljs.util", :name "synthetic-version?", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[]"], :doc "Returns true if clojurescript-version returns a synthetically-generated\n   version.", :row 62} {:fixed-arities #{0}, :end-row 71, :ns "cljs.util", :name "cljs-built-dep?", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[]"], :doc "Returns true if ClojureScript itself is a built dep.", :row 68} {:arglist-strs ["[f]"], :end-row 77, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "compiled-by-version", :ns "cljs.util", :row 73} {:arglist-strs ["[f]"], :end-row 83, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "build-options", :ns "cljs.util", :row 79} {:arglist-strs ["[ss]"], :end-row 86, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "munge-path", :ns "cljs.util", :row 85} {:fixed-arities #{1 3 2}, :end-row 96, :ns "cljs.util", :name "ns->relpath", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[ns]" "[ns ext]" "[ns ext sep]"], :doc "Given a namespace as a symbol return the relative path. May optionally\n  provide the file extension, defaults to :cljs.", :row 88} {:fixed-arities #{1}, :end-row 102, :ns "cljs.util", :name "ns->source", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[ns]"], :doc "Given a namespace as a symbol return the corresponding resource if it exists.", :row 98} {:arglist-strs ["[file-str]"], :end-row 109, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "path-seq", :ns "cljs.util", :row 104} {:arglist-strs ["[parts]" "[parts sep]"], :end-row 115, :filename "cljs/util.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "to-path", :ns "cljs.util", :row 111} {:arglist-strs ["[paths-str]"], :end-row 119, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "split-paths", :ns "cljs.util", :row 117} {:end-row 121, :filename "cljs/util.cljc", :lang :cljs, :name "ext", :ns "cljs.util", :row 121} {:arglist-strs ["[target-dir ns-info]" "[target-dir {:keys [ns source-file] :as ns-info} ext]"], :end-row 139, :filename "cljs/util.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "to-target-file", :ns "cljs.util", :row 123} {:fixed-arities #{1}, :end-row 144, :ns "cljs.util", :name "mkdirs", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[f]"], :doc "Create all parent directories for the passed file.", :row 141} {:arglist-strs ["[opts]" "[opts default]"], :end-row 150, :filename "cljs/util.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "output-directory", :ns "cljs.util", :row 146} {:end-row 153, :filename "cljs/util.cljc", :lang :cljs, :name "windows?", :ns "cljs.util", :row 152} {:arglist-strs ["[f]"], :end-row 156, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "file?", :ns "cljs.util", :row 155} {:arglist-strs ["[f]"], :end-row 159, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "url?", :ns "cljs.util", :row 158} {:arglist-strs ["[f]"], :end-row 162, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "filename", :ns "cljs.util", :row 161} {:arglist-strs ["[x]"], :end-row 170, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "normalize-path", :ns "cljs.util", :row 166} {:arglist-strs ["[x]"], :end-row 180, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "path", :ns "cljs.util", :row 172} {:fixed-arities #{1}, :end-row 190, :ns "cljs.util", :name "ext", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[x]"], :doc "Given a file, url or string return the file extension.", :row 182} {:fixed-arities #{1}, :end-row 198, :ns "cljs.util", :name "get-name", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[x]"], :doc "Given a file or url return the last component of the path.", :row 192} {:fixed-arities #{1}, :end-row 217, :ns "cljs.util", :name "relative-name", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[x]"], :doc "Given a file return a path relative to the working directory. Given a\n   URL return the JAR relative path of the resource.", :row 200} {:arglist-strs ["[src]"], :end-row 232, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "last-modified", :ns "cljs.util", :row 219} {:arglist-strs ["[a b]"], :end-row 235, :filename "cljs/util.cljc", :fixed-arities #{2}, :lang :cljs, :name "changed?", :ns "cljs.util", :row 234} {:arglist-strs ["[s]"], :end-row 239, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "file-or-resource", :ns "cljs.util", :row 237} {:arglist-strs ["[x get-deps]" "[x depth state memo-get-deps]"], :end-row 252, :filename "cljs/util.cljc", :fixed-arities #{4 2}, :lang :cljs, :name "topo-sort", :ns "cljs.util", :row 241} {:arglist-strs ["[s]"], :end-row 255, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "valid-js-id-start?", :ns "cljs.util", :row 254} {:end-row 257, :filename "cljs/util.cljc", :lang :cljs, :name "debug-prn-mutex", :ns "cljs.util", :row 257} {:arglist-strs ["[& args]"], :end-row 264, :filename "cljs/util.cljc", :lang :cljs, :name "debug-prn", :ns "cljs.util", :row 259} {:fixed-arities #{3 2}, :end-row 276, :ns "cljs.util", :name "measure", :lang :cljs, :filename "cljs/util.cljc", :macro true, :arglist-strs ["[msg expr]" "[enable msg expr]"], :doc "Like cljs.core/time but toggleable and takes a message string.", :row 266} {:fixed-arities #{3 2}, :end-row 284, :ns "cljs.util", :name "compile-if", :lang :cljs, :filename "cljs/util.cljc", :macro true, :arglist-strs ["[exp then]" "[exp then else]"], :row 278} {:fixed-arities #{2}, :end-row 288, :ns "cljs.util", :name "compile-when", :lang :cljs, :filename "cljs/util.cljc", :macro true, :arglist-strs ["[exp then]"], :row 286} {:arglist-strs ["[x]"], :end-row 291, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "boolean?", :ns "cljs.util", :row 290} {:fixed-arities #{2}, :end-row 308, :ns "cljs.util", :name "levenshtein-distance", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[s t]"], :doc "The the minimum number of single-element edits needed to\n  transform s in to t.", :row 293} {:fixed-arities #{3}, :end-row 319, :ns "cljs.util", :name "suggestion", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[threshold unknown knowns]"], :doc "Provides a best suggestion for an unknown, taken from knowns,\n  minimizing the Levenshtein distance, returning nil if threshold\n  cannot be satisfied.", :row 310} {:fixed-arities #{2}, :end-row 330, :ns "cljs.util", :name "unknown-opts", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[passed knowns]"], :doc "Takes a set of passed opt keys and known opt keys and for each\n  unknown opt key returns a vector of the key and its (potentially\n  nil) suggestion.", :row 321} {:arglist-strs ["[f coll]"], :end-row 343, :filename "cljs/util.cljc", :fixed-arities #{2}, :lang :cljs, :name "distinct-by", :ns "cljs.util", :row 332} {:end-row 345, :filename "cljs/util.cljc", :lang :cljs, :name "hex-digits", :ns "cljs.util", :private true, :row 345} {:fixed-arities #{1}, :end-row 357, :private true, :ns "cljs.util", :name "bytes-to-hex-str", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[bytes]"], :doc "Convert an array of bytes into a hex encoded string.", :row 347} {:arglist-strs ["[s]" "[s n]"], :end-row 369, :filename "cljs/util.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "content-sha", :ns "cljs.util", :row 359} {:arglist-strs ["[a b]"], :end-row 383, :filename "cljs/util.cljc", :fixed-arities #{2}, :lang :cljs, :name "map-merge", :ns "cljs.util", :row 371} {:arglist-strs ["[xs]"], :end-row 390, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "conjunction-str", :ns "cljs.util", :row 385} {:fixed-arities #{0 1}, :end-row 412, :ns "cljs.util", :name "module-file-seq", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[]" "[dir]"], :doc "Return a seq of all files in `node_modules` ending in `.js` or `.json` that are\n   not in an internally nested `node_modules` dir.", :row 392}]} {:end-row 17, :filename "cljs/util.cljc", :lang :cljs, :name "cljs.util", :row 9, :ns nil, :var-definitions [{:end-row 20, :filename "cljs/util.cljc", :lang :clj, :name "*clojurescript-version*", :ns "cljs.util", :row 20} {:arglist-strs ["[cause]"], :end-row 23, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "compilation-error", :ns "cljs.util", :row 22} {:fixed-arities #{0}, :end-row 29, :private true, :ns "cljs.util", :name "main-src-directory", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[]"], :row 25} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.util", :name "file-hash", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[file]"], :row 31} {:end-row 36, :filename "cljs/util.cljc", :lang :clj, :name "synthethetic-version-prefix", :ns "cljs.util", :private true, :row 36} {:end-row 44, :filename "cljs/util.cljc", :lang :clj, :name "synthetic-clojurescript-version", :ns "cljs.util", :private true, :row 38} {:fixed-arities #{0}, :end-row 60, :ns "cljs.util", :name "clojurescript-version", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[]"], :doc "Returns clojurescript version as a printable string.", :row 46} {:fixed-arities #{0}, :end-row 66, :ns "cljs.util", :name "synthetic-version?", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[]"], :doc "Returns true if clojurescript-version returns a synthetically-generated\n   version.", :row 62} {:fixed-arities #{0}, :end-row 71, :ns "cljs.util", :name "cljs-built-dep?", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[]"], :doc "Returns true if ClojureScript itself is a built dep.", :row 68} {:arglist-strs ["[f]"], :end-row 77, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "compiled-by-version", :ns "cljs.util", :row 73} {:arglist-strs ["[f]"], :end-row 83, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "build-options", :ns "cljs.util", :row 79} {:arglist-strs ["[ss]"], :end-row 86, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "munge-path", :ns "cljs.util", :row 85} {:fixed-arities #{1 3 2}, :end-row 96, :ns "cljs.util", :name "ns->relpath", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[ns]" "[ns ext]" "[ns ext sep]"], :doc "Given a namespace as a symbol return the relative path. May optionally\n  provide the file extension, defaults to :cljs.", :row 88} {:fixed-arities #{1}, :end-row 102, :ns "cljs.util", :name "ns->source", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[ns]"], :doc "Given a namespace as a symbol return the corresponding resource if it exists.", :row 98} {:arglist-strs ["[file-str]"], :end-row 109, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "path-seq", :ns "cljs.util", :row 104} {:arglist-strs ["[parts]" "[parts sep]"], :end-row 115, :filename "cljs/util.cljc", :fixed-arities #{1 2}, :lang :clj, :name "to-path", :ns "cljs.util", :row 111} {:arglist-strs ["[paths-str]"], :end-row 119, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "split-paths", :ns "cljs.util", :row 117} {:end-row 121, :filename "cljs/util.cljc", :lang :clj, :name "ext", :ns "cljs.util", :row 121} {:arglist-strs ["[target-dir ns-info]" "[target-dir {:keys [ns source-file] :as ns-info} ext]"], :end-row 139, :filename "cljs/util.cljc", :fixed-arities #{3 2}, :lang :clj, :name "to-target-file", :ns "cljs.util", :row 123} {:fixed-arities #{1}, :end-row 144, :ns "cljs.util", :name "mkdirs", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[f]"], :doc "Create all parent directories for the passed file.", :row 141} {:arglist-strs ["[opts]" "[opts default]"], :end-row 150, :filename "cljs/util.cljc", :fixed-arities #{1 2}, :lang :clj, :name "output-directory", :ns "cljs.util", :row 146} {:end-row 153, :filename "cljs/util.cljc", :lang :clj, :name "windows?", :ns "cljs.util", :row 152} {:arglist-strs ["[f]"], :end-row 156, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "file?", :ns "cljs.util", :row 155} {:arglist-strs ["[f]"], :end-row 159, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "url?", :ns "cljs.util", :row 158} {:arglist-strs ["[f]"], :end-row 162, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "filename", :ns "cljs.util", :row 161} {:arglist-strs ["[x]"], :end-row 170, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "normalize-path", :ns "cljs.util", :row 166} {:arglist-strs ["[x]"], :end-row 180, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "path", :ns "cljs.util", :row 172} {:fixed-arities #{1}, :end-row 190, :ns "cljs.util", :name "ext", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[x]"], :doc "Given a file, url or string return the file extension.", :row 182} {:fixed-arities #{1}, :end-row 198, :ns "cljs.util", :name "get-name", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[x]"], :doc "Given a file or url return the last component of the path.", :row 192} {:fixed-arities #{1}, :end-row 217, :ns "cljs.util", :name "relative-name", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[x]"], :doc "Given a file return a path relative to the working directory. Given a\n   URL return the JAR relative path of the resource.", :row 200} {:arglist-strs ["[src]"], :end-row 232, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "last-modified", :ns "cljs.util", :row 219} {:arglist-strs ["[a b]"], :end-row 235, :filename "cljs/util.cljc", :fixed-arities #{2}, :lang :clj, :name "changed?", :ns "cljs.util", :row 234} {:arglist-strs ["[s]"], :end-row 239, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "file-or-resource", :ns "cljs.util", :row 237} {:arglist-strs ["[x get-deps]" "[x depth state memo-get-deps]"], :end-row 252, :filename "cljs/util.cljc", :fixed-arities #{4 2}, :lang :clj, :name "topo-sort", :ns "cljs.util", :row 241} {:arglist-strs ["[s]"], :end-row 255, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "valid-js-id-start?", :ns "cljs.util", :row 254} {:end-row 257, :filename "cljs/util.cljc", :lang :clj, :name "debug-prn-mutex", :ns "cljs.util", :row 257} {:arglist-strs ["[& args]"], :end-row 264, :filename "cljs/util.cljc", :lang :clj, :name "debug-prn", :ns "cljs.util", :row 259} {:fixed-arities #{3 2}, :end-row 276, :ns "cljs.util", :name "measure", :lang :clj, :filename "cljs/util.cljc", :macro true, :arglist-strs ["[msg expr]" "[enable msg expr]"], :doc "Like cljs.core/time but toggleable and takes a message string.", :row 266} {:fixed-arities #{3 2}, :end-row 284, :ns "cljs.util", :name "compile-if", :lang :clj, :filename "cljs/util.cljc", :macro true, :arglist-strs ["[exp then]" "[exp then else]"], :row 278} {:fixed-arities #{2}, :end-row 288, :ns "cljs.util", :name "compile-when", :lang :clj, :filename "cljs/util.cljc", :macro true, :arglist-strs ["[exp then]"], :row 286} {:arglist-strs ["[x]"], :end-row 291, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "boolean?", :ns "cljs.util", :row 290} {:fixed-arities #{2}, :end-row 308, :ns "cljs.util", :name "levenshtein-distance", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[s t]"], :doc "The the minimum number of single-element edits needed to\n  transform s in to t.", :row 293} {:fixed-arities #{3}, :end-row 319, :ns "cljs.util", :name "suggestion", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[threshold unknown knowns]"], :doc "Provides a best suggestion for an unknown, taken from knowns,\n  minimizing the Levenshtein distance, returning nil if threshold\n  cannot be satisfied.", :row 310} {:fixed-arities #{2}, :end-row 330, :ns "cljs.util", :name "unknown-opts", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[passed knowns]"], :doc "Takes a set of passed opt keys and known opt keys and for each\n  unknown opt key returns a vector of the key and its (potentially\n  nil) suggestion.", :row 321} {:arglist-strs ["[f coll]"], :end-row 343, :filename "cljs/util.cljc", :fixed-arities #{2}, :lang :clj, :name "distinct-by", :ns "cljs.util", :row 332} {:end-row 345, :filename "cljs/util.cljc", :lang :clj, :name "hex-digits", :ns "cljs.util", :private true, :row 345} {:fixed-arities #{1}, :end-row 357, :private true, :ns "cljs.util", :name "bytes-to-hex-str", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[bytes]"], :doc "Convert an array of bytes into a hex encoded string.", :row 347} {:arglist-strs ["[s]" "[s n]"], :end-row 369, :filename "cljs/util.cljc", :fixed-arities #{1 2}, :lang :clj, :name "content-sha", :ns "cljs.util", :row 359} {:arglist-strs ["[a b]"], :end-row 383, :filename "cljs/util.cljc", :fixed-arities #{2}, :lang :clj, :name "map-merge", :ns "cljs.util", :row 371} {:arglist-strs ["[xs]"], :end-row 390, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :clj, :name "conjunction-str", :ns "cljs.util", :row 385} {:fixed-arities #{0 1}, :end-row 412, :ns "cljs.util", :name "module-file-seq", :lang :clj, :filename "cljs/util.cljc", :arglist-strs ["[]" "[dir]"], :doc "Return a seq of all files in `node_modules` ending in `.js` or `.json` that are\n   not in an internally nested `node_modules` dir.", :row 392} {:end-row 20, :filename "cljs/util.cljc", :lang :cljs, :name "*clojurescript-version*", :ns "cljs.util", :row 20} {:arglist-strs ["[cause]"], :end-row 23, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "compilation-error", :ns "cljs.util", :row 22} {:fixed-arities #{0}, :end-row 29, :private true, :ns "cljs.util", :name "main-src-directory", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[]"], :row 25} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.util", :name "file-hash", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[file]"], :row 31} {:end-row 36, :filename "cljs/util.cljc", :lang :cljs, :name "synthethetic-version-prefix", :ns "cljs.util", :private true, :row 36} {:end-row 44, :filename "cljs/util.cljc", :lang :cljs, :name "synthetic-clojurescript-version", :ns "cljs.util", :private true, :row 38} {:fixed-arities #{0}, :end-row 60, :ns "cljs.util", :name "clojurescript-version", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[]"], :doc "Returns clojurescript version as a printable string.", :row 46} {:fixed-arities #{0}, :end-row 66, :ns "cljs.util", :name "synthetic-version?", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[]"], :doc "Returns true if clojurescript-version returns a synthetically-generated\n   version.", :row 62} {:fixed-arities #{0}, :end-row 71, :ns "cljs.util", :name "cljs-built-dep?", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[]"], :doc "Returns true if ClojureScript itself is a built dep.", :row 68} {:arglist-strs ["[f]"], :end-row 77, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "compiled-by-version", :ns "cljs.util", :row 73} {:arglist-strs ["[f]"], :end-row 83, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "build-options", :ns "cljs.util", :row 79} {:arglist-strs ["[ss]"], :end-row 86, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "munge-path", :ns "cljs.util", :row 85} {:fixed-arities #{1 3 2}, :end-row 96, :ns "cljs.util", :name "ns->relpath", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[ns]" "[ns ext]" "[ns ext sep]"], :doc "Given a namespace as a symbol return the relative path. May optionally\n  provide the file extension, defaults to :cljs.", :row 88} {:fixed-arities #{1}, :end-row 102, :ns "cljs.util", :name "ns->source", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[ns]"], :doc "Given a namespace as a symbol return the corresponding resource if it exists.", :row 98} {:arglist-strs ["[file-str]"], :end-row 109, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "path-seq", :ns "cljs.util", :row 104} {:arglist-strs ["[parts]" "[parts sep]"], :end-row 115, :filename "cljs/util.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "to-path", :ns "cljs.util", :row 111} {:arglist-strs ["[paths-str]"], :end-row 119, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "split-paths", :ns "cljs.util", :row 117} {:end-row 121, :filename "cljs/util.cljc", :lang :cljs, :name "ext", :ns "cljs.util", :row 121} {:arglist-strs ["[target-dir ns-info]" "[target-dir {:keys [ns source-file] :as ns-info} ext]"], :end-row 139, :filename "cljs/util.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "to-target-file", :ns "cljs.util", :row 123} {:fixed-arities #{1}, :end-row 144, :ns "cljs.util", :name "mkdirs", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[f]"], :doc "Create all parent directories for the passed file.", :row 141} {:arglist-strs ["[opts]" "[opts default]"], :end-row 150, :filename "cljs/util.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "output-directory", :ns "cljs.util", :row 146} {:end-row 153, :filename "cljs/util.cljc", :lang :cljs, :name "windows?", :ns "cljs.util", :row 152} {:arglist-strs ["[f]"], :end-row 156, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "file?", :ns "cljs.util", :row 155} {:arglist-strs ["[f]"], :end-row 159, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "url?", :ns "cljs.util", :row 158} {:arglist-strs ["[f]"], :end-row 162, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "filename", :ns "cljs.util", :row 161} {:arglist-strs ["[x]"], :end-row 170, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "normalize-path", :ns "cljs.util", :row 166} {:arglist-strs ["[x]"], :end-row 180, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "path", :ns "cljs.util", :row 172} {:fixed-arities #{1}, :end-row 190, :ns "cljs.util", :name "ext", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[x]"], :doc "Given a file, url or string return the file extension.", :row 182} {:fixed-arities #{1}, :end-row 198, :ns "cljs.util", :name "get-name", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[x]"], :doc "Given a file or url return the last component of the path.", :row 192} {:fixed-arities #{1}, :end-row 217, :ns "cljs.util", :name "relative-name", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[x]"], :doc "Given a file return a path relative to the working directory. Given a\n   URL return the JAR relative path of the resource.", :row 200} {:arglist-strs ["[src]"], :end-row 232, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "last-modified", :ns "cljs.util", :row 219} {:arglist-strs ["[a b]"], :end-row 235, :filename "cljs/util.cljc", :fixed-arities #{2}, :lang :cljs, :name "changed?", :ns "cljs.util", :row 234} {:arglist-strs ["[s]"], :end-row 239, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "file-or-resource", :ns "cljs.util", :row 237} {:arglist-strs ["[x get-deps]" "[x depth state memo-get-deps]"], :end-row 252, :filename "cljs/util.cljc", :fixed-arities #{4 2}, :lang :cljs, :name "topo-sort", :ns "cljs.util", :row 241} {:arglist-strs ["[s]"], :end-row 255, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "valid-js-id-start?", :ns "cljs.util", :row 254} {:end-row 257, :filename "cljs/util.cljc", :lang :cljs, :name "debug-prn-mutex", :ns "cljs.util", :row 257} {:arglist-strs ["[& args]"], :end-row 264, :filename "cljs/util.cljc", :lang :cljs, :name "debug-prn", :ns "cljs.util", :row 259} {:fixed-arities #{3 2}, :end-row 276, :ns "cljs.util", :name "measure", :lang :cljs, :filename "cljs/util.cljc", :macro true, :arglist-strs ["[msg expr]" "[enable msg expr]"], :doc "Like cljs.core/time but toggleable and takes a message string.", :row 266} {:fixed-arities #{3 2}, :end-row 284, :ns "cljs.util", :name "compile-if", :lang :cljs, :filename "cljs/util.cljc", :macro true, :arglist-strs ["[exp then]" "[exp then else]"], :row 278} {:fixed-arities #{2}, :end-row 288, :ns "cljs.util", :name "compile-when", :lang :cljs, :filename "cljs/util.cljc", :macro true, :arglist-strs ["[exp then]"], :row 286} {:arglist-strs ["[x]"], :end-row 291, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "boolean?", :ns "cljs.util", :row 290} {:fixed-arities #{2}, :end-row 308, :ns "cljs.util", :name "levenshtein-distance", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[s t]"], :doc "The the minimum number of single-element edits needed to\n  transform s in to t.", :row 293} {:fixed-arities #{3}, :end-row 319, :ns "cljs.util", :name "suggestion", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[threshold unknown knowns]"], :doc "Provides a best suggestion for an unknown, taken from knowns,\n  minimizing the Levenshtein distance, returning nil if threshold\n  cannot be satisfied.", :row 310} {:fixed-arities #{2}, :end-row 330, :ns "cljs.util", :name "unknown-opts", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[passed knowns]"], :doc "Takes a set of passed opt keys and known opt keys and for each\n  unknown opt key returns a vector of the key and its (potentially\n  nil) suggestion.", :row 321} {:arglist-strs ["[f coll]"], :end-row 343, :filename "cljs/util.cljc", :fixed-arities #{2}, :lang :cljs, :name "distinct-by", :ns "cljs.util", :row 332} {:end-row 345, :filename "cljs/util.cljc", :lang :cljs, :name "hex-digits", :ns "cljs.util", :private true, :row 345} {:fixed-arities #{1}, :end-row 357, :private true, :ns "cljs.util", :name "bytes-to-hex-str", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[bytes]"], :doc "Convert an array of bytes into a hex encoded string.", :row 347} {:arglist-strs ["[s]" "[s n]"], :end-row 369, :filename "cljs/util.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "content-sha", :ns "cljs.util", :row 359} {:arglist-strs ["[a b]"], :end-row 383, :filename "cljs/util.cljc", :fixed-arities #{2}, :lang :cljs, :name "map-merge", :ns "cljs.util", :row 371} {:arglist-strs ["[xs]"], :end-row 390, :filename "cljs/util.cljc", :fixed-arities #{1}, :lang :cljs, :name "conjunction-str", :ns "cljs.util", :row 385} {:fixed-arities #{0 1}, :end-row 412, :ns "cljs.util", :name "module-file-seq", :lang :cljs, :filename "cljs/util.cljc", :arglist-strs ["[]" "[dir]"], :doc "Return a seq of all files in `node_modules` ending in `.js` or `.json` that are\n   not in an internally nested `node_modules` dir.", :row 392}]} {:end-row 39, :filename "cljs/compiler.cljc", :lang :clj, :name "cljs.compiler", :row 9, :ns nil, :var-definitions [{:end-row 43, :filename "cljs/compiler.cljc", :lang :clj, :name "js-reserved", :ns "cljs.compiler", :row 43} {:end-row 52, :filename "cljs/compiler.cljc", :lang :clj, :name "es5>=", :ns "cljs.compiler", :private true, :row 45} {:end-row 54, :filename "cljs/compiler.cljc", :lang :clj, :name "*recompiled*", :ns "cljs.compiler", :row 54} {:end-row 55, :filename "cljs/compiler.cljc", :lang :clj, :name "*inputs*", :ns "cljs.compiler", :row 55} {:end-row 56, :filename "cljs/compiler.cljc", :lang :clj, :name "*source-map-data*", :ns "cljs.compiler", :row 56} {:end-row 57, :filename "cljs/compiler.cljc", :lang :clj, :name "*source-map-data-gen-col*", :ns "cljs.compiler", :row 57} {:end-row 58, :filename "cljs/compiler.cljc", :lang :clj, :name "*lexical-renames*", :ns "cljs.compiler", :row 58} {:end-row 60, :filename "cljs/compiler.cljc", :lang :clj, :name "cljs-reserved-file-names", :ns "cljs.compiler", :row 60} {:fixed-arities #{1}, :end-row 71, :ns "cljs.compiler", :name "get-first-ns-segment", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[ns]"], :doc "Gets the part up to the first `.` of a namespace.\n   Returns the empty string for nil.\n   Returns the entire string if no `.` in namespace", :row 62} {:arglist-strs ["[needle]"], :end-row 79, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "find-ns-starts-with", :ns "cljs.compiler", :row 73} {:arglist-strs ["[s]"], :end-row 88, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "shadow-depth", :ns "cljs.compiler", :row 82} {:arglist-strs ["[s]"], :end-row 93, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "hash-scope", :ns "cljs.compiler", :row 90} {:end-row 95, :filename "cljs/compiler.cljc", :lang :clj, :name "munge", :ns "cljs.compiler", :row 95} {:arglist-strs ["[{:keys [name info] :as name-var}]"], :end-row 105, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "fn-self-name", :ns "cljs.compiler", :row 97} {:arglist-strs ["[reserved]"], :end-row 111, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "munge-reserved", :ns "cljs.compiler", :row 107} {:arglist-strs ["[s]" "[s reserved]"], :end-row 147, :filename "cljs/compiler.cljc", :fixed-arities #{1 2}, :lang :clj, :name "munge", :ns "cljs.compiler", :row 113} {:fixed-arities #{1}, :end-row 150, :private true, :ns "cljs.compiler", :name "comma-sep", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[xs]"], :row 149} {:fixed-arities #{1}, :end-row 170, :private true, :ns "cljs.compiler", :name "escape-char", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[c]"], :row 152} {:fixed-arities #{1}, :end-row 177, :private true, :ns "cljs.compiler", :name "escape-string", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[s]"], :row 172} {:fixed-arities #{1}, :end-row 180, :private true, :ns "cljs.compiler", :name "wrap-in-double-quotes", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[x]"], :row 179} {:end-row 182, :filename "cljs/compiler.cljc", :lang :clj, :name "emit*", :ns "cljs.compiler", :row 182} {:arglist-strs ["[ast]"], :end-row 204, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit", :ns "cljs.compiler", :row 184} {:arglist-strs ["[]" "[a]" "[a b]" "[a b c]" "[a b c d]" "[a b c d e]" "[a b c d e & xs]"], :end-row 232, :filename "cljs/compiler.cljc", :fixed-arities #{0 1 4 3 2 5}, :lang :clj, :name "emits", :ns "cljs.compiler", :row 206} {:fixed-arities #{0}, :end-row 243, :private true, :ns "cljs.compiler", :name "_emitln", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[]"], :row 234} {:arglist-strs ["[]" "[a]" "[a b]" "[a b c]" "[a b c d]" "[a b c d e]" "[a b c d e & xs]"], :end-row 260, :filename "cljs/compiler.cljc", :fixed-arities #{0 1 4 3 2 5}, :lang :clj, :name "emitln", :ns "cljs.compiler", :row 245} {:arglist-strs ["[expr]"], :end-row 263, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-str", :ns "cljs.compiler", :row 262} {:end-row 266, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-constant*", :ns "cljs.compiler", :row 266} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-map", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-list", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-vector", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-set", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-js-object", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-js-array", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-with-meta", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-constants-comma-sep", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-constant", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-record-value", :ns "cljs.compiler", :row 270} {:arglist-strs ["[xs]"], :end-row 274, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "all-distinct?", :ns "cljs.compiler", :row 273} {:arglist-strs ["[x]"], :end-row 285, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-constant-no-meta", :ns "cljs.compiler", :row 277} {:arglist-strs ["[v]"], :end-row 301, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-constant", :ns "cljs.compiler", :row 297} {:arglist-strs ["[kw]"], :end-row 380, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emits-keyword", :ns "cljs.compiler", :row 367} {:arglist-strs ["[sym]"], :end-row 398, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emits-symbol", :ns "cljs.compiler", :row 382} {:arglist-strs ["[cs]"], :end-row 419, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-constants-comma-sep", :ns "cljs.compiler", :row 412} {:end-row 421, :filename "cljs/compiler.cljc", :lang :clj, :name "array-map-threshold", :ns "cljs.compiler", :private true, :row 421} {:fixed-arities #{1}, :end-row 426, :private true, :ns "cljs.compiler", :name "emit-inst", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[inst-ms]"], :row 425} {:arglist-strs ["[env & body]"], :end-row 450, :filename "cljs/compiler.cljc", :lang :clj, :macro true, :name "emit-wrap", :ns "cljs.compiler", :row 446} {:arglist-strs ["[{:keys [info env form] :as ast}]"], :end-row 496, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-var", :ns "cljs.compiler", :row 454} {:arglist-strs ["[expr meta]"], :end-row 512, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-with-meta", :ns "cljs.compiler", :row 511} {:arglist-strs ["[keys]"], :end-row 522, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "distinct-keys?", :ns "cljs.compiler", :row 519} {:arglist-strs ["[keys vals comma-sep distinct-keys?]"], :end-row 543, :filename "cljs/compiler.cljc", :fixed-arities #{4}, :lang :clj, :name "emit-map", :ns "cljs.compiler", :row 524} {:arglist-strs ["[items comma-sep]"], :end-row 553, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-list", :ns "cljs.compiler", :row 550} {:arglist-strs ["[items comma-sep]"], :end-row 562, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-vector", :ns "cljs.compiler", :row 555} {:arglist-strs ["[items]"], :end-row 572, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "distinct-constants?", :ns "cljs.compiler", :row 569} {:arglist-strs ["[items comma-sep distinct-constants?]"], :end-row 583, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :clj, :name "emit-set", :ns "cljs.compiler", :row 574} {:arglist-strs ["[items emit-js-object-val]"], :end-row 597, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-js-object", :ns "cljs.compiler", :row 590} {:arglist-strs ["[items comma-sep]"], :end-row 600, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-js-array", :ns "cljs.compiler", :row 599} {:arglist-strs ["[ns name items]"], :end-row 614, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :clj, :name "emit-record-value", :ns "cljs.compiler", :row 612} {:arglist-strs ["[expr]"], :end-row 632, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "truthy-constant?", :ns "cljs.compiler", :row 625} {:arglist-strs ["[expr]"], :end-row 639, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "falsey-constant?", :ns "cljs.compiler", :row 634} {:arglist-strs ["[env e]"], :end-row 643, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "safe-test?", :ns "cljs.compiler", :row 641} {:end-row 700, :filename "cljs/compiler.cljc", :lang :clj, :name "base-types", :ns "cljs.compiler", :row 692} {:end-row 703, :filename "cljs/compiler.cljc", :lang :clj, :name "mapped-types", :ns "cljs.compiler", :row 702} {:arglist-strs ["[env t]"], :end-row 737, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "resolve-type", :ns "cljs.compiler", :row 705} {:arglist-strs ["[env ts]"], :end-row 742, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "resolve-types", :ns "cljs.compiler", :row 739} {:arglist-strs ["[env line]"], :end-row 764, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "munge-param-return", :ns "cljs.compiler", :row 744} {:arglist-strs ["[]"], :end-row 769, :filename "cljs/compiler.cljc", :fixed-arities #{0}, :lang :clj, :name "checking-types?", :ns "cljs.compiler", :row 766} {:fixed-arities #{3 2}, :end-row 794, :ns "cljs.compiler", :name "emit-comment", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[doc jsdoc]" "[env doc jsdoc]"], :doc "Emit a nicely formatted comment string.", :row 771} {:arglist-strs ["[x]"], :end-row 800, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "valid-define-value?", :ns "cljs.compiler", :row 796} {:arglist-strs ["[mname jsdoc]"], :end-row 811, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "get-define", :ns "cljs.compiler", :row 802} {:arglist-strs ["[{:keys [name params env]}]"], :end-row 886, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-apply-to", :ns "cljs.compiler", :row 853} {:arglist-strs ["[params]"], :end-row 893, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-fn-params", :ns "cljs.compiler", :row 888} {:arglist-strs ["[{expr :body :keys [type name params env recurs]}]"], :end-row 908, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-fn-method", :ns "cljs.compiler", :row 895} {:fixed-arities #{1}, :end-row 922, :ns "cljs.compiler", :name "emit-arguments-to-array", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[startslice]"], :doc "Emit code that copies function arguments into an array starting at an index.\n  Returns name of var holding the array.", :row 910} {:arglist-strs ["[{expr :body max-fixed-arity :fixed-arity variadic :variadic? :keys [type name params env recurs] :as f}]"], :end-row 972, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-variadic-fn-method", :ns "cljs.compiler", :row 924} {:arglist-strs ["[{expr :body :keys [bindings env]} is-loop]"], :end-row 1106, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-let", :ns "cljs.compiler", :row 1084} {:arglist-strs ["[psym]"], :end-row 1137, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "protocol-prefix", :ns "cljs.compiler", :row 1133} {:arglist-strs ["[sublib]"], :end-row 1271, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "sublib-select", :ns "cljs.compiler", :row 1266} {:arglist-strs ["[ns-name global-exports lib]"], :end-row 1287, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :clj, :name "emit-global-export", :ns "cljs.compiler", :row 1273} {:arglist-strs ["[libs seen reloads deps ns-name]"], :end-row 1369, :filename "cljs/compiler.cljc", :fixed-arities #{5}, :lang :clj, :name "load-libs", :ns "cljs.compiler", :row 1289} {:arglist-strs ["[{:keys [target field method args env]}]"], :end-row 1429, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-dot", :ns "cljs.compiler", :row 1422} {:fixed-arities #{1}, :end-row 1463, :ns "cljs.compiler", :name "rename-to-js", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[file-str]"], :doc "Change the file extension from .cljs to .js. Takes a File or a\n     String. Always returns a String.", :row 1448} {:fixed-arities #{0 1 2}, :end-row 1477, :ns "cljs.compiler", :name "with-core-cljs", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[]" "[opts]" "[opts body]"], :doc "Ensure that core.cljs has been loaded.", :row 1466} {:arglist-strs ["[f]"], :end-row 1481, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "url-path", :ns "cljs.compiler", :row 1480} {:arglist-strs ["[]" "[opts]"], :end-row 1493, :filename "cljs/compiler.cljc", :fixed-arities #{0 1}, :lang :clj, :name "compiled-by-string", :ns "cljs.compiler", :row 1484} {:arglist-strs ["[ns ext opts]"], :end-row 1500, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :clj, :name "cached-core", :ns "cljs.compiler", :row 1496} {:arglist-strs ["[ns ext opts]"], :end-row 1507, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :clj, :name "macro-ns?", :ns "cljs.compiler", :row 1503} {:arglist-strs ["[src dest cached opts]"], :end-row 1526, :filename "cljs/compiler.cljc", :fixed-arities #{4}, :lang :clj, :name "emit-cached-core", :ns "cljs.compiler", :row 1510} {:arglist-strs ["[src dest sm-data opts]"], :end-row 1554, :filename "cljs/compiler.cljc", :fixed-arities #{4}, :lang :clj, :name "emit-source-map", :ns "cljs.compiler", :row 1529} {:arglist-strs ["[src dest ext opts]"], :end-row 1645, :filename "cljs/compiler.cljc", :fixed-arities #{4}, :lang :clj, :name "emit-source", :ns "cljs.compiler", :row 1557} {:arglist-strs ["[src dest]" "[src dest opts]"], :end-row 1673, :filename "cljs/compiler.cljc", :fixed-arities #{3 2}, :lang :clj, :name "compile-file*", :ns "cljs.compiler", :row 1648} {:fixed-arities #{3 2}, :end-row 1701, :ns "cljs.compiler", :name "requires-compilation?", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[src dest]" "[src dest opts]"], :doc "Return true if the src file requires compilation.", :row 1676} {:fixed-arities #{1 3 2}, :end-row 1769, :ns "cljs.compiler", :name "compile-file", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[src]" "[src dest]" "[src dest opts]"], :doc "Compiles src to a file of the same name, but with a .js extension,\n      in the src file's directory.\n\n      With dest argument, write file to provided location. If the dest\n      argument is a file outside the source tree, missing parent\n      directories will be created. The src file will only be compiled if\n      the dest file has an older modification time.\n\n      Both src and dest may be either a String or a File.\n\n      Returns a map containing {:ns .. :provides .. :requires .. :file ..}.\n      If the file was not compiled returns only {:file ...}", :row 1704} {:fixed-arities #{1}, :end-row 1796, :ns "cljs.compiler", :name "cljs-files-in", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[dir]"], :doc "Return a sequence of all .cljs and .cljc files in the given directory.", :row 1772} {:fixed-arities #{1 3 2}, :end-row 1827, :ns "cljs.compiler", :name "compile-root", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[src-dir]" "[src-dir target-dir]" "[src-dir target-dir opts]"], :doc "Looks recursively in src-dir for .cljs files and compiles them to\n      .js files. If target-dir is provided, output will go into this\n      directory mirroring the source directory structure. Returns a list\n      of maps containing information about each file which was compiled\n      in dependency order.", :row 1799} {:arglist-strs ["[file]"], :end-row 1831, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "find-source", :ns "cljs.compiler", :row 1830} {:arglist-strs ["[src-dir]"], :end-row 1837, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "find-root-sources", :ns "cljs.compiler", :row 1834} {:arglist-strs ["[table]"], :end-row 1856, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-constants-table", :ns "cljs.compiler", :row 1841} {:arglist-strs ["[table dest]"], :end-row 1863, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-constants-table-to-file", :ns "cljs.compiler", :row 1859} {:arglist-strs ["[externs]" "[prefix externs top-level known-externs]"], :end-row 1885, :filename "cljs/compiler.cljc", :fixed-arities #{1 4}, :lang :clj, :name "emit-externs", :ns "cljs.compiler", :row 1865} {:arglist-strs ["[externs dest]"], :end-row 1892, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-inferred-externs-to-file", :ns "cljs.compiler", :row 1888} {:end-row 43, :filename "cljs/compiler.cljc", :lang :cljs, :name "js-reserved", :ns "cljs.compiler", :row 43} {:end-row 52, :filename "cljs/compiler.cljc", :lang :cljs, :name "es5>=", :ns "cljs.compiler", :private true, :row 45} {:end-row 54, :filename "cljs/compiler.cljc", :lang :cljs, :name "*recompiled*", :ns "cljs.compiler", :row 54} {:end-row 55, :filename "cljs/compiler.cljc", :lang :cljs, :name "*inputs*", :ns "cljs.compiler", :row 55} {:end-row 56, :filename "cljs/compiler.cljc", :lang :cljs, :name "*source-map-data*", :ns "cljs.compiler", :row 56} {:end-row 57, :filename "cljs/compiler.cljc", :lang :cljs, :name "*source-map-data-gen-col*", :ns "cljs.compiler", :row 57} {:end-row 58, :filename "cljs/compiler.cljc", :lang :cljs, :name "*lexical-renames*", :ns "cljs.compiler", :row 58} {:end-row 60, :filename "cljs/compiler.cljc", :lang :cljs, :name "cljs-reserved-file-names", :ns "cljs.compiler", :row 60} {:fixed-arities #{1}, :end-row 71, :ns "cljs.compiler", :name "get-first-ns-segment", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[ns]"], :doc "Gets the part up to the first `.` of a namespace.\n   Returns the empty string for nil.\n   Returns the entire string if no `.` in namespace", :row 62} {:arglist-strs ["[needle]"], :end-row 79, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "find-ns-starts-with", :ns "cljs.compiler", :row 73} {:arglist-strs ["[s]"], :end-row 88, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "shadow-depth", :ns "cljs.compiler", :row 82} {:arglist-strs ["[s]"], :end-row 93, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "hash-scope", :ns "cljs.compiler", :row 90} {:end-row 95, :filename "cljs/compiler.cljc", :lang :cljs, :name "munge", :ns "cljs.compiler", :row 95} {:arglist-strs ["[{:keys [name info] :as name-var}]"], :end-row 105, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "fn-self-name", :ns "cljs.compiler", :row 97} {:arglist-strs ["[reserved]"], :end-row 111, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "munge-reserved", :ns "cljs.compiler", :row 107} {:arglist-strs ["[s]" "[s reserved]"], :end-row 147, :filename "cljs/compiler.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "munge", :ns "cljs.compiler", :row 113} {:fixed-arities #{1}, :end-row 150, :private true, :ns "cljs.compiler", :name "comma-sep", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[xs]"], :row 149} {:fixed-arities #{1}, :end-row 170, :private true, :ns "cljs.compiler", :name "escape-char", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[c]"], :row 152} {:fixed-arities #{1}, :end-row 177, :private true, :ns "cljs.compiler", :name "escape-string", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[s]"], :row 172} {:fixed-arities #{1}, :end-row 180, :private true, :ns "cljs.compiler", :name "wrap-in-double-quotes", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[x]"], :row 179} {:end-row 182, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit*", :ns "cljs.compiler", :row 182} {:arglist-strs ["[ast]"], :end-row 204, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit", :ns "cljs.compiler", :row 184} {:arglist-strs ["[]" "[a]" "[a b]" "[a b c]" "[a b c d]" "[a b c d e]" "[a b c d e & xs]"], :end-row 232, :filename "cljs/compiler.cljc", :fixed-arities #{0 1 4 3 2 5}, :lang :cljs, :name "emits", :ns "cljs.compiler", :row 206} {:fixed-arities #{0}, :end-row 243, :private true, :ns "cljs.compiler", :name "_emitln", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[]"], :row 234} {:arglist-strs ["[]" "[a]" "[a b]" "[a b c]" "[a b c d]" "[a b c d e]" "[a b c d e & xs]"], :end-row 260, :filename "cljs/compiler.cljc", :fixed-arities #{0 1 4 3 2 5}, :lang :cljs, :name "emitln", :ns "cljs.compiler", :row 245} {:arglist-strs ["[expr]"], :end-row 263, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-str", :ns "cljs.compiler", :row 262} {:end-row 268, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-constant*", :ns "cljs.compiler", :row 268} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-map", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-list", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-vector", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-set", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-js-object", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-js-array", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-with-meta", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-constants-comma-sep", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-constant", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-record-value", :ns "cljs.compiler", :row 270} {:arglist-strs ["[xs]"], :end-row 274, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "all-distinct?", :ns "cljs.compiler", :row 273} {:arglist-strs ["[x]"], :end-row 295, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-constant-no-meta", :ns "cljs.compiler", :row 287} {:arglist-strs ["[v]"], :end-row 301, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-constant", :ns "cljs.compiler", :row 297} {:arglist-strs ["[kw]"], :end-row 380, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emits-keyword", :ns "cljs.compiler", :row 367} {:arglist-strs ["[sym]"], :end-row 398, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emits-symbol", :ns "cljs.compiler", :row 382} {:arglist-strs ["[cs]"], :end-row 419, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-constants-comma-sep", :ns "cljs.compiler", :row 412} {:end-row 421, :filename "cljs/compiler.cljc", :lang :cljs, :name "array-map-threshold", :ns "cljs.compiler", :private true, :row 421} {:fixed-arities #{1}, :end-row 426, :private true, :ns "cljs.compiler", :name "emit-inst", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[inst-ms]"], :row 425} {:arglist-strs ["[{:keys [info env form] :as ast}]"], :end-row 496, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-var", :ns "cljs.compiler", :row 454} {:arglist-strs ["[expr meta]"], :end-row 512, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "emit-with-meta", :ns "cljs.compiler", :row 511} {:arglist-strs ["[keys]"], :end-row 522, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "distinct-keys?", :ns "cljs.compiler", :row 519} {:arglist-strs ["[keys vals comma-sep distinct-keys?]"], :end-row 543, :filename "cljs/compiler.cljc", :fixed-arities #{4}, :lang :cljs, :name "emit-map", :ns "cljs.compiler", :row 524} {:arglist-strs ["[items comma-sep]"], :end-row 553, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "emit-list", :ns "cljs.compiler", :row 550} {:arglist-strs ["[items comma-sep]"], :end-row 562, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "emit-vector", :ns "cljs.compiler", :row 555} {:arglist-strs ["[items]"], :end-row 572, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "distinct-constants?", :ns "cljs.compiler", :row 569} {:arglist-strs ["[items comma-sep distinct-constants?]"], :end-row 583, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :cljs, :name "emit-set", :ns "cljs.compiler", :row 574} {:arglist-strs ["[items emit-js-object-val]"], :end-row 597, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "emit-js-object", :ns "cljs.compiler", :row 590} {:arglist-strs ["[items comma-sep]"], :end-row 600, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "emit-js-array", :ns "cljs.compiler", :row 599} {:arglist-strs ["[ns name items]"], :end-row 614, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :cljs, :name "emit-record-value", :ns "cljs.compiler", :row 612} {:arglist-strs ["[expr]"], :end-row 632, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "truthy-constant?", :ns "cljs.compiler", :row 625} {:arglist-strs ["[expr]"], :end-row 639, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "falsey-constant?", :ns "cljs.compiler", :row 634} {:arglist-strs ["[env e]"], :end-row 643, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "safe-test?", :ns "cljs.compiler", :row 641} {:end-row 700, :filename "cljs/compiler.cljc", :lang :cljs, :name "base-types", :ns "cljs.compiler", :row 692} {:end-row 703, :filename "cljs/compiler.cljc", :lang :cljs, :name "mapped-types", :ns "cljs.compiler", :row 702} {:arglist-strs ["[env t]"], :end-row 737, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "resolve-type", :ns "cljs.compiler", :row 705} {:arglist-strs ["[env ts]"], :end-row 742, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "resolve-types", :ns "cljs.compiler", :row 739} {:arglist-strs ["[env line]"], :end-row 764, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "munge-param-return", :ns "cljs.compiler", :row 744} {:arglist-strs ["[]"], :end-row 769, :filename "cljs/compiler.cljc", :fixed-arities #{0}, :lang :cljs, :name "checking-types?", :ns "cljs.compiler", :row 766} {:fixed-arities #{3 2}, :end-row 794, :ns "cljs.compiler", :name "emit-comment", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[doc jsdoc]" "[env doc jsdoc]"], :doc "Emit a nicely formatted comment string.", :row 771} {:arglist-strs ["[x]"], :end-row 800, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "valid-define-value?", :ns "cljs.compiler", :row 796} {:arglist-strs ["[mname jsdoc]"], :end-row 811, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-define", :ns "cljs.compiler", :row 802} {:arglist-strs ["[{:keys [name params env]}]"], :end-row 886, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-apply-to", :ns "cljs.compiler", :row 853} {:arglist-strs ["[params]"], :end-row 893, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-fn-params", :ns "cljs.compiler", :row 888} {:arglist-strs ["[{expr :body :keys [type name params env recurs]}]"], :end-row 908, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-fn-method", :ns "cljs.compiler", :row 895} {:fixed-arities #{1}, :end-row 922, :ns "cljs.compiler", :name "emit-arguments-to-array", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[startslice]"], :doc "Emit code that copies function arguments into an array starting at an index.\n  Returns name of var holding the array.", :row 910} {:arglist-strs ["[{expr :body max-fixed-arity :fixed-arity variadic :variadic? :keys [type name params env recurs] :as f}]"], :end-row 972, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-variadic-fn-method", :ns "cljs.compiler", :row 924} {:arglist-strs ["[{expr :body :keys [bindings env]} is-loop]"], :end-row 1106, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "emit-let", :ns "cljs.compiler", :row 1084} {:arglist-strs ["[psym]"], :end-row 1137, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "protocol-prefix", :ns "cljs.compiler", :row 1133} {:arglist-strs ["[sublib]"], :end-row 1271, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "sublib-select", :ns "cljs.compiler", :row 1266} {:arglist-strs ["[ns-name global-exports lib]"], :end-row 1287, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :cljs, :name "emit-global-export", :ns "cljs.compiler", :row 1273} {:arglist-strs ["[libs seen reloads deps ns-name]"], :end-row 1369, :filename "cljs/compiler.cljc", :fixed-arities #{5}, :lang :cljs, :name "load-libs", :ns "cljs.compiler", :row 1289} {:arglist-strs ["[{:keys [target field method args env]}]"], :end-row 1429, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-dot", :ns "cljs.compiler", :row 1422} {:arglist-strs ["[table]"], :end-row 1856, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-constants-table", :ns "cljs.compiler", :row 1841} {:arglist-strs ["[externs]" "[prefix externs top-level known-externs]"], :end-row 1885, :filename "cljs/compiler.cljc", :fixed-arities #{1 4}, :lang :cljs, :name "emit-externs", :ns "cljs.compiler", :row 1865}]} {:end-row 39, :filename "cljs/compiler.cljc", :lang :cljs, :name "cljs.compiler", :row 9, :ns nil, :var-definitions [{:end-row 43, :filename "cljs/compiler.cljc", :lang :clj, :name "js-reserved", :ns "cljs.compiler", :row 43} {:end-row 52, :filename "cljs/compiler.cljc", :lang :clj, :name "es5>=", :ns "cljs.compiler", :private true, :row 45} {:end-row 54, :filename "cljs/compiler.cljc", :lang :clj, :name "*recompiled*", :ns "cljs.compiler", :row 54} {:end-row 55, :filename "cljs/compiler.cljc", :lang :clj, :name "*inputs*", :ns "cljs.compiler", :row 55} {:end-row 56, :filename "cljs/compiler.cljc", :lang :clj, :name "*source-map-data*", :ns "cljs.compiler", :row 56} {:end-row 57, :filename "cljs/compiler.cljc", :lang :clj, :name "*source-map-data-gen-col*", :ns "cljs.compiler", :row 57} {:end-row 58, :filename "cljs/compiler.cljc", :lang :clj, :name "*lexical-renames*", :ns "cljs.compiler", :row 58} {:end-row 60, :filename "cljs/compiler.cljc", :lang :clj, :name "cljs-reserved-file-names", :ns "cljs.compiler", :row 60} {:fixed-arities #{1}, :end-row 71, :ns "cljs.compiler", :name "get-first-ns-segment", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[ns]"], :doc "Gets the part up to the first `.` of a namespace.\n   Returns the empty string for nil.\n   Returns the entire string if no `.` in namespace", :row 62} {:arglist-strs ["[needle]"], :end-row 79, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "find-ns-starts-with", :ns "cljs.compiler", :row 73} {:arglist-strs ["[s]"], :end-row 88, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "shadow-depth", :ns "cljs.compiler", :row 82} {:arglist-strs ["[s]"], :end-row 93, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "hash-scope", :ns "cljs.compiler", :row 90} {:end-row 95, :filename "cljs/compiler.cljc", :lang :clj, :name "munge", :ns "cljs.compiler", :row 95} {:arglist-strs ["[{:keys [name info] :as name-var}]"], :end-row 105, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "fn-self-name", :ns "cljs.compiler", :row 97} {:arglist-strs ["[reserved]"], :end-row 111, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "munge-reserved", :ns "cljs.compiler", :row 107} {:arglist-strs ["[s]" "[s reserved]"], :end-row 147, :filename "cljs/compiler.cljc", :fixed-arities #{1 2}, :lang :clj, :name "munge", :ns "cljs.compiler", :row 113} {:fixed-arities #{1}, :end-row 150, :private true, :ns "cljs.compiler", :name "comma-sep", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[xs]"], :row 149} {:fixed-arities #{1}, :end-row 170, :private true, :ns "cljs.compiler", :name "escape-char", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[c]"], :row 152} {:fixed-arities #{1}, :end-row 177, :private true, :ns "cljs.compiler", :name "escape-string", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[s]"], :row 172} {:fixed-arities #{1}, :end-row 180, :private true, :ns "cljs.compiler", :name "wrap-in-double-quotes", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[x]"], :row 179} {:end-row 182, :filename "cljs/compiler.cljc", :lang :clj, :name "emit*", :ns "cljs.compiler", :row 182} {:arglist-strs ["[ast]"], :end-row 204, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit", :ns "cljs.compiler", :row 184} {:arglist-strs ["[]" "[a]" "[a b]" "[a b c]" "[a b c d]" "[a b c d e]" "[a b c d e & xs]"], :end-row 232, :filename "cljs/compiler.cljc", :fixed-arities #{0 1 4 3 2 5}, :lang :clj, :name "emits", :ns "cljs.compiler", :row 206} {:fixed-arities #{0}, :end-row 243, :private true, :ns "cljs.compiler", :name "_emitln", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[]"], :row 234} {:arglist-strs ["[]" "[a]" "[a b]" "[a b c]" "[a b c d]" "[a b c d e]" "[a b c d e & xs]"], :end-row 260, :filename "cljs/compiler.cljc", :fixed-arities #{0 1 4 3 2 5}, :lang :clj, :name "emitln", :ns "cljs.compiler", :row 245} {:arglist-strs ["[expr]"], :end-row 263, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-str", :ns "cljs.compiler", :row 262} {:end-row 266, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-constant*", :ns "cljs.compiler", :row 266} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-map", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-list", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-vector", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-set", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-js-object", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-js-array", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-with-meta", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-constants-comma-sep", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-constant", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :clj, :name "emit-record-value", :ns "cljs.compiler", :row 270} {:arglist-strs ["[xs]"], :end-row 274, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "all-distinct?", :ns "cljs.compiler", :row 273} {:arglist-strs ["[x]"], :end-row 285, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-constant-no-meta", :ns "cljs.compiler", :row 277} {:arglist-strs ["[v]"], :end-row 301, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-constant", :ns "cljs.compiler", :row 297} {:arglist-strs ["[kw]"], :end-row 380, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emits-keyword", :ns "cljs.compiler", :row 367} {:arglist-strs ["[sym]"], :end-row 398, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emits-symbol", :ns "cljs.compiler", :row 382} {:arglist-strs ["[cs]"], :end-row 419, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-constants-comma-sep", :ns "cljs.compiler", :row 412} {:end-row 421, :filename "cljs/compiler.cljc", :lang :clj, :name "array-map-threshold", :ns "cljs.compiler", :private true, :row 421} {:fixed-arities #{1}, :end-row 426, :private true, :ns "cljs.compiler", :name "emit-inst", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[inst-ms]"], :row 425} {:arglist-strs ["[env & body]"], :end-row 450, :filename "cljs/compiler.cljc", :lang :clj, :macro true, :name "emit-wrap", :ns "cljs.compiler", :row 446} {:arglist-strs ["[{:keys [info env form] :as ast}]"], :end-row 496, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-var", :ns "cljs.compiler", :row 454} {:arglist-strs ["[expr meta]"], :end-row 512, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-with-meta", :ns "cljs.compiler", :row 511} {:arglist-strs ["[keys]"], :end-row 522, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "distinct-keys?", :ns "cljs.compiler", :row 519} {:arglist-strs ["[keys vals comma-sep distinct-keys?]"], :end-row 543, :filename "cljs/compiler.cljc", :fixed-arities #{4}, :lang :clj, :name "emit-map", :ns "cljs.compiler", :row 524} {:arglist-strs ["[items comma-sep]"], :end-row 553, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-list", :ns "cljs.compiler", :row 550} {:arglist-strs ["[items comma-sep]"], :end-row 562, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-vector", :ns "cljs.compiler", :row 555} {:arglist-strs ["[items]"], :end-row 572, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "distinct-constants?", :ns "cljs.compiler", :row 569} {:arglist-strs ["[items comma-sep distinct-constants?]"], :end-row 583, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :clj, :name "emit-set", :ns "cljs.compiler", :row 574} {:arglist-strs ["[items emit-js-object-val]"], :end-row 597, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-js-object", :ns "cljs.compiler", :row 590} {:arglist-strs ["[items comma-sep]"], :end-row 600, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-js-array", :ns "cljs.compiler", :row 599} {:arglist-strs ["[ns name items]"], :end-row 614, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :clj, :name "emit-record-value", :ns "cljs.compiler", :row 612} {:arglist-strs ["[expr]"], :end-row 632, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "truthy-constant?", :ns "cljs.compiler", :row 625} {:arglist-strs ["[expr]"], :end-row 639, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "falsey-constant?", :ns "cljs.compiler", :row 634} {:arglist-strs ["[env e]"], :end-row 643, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "safe-test?", :ns "cljs.compiler", :row 641} {:end-row 700, :filename "cljs/compiler.cljc", :lang :clj, :name "base-types", :ns "cljs.compiler", :row 692} {:end-row 703, :filename "cljs/compiler.cljc", :lang :clj, :name "mapped-types", :ns "cljs.compiler", :row 702} {:arglist-strs ["[env t]"], :end-row 737, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "resolve-type", :ns "cljs.compiler", :row 705} {:arglist-strs ["[env ts]"], :end-row 742, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "resolve-types", :ns "cljs.compiler", :row 739} {:arglist-strs ["[env line]"], :end-row 764, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "munge-param-return", :ns "cljs.compiler", :row 744} {:arglist-strs ["[]"], :end-row 769, :filename "cljs/compiler.cljc", :fixed-arities #{0}, :lang :clj, :name "checking-types?", :ns "cljs.compiler", :row 766} {:fixed-arities #{3 2}, :end-row 794, :ns "cljs.compiler", :name "emit-comment", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[doc jsdoc]" "[env doc jsdoc]"], :doc "Emit a nicely formatted comment string.", :row 771} {:arglist-strs ["[x]"], :end-row 800, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "valid-define-value?", :ns "cljs.compiler", :row 796} {:arglist-strs ["[mname jsdoc]"], :end-row 811, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "get-define", :ns "cljs.compiler", :row 802} {:arglist-strs ["[{:keys [name params env]}]"], :end-row 886, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-apply-to", :ns "cljs.compiler", :row 853} {:arglist-strs ["[params]"], :end-row 893, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-fn-params", :ns "cljs.compiler", :row 888} {:arglist-strs ["[{expr :body :keys [type name params env recurs]}]"], :end-row 908, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-fn-method", :ns "cljs.compiler", :row 895} {:fixed-arities #{1}, :end-row 922, :ns "cljs.compiler", :name "emit-arguments-to-array", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[startslice]"], :doc "Emit code that copies function arguments into an array starting at an index.\n  Returns name of var holding the array.", :row 910} {:arglist-strs ["[{expr :body max-fixed-arity :fixed-arity variadic :variadic? :keys [type name params env recurs] :as f}]"], :end-row 972, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-variadic-fn-method", :ns "cljs.compiler", :row 924} {:arglist-strs ["[{expr :body :keys [bindings env]} is-loop]"], :end-row 1106, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-let", :ns "cljs.compiler", :row 1084} {:arglist-strs ["[psym]"], :end-row 1137, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "protocol-prefix", :ns "cljs.compiler", :row 1133} {:arglist-strs ["[sublib]"], :end-row 1271, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "sublib-select", :ns "cljs.compiler", :row 1266} {:arglist-strs ["[ns-name global-exports lib]"], :end-row 1287, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :clj, :name "emit-global-export", :ns "cljs.compiler", :row 1273} {:arglist-strs ["[libs seen reloads deps ns-name]"], :end-row 1369, :filename "cljs/compiler.cljc", :fixed-arities #{5}, :lang :clj, :name "load-libs", :ns "cljs.compiler", :row 1289} {:arglist-strs ["[{:keys [target field method args env]}]"], :end-row 1429, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-dot", :ns "cljs.compiler", :row 1422} {:fixed-arities #{1}, :end-row 1463, :ns "cljs.compiler", :name "rename-to-js", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[file-str]"], :doc "Change the file extension from .cljs to .js. Takes a File or a\n     String. Always returns a String.", :row 1448} {:fixed-arities #{0 1 2}, :end-row 1477, :ns "cljs.compiler", :name "with-core-cljs", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[]" "[opts]" "[opts body]"], :doc "Ensure that core.cljs has been loaded.", :row 1466} {:arglist-strs ["[f]"], :end-row 1481, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "url-path", :ns "cljs.compiler", :row 1480} {:arglist-strs ["[]" "[opts]"], :end-row 1493, :filename "cljs/compiler.cljc", :fixed-arities #{0 1}, :lang :clj, :name "compiled-by-string", :ns "cljs.compiler", :row 1484} {:arglist-strs ["[ns ext opts]"], :end-row 1500, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :clj, :name "cached-core", :ns "cljs.compiler", :row 1496} {:arglist-strs ["[ns ext opts]"], :end-row 1507, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :clj, :name "macro-ns?", :ns "cljs.compiler", :row 1503} {:arglist-strs ["[src dest cached opts]"], :end-row 1526, :filename "cljs/compiler.cljc", :fixed-arities #{4}, :lang :clj, :name "emit-cached-core", :ns "cljs.compiler", :row 1510} {:arglist-strs ["[src dest sm-data opts]"], :end-row 1554, :filename "cljs/compiler.cljc", :fixed-arities #{4}, :lang :clj, :name "emit-source-map", :ns "cljs.compiler", :row 1529} {:arglist-strs ["[src dest ext opts]"], :end-row 1645, :filename "cljs/compiler.cljc", :fixed-arities #{4}, :lang :clj, :name "emit-source", :ns "cljs.compiler", :row 1557} {:arglist-strs ["[src dest]" "[src dest opts]"], :end-row 1673, :filename "cljs/compiler.cljc", :fixed-arities #{3 2}, :lang :clj, :name "compile-file*", :ns "cljs.compiler", :row 1648} {:fixed-arities #{3 2}, :end-row 1701, :ns "cljs.compiler", :name "requires-compilation?", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[src dest]" "[src dest opts]"], :doc "Return true if the src file requires compilation.", :row 1676} {:fixed-arities #{1 3 2}, :end-row 1769, :ns "cljs.compiler", :name "compile-file", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[src]" "[src dest]" "[src dest opts]"], :doc "Compiles src to a file of the same name, but with a .js extension,\n      in the src file's directory.\n\n      With dest argument, write file to provided location. If the dest\n      argument is a file outside the source tree, missing parent\n      directories will be created. The src file will only be compiled if\n      the dest file has an older modification time.\n\n      Both src and dest may be either a String or a File.\n\n      Returns a map containing {:ns .. :provides .. :requires .. :file ..}.\n      If the file was not compiled returns only {:file ...}", :row 1704} {:fixed-arities #{1}, :end-row 1796, :ns "cljs.compiler", :name "cljs-files-in", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[dir]"], :doc "Return a sequence of all .cljs and .cljc files in the given directory.", :row 1772} {:fixed-arities #{1 3 2}, :end-row 1827, :ns "cljs.compiler", :name "compile-root", :lang :clj, :filename "cljs/compiler.cljc", :arglist-strs ["[src-dir]" "[src-dir target-dir]" "[src-dir target-dir opts]"], :doc "Looks recursively in src-dir for .cljs files and compiles them to\n      .js files. If target-dir is provided, output will go into this\n      directory mirroring the source directory structure. Returns a list\n      of maps containing information about each file which was compiled\n      in dependency order.", :row 1799} {:arglist-strs ["[file]"], :end-row 1831, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "find-source", :ns "cljs.compiler", :row 1830} {:arglist-strs ["[src-dir]"], :end-row 1837, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "find-root-sources", :ns "cljs.compiler", :row 1834} {:arglist-strs ["[table]"], :end-row 1856, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :clj, :name "emit-constants-table", :ns "cljs.compiler", :row 1841} {:arglist-strs ["[table dest]"], :end-row 1863, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-constants-table-to-file", :ns "cljs.compiler", :row 1859} {:arglist-strs ["[externs]" "[prefix externs top-level known-externs]"], :end-row 1885, :filename "cljs/compiler.cljc", :fixed-arities #{1 4}, :lang :clj, :name "emit-externs", :ns "cljs.compiler", :row 1865} {:arglist-strs ["[externs dest]"], :end-row 1892, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :clj, :name "emit-inferred-externs-to-file", :ns "cljs.compiler", :row 1888} {:end-row 43, :filename "cljs/compiler.cljc", :lang :cljs, :name "js-reserved", :ns "cljs.compiler", :row 43} {:end-row 52, :filename "cljs/compiler.cljc", :lang :cljs, :name "es5>=", :ns "cljs.compiler", :private true, :row 45} {:end-row 54, :filename "cljs/compiler.cljc", :lang :cljs, :name "*recompiled*", :ns "cljs.compiler", :row 54} {:end-row 55, :filename "cljs/compiler.cljc", :lang :cljs, :name "*inputs*", :ns "cljs.compiler", :row 55} {:end-row 56, :filename "cljs/compiler.cljc", :lang :cljs, :name "*source-map-data*", :ns "cljs.compiler", :row 56} {:end-row 57, :filename "cljs/compiler.cljc", :lang :cljs, :name "*source-map-data-gen-col*", :ns "cljs.compiler", :row 57} {:end-row 58, :filename "cljs/compiler.cljc", :lang :cljs, :name "*lexical-renames*", :ns "cljs.compiler", :row 58} {:end-row 60, :filename "cljs/compiler.cljc", :lang :cljs, :name "cljs-reserved-file-names", :ns "cljs.compiler", :row 60} {:fixed-arities #{1}, :end-row 71, :ns "cljs.compiler", :name "get-first-ns-segment", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[ns]"], :doc "Gets the part up to the first `.` of a namespace.\n   Returns the empty string for nil.\n   Returns the entire string if no `.` in namespace", :row 62} {:arglist-strs ["[needle]"], :end-row 79, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "find-ns-starts-with", :ns "cljs.compiler", :row 73} {:arglist-strs ["[s]"], :end-row 88, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "shadow-depth", :ns "cljs.compiler", :row 82} {:arglist-strs ["[s]"], :end-row 93, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "hash-scope", :ns "cljs.compiler", :row 90} {:end-row 95, :filename "cljs/compiler.cljc", :lang :cljs, :name "munge", :ns "cljs.compiler", :row 95} {:arglist-strs ["[{:keys [name info] :as name-var}]"], :end-row 105, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "fn-self-name", :ns "cljs.compiler", :row 97} {:arglist-strs ["[reserved]"], :end-row 111, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "munge-reserved", :ns "cljs.compiler", :row 107} {:arglist-strs ["[s]" "[s reserved]"], :end-row 147, :filename "cljs/compiler.cljc", :fixed-arities #{1 2}, :lang :cljs, :name "munge", :ns "cljs.compiler", :row 113} {:fixed-arities #{1}, :end-row 150, :private true, :ns "cljs.compiler", :name "comma-sep", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[xs]"], :row 149} {:fixed-arities #{1}, :end-row 170, :private true, :ns "cljs.compiler", :name "escape-char", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[c]"], :row 152} {:fixed-arities #{1}, :end-row 177, :private true, :ns "cljs.compiler", :name "escape-string", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[s]"], :row 172} {:fixed-arities #{1}, :end-row 180, :private true, :ns "cljs.compiler", :name "wrap-in-double-quotes", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[x]"], :row 179} {:end-row 182, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit*", :ns "cljs.compiler", :row 182} {:arglist-strs ["[ast]"], :end-row 204, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit", :ns "cljs.compiler", :row 184} {:arglist-strs ["[]" "[a]" "[a b]" "[a b c]" "[a b c d]" "[a b c d e]" "[a b c d e & xs]"], :end-row 232, :filename "cljs/compiler.cljc", :fixed-arities #{0 1 4 3 2 5}, :lang :cljs, :name "emits", :ns "cljs.compiler", :row 206} {:fixed-arities #{0}, :end-row 243, :private true, :ns "cljs.compiler", :name "_emitln", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[]"], :row 234} {:arglist-strs ["[]" "[a]" "[a b]" "[a b c]" "[a b c d]" "[a b c d e]" "[a b c d e & xs]"], :end-row 260, :filename "cljs/compiler.cljc", :fixed-arities #{0 1 4 3 2 5}, :lang :cljs, :name "emitln", :ns "cljs.compiler", :row 245} {:arglist-strs ["[expr]"], :end-row 263, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-str", :ns "cljs.compiler", :row 262} {:end-row 268, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-constant*", :ns "cljs.compiler", :row 268} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-map", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-list", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-vector", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-set", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-js-object", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-js-array", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-with-meta", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-constants-comma-sep", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-constant", :ns "cljs.compiler", :row 270} {:end-row 271, :filename "cljs/compiler.cljc", :lang :cljs, :name "emit-record-value", :ns "cljs.compiler", :row 270} {:arglist-strs ["[xs]"], :end-row 274, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "all-distinct?", :ns "cljs.compiler", :row 273} {:arglist-strs ["[x]"], :end-row 295, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-constant-no-meta", :ns "cljs.compiler", :row 287} {:arglist-strs ["[v]"], :end-row 301, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-constant", :ns "cljs.compiler", :row 297} {:arglist-strs ["[kw]"], :end-row 380, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emits-keyword", :ns "cljs.compiler", :row 367} {:arglist-strs ["[sym]"], :end-row 398, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emits-symbol", :ns "cljs.compiler", :row 382} {:arglist-strs ["[cs]"], :end-row 419, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-constants-comma-sep", :ns "cljs.compiler", :row 412} {:end-row 421, :filename "cljs/compiler.cljc", :lang :cljs, :name "array-map-threshold", :ns "cljs.compiler", :private true, :row 421} {:fixed-arities #{1}, :end-row 426, :private true, :ns "cljs.compiler", :name "emit-inst", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[inst-ms]"], :row 425} {:arglist-strs ["[{:keys [info env form] :as ast}]"], :end-row 496, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-var", :ns "cljs.compiler", :row 454} {:arglist-strs ["[expr meta]"], :end-row 512, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "emit-with-meta", :ns "cljs.compiler", :row 511} {:arglist-strs ["[keys]"], :end-row 522, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "distinct-keys?", :ns "cljs.compiler", :row 519} {:arglist-strs ["[keys vals comma-sep distinct-keys?]"], :end-row 543, :filename "cljs/compiler.cljc", :fixed-arities #{4}, :lang :cljs, :name "emit-map", :ns "cljs.compiler", :row 524} {:arglist-strs ["[items comma-sep]"], :end-row 553, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "emit-list", :ns "cljs.compiler", :row 550} {:arglist-strs ["[items comma-sep]"], :end-row 562, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "emit-vector", :ns "cljs.compiler", :row 555} {:arglist-strs ["[items]"], :end-row 572, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "distinct-constants?", :ns "cljs.compiler", :row 569} {:arglist-strs ["[items comma-sep distinct-constants?]"], :end-row 583, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :cljs, :name "emit-set", :ns "cljs.compiler", :row 574} {:arglist-strs ["[items emit-js-object-val]"], :end-row 597, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "emit-js-object", :ns "cljs.compiler", :row 590} {:arglist-strs ["[items comma-sep]"], :end-row 600, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "emit-js-array", :ns "cljs.compiler", :row 599} {:arglist-strs ["[ns name items]"], :end-row 614, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :cljs, :name "emit-record-value", :ns "cljs.compiler", :row 612} {:arglist-strs ["[expr]"], :end-row 632, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "truthy-constant?", :ns "cljs.compiler", :row 625} {:arglist-strs ["[expr]"], :end-row 639, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "falsey-constant?", :ns "cljs.compiler", :row 634} {:arglist-strs ["[env e]"], :end-row 643, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "safe-test?", :ns "cljs.compiler", :row 641} {:end-row 700, :filename "cljs/compiler.cljc", :lang :cljs, :name "base-types", :ns "cljs.compiler", :row 692} {:end-row 703, :filename "cljs/compiler.cljc", :lang :cljs, :name "mapped-types", :ns "cljs.compiler", :row 702} {:arglist-strs ["[env t]"], :end-row 737, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "resolve-type", :ns "cljs.compiler", :row 705} {:arglist-strs ["[env ts]"], :end-row 742, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "resolve-types", :ns "cljs.compiler", :row 739} {:arglist-strs ["[env line]"], :end-row 764, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "munge-param-return", :ns "cljs.compiler", :row 744} {:arglist-strs ["[]"], :end-row 769, :filename "cljs/compiler.cljc", :fixed-arities #{0}, :lang :cljs, :name "checking-types?", :ns "cljs.compiler", :row 766} {:fixed-arities #{3 2}, :end-row 794, :ns "cljs.compiler", :name "emit-comment", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[doc jsdoc]" "[env doc jsdoc]"], :doc "Emit a nicely formatted comment string.", :row 771} {:arglist-strs ["[x]"], :end-row 800, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "valid-define-value?", :ns "cljs.compiler", :row 796} {:arglist-strs ["[mname jsdoc]"], :end-row 811, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-define", :ns "cljs.compiler", :row 802} {:arglist-strs ["[{:keys [name params env]}]"], :end-row 886, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-apply-to", :ns "cljs.compiler", :row 853} {:arglist-strs ["[params]"], :end-row 893, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-fn-params", :ns "cljs.compiler", :row 888} {:arglist-strs ["[{expr :body :keys [type name params env recurs]}]"], :end-row 908, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-fn-method", :ns "cljs.compiler", :row 895} {:fixed-arities #{1}, :end-row 922, :ns "cljs.compiler", :name "emit-arguments-to-array", :lang :cljs, :filename "cljs/compiler.cljc", :arglist-strs ["[startslice]"], :doc "Emit code that copies function arguments into an array starting at an index.\n  Returns name of var holding the array.", :row 910} {:arglist-strs ["[{expr :body max-fixed-arity :fixed-arity variadic :variadic? :keys [type name params env recurs] :as f}]"], :end-row 972, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-variadic-fn-method", :ns "cljs.compiler", :row 924} {:arglist-strs ["[{expr :body :keys [bindings env]} is-loop]"], :end-row 1106, :filename "cljs/compiler.cljc", :fixed-arities #{2}, :lang :cljs, :name "emit-let", :ns "cljs.compiler", :row 1084} {:arglist-strs ["[psym]"], :end-row 1137, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "protocol-prefix", :ns "cljs.compiler", :row 1133} {:arglist-strs ["[sublib]"], :end-row 1271, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "sublib-select", :ns "cljs.compiler", :row 1266} {:arglist-strs ["[ns-name global-exports lib]"], :end-row 1287, :filename "cljs/compiler.cljc", :fixed-arities #{3}, :lang :cljs, :name "emit-global-export", :ns "cljs.compiler", :row 1273} {:arglist-strs ["[libs seen reloads deps ns-name]"], :end-row 1369, :filename "cljs/compiler.cljc", :fixed-arities #{5}, :lang :cljs, :name "load-libs", :ns "cljs.compiler", :row 1289} {:arglist-strs ["[{:keys [target field method args env]}]"], :end-row 1429, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-dot", :ns "cljs.compiler", :row 1422} {:arglist-strs ["[table]"], :end-row 1856, :filename "cljs/compiler.cljc", :fixed-arities #{1}, :lang :cljs, :name "emit-constants-table", :ns "cljs.compiler", :row 1841} {:arglist-strs ["[externs]" "[prefix externs top-level known-externs]"], :end-row 1885, :filename "cljs/compiler.cljc", :fixed-arities #{1 4}, :lang :cljs, :name "emit-externs", :ns "cljs.compiler", :row 1865}]} {:end-row 13, :filename "cljs/source_map.cljs", :name "cljs.source-map", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[sources]"], :doc "Take a seq of source file names and return a map from\n   file number to integer index.", :end-row 48, :filename "cljs/source_map.clj", :fixed-arities #{1}, :name "indexed-sources", :ns "cljs.source-map", :row 42} {:arglist-strs ["[sources]"], :doc "Take a seq of source file names and return a comparator\n   that can be used to construct a sorted map.", :end-row 55, :filename "cljs/source_map.clj", :fixed-arities #{1}, :name "source-compare", :ns "cljs.source-map", :row 50} {:arglist-strs ["[seg source-map]"], :doc "Take a source map segment represented as a vector\n   and return a map.", :end-row 70, :filename "cljs/source_map.clj", :fixed-arities #{2}, :name "seg->map", :ns "cljs.source-map", :row 60} {:arglist-strs ["[seg relseg]"], :doc "Combine a source map segment vector and a relative\n   source map segment vector and combine them to get\n   an absolute segment posititon information as a vector.", :end-row 86, :filename "cljs/source_map.clj", :fixed-arities #{2}, :name "seg-combine", :ns "cljs.source-map", :row 72} {:arglist-strs ["[result segmap gline]"], :doc "Helper for decode-reverse. Take a source map and update it\n  based on a segment map.", :end-row 104, :filename "cljs/source_map.clj", :fixed-arities #{3}, :name "update-reverse-result", :ns "cljs.source-map", :row 88} {:arglist-strs ["[source-map]" "[mappings source-map]"], :doc "Convert a v3 source map JSON object into a nested sorted map\n   organized as file, line, and column. Note this source map\n   maps from *original* source location to generated source location.", :end-row 134, :filename "cljs/source_map.clj", :fixed-arities #{1 2}, :name "decode-reverse", :ns "cljs.source-map", :row 106} {:arglist-strs ["[result segmap gline]"], :doc "Helper for decode. Take a source map and update it based on a\n  segment map.", :end-row 149, :filename "cljs/source_map.clj", :fixed-arities #{3}, :name "update-result", :ns "cljs.source-map", :row 136} {:arglist-strs ["[source-map]" "[mappings source-map]"], :doc "Convert a v3 source map JSON object into a nested sorted map\n   organized as file, line, and column. Note this source map\n   maps from *generated* source location to original source\n   location.", :end-row 176, :filename "cljs/source_map.clj", :fixed-arities #{1 2}, :name "decode", :ns "cljs.source-map", :row 151} {:arglist-strs ["[lines]"], :doc "Take a nested sorted map encoding line and column information\n   for a file and return a vector of vectors of encoded segments.\n   Each vector represents a line, and the internal vectors are segments\n   representing the contents of the line.", :end-row 202, :filename "cljs/source_map.clj", :fixed-arities #{1}, :name "lines->segs", :ns "cljs.source-map", :row 181} {:arglist-strs ["[path {:keys [output-dir source-map-path source-map relpaths] :as opts}]"], :doc "Relativize a path using :source-map-path if provided or the parent directory\n   otherwise.", :end-row 221, :filename "cljs/source_map.clj", :fixed-arities #{2}, :name "relativize-path", :ns "cljs.source-map", :row 204} {:arglist-strs ["[m opts]"], :doc "Take an internal source map representation represented as nested\n   sorted maps of file, line, column and return a v3 representation.", :end-row 286, :filename "cljs/source_map.clj", :fixed-arities #{2}, :name "encode*", :ns "cljs.source-map", :row 223} {:arglist-strs ["[m opts]"], :doc "Take an internal source map representation represented as nested\n   sorted maps of file, line, column and return a source map v3 JSON\n   string.", :end-row 299, :filename "cljs/source_map.clj", :fixed-arities #{2}, :name "encode", :ns "cljs.source-map", :row 288} {:arglist-strs ["[cljs-map js-map]"], :doc "Merge an internal source map representation of a single\n   ClojureScript file mapping original to generated with a\n   second source map mapping original JS to generated JS.\n   The is to support source maps that work through multiple\n   compilation steps like Google Closure optimization passes.", :end-row 326, :filename "cljs/source_map.clj", :fixed-arities #{2}, :name "merge-source-maps", :ns "cljs.source-map", :row 304} {:arglist-strs ["[reverse-map]"], :doc "Given a ClojureScript to JavaScript source map, invert it. Useful when\n   mapping JavaScript stack traces when environment support is unavailable.", :end-row 344, :filename "cljs/source_map.clj", :fixed-arities #{1}, :name "invert-reverse-map", :ns "cljs.source-map", :row 331} {:end-row 362, :filename "cljs/source_map.clj", :name "raw-source-map", :ns "cljs.source-map", :row 361} {:arglist-strs ["[sources]"], :doc "Take a seq of source file names and return a map from\n   file number to integer index. For reverse source maps.", :end-row 40, :filename "cljs/source_map.cljs", :fixed-arities #{1}, :name "indexed-sources", :ns "cljs.source-map", :row 34} {:arglist-strs ["[sources]"], :doc "Take a seq of source file names and return a comparator\n   that can be used to construct a sorted map. For reverse\n   source maps.", :end-row 48, :filename "cljs/source_map.cljs", :fixed-arities #{1}, :name "source-compare", :ns "cljs.source-map", :row 42} {:arglist-strs ["[seg source-map]"], :doc "Take a source map segment represented as a vector\n   and return a map.", :end-row 63, :filename "cljs/source_map.cljs", :fixed-arities #{2}, :name "seg->map", :ns "cljs.source-map", :row 53} {:arglist-strs ["[seg relseg]"], :doc "Combine a source map segment vector and a relative\n   source map segment vector and combine them to get\n   an absolute segment posititon information as a vector.", :end-row 79, :filename "cljs/source_map.cljs", :fixed-arities #{2}, :name "seg-combine", :ns "cljs.source-map", :row 65} {:arglist-strs ["[result segmap gline]"], :doc "Helper for decode-reverse. Take a reverse source map and\n  update it with a segment map.", :end-row 97, :filename "cljs/source_map.cljs", :fixed-arities #{3}, :name "update-reverse-result", :ns "cljs.source-map", :row 81} {:arglist-strs ["[source-map]" "[mappings source-map]"], :doc "Convert a v3 source map JSON object into a reverse source map\n  mapping original ClojureScript source locations to the generated\n  JavaScript.", :end-row 128, :filename "cljs/source_map.cljs", :fixed-arities #{1 2}, :name "decode-reverse", :ns "cljs.source-map", :row 99} {:arglist-strs ["[result segmap gline]"], :doc "Helper for decode. Take a source map and update it based on a\n  segment map.", :end-row 143, :filename "cljs/source_map.cljs", :fixed-arities #{3}, :name "update-result", :ns "cljs.source-map", :row 130} {:arglist-strs ["[source-map]" "[mappings source-map]"], :doc "Convert a v3 source map JSON object into a source map mapping\n  generated JavaScript source locations to the original\n  ClojureScript.", :end-row 170, :filename "cljs/source_map.cljs", :fixed-arities #{1 2}, :name "decode", :ns "cljs.source-map", :row 145} {:arglist-strs ["[lines]"], :doc "Take a nested sorted map encoding line and column information\n   for a file and return a vector of vectors of encoded segments.\n   Each vector represents a line, and the internal vectors are segments\n   representing the contents of the line.", :end-row 196, :filename "cljs/source_map.cljs", :fixed-arities #{1}, :name "lines->segs", :ns "cljs.source-map", :row 175} {:arglist-strs ["[m opts]"], :doc "Take an internal source map representation represented as nested\n   sorted maps of file, line, column and return a source map v3 JSON\n   string.", :end-row 253, :filename "cljs/source_map.cljs", :fixed-arities #{2}, :name "encode", :ns "cljs.source-map", :row 198} {:arglist-strs ["[cljs-map js-map]"], :doc "Merge an internal source map representation of a single\n   ClojureScript file mapping original to generated with a\n   second source map mapping original JS to generated JS.\n   The is to support source maps that work through multiple\n   compilation steps like Google Closure optimization passes.", :end-row 280, :filename "cljs/source_map.cljs", :fixed-arities #{2}, :name "merge-source-maps", :ns "cljs.source-map", :row 258} {:arglist-strs ["[reverse-map]"], :doc "Given a ClojureScript to JavaScript source map, invert it. Useful when\n   mapping JavaScript stack traces when environment support is unavailable.", :end-row 298, :filename "cljs/source_map.cljs", :fixed-arities #{1}, :name "invert-reverse-map", :ns "cljs.source-map", :row 285}]} {:end-row 11, :filename "cljs/tagged_literals.cljc", :lang :clj, :name "cljs.tagged-literals", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[form]"], :end-row 21, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :clj, :name "read-queue", :ns "cljs.tagged-literals", :row 13} {:arglist-strs ["[form]"], :end-row 31, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :clj, :name "read-uuid", :ns "cljs.tagged-literals", :row 24} {:arglist-strs ["[form]"], :end-row 51, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :clj, :name "read-inst", :ns "cljs.tagged-literals", :row 44} {:arglist-strs ["[k]"], :end-row 66, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :clj, :name "valid-js-literal-key?", :ns "cljs.tagged-literals", :row 63} {:end-row 68, :filename "cljs/tagged_literals.cljc", :lang :clj, :name "JSValue", :ns "cljs.tagged-literals", :row 68} {:arglist-strs ["[val]"], :end-row 68, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :clj, :name "->JSValue", :ns "cljs.tagged-literals", :row 68} {:arglist-strs ["[form]"], :end-row 85, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :clj, :name "read-js", :ns "cljs.tagged-literals", :row 70} {:end-row 93, :filename "cljs/tagged_literals.cljc", :lang :clj, :name "*cljs-data-readers*", :ns "cljs.tagged-literals", :row 87} {:arglist-strs ["[form]"], :end-row 21, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :cljs, :name "read-queue", :ns "cljs.tagged-literals", :row 13} {:arglist-strs ["[form]"], :end-row 41, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :cljs, :name "read-uuid", :ns "cljs.tagged-literals", :row 34} {:arglist-strs ["[form]"], :end-row 61, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :cljs, :name "read-inst", :ns "cljs.tagged-literals", :row 54} {:arglist-strs ["[k]"], :end-row 66, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :cljs, :name "valid-js-literal-key?", :ns "cljs.tagged-literals", :row 63} {:end-row 68, :filename "cljs/tagged_literals.cljc", :lang :cljs, :name "JSValue", :ns "cljs.tagged-literals", :row 68} {:arglist-strs ["[val]"], :end-row 68, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :cljs, :name "->JSValue", :ns "cljs.tagged-literals", :row 68} {:arglist-strs ["[form]"], :end-row 85, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :cljs, :name "read-js", :ns "cljs.tagged-literals", :row 70} {:end-row 93, :filename "cljs/tagged_literals.cljc", :lang :cljs, :name "*cljs-data-readers*", :ns "cljs.tagged-literals", :row 87}]} {:end-row 11, :filename "cljs/tagged_literals.cljc", :lang :cljs, :name "cljs.tagged-literals", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[form]"], :end-row 21, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :clj, :name "read-queue", :ns "cljs.tagged-literals", :row 13} {:arglist-strs ["[form]"], :end-row 31, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :clj, :name "read-uuid", :ns "cljs.tagged-literals", :row 24} {:arglist-strs ["[form]"], :end-row 51, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :clj, :name "read-inst", :ns "cljs.tagged-literals", :row 44} {:arglist-strs ["[k]"], :end-row 66, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :clj, :name "valid-js-literal-key?", :ns "cljs.tagged-literals", :row 63} {:end-row 68, :filename "cljs/tagged_literals.cljc", :lang :clj, :name "JSValue", :ns "cljs.tagged-literals", :row 68} {:arglist-strs ["[val]"], :end-row 68, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :clj, :name "->JSValue", :ns "cljs.tagged-literals", :row 68} {:arglist-strs ["[form]"], :end-row 85, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :clj, :name "read-js", :ns "cljs.tagged-literals", :row 70} {:end-row 93, :filename "cljs/tagged_literals.cljc", :lang :clj, :name "*cljs-data-readers*", :ns "cljs.tagged-literals", :row 87} {:arglist-strs ["[form]"], :end-row 21, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :cljs, :name "read-queue", :ns "cljs.tagged-literals", :row 13} {:arglist-strs ["[form]"], :end-row 41, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :cljs, :name "read-uuid", :ns "cljs.tagged-literals", :row 34} {:arglist-strs ["[form]"], :end-row 61, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :cljs, :name "read-inst", :ns "cljs.tagged-literals", :row 54} {:arglist-strs ["[k]"], :end-row 66, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :cljs, :name "valid-js-literal-key?", :ns "cljs.tagged-literals", :row 63} {:end-row 68, :filename "cljs/tagged_literals.cljc", :lang :cljs, :name "JSValue", :ns "cljs.tagged-literals", :row 68} {:arglist-strs ["[val]"], :end-row 68, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :cljs, :name "->JSValue", :ns "cljs.tagged-literals", :row 68} {:arglist-strs ["[form]"], :end-row 85, :filename "cljs/tagged_literals.cljc", :fixed-arities #{1}, :lang :cljs, :name "read-js", :ns "cljs.tagged-literals", :row 70} {:end-row 93, :filename "cljs/tagged_literals.cljc", :lang :cljs, :name "*cljs-data-readers*", :ns "cljs.tagged-literals", :row 87}]} {:end-row 14, :filename "cljs/server/browser.clj", :name "cljs.server.browser", :row 9, :ns nil, :var-definitions [{:end-row 16, :filename "cljs/server/browser.clj", :name "envs", :ns "cljs.server.browser", :row 16} {:arglist-strs ["[{:keys [host port]}]"], :end-row 19, :filename "cljs/server/browser.clj", :fixed-arities #{1}, :name "env-opts->key", :ns "cljs.server.browser", :row 18} {:arglist-strs ["[{:keys [server-state] :as repl-env}]"], :end-row 24, :filename "cljs/server/browser.clj", :fixed-arities #{1}, :name "stale?", :ns "cljs.server.browser", :row 21} {:arglist-strs ["[env-opts]"], :end-row 36, :filename "cljs/server/browser.clj", :fixed-arities #{1}, :name "get-envs", :ns "cljs.server.browser", :row 26} {:arglist-strs ["[]" "[{:keys [opts env-opts]}]"], :end-row 44, :filename "cljs/server/browser.clj", :fixed-arities #{0 1}, :name "repl", :ns "cljs.server.browser", :row 38} {:arglist-strs ["[]" "[{:keys [opts env-opts]}]"], :end-row 54, :filename "cljs/server/browser.clj", :fixed-arities #{0 1}, :name "prepl", :ns "cljs.server.browser", :row 46}]} {:end-row 14, :filename "cljs/server/node.clj", :name "cljs.server.node", :row 9, :ns nil, :var-definitions [{:end-row 16, :filename "cljs/server/node.clj", :name "envs", :ns "cljs.server.node", :row 16} {:arglist-strs ["[{:keys [host port]}]"], :end-row 19, :filename "cljs/server/node.clj", :fixed-arities #{1}, :name "env-opts->key", :ns "cljs.server.node", :row 18} {:arglist-strs ["[{:keys [socket] :as repl-env}]"], :end-row 24, :filename "cljs/server/node.clj", :fixed-arities #{1}, :name "stale?", :ns "cljs.server.node", :row 21} {:arglist-strs ["[env-opts]"], :end-row 36, :filename "cljs/server/node.clj", :fixed-arities #{1}, :name "get-envs", :ns "cljs.server.node", :row 26} {:arglist-strs ["[]" "[{:keys [opts env-opts]}]"], :end-row 44, :filename "cljs/server/node.clj", :fixed-arities #{0 1}, :name "repl", :ns "cljs.server.node", :row 38} {:arglist-strs ["[]" "[{:keys [opts env-opts]}]"], :end-row 54, :filename "cljs/server/node.clj", :fixed-arities #{0 1}, :name "prepl", :ns "cljs.server.node", :row 46}]} {:end-row 13, :filename "cljs/main.clj", :name "cljs.main", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[x]"], :end-row 16, :filename "cljs/main.clj", :fixed-arities #{1}, :name "single-segment?", :ns "cljs.main", :row 15} {:arglist-strs ["[args]"], :end-row 36, :filename "cljs/main.clj", :fixed-arities #{1}, :name "get-js-opt", :ns "cljs.main", :private true, :row 18} {:arglist-strs ["[args]"], :end-row 50, :filename "cljs/main.clj", :fixed-arities #{1}, :name "normalize*", :ns "cljs.main", :private true, :row 38} {:arglist-strs ["[args]"], :end-row 54, :filename "cljs/main.clj", :fixed-arities #{1}, :name "normalize", :ns "cljs.main", :row 52} {:arglist-strs ["[& args]"], :end-row 67, :filename "cljs/main.clj", :name "-main", :ns "cljs.main", :row 56}]} {:end-row 16, :filename "cljs/core.cljs", :name "cljs.core", :row 9, :ns nil, :var-definitions [{:fixed-arities #{2}, :end-row 90, :ns "cljs.core", :name "import-macros", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[ns [& vars]]"], :row 64} {:end-row 192, :ns "cljs.core", :name "doto", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x & forms]"], :doc "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new js/Map) (.set \"a\" 1) (.set \"b\" 2))", :row 178} {:end-row 389, :ns "cljs.core", :name "memfn", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & args]"], :doc "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a JavaScript\n  method as a first-class fn.", :row 380} {:fixed-arities #{1}, :end-row 590, :private true, :ns "cljs.core", :name "assert-valid-fdecl", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :doc "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.", :row 553} {:fixed-arities #{1}, :end-row 617, :private true, :ns "cljs.core", :name "sigs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 592} {:fixed-arities #{2}, :end-row 627, :ns "cljs.core", :name "defonce", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x init]"], :doc "defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated", :row 619} {:arglist-strs ["[bindings]"], :end-row 730, :filename "cljs/core.cljc", :fixed-arities #{1}, :lang :clj, :name "destructure", :ns "cljs.core", :row 629} {:end-row 736, :private true, :ns "cljs.core", :name "return-first", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :row 732} {:fixed-arities #{2}, :end-row 770, :ns "cljs.core", :name "goog-define", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[sym default]"], :doc "Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n    or\n    :closure-defines {your-app.core/DEBUG! true}", :row 738} {:end-row 787, :ns "cljs.core", :name "let", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => binding-form init-expr\n  binding-form => name, or destructuring-form\n  destructuring-form => map-destructure-form, or seq-destructure-form\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\n\n  See https://clojure.org/reference/special_forms#binding-forms for\n  more information about destructuring.", :row 772} {:end-row 811, :ns "cljs.core", :name "loop", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", :row 789} {:doc "protocol fqn -> [partition number, bit]", :end-row 829, :filename "cljs/core.cljc", :lang :clj, :name "fast-path-protocols", :ns "cljs.core", :row 813} {:doc "total number of partitions", :end-row 837, :filename "cljs/core.cljc", :lang :clj, :name "fast-path-protocol-partitions-count", :ns "cljs.core", :row 831} {:fixed-arities #{2}, :end-row 842, :private true, :ns "cljs.core", :name "compatible?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[inferred-tag allowed-tags]"], :row 839} {:fixed-arities #{3}, :end-row 847, :private true, :ns "cljs.core", :name "typed-expr?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env form allowed-tags]"], :row 844} {:fixed-arities #{1}, :end-row 850, :private true, :ns "cljs.core", :name "string-expr", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[e]"], :row 849} {:fixed-arities #{0 1}, :end-row 867, :ns "cljs.core", :name "str", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & ys]"], :row 852} {:fixed-arities #{1}, :end-row 870, :private true, :ns "cljs.core", :name "bool-expr", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[e]"], :row 869} {:fixed-arities #{2}, :end-row 875, :private true, :ns "cljs.core", :name "simple-test-expr?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env ast]"], :row 872} {:fixed-arities #{0 1}, :end-row 886, :ns "cljs.core", :name "and", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", :row 877} {:fixed-arities #{0 1}, :end-row 897, :ns "cljs.core", :name "or", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", :row 888} {:fixed-arities #{1}, :end-row 900, :ns "cljs.core", :name "nil?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 899} {:fixed-arities #{1}, :end-row 903, :ns "cljs.core", :name "some?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 902} {:fixed-arities #{1}, :end-row 906, :ns "cljs.core", :name "coercive-not", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 905} {:fixed-arities #{2}, :end-row 909, :ns "cljs.core", :name "coercive-not=", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]"], :row 908} {:fixed-arities #{2}, :end-row 912, :ns "cljs.core", :name "coercive-=", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]"], :row 911} {:fixed-arities #{1}, :end-row 916, :ns "cljs.core", :name "coercive-boolean", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 914} {:fixed-arities #{1}, :end-row 921, :ns "cljs.core", :name "truth_", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 919} {:fixed-arities #{0}, :end-row 924, :ns "cljs.core", :name "js-arguments", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 923} {:fixed-arities #{2}, :end-row 927, :ns "cljs.core", :name "js-delete", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key]"], :row 926} {:fixed-arities #{2}, :end-row 930, :ns "cljs.core", :name "js-in", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[key obj]"], :row 929} {:fixed-arities #{0}, :end-row 937, :ns "cljs.core", :name "js-debugger", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :doc "Emit JavaScript \"debugger;\" statement", :row 932} {:fixed-arities #{1}, :end-row 951, :ns "cljs.core", :name "js-comment", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[comment]"], :doc "Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline", :row 939} {:fixed-arities #{2}, :end-row 957, :ns "cljs.core", :name "unsafe-cast", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[t x]"], :doc "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type.", :row 953} {:fixed-arities #{1}, :end-row 962, :ns "cljs.core", :name "js-inline-comment", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[comment]"], :doc "Emit an inline JavaScript comment.", :row 959} {:fixed-arities #{1}, :end-row 965, :ns "cljs.core", :name "true?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 964} {:fixed-arities #{1}, :end-row 968, :ns "cljs.core", :name "false?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 967} {:fixed-arities #{1}, :end-row 971, :ns "cljs.core", :name "string?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 970} {:fixed-arities #{1}, :end-row 974, :ns "cljs.core", :name "js-fn?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 973} {:fixed-arities #{1}, :end-row 991, :ns "cljs.core", :name "exists?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :doc "Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript.", :row 976} {:fixed-arities #{1}, :end-row 996, :ns "cljs.core", :name "undefined?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :doc "Return true if argument is identical to the JavaScript undefined value.", :row 993} {:fixed-arities #{2}, :end-row 999, :ns "cljs.core", :name "identical?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a b]"], :row 998} {:fixed-arities #{2}, :end-row 1008, :ns "cljs.core", :name "instance?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[c x]"], :row 1001} {:fixed-arities #{1}, :end-row 1011, :ns "cljs.core", :name "number?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1010} {:fixed-arities #{1}, :end-row 1014, :ns "cljs.core", :name "symbol?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1013} {:fixed-arities #{1}, :end-row 1017, :ns "cljs.core", :name "keyword?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1016} {:fixed-arities #{2}, :end-row 1030, :ns "cljs.core", :name "aget", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[array idx]" "[array idx & idxs]"], :row 1019} {:fixed-arities #{3}, :end-row 1044, :ns "cljs.core", :name "aset", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :row 1032} {:fixed-arities #{2}, :end-row 1051, :ns "cljs.core", :name "unchecked-get", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key]"], :doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :row 1046} {:fixed-arities #{3}, :end-row 1058, :ns "cljs.core", :name "unchecked-set", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key val]"], :doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :row 1053} {:fixed-arities #{0 1 2}, :end-row 1064, :ns "cljs.core", :name "+", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :row 1060} {:fixed-arities #{1}, :end-row 1066, :ns "cljs.core", :name "byte", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1066} {:fixed-arities #{1}, :end-row 1067, :ns "cljs.core", :name "short", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1067} {:fixed-arities #{1}, :end-row 1068, :ns "cljs.core", :name "float", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1068} {:fixed-arities #{1}, :end-row 1069, :ns "cljs.core", :name "double", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1069} {:fixed-arities #{1}, :end-row 1071, :ns "cljs.core", :name "unchecked-byte", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1071} {:fixed-arities #{1}, :end-row 1072, :ns "cljs.core", :name "unchecked-char", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1072} {:fixed-arities #{1}, :end-row 1073, :ns "cljs.core", :name "unchecked-short", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1073} {:fixed-arities #{1}, :end-row 1074, :ns "cljs.core", :name "unchecked-float", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1074} {:fixed-arities #{1}, :end-row 1075, :ns "cljs.core", :name "unchecked-double", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1075} {:arglist-strs ["[& xs]"], :end-row 1078, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-add", :ns "cljs.core", :row 1077} {:arglist-strs ["[& xs]"], :end-row 1081, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-add-int", :ns "cljs.core", :row 1080} {:fixed-arities #{1}, :end-row 1084, :ns "cljs.core", :name "unchecked-dec", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1083} {:fixed-arities #{1}, :end-row 1087, :ns "cljs.core", :name "unchecked-dec-int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1086} {:arglist-strs ["[& xs]"], :end-row 1090, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-divide-int", :ns "cljs.core", :row 1089} {:fixed-arities #{1}, :end-row 1093, :ns "cljs.core", :name "unchecked-inc", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1092} {:fixed-arities #{1}, :end-row 1096, :ns "cljs.core", :name "unchecked-inc-int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1095} {:arglist-strs ["[& xs]"], :end-row 1099, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-multiply", :ns "cljs.core", :row 1098} {:arglist-strs ["[& xs]"], :end-row 1102, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-multiply-int", :ns "cljs.core", :row 1101} {:fixed-arities #{1}, :end-row 1105, :ns "cljs.core", :name "unchecked-negate", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1104} {:fixed-arities #{1}, :end-row 1108, :ns "cljs.core", :name "unchecked-negate-int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1107} {:fixed-arities #{2}, :end-row 1111, :ns "cljs.core", :name "unchecked-remainder-int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1110} {:arglist-strs ["[& xs]"], :end-row 1114, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-subtract", :ns "cljs.core", :row 1113} {:arglist-strs ["[& xs]"], :end-row 1117, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "unchecked-subtract-int", :ns "cljs.core", :row 1116} {:fixed-arities #{1 2}, :end-row 1122, :ns "cljs.core", :name "-", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1119} {:fixed-arities #{0 1 2}, :end-row 1128, :ns "cljs.core", :name "*", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :row 1124} {:fixed-arities #{1 2}, :end-row 1133, :ns "cljs.core", :name "/", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1130} {:fixed-arities #{1 2}, :end-row 1138, :ns "cljs.core", :name "divide", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1135} {:fixed-arities #{1 2}, :end-row 1143, :ns "cljs.core", :name "<", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1140} {:fixed-arities #{1 2}, :end-row 1148, :ns "cljs.core", :name "<=", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1145} {:fixed-arities #{1 2}, :end-row 1153, :ns "cljs.core", :name ">", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1150} {:fixed-arities #{1 2}, :end-row 1158, :ns "cljs.core", :name ">=", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1155} {:fixed-arities #{1 2}, :end-row 1163, :ns "cljs.core", :name "==", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1160} {:fixed-arities #{1}, :end-row 1166, :ns "cljs.core", :name "dec", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1165} {:fixed-arities #{1}, :end-row 1169, :ns "cljs.core", :name "inc", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1168} {:fixed-arities #{1}, :end-row 1172, :ns "cljs.core", :name "zero?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1171} {:fixed-arities #{1}, :end-row 1175, :ns "cljs.core", :name "pos?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1174} {:fixed-arities #{1}, :end-row 1178, :ns "cljs.core", :name "neg?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1177} {:fixed-arities #{1 2}, :end-row 1184, :ns "cljs.core", :name "max", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1180} {:fixed-arities #{1 2}, :end-row 1190, :ns "cljs.core", :name "min", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1186} {:fixed-arities #{2}, :end-row 1193, :ns "cljs.core", :name "js-mod", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[num div]"], :row 1192} {:fixed-arities #{1}, :end-row 1196, :ns "cljs.core", :name "bit-not", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1195} {:fixed-arities #{2}, :end-row 1200, :ns "cljs.core", :name "bit-and", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1198} {:fixed-arities #{2}, :end-row 1205, :ns "cljs.core", :name "unsafe-bit-and", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1203} {:fixed-arities #{2}, :end-row 1209, :ns "cljs.core", :name "bit-or", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1207} {:fixed-arities #{1}, :end-row 1212, :ns "cljs.core", :name "int", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1211} {:fixed-arities #{2}, :end-row 1216, :ns "cljs.core", :name "bit-xor", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1214} {:fixed-arities #{2}, :end-row 1220, :ns "cljs.core", :name "bit-and-not", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1218} {:fixed-arities #{2}, :end-row 1223, :ns "cljs.core", :name "bit-clear", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1222} {:fixed-arities #{2}, :end-row 1226, :ns "cljs.core", :name "bit-flip", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1225} {:fixed-arities #{2}, :end-row 1229, :ns "cljs.core", :name "bit-test", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1228} {:fixed-arities #{2}, :end-row 1232, :ns "cljs.core", :name "bit-shift-left", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1231} {:fixed-arities #{2}, :end-row 1235, :ns "cljs.core", :name "bit-shift-right", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1234} {:fixed-arities #{2}, :end-row 1238, :ns "cljs.core", :name "bit-shift-right-zero-fill", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1237} {:fixed-arities #{2}, :end-row 1241, :ns "cljs.core", :name "unsigned-bit-shift-right", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1240} {:fixed-arities #{2}, :end-row 1244, :ns "cljs.core", :name "bit-set", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1243} {:fixed-arities #{2}, :end-row 1248, :ns "cljs.core", :name "mask", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[hash shift]"], :row 1247} {:fixed-arities #{2}, :end-row 1252, :ns "cljs.core", :name "bitpos", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[hash shift]"], :row 1251} {:fixed-arities #{3}, :end-row 1262, :ns "cljs.core", :name "caching-hash", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[coll hash-fn hash-key]"], :row 1255} {:fixed-arities #{5}, :end-row 1271, :private true, :ns "cljs.core", :name "do-curried", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[name doc meta args body]"], :row 1266} {:end-row 1277, :private true, :ns "cljs.core", :name "defcurried", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name doc meta args & body]"], :doc "Builds another arity of the fn that returns a fn awaiting the last\n  param", :row 1273} {:fixed-arities #{3}, :end-row 1288, :private true, :ns "cljs.core", :name "do-rfn", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[f1 k fkv]"], :row 1279} {:fixed-arities #{2}, :end-row 1293, :private true, :ns "cljs.core", :name "rfn", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[[f1 k] fkv]"], :doc "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.", :row 1290} {:fixed-arities #{1}, :end-row 1301, :private true, :ns "cljs.core", :name "protocol-prefix", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[psym]"], :row 1297} {:end-row 1311, :filename "cljs/core.cljc", :lang :clj, :name "base-type", :ns "cljs.core", :private true, :row 1303} {:end-row 1319, :filename "cljs/core.cljc", :lang :clj, :name "js-base-type", :ns "cljs.core", :private true, :row 1313} {:end-row 1380, :ns "cljs.core", :name "reify", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& impls]"], :doc "reify creates an object implementing a protocol.\n  reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \"foo\"]\n       (reify Object\n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"]\n       (reify ISeqable\n         (-seq [this] (seq f)))))\n  == (\"f\" \"o\" \"o\"))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", :row 1321} {:end-row 1388, :ns "cljs.core", :name "specify!", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & impls]"], :doc "Identical to reify but mutates its first argument.", :row 1382} {:end-row 1395, :ns "cljs.core", :name "specify", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & impls]"], :doc "Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance.", :row 1390} {:fixed-arities #{0}, :end-row 1398, :private true, :ns "cljs.core", :name "js-this", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 1397} {:end-row 1404, :ns "cljs.core", :name "this-as", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & body]"], :doc "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.", :row 1400} {:fixed-arities #{1}, :end-row 1407, :private true, :ns "cljs.core", :name "to-property", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[sym]"], :row 1406} {:fixed-arities #{3}, :end-row 1425, :private true, :ns "cljs.core", :name "update-protocol-var", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[p type env]"], :row 1409} {:fixed-arities #{2}, :end-row 1430, :private true, :ns "cljs.core", :name "resolve-var", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env sym]"], :row 1427} {:fixed-arities #{1}, :end-row 1437, :private true, :ns "cljs.core", :name "->impl-map", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[impls]"], :row 1432} {:fixed-arities #{5}, :end-row 1448, :private true, :ns "cljs.core", :name "base-assign-impls", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env resolve tsym type [p sigs]]"], :row 1439} {:end-row 1450, :filename "cljs/core.cljc", :lang :clj, :name "extend-prefix", :ns "cljs.core", :private true, :row 1450} {:fixed-arities #{2}, :end-row 1461, :private true, :ns "cljs.core", :name "adapt-obj-params", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1459} {:fixed-arities #{2}, :end-row 1468, :private true, :ns "cljs.core", :name "adapt-ifn-params", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1463} {:fixed-arities #{2}, :end-row 1474, :private true, :ns "cljs.core", :name "adapt-ifn-invoke-params", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1471} {:fixed-arities #{2}, :end-row 1480, :private true, :ns "cljs.core", :name "adapt-proto-params", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1476} {:fixed-arities #{3}, :end-row 1489, :private true, :ns "cljs.core", :name "add-obj-methods", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym sigs]"], :row 1482} {:fixed-arities #{3}, :end-row 1497, :private true, :ns "cljs.core", :name "ifn-invoke-methods", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym [f & meths :as form]]"], :row 1491} {:fixed-arities #{3}, :end-row 1518, :private true, :ns "cljs.core", :name "add-ifn-methods", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym [f & meths :as form]]"], :row 1499} {:fixed-arities #{4}, :end-row 1530, :private true, :ns "cljs.core", :name "add-proto-methods*", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[pprefix type type-sym [f & meths :as form]]"], :row 1520} {:fixed-arities #{5}, :end-row 1547, :private true, :ns "cljs.core", :name "proto-assign-impls", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env resolve type-sym type [p sigs]]"], :row 1532} {:fixed-arities #{3}, :end-row 1577, :private true, :ns "cljs.core", :name "validate-impl-sigs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env p method]"], :row 1549} {:fixed-arities #{2}, :end-row 1595, :private true, :ns "cljs.core", :name "validate-impls", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env impls]"], :row 1579} {:fixed-arities #{2}, :end-row 1599, :private true, :ns "cljs.core", :name "type-hint-first-arg", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym argv]"], :row 1597} {:fixed-arities #{2}, :end-row 1603, :private true, :ns "cljs.core", :name "type-hint-single-arity-sig", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1601} {:fixed-arities #{2}, :end-row 1607, :private true, :ns "cljs.core", :name "type-hint-multi-arity-sig", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1605} {:fixed-arities #{2}, :end-row 1611, :private true, :ns "cljs.core", :name "type-hint-multi-arity-sigs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sigs]"], :row 1609} {:fixed-arities #{2}, :end-row 1617, :private true, :ns "cljs.core", :name "type-hint-sigs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1613} {:fixed-arities #{2}, :end-row 1623, :private true, :ns "cljs.core", :name "type-hint-impl-map", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[type-sym impl-map]"], :row 1619} {:end-row 1665, :ns "cljs.core", :name "extend-type", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[type-sym & impls]"], :doc "Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y] ...) ...)", :row 1625} {:fixed-arities #{2}, :end-row 1687, :private true, :ns "cljs.core", :name "prepare-protocol-masks", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env impls]"], :row 1667} {:fixed-arities #{3}, :end-row 1692, :private true, :ns "cljs.core", :name "annotate-specs", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[annots v [f sigs]]"], :row 1689} {:arglist-strs ["[type specs fields]" "[type specs fields inline]"], :end-row 1709, :filename "cljs/core.cljc", :fixed-arities #{4 3}, :lang :clj, :name "dt->et", :ns "cljs.core", :row 1694} {:fixed-arities #{2}, :end-row 1715, :private true, :ns "cljs.core", :name "collect-protocols", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[impls env]"], :row 1711} {:fixed-arities #{3}, :end-row 1726, :private true, :ns "cljs.core", :name "build-positional-factory", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[rsym rname fields]"], :row 1717} {:fixed-arities #{3}, :end-row 1733, :private true, :ns "cljs.core", :name "validate-fields", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[case name fields]"], :row 1728} {:end-row 1803, :ns "cljs.core", :name "deftype", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[t fields & impls]"], :doc "(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", :row 1735} {:fixed-arities #{5}, :end-row 1910, :private true, :ns "cljs.core", :name "emit-defrecord", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env tagname rname fields impls]"], :doc "Do not use this directly - use defrecord", :row 1805} {:fixed-arities #{3}, :end-row 1922, :private true, :ns "cljs.core", :name "build-map-factory", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[rsym rname fields]"], :row 1912} {:end-row 1991, :ns "cljs.core", :name "defrecord", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[rsym fields & impls]"], :doc "(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", :row 1924} {:end-row 2177, :ns "cljs.core", :name "defprotocol", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym & doc+methods]"], :doc "A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", :row 1993} {:fixed-arities #{2}, :end-row 2203, :ns "cljs.core", :name "implements?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym x]"], :doc "EXPERIMENTAL", :row 2179} {:fixed-arities #{2}, :end-row 2235, :ns "cljs.core", :name "satisfies?", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym x]"], :doc "Returns true if x satisfies the protocol", :row 2205} {:end-row 2243, :ns "cljs.core", :name "lazy-seq", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls.", :row 2237} {:end-row 2251, :ns "cljs.core", :name "delay", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.", :row 2245} {:end-row 2275, :ns "cljs.core", :name "with-redefs", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing.", :row 2253} {:end-row 2288, :ns "cljs.core", :name "binding", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", :row 2277} {:end-row 2329, :ns "cljs.core", :name "condp", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[pred expr & clauses]"], :doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an Error is thrown.", :row 2290} {:fixed-arities #{4}, :end-row 2346, :private true, :ns "cljs.core", :name "assoc-test", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[m test expr env]"], :row 2331} {:fixed-arities #{2}, :end-row 2351, :private true, :ns "cljs.core", :name "const?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[env x]"], :row 2348} {:end-row 2422, :ns "cljs.core", :name "case", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[e & clauses]"], :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", :row 2353} {:fixed-arities #{1}, :end-row 2425, :private true, :ns "cljs.core", :name "when-assert", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 2424} {:fixed-arities #{1 2}, :end-row 2438, :ns "cljs.core", :name "assert", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x message]"], :doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.", :row 2427} {:fixed-arities #{2}, :end-row 2525, :ns "cljs.core", :name "for", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[seq-exprs body-expr]"], :doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))", :row 2440} {:end-row 2581, :ns "cljs.core", :name "doseq", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[seq-exprs & body]"], :doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", :row 2527} {:arglist-strs ["[& rest]"], :end-row 2590, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "array", :ns "cljs.core", :row 2583} {:fixed-arities #{1 2}, :end-row 2608, :ns "cljs.core", :name "make-array", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[size]" "[type size]" "[type size & more-sizes]"], :row 2592} {:fixed-arities #{0 1}, :end-row 2617, :ns "cljs.core", :name "list", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & xs]"], :row 2610} {:fixed-arities #{0}, :end-row 2628, :ns "cljs.core", :name "vector", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& xs]"], :row 2619} {:fixed-arities #{0}, :end-row 2638, :ns "cljs.core", :name "array-map", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& kvs]"], :row 2630} {:fixed-arities #{0}, :end-row 2651, :ns "cljs.core", :name "hash-map", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& kvs]"], :row 2640} {:fixed-arities #{0}, :end-row 2665, :ns "cljs.core", :name "hash-set", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& xs]"], :row 2653} {:fixed-arities #{1}, :end-row 2674, :private true, :ns "cljs.core", :name "js-obj*", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[kvs]"], :row 2667} {:arglist-strs ["[& rest]"], :end-row 2694, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "js-obj", :ns "cljs.core", :row 2676} {:fixed-arities #{1}, :end-row 2699, :ns "cljs.core", :name "alength", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a]"], :row 2696} {:fixed-arities #{4}, :end-row 2715, :ns "cljs.core", :name "amap", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a idx ret expr]"], :doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret.", :row 2701} {:fixed-arities #{5}, :end-row 2727, :ns "cljs.core", :name "areduce", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a idx ret init expr]"], :doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret.", :row 2717} {:end-row 2741, :ns "cljs.core", :name "dotimes", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", :row 2729} {:end-row 2751, :private true, :ns "cljs.core", :name "check-valid-options", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[options & valid-keys]"], :doc "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", :row 2743} {:end-row 2798, :ns "cljs.core", :name "defmulti", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[mm-name & options]"], :doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy", :row 2753} {:end-row 2803, :ns "cljs.core", :name "defmethod", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[multifn dispatch-val & fn-tail]"], :doc "Creates and installs a new method of multimethod associated with dispatch-value. ", :row 2800} {:fixed-arities #{1}, :end-row 2813, :ns "cljs.core", :name "time", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr]"], :doc "Evaluates expr and prints the time it took. Returns the value of expr.", :row 2805} {:end-row 2831, :ns "cljs.core", :name "simple-benchmark", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]"], :doc "Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case.", :row 2815} {:end-row 2833, :filename "cljs/core.cljc", :lang :clj, :name "cs", :ns "cljs.core", :private true, :row 2833} {:fixed-arities #{0 1}, :end-row 2844, :private true, :ns "cljs.core", :name "gen-apply-to-helper", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[]" "[n]"], :row 2835} {:fixed-arities #{0}, :end-row 2854, :ns "cljs.core", :name "gen-apply-to", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 2846} {:fixed-arities #{3}, :end-row 2878, :private true, :ns "cljs.core", :name "gen-apply-to-simple-helper", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[f num-args args]"], :row 2856} {:fixed-arities #{3}, :end-row 2882, :ns "cljs.core", :name "gen-apply-to-simple", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[f num-args args]"], :row 2880} {:end-row 2893, :ns "cljs.core", :name "with-out-str", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls.", :row 2884} {:end-row 2902, :ns "cljs.core", :name "lazy-cat", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& colls]"], :doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", :row 2895} {:fixed-arities #{1}, :end-row 2905, :ns "cljs.core", :name "js-str", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[s]"], :row 2904} {:fixed-arities #{1}, :end-row 2911, :ns "cljs.core", :name "es6-iterable", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[ty]"], :row 2907} {:fixed-arities #{1}, :end-row 2927, :ns "cljs.core", :name "ns-publics", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the public intern mappings for the namespace.", :row 2913} {:fixed-arities #{1}, :end-row 2941, :ns "cljs.core", :name "ns-imports", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the import mappings for the namespace.", :row 2929} {:fixed-arities #{1}, :end-row 2955, :ns "cljs.core", :name "ns-interns", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the intern mappings for the namespace.", :row 2943} {:fixed-arities #{2}, :end-row 2967, :ns "cljs.core", :name "ns-unmap", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns quoted-sym]"], :doc "Removes the mappings for the symbol from the namespace.", :row 2957} {:end-row 2974, :ns "cljs.core", :name "vswap!", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[vol f & args]"], :doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", :row 2969} {:arglist-strs ["[x & forms]"], :end-row 2978, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "locking", :ns "cljs.core", :row 2976} {:fixed-arities #{0}, :end-row 2981, :private true, :ns "cljs.core", :name "ns-special-form", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 2981} {:end-row 3036, :ns "cljs.core", :name "require", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib's name also locates its root directory\n  within classpath using Java's package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace.\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n  :rename specifies a map from referred var names to different\n    symbols (and can be used to prevent clashes)\n\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require '[clojure.string :as string])", :row 2983} {:end-row 3041, :ns "cljs.core", :name "require-macros", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Similar to require but only for macros.", :row 3038} {:end-row 3054, :ns "cljs.core", :name "use", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Like require, but referring vars specified by the mandatory\n  :only option.\n\n  Example:\n\n  The following would load the library clojure.set while referring\n  the intersection var.\n\n  (use '[clojure.set :only [intersection]])", :row 3043} {:end-row 3059, :ns "cljs.core", :name "use-macros", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Similar to use but only for macros.", :row 3056} {:end-row 3068, :ns "cljs.core", :name "import", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& import-symbols-or-lists]"], :doc "import-list => (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", :row 3061} {:end-row 3081, :ns "cljs.core", :name "refer-clojure", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Refers to all the public vars of `cljs.core`, subject to\n  filters.\n  Filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  Filters can be used to select a subset, via exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent clashes.", :row 3070} {:fixed-arities #{1}, :end-row 3085, :ns "cljs.core", :name "load-file*", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[f]"], :row 3084} {:fixed-arities #{1}, :end-row 3096, :ns "cljs.core", :name "macroexpand-1", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted]"], :doc "If form represents a macro form, returns its expansion,\n  else returns form.", :row 3087} {:fixed-arities #{1}, :end-row 3112, :ns "cljs.core", :name "macroexpand", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted]"], :doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", :row 3098} {:fixed-arities #{1}, :end-row 3115, :private true, :ns "cljs.core", :name "multi-arity-fn?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 3114} {:fixed-arities #{1}, :end-row 3119, :private true, :ns "cljs.core", :name "variadic-fn?", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 3117} {:fixed-arities #{3 2}, :end-row 3155, :private true, :ns "cljs.core", :name "variadic-fn*", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[sym method]" "[sym [arglist & body :as method] solo]"], :row 3121} {:fixed-arities #{1}, :end-row 3162, :ns "cljs.core", :name "copy-arguments", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[dest]"], :row 3157} {:fixed-arities #{1}, :end-row 3169, :private true, :ns "cljs.core", :name "elide-implicit-macro-args", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[arglists]"], :row 3164} {:fixed-arities #{4}, :end-row 3199, :private true, :ns "cljs.core", :name "variadic-fn", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[name meta [[arglist & body :as method] :as fdecl] emit-var?]"], :row 3171} {:fixed-arities #{4}, :end-row 3286, :private true, :ns "cljs.core", :name "multi-arity-fn", :lang :clj, :filename "cljs/core.cljc", :arglist-strs ["[name meta fdecl emit-var?]"], :row 3209} {:doc "Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", :end-row 3368, :filename "cljs/core.cljc", :lang :clj, :macro true, :name "defn", :ns "cljs.core", :row 3297} {:end-row 3414, :ns "cljs.core", :name "defmacro", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[&form &env name & args]"], :doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", :row 3373} {:fixed-arities #{1}, :end-row 3435, :ns "cljs.core", :name "resolve", :lang :clj, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-sym]"], :doc "Returns the var to which a symbol will be resolved in the namespace else nil.", :row 3419} {:end-row 117, :ns "cljs.core", :name "->", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x & forms]"], :doc "Threads the expr through the forms. Inserts x as the\n     second item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     second item in second form, etc.", :row 104} {:end-row 133, :ns "cljs.core", :name "->>", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x & forms]"], :doc "Threads the expr through the forms. Inserts x as the\n     last item in the first form, making a list of it if it is not a\n     list already. If there are more forms, inserts the first form as the\n     last item in second form, etc.", :row 120} {:fixed-arities #{2}, :end-row 151, :ns "cljs.core", :name "..", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x form]" "[x form & more]"], :doc "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n     Expands into a member access (.) of the first member on the first\n     argument, followed by the next member on the result, etc. For\n     instance:\n\n     (.. System (getProperties) (get \"os.name\"))\n\n     expands to:\n\n     (. (. System (getProperties)) (get \"os.name\"))\n\n     but is easier to write, read, and understand.", :row 136} {:end-row 156, :ns "cljs.core", :name "comment", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Ignores body, yields nil", :row 154} {:end-row 171, :ns "cljs.core", :name "cond", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& clauses]"], :doc "Takes a set of test/expr pairs. It evaluates each test one at a\n     time.  If a test returns logical true, cond evaluates and returns\n     the value of the corresponding expr and doesn't evaluate any of the\n     other tests or exprs. (cond) returns nil.", :row 159} {:end-row 176, :ns "cljs.core", :name "declare", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& names]"], :doc "defs the supplied var names with no bindings, useful for making forward declarations.", :row 174} {:end-row 192, :ns "cljs.core", :name "doto", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x & forms]"], :doc "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new js/Map) (.set \"a\" 1) (.set \"b\" 2))", :row 178} {:fixed-arities #{1}, :end-row 200, :private true, :ns "cljs.core", :name "parse-impls", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[specs]"], :row 195} {:fixed-arities #{2}, :end-row 208, :private true, :ns "cljs.core", :name "emit-extend-protocol", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[p specs]"], :row 203} {:end-row 247, :ns "cljs.core", :name "extend-protocol", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[p & specs]"], :doc "Useful when you want to provide several implementations of the same\n     protocol all at once. Takes a single protocol and the implementation\n     of that protocol for one or more types. Expands into calls to\n     extend-type:\n\n     (extend-protocol Protocol\n       AType\n         (foo [x] ...)\n         (bar [x y] ...)\n       BType\n         (foo [x] ...)\n         (bar [x y] ...)\n       AClass\n         (foo [x] ...)\n         (bar [x y] ...)\n       nil\n         (foo [x] ...)\n         (bar [x y] ...))\n\n     expands into:\n\n     (do\n      (clojure.core/extend-type AType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type BType Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type AClass Protocol\n        (foo [x] ...)\n        (bar [x y] ...))\n      (clojure.core/extend-type nil Protocol\n        (foo [x] ...)\n        (bar [x y] ...)))", :row 211} {:fixed-arities #{2}, :end-row 266, :private true, :ns "cljs.core", :name "maybe-destructured", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[params body]"], :row 250} {:end-row 330, :ns "cljs.core", :name "fn", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& sigs]"], :doc "params => positional-params* , or positional-params* & rest-param\n     positional-param => binding-form\n     rest-param => binding-form\n     binding-form => name, or destructuring-form\n\n     Defines a function\n\n     See https://clojure.org/reference/special_forms#fn for more information", :row 269} {:end-row 336, :ns "cljs.core", :name "defn-", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & decls]"], :doc "same as defn, yielding non-public def", :row 333} {:fixed-arities #{3 2}, :end-row 356, :ns "cljs.core", :name "if-let", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings then]" "[bindings then else & oldform]"], :doc "bindings => binding-form test\n\n     If test is true, evaluates then with binding-form bound to the value of\n     test, if not, yields else", :row 339} {:fixed-arities #{3 2}, :end-row 364, :ns "cljs.core", :name "if-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[test then]" "[test then else]"], :doc "Evaluates test. If logical false, evaluates and returns then expr,\n     otherwise else expr, if supplied, else nil.", :row 359} {:end-row 378, :ns "cljs.core", :name "letfn", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[fnspecs & body]"], :doc "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n     Takes a vector of function specs and a body, and generates a set of\n     bindings of functions to their names. All of the names are available\n     in all of the definitions of the functions, as well as the body.", :row 367} {:end-row 389, :ns "cljs.core", :name "memfn", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & args]"], :doc "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a JavaScript\n  method as a first-class fn.", :row 380} {:end-row 395, :ns "cljs.core", :name "when", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[test & body]"], :doc "Evaluates test. If logical true, evaluates body in an implicit do.", :row 392} {:end-row 409, :ns "cljs.core", :name "when-first", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => x xs\n\n     Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", :row 398} {:end-row 424, :ns "cljs.core", :name "when-let", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => binding-form test\n\n     When test is true, evaluates body with binding-form bound to the value of test", :row 412} {:end-row 430, :ns "cljs.core", :name "when-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[test & body]"], :doc "Evaluates test. If logical false, evaluates body in an implicit do.", :row 427} {:end-row 440, :ns "cljs.core", :name "while", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[test & body]"], :doc "Repeatedly executes body while test expression is true. Presumes\n     some side-effect will cause test to become false/nil. Returns nil", :row 433} {:end-row 457, :ns "cljs.core", :name "cond->", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & clauses]"], :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n     through each form for which the corresponding test\n     expression is true. Note that, unlike cond branching, cond-> threading does\n     not short circuit after the first true test expression.", :row 443} {:end-row 474, :ns "cljs.core", :name "cond->>", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & clauses]"], :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n     through each form for which the corresponding test expression\n     is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n     after the first true test expression.", :row 460} {:end-row 486, :ns "cljs.core", :name "as->", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr name & forms]"], :doc "Binds name to expr, evaluates the first form in the lexical context\n     of that binding, then binds name to that result, repeating for each\n     successive form, returning the result of the last form.", :row 477} {:end-row 500, :ns "cljs.core", :name "some->", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & forms]"], :doc "When expr is not nil, threads it into the first form (via ->),\n     and when that result is not nil, through the next etc", :row 489} {:end-row 514, :ns "cljs.core", :name "some->>", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & forms]"], :doc "When expr is not nil, threads it into the first form (via ->>),\n     and when that result is not nil, through the next etc", :row 503} {:fixed-arities #{3 2}, :end-row 534, :ns "cljs.core", :name "if-some", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings then]" "[bindings then else & oldform]"], :doc "bindings => binding-form test\n\n      If test is not nil, evaluates then with binding-form bound to the\n      value of test, if not, yields else", :row 517} {:end-row 551, :ns "cljs.core", :name "when-some", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => binding-form test\n\n      When test is not nil, evaluates body with binding-form bound to the\n      value of test", :row 537} {:fixed-arities #{1}, :end-row 590, :private true, :ns "cljs.core", :name "assert-valid-fdecl", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :doc "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.", :row 553} {:fixed-arities #{1}, :end-row 617, :private true, :ns "cljs.core", :name "sigs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 592} {:fixed-arities #{2}, :end-row 627, :ns "cljs.core", :name "defonce", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x init]"], :doc "defs name to have the root value of init iff the named var has no root value,\n  else init is unevaluated", :row 619} {:arglist-strs ["[bindings]"], :end-row 730, :filename "cljs/core.cljc", :fixed-arities #{1}, :lang :cljs, :name "destructure", :ns "cljs.core", :row 629} {:end-row 736, :private true, :ns "cljs.core", :name "return-first", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :row 732} {:fixed-arities #{2}, :end-row 770, :ns "cljs.core", :name "goog-define", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[sym default]"], :doc "Defines a var using `goog.define`. Passed default value must be\n  string, number or boolean.\n\n  Default value can be overridden at compile time using the\n  compiler option `:closure-defines`.\n\n  Example:\n    (ns your-app.core)\n    (goog-define DEBUG! false)\n    ;; can be overridden with\n    :closure-defines {\"your_app.core.DEBUG_BANG_\" true}\n    or\n    :closure-defines {your-app.core/DEBUG! true}", :row 738} {:end-row 787, :ns "cljs.core", :name "let", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => binding-form init-expr\n  binding-form => name, or destructuring-form\n  destructuring-form => map-destructure-form, or seq-destructure-form\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\n\n  See https://clojure.org/reference/special_forms#binding-forms for\n  more information about destructuring.", :row 772} {:end-row 811, :ns "cljs.core", :name "loop", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", :row 789} {:doc "protocol fqn -> [partition number, bit]", :end-row 829, :filename "cljs/core.cljc", :lang :cljs, :name "fast-path-protocols", :ns "cljs.core", :row 813} {:doc "total number of partitions", :end-row 837, :filename "cljs/core.cljc", :lang :cljs, :name "fast-path-protocol-partitions-count", :ns "cljs.core", :row 831} {:fixed-arities #{2}, :end-row 842, :private true, :ns "cljs.core", :name "compatible?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[inferred-tag allowed-tags]"], :row 839} {:fixed-arities #{3}, :end-row 847, :private true, :ns "cljs.core", :name "typed-expr?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env form allowed-tags]"], :row 844} {:fixed-arities #{1}, :end-row 850, :private true, :ns "cljs.core", :name "string-expr", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[e]"], :row 849} {:fixed-arities #{0 1}, :end-row 867, :ns "cljs.core", :name "str", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & ys]"], :row 852} {:fixed-arities #{1}, :end-row 870, :private true, :ns "cljs.core", :name "bool-expr", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[e]"], :row 869} {:fixed-arities #{2}, :end-row 875, :private true, :ns "cljs.core", :name "simple-test-expr?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env ast]"], :row 872} {:fixed-arities #{0 1}, :end-row 886, :ns "cljs.core", :name "and", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", :row 877} {:fixed-arities #{0 1}, :end-row 897, :ns "cljs.core", :name "or", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", :row 888} {:fixed-arities #{1}, :end-row 900, :ns "cljs.core", :name "nil?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 899} {:fixed-arities #{1}, :end-row 903, :ns "cljs.core", :name "some?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 902} {:fixed-arities #{1}, :end-row 906, :ns "cljs.core", :name "coercive-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 905} {:fixed-arities #{2}, :end-row 909, :ns "cljs.core", :name "coercive-not=", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]"], :row 908} {:fixed-arities #{2}, :end-row 912, :ns "cljs.core", :name "coercive-=", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]"], :row 911} {:fixed-arities #{1}, :end-row 916, :ns "cljs.core", :name "coercive-boolean", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 914} {:fixed-arities #{1}, :end-row 921, :ns "cljs.core", :name "truth_", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 919} {:fixed-arities #{0}, :end-row 924, :ns "cljs.core", :name "js-arguments", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 923} {:fixed-arities #{2}, :end-row 927, :ns "cljs.core", :name "js-delete", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key]"], :row 926} {:fixed-arities #{2}, :end-row 930, :ns "cljs.core", :name "js-in", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[key obj]"], :row 929} {:fixed-arities #{0}, :end-row 937, :ns "cljs.core", :name "js-debugger", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :doc "Emit JavaScript \"debugger;\" statement", :row 932} {:fixed-arities #{1}, :end-row 951, :ns "cljs.core", :name "js-comment", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[comment]"], :doc "Emit a top-level JavaScript multi-line comment. New lines will create a\n  new comment line. Comment block will be preceded and followed by a newline", :row 939} {:fixed-arities #{2}, :end-row 957, :ns "cljs.core", :name "unsafe-cast", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[t x]"], :doc "EXPERIMENTAL: Subject to change. Unsafely cast a value to a different type.", :row 953} {:fixed-arities #{1}, :end-row 962, :ns "cljs.core", :name "js-inline-comment", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[comment]"], :doc "Emit an inline JavaScript comment.", :row 959} {:fixed-arities #{1}, :end-row 965, :ns "cljs.core", :name "true?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 964} {:fixed-arities #{1}, :end-row 968, :ns "cljs.core", :name "false?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 967} {:fixed-arities #{1}, :end-row 971, :ns "cljs.core", :name "string?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 970} {:fixed-arities #{1}, :end-row 974, :ns "cljs.core", :name "js-fn?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 973} {:fixed-arities #{1}, :end-row 991, :ns "cljs.core", :name "exists?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :doc "Return true if argument exists, analogous to usage of typeof operator\n   in JavaScript.", :row 976} {:fixed-arities #{1}, :end-row 996, :ns "cljs.core", :name "undefined?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :doc "Return true if argument is identical to the JavaScript undefined value.", :row 993} {:fixed-arities #{2}, :end-row 999, :ns "cljs.core", :name "identical?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a b]"], :row 998} {:fixed-arities #{2}, :end-row 1008, :ns "cljs.core", :name "instance?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[c x]"], :row 1001} {:fixed-arities #{1}, :end-row 1011, :ns "cljs.core", :name "number?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1010} {:fixed-arities #{1}, :end-row 1014, :ns "cljs.core", :name "symbol?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1013} {:fixed-arities #{1}, :end-row 1017, :ns "cljs.core", :name "keyword?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1016} {:fixed-arities #{2}, :end-row 1030, :ns "cljs.core", :name "aget", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[array idx]" "[array idx & idxs]"], :row 1019} {:fixed-arities #{3}, :end-row 1044, :ns "cljs.core", :name "aset", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :row 1032} {:fixed-arities #{2}, :end-row 1051, :ns "cljs.core", :name "unchecked-get", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key]"], :doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :row 1046} {:fixed-arities #{3}, :end-row 1058, :ns "cljs.core", :name "unchecked-set", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[obj key val]"], :doc "INTERNAL. Compiles to JavaScript property access using bracket notation. Does\n  not distinguish between object and array types and not subject to compiler\n  static analysis.", :row 1053} {:fixed-arities #{0 1 2}, :end-row 1064, :ns "cljs.core", :name "+", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :row 1060} {:fixed-arities #{1}, :end-row 1066, :ns "cljs.core", :name "byte", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1066} {:fixed-arities #{1}, :end-row 1067, :ns "cljs.core", :name "short", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1067} {:fixed-arities #{1}, :end-row 1068, :ns "cljs.core", :name "float", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1068} {:fixed-arities #{1}, :end-row 1069, :ns "cljs.core", :name "double", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1069} {:fixed-arities #{1}, :end-row 1071, :ns "cljs.core", :name "unchecked-byte", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1071} {:fixed-arities #{1}, :end-row 1072, :ns "cljs.core", :name "unchecked-char", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1072} {:fixed-arities #{1}, :end-row 1073, :ns "cljs.core", :name "unchecked-short", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1073} {:fixed-arities #{1}, :end-row 1074, :ns "cljs.core", :name "unchecked-float", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1074} {:fixed-arities #{1}, :end-row 1075, :ns "cljs.core", :name "unchecked-double", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1075} {:arglist-strs ["[& xs]"], :end-row 1078, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-add", :ns "cljs.core", :row 1077} {:arglist-strs ["[& xs]"], :end-row 1081, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-add-int", :ns "cljs.core", :row 1080} {:fixed-arities #{1}, :end-row 1084, :ns "cljs.core", :name "unchecked-dec", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1083} {:fixed-arities #{1}, :end-row 1087, :ns "cljs.core", :name "unchecked-dec-int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1086} {:arglist-strs ["[& xs]"], :end-row 1090, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-divide-int", :ns "cljs.core", :row 1089} {:fixed-arities #{1}, :end-row 1093, :ns "cljs.core", :name "unchecked-inc", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1092} {:fixed-arities #{1}, :end-row 1096, :ns "cljs.core", :name "unchecked-inc-int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1095} {:arglist-strs ["[& xs]"], :end-row 1099, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-multiply", :ns "cljs.core", :row 1098} {:arglist-strs ["[& xs]"], :end-row 1102, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-multiply-int", :ns "cljs.core", :row 1101} {:fixed-arities #{1}, :end-row 1105, :ns "cljs.core", :name "unchecked-negate", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1104} {:fixed-arities #{1}, :end-row 1108, :ns "cljs.core", :name "unchecked-negate-int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1107} {:fixed-arities #{2}, :end-row 1111, :ns "cljs.core", :name "unchecked-remainder-int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1110} {:arglist-strs ["[& xs]"], :end-row 1114, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-subtract", :ns "cljs.core", :row 1113} {:arglist-strs ["[& xs]"], :end-row 1117, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "unchecked-subtract-int", :ns "cljs.core", :row 1116} {:fixed-arities #{1 2}, :end-row 1122, :ns "cljs.core", :name "-", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1119} {:fixed-arities #{0 1 2}, :end-row 1128, :ns "cljs.core", :name "*", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :row 1124} {:fixed-arities #{1 2}, :end-row 1133, :ns "cljs.core", :name "/", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1130} {:fixed-arities #{1 2}, :end-row 1138, :ns "cljs.core", :name "divide", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1135} {:fixed-arities #{1 2}, :end-row 1143, :ns "cljs.core", :name "<", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1140} {:fixed-arities #{1 2}, :end-row 1148, :ns "cljs.core", :name "<=", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1145} {:fixed-arities #{1 2}, :end-row 1153, :ns "cljs.core", :name ">", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1150} {:fixed-arities #{1 2}, :end-row 1158, :ns "cljs.core", :name ">=", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1155} {:fixed-arities #{1 2}, :end-row 1163, :ns "cljs.core", :name "==", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1160} {:fixed-arities #{1}, :end-row 1166, :ns "cljs.core", :name "dec", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1165} {:fixed-arities #{1}, :end-row 1169, :ns "cljs.core", :name "inc", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1168} {:fixed-arities #{1}, :end-row 1172, :ns "cljs.core", :name "zero?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1171} {:fixed-arities #{1}, :end-row 1175, :ns "cljs.core", :name "pos?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1174} {:fixed-arities #{1}, :end-row 1178, :ns "cljs.core", :name "neg?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1177} {:fixed-arities #{1 2}, :end-row 1184, :ns "cljs.core", :name "max", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1180} {:fixed-arities #{1 2}, :end-row 1190, :ns "cljs.core", :name "min", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x y]" "[x y & more]"], :row 1186} {:fixed-arities #{2}, :end-row 1193, :ns "cljs.core", :name "js-mod", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[num div]"], :row 1192} {:fixed-arities #{1}, :end-row 1196, :ns "cljs.core", :name "bit-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1195} {:fixed-arities #{2}, :end-row 1200, :ns "cljs.core", :name "bit-and", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1198} {:fixed-arities #{2}, :end-row 1205, :ns "cljs.core", :name "unsafe-bit-and", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1203} {:fixed-arities #{2}, :end-row 1209, :ns "cljs.core", :name "bit-or", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1207} {:fixed-arities #{1}, :end-row 1212, :ns "cljs.core", :name "int", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 1211} {:fixed-arities #{2}, :end-row 1216, :ns "cljs.core", :name "bit-xor", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1214} {:fixed-arities #{2}, :end-row 1220, :ns "cljs.core", :name "bit-and-not", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x y]" "[x y & more]"], :row 1218} {:fixed-arities #{2}, :end-row 1223, :ns "cljs.core", :name "bit-clear", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1222} {:fixed-arities #{2}, :end-row 1226, :ns "cljs.core", :name "bit-flip", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1225} {:fixed-arities #{2}, :end-row 1229, :ns "cljs.core", :name "bit-test", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1228} {:fixed-arities #{2}, :end-row 1232, :ns "cljs.core", :name "bit-shift-left", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1231} {:fixed-arities #{2}, :end-row 1235, :ns "cljs.core", :name "bit-shift-right", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1234} {:fixed-arities #{2}, :end-row 1238, :ns "cljs.core", :name "bit-shift-right-zero-fill", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1237} {:fixed-arities #{2}, :end-row 1241, :ns "cljs.core", :name "unsigned-bit-shift-right", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1240} {:fixed-arities #{2}, :end-row 1244, :ns "cljs.core", :name "bit-set", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x n]"], :row 1243} {:fixed-arities #{2}, :end-row 1248, :ns "cljs.core", :name "mask", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[hash shift]"], :row 1247} {:fixed-arities #{2}, :end-row 1252, :ns "cljs.core", :name "bitpos", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[hash shift]"], :row 1251} {:fixed-arities #{3}, :end-row 1262, :ns "cljs.core", :name "caching-hash", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[coll hash-fn hash-key]"], :row 1255} {:fixed-arities #{5}, :end-row 1271, :private true, :ns "cljs.core", :name "do-curried", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[name doc meta args body]"], :row 1266} {:end-row 1277, :private true, :ns "cljs.core", :name "defcurried", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name doc meta args & body]"], :doc "Builds another arity of the fn that returns a fn awaiting the last\n  param", :row 1273} {:fixed-arities #{3}, :end-row 1288, :private true, :ns "cljs.core", :name "do-rfn", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[f1 k fkv]"], :row 1279} {:fixed-arities #{2}, :end-row 1293, :private true, :ns "cljs.core", :name "rfn", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[[f1 k] fkv]"], :doc "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.", :row 1290} {:fixed-arities #{1}, :end-row 1301, :private true, :ns "cljs.core", :name "protocol-prefix", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[psym]"], :row 1297} {:end-row 1311, :filename "cljs/core.cljc", :lang :cljs, :name "base-type", :ns "cljs.core", :private true, :row 1303} {:end-row 1319, :filename "cljs/core.cljc", :lang :cljs, :name "js-base-type", :ns "cljs.core", :private true, :row 1313} {:end-row 1380, :ns "cljs.core", :name "reify", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& impls]"], :doc "reify creates an object implementing a protocol.\n  reify is a macro with the following structure:\n\n (reify options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of the protocol name followed by zero\n  or more method bodies:\n\n  protocol\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for Object methods. Note that\n  the first parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls\n  to the method head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n\n  (str (let [f \"foo\"]\n       (reify Object\n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"]\n       (reify ISeqable\n         (-seq [this] (seq f)))))\n  == (\"f\" \"o\" \"o\"))\n\n  reify always implements IMeta and IWithMeta and transfers meta\n  data of the form to the created object.\n\n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", :row 1321} {:end-row 1388, :ns "cljs.core", :name "specify!", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & impls]"], :doc "Identical to reify but mutates its first argument.", :row 1382} {:end-row 1395, :ns "cljs.core", :name "specify", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr & impls]"], :doc "Identical to specify! but does not mutate its first argument. The first\n  argument must be an ICloneable instance.", :row 1390} {:fixed-arities #{0}, :end-row 1398, :private true, :ns "cljs.core", :name "js-this", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 1397} {:end-row 1404, :ns "cljs.core", :name "this-as", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[name & body]"], :doc "Defines a scope where JavaScript's implicit \"this\" is bound to the name provided.", :row 1400} {:fixed-arities #{1}, :end-row 1407, :private true, :ns "cljs.core", :name "to-property", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[sym]"], :row 1406} {:fixed-arities #{3}, :end-row 1425, :private true, :ns "cljs.core", :name "update-protocol-var", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[p type env]"], :row 1409} {:fixed-arities #{2}, :end-row 1430, :private true, :ns "cljs.core", :name "resolve-var", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env sym]"], :row 1427} {:fixed-arities #{1}, :end-row 1437, :private true, :ns "cljs.core", :name "->impl-map", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[impls]"], :row 1432} {:fixed-arities #{5}, :end-row 1448, :private true, :ns "cljs.core", :name "base-assign-impls", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env resolve tsym type [p sigs]]"], :row 1439} {:end-row 1450, :filename "cljs/core.cljc", :lang :cljs, :name "extend-prefix", :ns "cljs.core", :private true, :row 1450} {:fixed-arities #{2}, :end-row 1461, :private true, :ns "cljs.core", :name "adapt-obj-params", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1459} {:fixed-arities #{2}, :end-row 1468, :private true, :ns "cljs.core", :name "adapt-ifn-params", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1463} {:fixed-arities #{2}, :end-row 1474, :private true, :ns "cljs.core", :name "adapt-ifn-invoke-params", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1471} {:fixed-arities #{2}, :end-row 1480, :private true, :ns "cljs.core", :name "adapt-proto-params", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type [[this & args :as sig] & body]]"], :row 1476} {:fixed-arities #{3}, :end-row 1489, :private true, :ns "cljs.core", :name "add-obj-methods", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym sigs]"], :row 1482} {:fixed-arities #{3}, :end-row 1497, :private true, :ns "cljs.core", :name "ifn-invoke-methods", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym [f & meths :as form]]"], :row 1491} {:fixed-arities #{3}, :end-row 1518, :private true, :ns "cljs.core", :name "add-ifn-methods", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type type-sym [f & meths :as form]]"], :row 1499} {:fixed-arities #{4}, :end-row 1530, :private true, :ns "cljs.core", :name "add-proto-methods*", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[pprefix type type-sym [f & meths :as form]]"], :row 1520} {:fixed-arities #{5}, :end-row 1547, :private true, :ns "cljs.core", :name "proto-assign-impls", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env resolve type-sym type [p sigs]]"], :row 1532} {:fixed-arities #{3}, :end-row 1577, :private true, :ns "cljs.core", :name "validate-impl-sigs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env p method]"], :row 1549} {:fixed-arities #{2}, :end-row 1595, :private true, :ns "cljs.core", :name "validate-impls", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env impls]"], :row 1579} {:fixed-arities #{2}, :end-row 1599, :private true, :ns "cljs.core", :name "type-hint-first-arg", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym argv]"], :row 1597} {:fixed-arities #{2}, :end-row 1603, :private true, :ns "cljs.core", :name "type-hint-single-arity-sig", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1601} {:fixed-arities #{2}, :end-row 1607, :private true, :ns "cljs.core", :name "type-hint-multi-arity-sig", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1605} {:fixed-arities #{2}, :end-row 1611, :private true, :ns "cljs.core", :name "type-hint-multi-arity-sigs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sigs]"], :row 1609} {:fixed-arities #{2}, :end-row 1617, :private true, :ns "cljs.core", :name "type-hint-sigs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym sig]"], :row 1613} {:fixed-arities #{2}, :end-row 1623, :private true, :ns "cljs.core", :name "type-hint-impl-map", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[type-sym impl-map]"], :row 1619} {:end-row 1665, :ns "cljs.core", :name "extend-type", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[type-sym & impls]"], :doc "Extend a type to a series of protocols. Useful when you are\n  supplying the definitions explicitly inline. Propagates the\n  type as a type hint on the first argument of all fns.\n\n  type-sym may be\n\n   * default, meaning the definitions will apply for any value,\n     unless an extend-type exists for one of the more specific\n     cases below.\n   * nil, meaning the definitions will apply for the nil value.\n   * any of object, boolean, number, string, array, or function,\n     indicating the definitions will apply for values of the\n     associated base JavaScript types. Note that, for example,\n     string should be used instead of js/String.\n   * a JavaScript type not covered by the previous list, such\n     as js/RegExp.\n   * a type defined by deftype or defrecord.\n\n  (extend-type MyType\n    ICounted\n    (-count [c] ...)\n    Foo\n    (bar [x y] ...)\n    (baz ([x] ...) ([x y] ...) ...)", :row 1625} {:fixed-arities #{2}, :end-row 1687, :private true, :ns "cljs.core", :name "prepare-protocol-masks", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env impls]"], :row 1667} {:fixed-arities #{3}, :end-row 1692, :private true, :ns "cljs.core", :name "annotate-specs", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[annots v [f sigs]]"], :row 1689} {:arglist-strs ["[type specs fields]" "[type specs fields inline]"], :end-row 1709, :filename "cljs/core.cljc", :fixed-arities #{4 3}, :lang :cljs, :name "dt->et", :ns "cljs.core", :row 1694} {:fixed-arities #{2}, :end-row 1715, :private true, :ns "cljs.core", :name "collect-protocols", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[impls env]"], :row 1711} {:fixed-arities #{3}, :end-row 1726, :private true, :ns "cljs.core", :name "build-positional-factory", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[rsym rname fields]"], :row 1717} {:fixed-arities #{3}, :end-row 1733, :private true, :ns "cljs.core", :name "validate-fields", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[case name fields]"], :row 1728} {:end-row 1803, :ns "cljs.core", :name "deftype", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[t fields & impls]"], :doc "(deftype name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The type will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :mutable true at which point (set! afield aval) will be\n  supported in method bodies. Note well that mutable fields are extremely\n  difficult to use correctly, and are present only to facilitate the building\n  of higherlevel constructs, such as ClojureScript's reference types, in\n  ClojureScript itself. They are for experts only - if the semantics and\n  implications of :mutable are not immediately apparent to you, you should not\n  be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for methods of Object. Note that\n  a parameter must be supplied to correspond to the target object\n  ('this' in JavaScript parlance). Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta and __extmap are currently reserved and\n  should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", :row 1735} {:fixed-arities #{5}, :end-row 1910, :private true, :ns "cljs.core", :name "emit-defrecord", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env tagname rname fields impls]"], :doc "Do not use this directly - use defrecord", :row 1805} {:fixed-arities #{3}, :end-row 1922, :private true, :ns "cljs.core", :name "build-map-factory", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[rsym rname fields]"], :row 1912} {:end-row 1991, :ns "cljs.core", :name "defrecord", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[rsym fields & impls]"], :doc "(defrecord name [fields*]  options* specs*)\n\n  Currently there are no options.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-Object\n  (methodName [args*] body)*\n\n  The record will have the (immutable) fields named by\n  fields, which can have type hints. Protocols and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in JavaScript parlance). Note also\n  that recur calls to the method head should *not* pass the target object, it\n  will be supplied automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The type will have implementations of several ClojureScript\n  protocol generated automatically: IMeta/IWithMeta (metadata support) and\n  IMap, etc.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will define ClojureScript IHash and IEquiv.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta\n  and __extmap are currently reserved and should not be used when\n  defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", :row 1924} {:end-row 2177, :ns "cljs.core", :name "defprotocol", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym & doc+methods]"], :doc "A protocol is a named set of named methods and their signatures:\n\n  (defprotocol AProtocolName\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in\n  JavaScript parlance). defprotocol is dynamic, has no special compile-time\n  effect, and defines no new types.\n\n  (defprotocol P\n    (foo [this])\n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c]\n    P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n\n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo\n    (let [x 42]\n      (reify P\n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", :row 1993} {:fixed-arities #{2}, :end-row 2203, :ns "cljs.core", :name "implements?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym x]"], :doc "EXPERIMENTAL", :row 2179} {:fixed-arities #{2}, :end-row 2235, :ns "cljs.core", :name "satisfies?", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[psym x]"], :doc "Returns true if x satisfies the protocol", :row 2205} {:end-row 2243, :ns "cljs.core", :name "lazy-seq", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a ISeqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls.", :row 2237} {:end-row 2251, :ns "cljs.core", :name "delay", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls.", :row 2245} {:end-row 2275, :ns "cljs.core", :name "with-redefs", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its var.  After the body is\n  executed, the root values of all the vars will be set back to their\n  old values. Useful for mocking out functions during testing.", :row 2253} {:end-row 2288, :ns "cljs.core", :name "binding", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", :row 2277} {:end-row 2329, :ns "cljs.core", :name "condp", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[pred expr & clauses]"], :doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an Error is thrown.", :row 2290} {:fixed-arities #{4}, :end-row 2346, :private true, :ns "cljs.core", :name "assoc-test", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[m test expr env]"], :row 2331} {:fixed-arities #{2}, :end-row 2351, :private true, :ns "cljs.core", :name "const?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[env x]"], :row 2348} {:end-row 2422, :ns "cljs.core", :name "case", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[e & clauses]"], :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an Error is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (ClojureScript) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", :row 2353} {:fixed-arities #{1}, :end-row 2425, :private true, :ns "cljs.core", :name "when-assert", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]"], :row 2424} {:fixed-arities #{1 2}, :end-row 2438, :ns "cljs.core", :name "assert", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[x]" "[x message]"], :doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.", :row 2427} {:fixed-arities #{2}, :end-row 2525, :ns "cljs.core", :name "for", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[seq-exprs body-expr]"], :doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)]  [x y]))", :row 2440} {:end-row 2581, :ns "cljs.core", :name "doseq", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[seq-exprs & body]"], :doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", :row 2527} {:arglist-strs ["[& rest]"], :end-row 2590, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "array", :ns "cljs.core", :row 2583} {:fixed-arities #{1 2}, :end-row 2608, :ns "cljs.core", :name "make-array", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[size]" "[type size]" "[type size & more-sizes]"], :row 2592} {:fixed-arities #{0 1}, :end-row 2617, :ns "cljs.core", :name "list", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[x]" "[x & xs]"], :row 2610} {:fixed-arities #{0}, :end-row 2628, :ns "cljs.core", :name "vector", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& xs]"], :row 2619} {:fixed-arities #{0}, :end-row 2638, :ns "cljs.core", :name "array-map", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& kvs]"], :row 2630} {:fixed-arities #{0}, :end-row 2651, :ns "cljs.core", :name "hash-map", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& kvs]"], :row 2640} {:fixed-arities #{0}, :end-row 2665, :ns "cljs.core", :name "hash-set", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]" "[& xs]"], :row 2653} {:fixed-arities #{1}, :end-row 2674, :private true, :ns "cljs.core", :name "js-obj*", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[kvs]"], :row 2667} {:arglist-strs ["[& rest]"], :end-row 2694, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "js-obj", :ns "cljs.core", :row 2676} {:fixed-arities #{1}, :end-row 2699, :ns "cljs.core", :name "alength", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a]"], :row 2696} {:fixed-arities #{4}, :end-row 2715, :ns "cljs.core", :name "amap", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a idx ret expr]"], :doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting\n  each element of ret to the evaluation of expr, returning the new\n  array ret.", :row 2701} {:fixed-arities #{5}, :end-row 2727, :ns "cljs.core", :name "areduce", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[a idx ret init expr]"], :doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the\n  evaluation of expr at each step, returning ret.", :row 2717} {:end-row 2741, :ns "cljs.core", :name "dotimes", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings & body]"], :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", :row 2729} {:end-row 2751, :private true, :ns "cljs.core", :name "check-valid-options", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[options & valid-keys]"], :doc "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", :row 2743} {:end-row 2798, :ns "cljs.core", :name "defmulti", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[mm-name & options]"], :doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attribute-map are optional.\n\n  Options are key-value pairs and may be one of:\n    :default    the default dispatch value, defaults to :default\n    :hierarchy  the isa? hierarchy to use for dispatching\n                defaults to the global hierarchy", :row 2753} {:end-row 2803, :ns "cljs.core", :name "defmethod", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[multifn dispatch-val & fn-tail]"], :doc "Creates and installs a new method of multimethod associated with dispatch-value. ", :row 2800} {:fixed-arities #{1}, :end-row 2813, :ns "cljs.core", :name "time", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[expr]"], :doc "Evaluates expr and prints the time it took. Returns the value of expr.", :row 2805} {:end-row 2831, :ns "cljs.core", :name "simple-benchmark", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[bindings expr iterations & {:keys [print-fn] :or {print-fn 'println}}]"], :doc "Runs expr iterations times in the context of a let expression with\n  the given bindings, then prints out the bindings and the expr\n  followed by number of iterations and total time. The optional\n  argument print-fn, defaulting to println, sets function used to\n  print the result. expr's string representation will be produced\n  using pr-str in any case.", :row 2815} {:end-row 2833, :filename "cljs/core.cljc", :lang :cljs, :name "cs", :ns "cljs.core", :private true, :row 2833} {:fixed-arities #{0 1}, :end-row 2844, :private true, :ns "cljs.core", :name "gen-apply-to-helper", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[]" "[n]"], :row 2835} {:fixed-arities #{0}, :end-row 2854, :ns "cljs.core", :name "gen-apply-to", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 2846} {:fixed-arities #{3}, :end-row 2878, :private true, :ns "cljs.core", :name "gen-apply-to-simple-helper", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[f num-args args]"], :row 2856} {:fixed-arities #{3}, :end-row 2882, :ns "cljs.core", :name "gen-apply-to-simple", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[f num-args args]"], :row 2880} {:end-row 2893, :ns "cljs.core", :name "with-out-str", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Evaluates exprs in a context in which *print-fn* is bound to .append\n  on a fresh StringBuffer.  Returns the string created by any nested\n  printing calls.", :row 2884} {:end-row 2902, :ns "cljs.core", :name "lazy-cat", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& colls]"], :doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed.\n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", :row 2895} {:fixed-arities #{1}, :end-row 2905, :ns "cljs.core", :name "js-str", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[s]"], :row 2904} {:fixed-arities #{1}, :end-row 2911, :ns "cljs.core", :name "es6-iterable", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[ty]"], :row 2907} {:fixed-arities #{1}, :end-row 2927, :ns "cljs.core", :name "ns-publics", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the public intern mappings for the namespace.", :row 2913} {:fixed-arities #{1}, :end-row 2941, :ns "cljs.core", :name "ns-imports", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the import mappings for the namespace.", :row 2929} {:fixed-arities #{1}, :end-row 2955, :ns "cljs.core", :name "ns-interns", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns]"], :doc "Returns a map of the intern mappings for the namespace.", :row 2943} {:fixed-arities #{2}, :end-row 2967, :ns "cljs.core", :name "ns-unmap", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-ns quoted-sym]"], :doc "Removes the mappings for the symbol from the namespace.", :row 2957} {:end-row 2974, :ns "cljs.core", :name "vswap!", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[vol f & args]"], :doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", :row 2969} {:arglist-strs ["[x & forms]"], :end-row 2978, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "locking", :ns "cljs.core", :row 2976} {:fixed-arities #{0}, :end-row 2981, :private true, :ns "cljs.core", :name "ns-special-form", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[]"], :row 2981} {:end-row 3036, :ns "cljs.core", :name "require", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib or a flag that modifies how all the identified\n  libs are loaded. Use :require in the ns macro in preference to calling this\n  directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of ClojureScript code. Lib names are symbols and each lib is associated\n  with a ClojureScript namespace. A lib's name also locates its root directory\n  within classpath using Java's package name to classpath-relative path mapping.\n  All resources in a lib should be contained in the directory structure under its\n  root directory. All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj. The root\n  resource should contain code to create the lib's namespace (usually by using\n  the ns macro) and load any additional lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :refer takes a list of symbols to refer from the namespace.\n  :refer-macros takes a list of macro symbols to refer from the namespace.\n  :include-macros true causes macros from the namespace to be required.\n  :rename specifies a map from referred var names to different\n    symbols (and can be used to prevent clashes)\n\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the library clojure.string :as string.\n\n  (require '[clojure.string :as string])", :row 2983} {:end-row 3041, :ns "cljs.core", :name "require-macros", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Similar to require but only for macros.", :row 3038} {:end-row 3054, :ns "cljs.core", :name "use", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Like require, but referring vars specified by the mandatory\n  :only option.\n\n  Example:\n\n  The following would load the library clojure.set while referring\n  the intersection var.\n\n  (use '[clojure.set :only [intersection]])", :row 3043} {:end-row 3059, :ns "cljs.core", :name "use-macros", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Similar to use but only for macros.", :row 3056} {:end-row 3068, :ns "cljs.core", :name "import", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& import-symbols-or-lists]"], :doc "import-list => (closure-namespace constructor-name-symbols*)\n\n  For each name in constructor-name-symbols, adds a mapping from name to the\n  constructor named by closure-namespace to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", :row 3061} {:end-row 3081, :ns "cljs.core", :name "refer-clojure", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[& args]"], :doc "Refers to all the public vars of `cljs.core`, subject to\n  filters.\n  Filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  Filters can be used to select a subset, via exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent clashes.", :row 3070} {:fixed-arities #{1}, :end-row 3085, :ns "cljs.core", :name "load-file*", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[f]"], :row 3084} {:fixed-arities #{1}, :end-row 3096, :ns "cljs.core", :name "macroexpand-1", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted]"], :doc "If form represents a macro form, returns its expansion,\n  else returns form.", :row 3087} {:fixed-arities #{1}, :end-row 3112, :ns "cljs.core", :name "macroexpand", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted]"], :doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", :row 3098} {:fixed-arities #{1}, :end-row 3115, :private true, :ns "cljs.core", :name "multi-arity-fn?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 3114} {:fixed-arities #{1}, :end-row 3119, :private true, :ns "cljs.core", :name "variadic-fn?", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[fdecl]"], :row 3117} {:fixed-arities #{3 2}, :end-row 3155, :private true, :ns "cljs.core", :name "variadic-fn*", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[sym method]" "[sym [arglist & body :as method] solo]"], :row 3121} {:fixed-arities #{1}, :end-row 3162, :ns "cljs.core", :name "copy-arguments", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[dest]"], :row 3157} {:fixed-arities #{1}, :end-row 3169, :private true, :ns "cljs.core", :name "elide-implicit-macro-args", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[arglists]"], :row 3164} {:fixed-arities #{4}, :end-row 3199, :private true, :ns "cljs.core", :name "variadic-fn", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[name meta [[arglist & body :as method] :as fdecl] emit-var?]"], :row 3171} {:fixed-arities #{4}, :end-row 3286, :private true, :ns "cljs.core", :name "multi-arity-fn", :lang :cljs, :filename "cljs/core.cljc", :arglist-strs ["[name meta fdecl emit-var?]"], :row 3209} {:doc "Same as (def name (core/fn [params* ] exprs*)) or (def\n    name (core/fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", :end-row 3368, :filename "cljs/core.cljc", :lang :cljs, :macro true, :name "defn", :ns "cljs.core", :row 3297} {:end-row 3414, :ns "cljs.core", :name "defmacro", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[&form &env name & args]"], :doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", :row 3373} {:fixed-arities #{1}, :end-row 3435, :ns "cljs.core", :name "resolve", :lang :cljs, :filename "cljs/core.cljc", :macro true, :arglist-strs ["[quoted-sym]"], :doc "Returns the var to which a symbol will be resolved in the namespace else nil.", :row 3419} {:end-row 19, :filename "cljs/core.cljs", :name "*clojurescript-version*", :ns "cljs.core", :row 19} {:end-row 26, :filename "cljs/core.cljs", :name "*unchecked-if*", :ns "cljs.core", :row 26} {:end-row 30, :filename "cljs/core.cljs", :name "*unchecked-arrays*", :ns "cljs.core", :row 30} {:end-row 33, :filename "cljs/core.cljs", :name "*warn-on-infer*", :ns "cljs.core", :row 33} {:end-row 37, :filename "cljs/core.cljs", :name "PROTOCOL_SENTINEL", :ns "cljs.core", :row 37} {:end-row 39, :filename "cljs/core.cljs", :name "MODULE_URIS", :ns "cljs.core", :row 39} {:end-row 40, :filename "cljs/core.cljs", :name "MODULE_INFOS", :ns "cljs.core", :row 40} {:doc "Var bound to the name value of the compiler build :target option.\n  For example, if the compiler build :target is :nodejs, *target* will be bound\n  to \"nodejs\". *target* is a Google Closure define and can be set by compiler\n  :closure-defines option.", :end-row 48, :filename "cljs/core.cljs", :name "*target*", :ns "cljs.core", :row 42} {:doc "Manually set the JavaScript global context. Only \"window\", \"self\"\n  , and \"global\" supported. ", :end-row 54, :filename "cljs/core.cljs", :name "*global*", :ns "cljs.core", :row 50} {:doc "Var bound to the current namespace. Only used for bootstrapping.", :end-row 60, :filename "cljs/core.cljs", :name "*ns*", :ns "cljs.core", :row 56} {:end-row 65, :filename "cljs/core.cljs", :name "*out*", :ns "cljs.core", :row 62} {:end-row 69, :filename "cljs/core.cljs", :name "*assert*", :ns "cljs.core", :row 67} {:doc "Each runtime environment provides a different way to print output.\n  Whatever function *print-fn* is bound to will be passed any\n  Strings which should be printed.", :end-row 75, :filename "cljs/core.cljs", :name "*print-fn*", :ns "cljs.core", :row 71} {:end-row 77, :filename "cljs/core.cljs", :name "boolean", :ns "cljs.core", :row 77} {:arglist-strs ["[f]"], :doc "Arranges to have tap functions executed via the supplied f, a\n  function of no arguments. Returns true if successful, false otherwise.", :end-row 86, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "*exec-tap-fn*", :ns "cljs.core", :row 79} {:doc "Each runtime environment provides a different way to print error output.\n  Whatever function *print-err-fn* is bound to will be passed any\n  Strings which should be printed.", :end-row 92, :filename "cljs/core.cljs", :name "*print-err-fn*", :ns "cljs.core", :row 88} {:arglist-strs ["[f]"], :doc "Set *print-fn* to f.", :end-row 96, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set-print-fn!", :ns "cljs.core", :row 94} {:arglist-strs ["[f]"], :doc "Set *print-err-fn* to f.", :end-row 100, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set-print-err-fn!", :ns "cljs.core", :row 98} {:doc "When set to true, output will be flushed whenever a newline is printed.\n\n  Defaults to true.", :end-row 107, :filename "cljs/core.cljs", :name "*flush-on-newline*", :ns "cljs.core", :row 102} {:doc "When set to logical false will drop newlines from printing calls.\n  This is to work around the implicit newlines emitted by standard JavaScript\n  console objects.", :end-row 114, :filename "cljs/core.cljs", :name "*print-newline*", :ns "cljs.core", :row 109} {:doc "When set to logical false, strings and characters will be printed with\n  non-alphanumeric characters converted to the appropriate escape sequences.\n\n  Defaults to true", :end-row 122, :filename "cljs/core.cljs", :name "*print-readably*", :ns "cljs.core", :row 116} {:doc "If set to logical true, when printing an object, its metadata will also\n  be printed in a form that can be read back by the reader.\n\n  Defaults to false.", :end-row 130, :filename "cljs/core.cljs", :name "*print-meta*", :ns "cljs.core", :row 124} {:doc "When set to logical true, objects will be printed in a way that preserves\n  their type when read in later.\n\n  Defaults to false.", :end-row 138, :filename "cljs/core.cljs", :name "*print-dup*", :ns "cljs.core", :row 132} {:doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax.\n\n  Defaults to false, but the REPL binds it to true.", :end-row 146, :filename "cljs/core.cljs", :name "*print-namespace-maps*", :ns "cljs.core", :row 140} {:doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", :end-row 158, :filename "cljs/core.cljs", :name "*print-length*", :ns "cljs.core", :row 148} {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :end-row 171, :filename "cljs/core.cljs", :name "*print-level*", :ns "cljs.core", :row 160} {:doc "*print-fns-bodies* controls whether functions print their source or\n    only their names.", :end-row 177, :filename "cljs/core.cljs", :name "*print-fn-bodies*", :ns "cljs.core", :row 173} {:end-row 182, :filename "cljs/core.cljs", :name "*loaded-libs*", :ns "cljs.core", :row 179} {:arglist-strs ["[]"], :end-row 189, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "pr-opts", :ns "cljs.core", :private true, :row 184} {:end-row 191, :filename "cljs/core.cljs", :name "into-array", :ns "cljs.core", :row 191} {:arglist-strs ["[]"], :doc "Set *print-fn* to console.log", :end-row 205, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "enable-console-print!", :ns "cljs.core", :row 193} {:doc "bound in a repl thread to the most recent value printed", :end-row 209, :filename "cljs/core.cljs", :name "*1", :ns "cljs.core", :row 207} {:doc "bound in a repl thread to the second most recent value printed", :end-row 213, :filename "cljs/core.cljs", :name "*2", :ns "cljs.core", :row 211} {:doc "bound in a repl thread to the third most recent value printed", :end-row 217, :filename "cljs/core.cljs", :name "*3", :ns "cljs.core", :row 215} {:doc "bound in a repl thread to the most recent exception caught by the repl", :end-row 221, :filename "cljs/core.cljs", :name "*e", :ns "cljs.core", :row 219} {:arglist-strs ["[x]"], :doc "Internal - do not use!", :end-row 226, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "truth_", :ns "cljs.core", :row 223} {:end-row 228, :filename "cljs/core.cljs", :name "not-native", :ns "cljs.core", :row 228} {:end-row 230, :filename "cljs/core.cljs", :name "instance?", :ns "cljs.core", :row 230} {:end-row 230, :filename "cljs/core.cljs", :name "Keyword", :ns "cljs.core", :row 230} {:arglist-strs ["[x y]"], :doc "Tests if 2 arguments are the same object", :end-row 235, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "identical?", :ns "cljs.core", :row 232} {:arglist-strs ["[x]"], :doc "Returns true if x is nil, false otherwise.", :end-row 240, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "nil?", :ns "cljs.core", :row 237} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript array.", :end-row 247, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "array?", :ns "cljs.core", :row 242} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript number.", :end-row 252, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "number?", :ns "cljs.core", :row 249} {:arglist-strs ["[x]"], :doc "Returns true if x is logical false, false otherwise.", :end-row 260, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "not", :ns "cljs.core", :row 254} {:arglist-strs ["[x]"], :doc "Returns true if x is not nil, false otherwise.", :end-row 264, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "some?", :ns "cljs.core", :row 262} {:arglist-strs ["[x]"], :doc "Returns true if x's constructor is Object", :end-row 271, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "object?", :ns "cljs.core", :row 266} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript string.", :end-row 276, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "string?", :ns "cljs.core", :row 273} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript string of length one.", :end-row 281, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "char?", :ns "cljs.core", :row 278} {:arglist-strs ["[x]"], :doc "Returns true if given any argument.", :end-row 285, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "any?", :ns "cljs.core", :row 283} {:arglist-strs ["[p x]"], :doc "Internal - do not use!", :end-row 295, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "native-satisfies?", :ns "cljs.core", :row 288} {:arglist-strs ["[x]"], :end-row 300, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "is_proto_", :ns "cljs.core", :row 298} {:doc "When compiled for a command-line target, whatever function\n  *main-cli-fn* is set to will be called with the command-line\n  argv as arguments", :end-row 306, :filename "cljs/core.cljs", :name "*main-cli-fn*", :ns "cljs.core", :row 302} {:doc "A sequence of the supplied command line arguments, or nil if\n  none were supplied", :end-row 311, :filename "cljs/core.cljs", :name "*command-line-args*", :ns "cljs.core", :row 308} {:arglist-strs ["[x]"], :doc "Return x's constructor.", :end-row 317, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "type", :ns "cljs.core", :row 313} {:arglist-strs ["[proto obj]"], :end-row 326, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "missing-protocol", :ns "cljs.core", :row 319} {:arglist-strs ["[ty]"], :end-row 331, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "type->str", :ns "cljs.core", :row 328} {:arglist-strs ["[file]"], :end-row 336, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "load-file", :ns "cljs.core", :row 334} {:end-row 340, :filename "cljs/core.cljs", :name "ITER_SYMBOL", :ns "cljs.core", :row 340} {:end-row 341, :filename "cljs/core.cljs", :name "ITER_SYMBOL", :ns "cljs.core", :row 341} {:end-row 368, :filename "cljs/core.cljs", :name "CHAR_MAP", :ns "cljs.core", :row 343} {:end-row 395, :filename "cljs/core.cljs", :name "DEMUNGE_MAP", :ns "cljs.core", :row 370} {:end-row 397, :filename "cljs/core.cljs", :name "DEMUNGE_PATTERN", :ns "cljs.core", :row 397} {:arglist-strs ["[]"], :doc "Returns highest resolution time offered by host in milliseconds.", :end-row 412, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "system-time", :ns "cljs.core", :row 399} {:end-row 416, :filename "cljs/core.cljs", :name "apply", :ns "cljs.core", :row 416} {:arglist-strs ["[size]" "[type size]" "[type size & more-sizes]"], :doc "Construct a JavaScript array of the specified dimensions. Accepts ignored\n  type argument for compatibility with Clojure. Note that there is no efficient\n  way to allocate multi-dimensional arrays in JavaScript; as such, this function\n  will run in polynomial time when called with 3 or more arguments.", :end-row 432, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "make-array", :ns "cljs.core", :row 418} {:arglist-strs ["[arr]"], :doc "Returns a javascript array, cloned from the passed in array", :end-row 441, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "aclone", :ns "cljs.core", :row 434} {:arglist-strs ["[var-args]"], :doc "Creates a new javascript array.\n@param {...*} var_args", :end-row 453, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "array", :ns "cljs.core", :row 443} {:arglist-strs ["[e]"], :end-row 458, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "maybe-warn", :ns "cljs.core", :private true, :row 455} {:arglist-strs ["[array idx]" "[array idx & idxs]"], :end-row 472, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "checked-aget", :ns "cljs.core", :private true, :row 460} {:arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :end-row 486, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "checked-aset", :ns "cljs.core", :private true, :row 474} {:arglist-strs ["[array idx]" "[array idx & idxs]"], :end-row 494, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "checked-aget'", :ns "cljs.core", :private true, :row 488} {:arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :end-row 502, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "checked-aset'", :ns "cljs.core", :private true, :row 496} {:arglist-strs ["[array idx]" "[array idx & idxs]"], :doc "Returns the value at the index/indices. Works on JavaScript arrays.", :end-row 509, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "aget", :ns "cljs.core", :row 504} {:arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :doc "Sets the value at the index/indices. Works on JavaScript arrays.\n  Returns val.", :end-row 517, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "aset", :ns "cljs.core", :row 511} {:arglist-strs ["[array]"], :doc "Returns the length of the array. Works on arrays of all types.", :end-row 522, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "alength", :ns "cljs.core", :row 519} {:end-row 524, :filename "cljs/core.cljs", :name "reduce", :ns "cljs.core", :row 524} {:arglist-strs ["[aseq]" "[type aseq]"], :doc "Returns an array with components set to the values in aseq. Optional type\n  argument accepted for compatibility with Clojure.", :end-row 532, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "into-array", :ns "cljs.core", :row 526} {:arglist-strs ["[obj s & args]"], :doc "Invoke JavaScript object method via string. Needed when the\n  string is not a valid unquoted property name.", :end-row 538, :filename "cljs/core.cljs", :name "js-invoke", :ns "cljs.core", :row 534} {:arglist-strs ["[x]"], :doc "Returns true if x is an instance of Symbol", :end-row 545, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js-symbol?", :ns "cljs.core", :row 540} {:doc "Marker protocol", :end-row 550, :filename "cljs/core.cljs", :name "Fn", :ns "cljs.core", :row 549} {:doc "Protocol for adding the ability to invoke an object as a function.\n  For example, a vector can also be used to look up a value:\n  ([1 2 3 4] 1) => 2", :end-row 578, :filename "cljs/core.cljs", :name "IFn", :ns "cljs.core", :row 552} {:arglist-strs ["[this]" "[this a]" "[this a b]" "[this a b c]" "[this a b c d]" "[this a b c d e]" "[this a b c d e f]" "[this a b c d e f g]" "[this a b c d e f g h]" "[this a b c d e f g h i]" "[this a b c d e f g h i j]" "[this a b c d e f g h i j k]" "[this a b c d e f g h i j k l]" "[this a b c d e f g h i j k l m]" "[this a b c d e f g h i j k l m n]" "[this a b c d e f g h i j k l m n o]" "[this a b c d e f g h i j k l m n o p]" "[this a b c d e f g h i j k l m n o p q]" "[this a b c d e f g h i j k l m n o p q r]" "[this a b c d e f g h i j k l m n o p q r s]" "[this a b c d e f g h i j k l m n o p q r s t]" "[this a b c d e f g h i j k l m n o p q r s t rest]"], :end-row 578, :filename "cljs/core.cljs", :fixed-arities #{7 20 1 4 15 21 13 22 6 17 3 12 2 19 11 9 5 14 16 10 18 8}, :name "-invoke", :ns "cljs.core", :row 556} {:doc "Protocol for cloning a value.", :end-row 583, :filename "cljs/core.cljs", :name "ICloneable", :ns "cljs.core", :row 580} {:arglist-strs ["[value]"], :doc "Creates a clone of value.", :end-row 583, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-clone", :ns "cljs.core", :row 582} {:doc "Protocol for adding the ability to count a collection in constant time.", :end-row 588, :filename "cljs/core.cljs", :name "ICounted", :ns "cljs.core", :row 585} {:arglist-strs ["[coll]"], :doc "Calculates the count of coll in constant time. Used by cljs.core/count.", :end-row 588, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-count", :ns "cljs.core", :row 587} {:doc "Protocol for creating an empty collection.", :end-row 594, :filename "cljs/core.cljs", :name "IEmptyableCollection", :ns "cljs.core", :row 590} {:arglist-strs ["[coll]"], :doc "Returns an empty collection of the same category as coll. Used\n     by cljs.core/empty.", :end-row 594, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-empty", :ns "cljs.core", :row 592} {:doc "Protocol for adding to a collection.", :end-row 602, :filename "cljs/core.cljs", :name "ICollection", :ns "cljs.core", :row 596} {:arglist-strs ["[coll o]"], :doc "Returns a new collection of coll with o added to it. The new item\n     should be added to the most efficient place, e.g.\n     (conj [1 2 3 4] 5) => [1 2 3 4 5]\n     (conj '(2 3 4 5) 1) => '(1 2 3 4 5)", :end-row 602, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-conj", :ns "cljs.core", :row 598} {:doc "Protocol for collections to provide indexed-based access to their items.", :end-row 611, :filename "cljs/core.cljs", :name "IIndexed", :ns "cljs.core", :row 607} {:arglist-strs ["[coll n]" "[coll n not-found]"], :doc "Returns the value at the index n in the collection coll.\n     Returns not-found if index n is out of bounds and not-found is supplied.", :end-row 611, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-nth", :ns "cljs.core", :row 609} {:doc "Marker protocol indicating an array sequence.", :end-row 614, :filename "cljs/core.cljs", :name "ASeq", :ns "cljs.core", :row 613} {:doc "Protocol for collections to provide access to their items as sequences.", :end-row 624, :filename "cljs/core.cljs", :name "ISeq", :ns "cljs.core", :row 616} {:arglist-strs ["[coll]"], :doc "Returns the first item in the collection coll. Used by cljs.core/first.", :end-row 619, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-first", :ns "cljs.core", :row 618} {:arglist-strs ["[coll]"], :doc "Returns a new collection of coll without the first item. It should\n     always return a seq, e.g.\n     (rest []) => ()\n     (rest nil) => ()", :end-row 624, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-rest", :ns "cljs.core", :row 620} {:doc "Protocol for accessing the next items of a collection.", :end-row 632, :filename "cljs/core.cljs", :name "INext", :ns "cljs.core", :row 626} {:arglist-strs ["[coll]"], :doc "Returns a new collection of coll without the first item. In contrast to\n     rest, it should return nil if there are no more items, e.g.\n     (next []) => nil\n     (next nil) => nil", :end-row 632, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-next", :ns "cljs.core", :row 628} {:doc "Protocol for looking up a value in a data structure.", :end-row 638, :filename "cljs/core.cljs", :name "ILookup", :ns "cljs.core", :row 634} {:arglist-strs ["[o k]" "[o k not-found]"], :doc "Use k to look up a value in o. If not-found is supplied and k is not\n     a valid value that can be used for look up, not-found is returned.", :end-row 638, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-lookup", :ns "cljs.core", :row 636} {:doc "Protocol for adding associativity to collections.", :end-row 647, :filename "cljs/core.cljs", :name "IAssociative", :ns "cljs.core", :row 640} {:arglist-strs ["[coll k]"], :doc "Returns true if k is a key in coll.", :end-row 643, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-contains-key?", :ns "cljs.core", :row 642} {:arglist-strs ["[coll k v]"], :doc "Returns a new collection of coll with a mapping from key k to\n     value v added to it.", :end-row 647, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-assoc", :ns "cljs.core", :row 645} {:doc "Protocol for implementing entry finding in collections.", :end-row 651, :filename "cljs/core.cljs", :name "IFind", :ns "cljs.core", :row 649} {:arglist-strs ["[coll k]"], :doc "Returns the map entry for key, or nil if key not present.", :end-row 651, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-find", :ns "cljs.core", :row 651} {:doc "Protocol for adding mapping functionality to collections.", :end-row 657, :filename "cljs/core.cljs", :name "IMap", :ns "cljs.core", :row 653} {:arglist-strs ["[coll k]"], :doc "Returns a new collection of coll without the mapping for key k.", :end-row 657, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-dissoc", :ns "cljs.core", :row 656} {:doc "Protocol for examining a map entry.", :end-row 664, :filename "cljs/core.cljs", :name "IMapEntry", :ns "cljs.core", :row 659} {:arglist-strs ["[coll]"], :doc "Returns the key of the map entry.", :end-row 662, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-key", :ns "cljs.core", :row 661} {:arglist-strs ["[coll]"], :doc "Returns the value of the map entry.", :end-row 664, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-val", :ns "cljs.core", :row 663} {:doc "Protocol for adding set functionality to a collection.", :end-row 669, :filename "cljs/core.cljs", :name "ISet", :ns "cljs.core", :row 666} {:arglist-strs ["[coll v]"], :doc "Returns a new collection of coll that does not contain v.", :end-row 669, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-disjoin", :ns "cljs.core", :row 668} {:doc "Protocol for collections to provide access to their items as stacks. The top\n  of the stack should be accessed in the most efficient way for the different\n  data structures.", :end-row 679, :filename "cljs/core.cljs", :name "IStack", :ns "cljs.core", :row 671} {:arglist-strs ["[coll]"], :doc "Returns the item from the top of the stack. Is used by cljs.core/peek.", :end-row 676, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-peek", :ns "cljs.core", :row 675} {:arglist-strs ["[coll]"], :doc "Returns a new stack without the item on top of the stack. Is used\n     by cljs.core/pop.", :end-row 679, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-pop", :ns "cljs.core", :row 677} {:doc "Protocol for adding vector functionality to collections.", :end-row 684, :filename "cljs/core.cljs", :name "IVector", :ns "cljs.core", :row 681} {:arglist-strs ["[coll n val]"], :doc "Returns a new vector with value val added at position n.", :end-row 684, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-assoc-n", :ns "cljs.core", :row 683} {:doc "Protocol for adding dereference functionality to a reference.", :end-row 689, :filename "cljs/core.cljs", :name "IDeref", :ns "cljs.core", :row 686} {:arglist-strs ["[o]"], :doc "Returns the value of the reference o.", :end-row 689, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-deref", :ns "cljs.core", :row 688} {:end-row 692, :filename "cljs/core.cljs", :name "IDerefWithTimeout", :ns "cljs.core", :row 691} {:arglist-strs ["[o msec timeout-val]"], :end-row 692, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-deref-with-timeout", :ns "cljs.core", :row 692} {:doc "Protocol for accessing the metadata of an object.", :end-row 697, :filename "cljs/core.cljs", :name "IMeta", :ns "cljs.core", :row 694} {:arglist-strs ["[o]"], :doc "Returns the metadata of object o.", :end-row 697, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-meta", :ns "cljs.core", :row 696} {:doc "Protocol for adding metadata to an object.", :end-row 702, :filename "cljs/core.cljs", :name "IWithMeta", :ns "cljs.core", :row 699} {:arglist-strs ["[o meta]"], :doc "Returns a new object with value of o and metadata meta added to it.", :end-row 702, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-with-meta", :ns "cljs.core", :row 701} {:doc "Protocol for seq types that can reduce themselves.\n  Called by cljs.core/reduce.", :end-row 710, :filename "cljs/core.cljs", :name "IReduce", :ns "cljs.core", :row 704} {:arglist-strs ["[coll f]" "[coll f start]"], :doc "f should be a function of 2 arguments. If start is not supplied,\n     returns the result of applying f to the first 2 items in coll, then\n     applying f to that result and the 3rd item, etc.", :end-row 710, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-reduce", :ns "cljs.core", :row 707} {:doc "Protocol for associative types that can reduce themselves\n  via a function of key and val. Called by cljs.core/reduce-kv.", :end-row 717, :filename "cljs/core.cljs", :name "IKVReduce", :ns "cljs.core", :row 712} {:arglist-strs ["[coll f init]"], :doc "Reduces an associative collection and returns the result. f should be\n     a function that takes three arguments.", :end-row 717, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-kv-reduce", :ns "cljs.core", :row 715} {:doc "Protocol for adding value comparison functionality to a type.", :end-row 722, :filename "cljs/core.cljs", :name "IEquiv", :ns "cljs.core", :row 719} {:arglist-strs ["[o other]"], :doc "Returns true if o and other are equal, false otherwise.", :end-row 722, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-equiv", :ns "cljs.core", :row 721} {:doc "Protocol for adding hashing functionality to a type.", :end-row 727, :filename "cljs/core.cljs", :name "IHash", :ns "cljs.core", :row 724} {:arglist-strs ["[o]"], :doc "Returns the hash code of o.", :end-row 727, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-hash", :ns "cljs.core", :row 726} {:doc "Protocol for adding the ability to a type to be transformed into a sequence.", :end-row 732, :filename "cljs/core.cljs", :name "ISeqable", :ns "cljs.core", :row 729} {:arglist-strs ["[o]"], :doc "Returns a seq of o, or nil if o is empty.", :end-row 732, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-seq", :ns "cljs.core", :row 731} {:doc "Marker interface indicating a persistent collection of sequential items", :end-row 735, :filename "cljs/core.cljs", :name "ISequential", :ns "cljs.core", :row 734} {:doc "Marker interface indicating a persistent list", :end-row 738, :filename "cljs/core.cljs", :name "IList", :ns "cljs.core", :row 737} {:doc "Marker interface indicating a record object", :end-row 741, :filename "cljs/core.cljs", :name "IRecord", :ns "cljs.core", :row 740} {:doc "Protocol for reversing a seq.", :end-row 746, :filename "cljs/core.cljs", :name "IReversible", :ns "cljs.core", :row 743} {:arglist-strs ["[coll]"], :doc "Returns a seq of the items in coll in reversed order.", :end-row 746, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-rseq", :ns "cljs.core", :row 745} {:doc "Protocol for a collection which can represent their items\n  in a sorted manner. ", :end-row 763, :filename "cljs/core.cljs", :name "ISorted", :ns "cljs.core", :row 748} {:arglist-strs ["[coll ascending?]"], :doc "Returns a sorted seq from coll in either ascending or descending order.", :end-row 752, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-sorted-seq", :ns "cljs.core", :row 751} {:arglist-strs ["[coll k ascending?]"], :doc "Returns a sorted seq from coll in either ascending or descending order.\n     If ascending is true, the result should contain all items which are > or >=\n     than k. If ascending is false, the result should contain all items which\n     are < or <= than k, e.g.\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 true) => (3 4 5)\n     (-sorted-seq-from (sorted-set 1 2 3 4 5) 3 false) => (3 2 1)", :end-row 759, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-sorted-seq-from", :ns "cljs.core", :row 753} {:arglist-strs ["[coll entry]"], :doc "Returns the key for entry.", :end-row 761, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-entry-key", :ns "cljs.core", :row 760} {:arglist-strs ["[coll]"], :doc "Returns the comparator for coll.", :end-row 763, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-comparator", :ns "cljs.core", :row 762} {:doc "Protocol for writing. Currently only implemented by StringBufferWriter.", :end-row 770, :filename "cljs/core.cljs", :name "IWriter", :ns "cljs.core", :row 765} {:arglist-strs ["[writer s]"], :doc "Writes s with writer and returns the result.", :end-row 768, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-write", :ns "cljs.core", :row 767} {:arglist-strs ["[writer]"], :doc "Flush writer.", :end-row 770, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-flush", :ns "cljs.core", :row 769} {:doc "The old IPrintable protocol's implementation consisted of building a giant\n   list of strings to concatenate.  This involved lots of concat calls,\n   intermediate vectors, and lazy-seqs, and was very slow in some older JS\n   engines.  IPrintWithWriter implements printing via the IWriter protocol, so it\n   be implemented efficiently in terms of e.g. a StringBuffer append.", :end-row 778, :filename "cljs/core.cljs", :name "IPrintWithWriter", :ns "cljs.core", :row 772} {:arglist-strs ["[o writer opts]"], :end-row 778, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-pr-writer", :ns "cljs.core", :row 778} {:doc "Protocol for types which can have a deferred realization. Currently only\n  implemented by Delay and LazySeq.", :end-row 784, :filename "cljs/core.cljs", :name "IPending", :ns "cljs.core", :row 780} {:arglist-strs ["[x]"], :doc "Returns true if a value for x has been produced, false otherwise.", :end-row 784, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-realized?", :ns "cljs.core", :row 783} {:doc "Protocol for types that can be watched. Currently only implemented by Atom.", :end-row 794, :filename "cljs/core.cljs", :name "IWatchable", :ns "cljs.core", :row 786} {:arglist-strs ["[this oldval newval]"], :doc "Calls all watchers with this, oldval and newval.", :end-row 789, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-notify-watches", :ns "cljs.core", :row 788} {:arglist-strs ["[this key f]"], :doc "Adds a watcher function f to this. Keys must be unique per reference,\n     and can be used to remove the watch with -remove-watch.", :end-row 792, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-add-watch", :ns "cljs.core", :row 790} {:arglist-strs ["[this key]"], :doc "Removes watcher that corresponds to key from this.", :end-row 794, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-remove-watch", :ns "cljs.core", :row 793} {:doc "Protocol for collections which can transformed to transients.", :end-row 799, :filename "cljs/core.cljs", :name "IEditableCollection", :ns "cljs.core", :row 796} {:arglist-strs ["[coll]"], :doc "Returns a new, transient version of the collection, in constant time.", :end-row 799, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-as-transient", :ns "cljs.core", :row 798} {:doc "Protocol for adding basic functionality to transient collections.", :end-row 806, :filename "cljs/core.cljs", :name "ITransientCollection", :ns "cljs.core", :row 801} {:arglist-strs ["[tcoll val]"], :doc "Adds value val to tcoll and returns tcoll.", :end-row 804, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-conj!", :ns "cljs.core", :row 803} {:arglist-strs ["[tcoll]"], :doc "Creates a persistent data structure from tcoll and returns it.", :end-row 806, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-persistent!", :ns "cljs.core", :row 805} {:doc "Protocol for adding associativity to transient collections.", :end-row 812, :filename "cljs/core.cljs", :name "ITransientAssociative", :ns "cljs.core", :row 808} {:arglist-strs ["[tcoll key val]"], :doc "Returns a new transient collection of tcoll with a mapping from key to\n     val added to it.", :end-row 812, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-assoc!", :ns "cljs.core", :row 810} {:doc "Protocol for adding mapping functionality to transient collections.", :end-row 817, :filename "cljs/core.cljs", :name "ITransientMap", :ns "cljs.core", :row 814} {:arglist-strs ["[tcoll key]"], :doc "Returns a new transient collection of tcoll without the mapping for key.", :end-row 817, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-dissoc!", :ns "cljs.core", :row 816} {:doc "Protocol for adding vector functionality to transient collections.", :end-row 824, :filename "cljs/core.cljs", :name "ITransientVector", :ns "cljs.core", :row 819} {:arglist-strs ["[tcoll n val]"], :doc "Returns tcoll with value val added at position n.", :end-row 822, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-assoc-n!", :ns "cljs.core", :row 821} {:arglist-strs ["[tcoll]"], :doc "Returns tcoll with the last item removed from it.", :end-row 824, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-pop!", :ns "cljs.core", :row 823} {:doc "Protocol for adding set functionality to a transient collection.", :end-row 829, :filename "cljs/core.cljs", :name "ITransientSet", :ns "cljs.core", :row 826} {:arglist-strs ["[tcoll v]"], :doc "Returns tcoll without v.", :end-row 829, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-disjoin!", :ns "cljs.core", :row 828} {:doc "Protocol for values that can be compared.", :end-row 835, :filename "cljs/core.cljs", :name "IComparable", :ns "cljs.core", :row 831} {:arglist-strs ["[x y]"], :doc "Returns a negative number, zero, or a positive number when x is logically\n     'less than', 'equal to', or 'greater than' y.", :end-row 835, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-compare", :ns "cljs.core", :row 833} {:doc "Protocol for accessing the items of a chunk.", :end-row 840, :filename "cljs/core.cljs", :name "IChunk", :ns "cljs.core", :row 837} {:arglist-strs ["[coll]"], :doc "Return a new chunk of coll with the first item removed.", :end-row 840, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-drop-first", :ns "cljs.core", :row 839} {:doc "Protocol for accessing a collection as sequential chunks.", :end-row 847, :filename "cljs/core.cljs", :name "IChunkedSeq", :ns "cljs.core", :row 842} {:arglist-strs ["[coll]"], :doc "Returns the first chunk in coll.", :end-row 845, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-chunked-first", :ns "cljs.core", :row 844} {:arglist-strs ["[coll]"], :doc "Return a new collection of coll with the first chunk removed.", :end-row 847, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-chunked-rest", :ns "cljs.core", :row 846} {:doc "Protocol for accessing the chunks of a collection.", :end-row 852, :filename "cljs/core.cljs", :name "IChunkedNext", :ns "cljs.core", :row 849} {:arglist-strs ["[coll]"], :doc "Returns a new collection of coll without the first chunk.", :end-row 852, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-chunked-next", :ns "cljs.core", :row 851} {:doc "Protocol for adding a name.", :end-row 859, :filename "cljs/core.cljs", :name "INamed", :ns "cljs.core", :row 854} {:arglist-strs ["[x]"], :doc "Returns the name String of x.", :end-row 857, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-name", :ns "cljs.core", :row 856} {:arglist-strs ["[x]"], :doc "Returns the namespace String of x.", :end-row 859, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-namespace", :ns "cljs.core", :row 858} {:doc "Marker protocol indicating an atom.", :end-row 862, :filename "cljs/core.cljs", :name "IAtom", :ns "cljs.core", :row 861} {:doc "Protocol for adding resetting functionality.", :end-row 867, :filename "cljs/core.cljs", :name "IReset", :ns "cljs.core", :row 864} {:arglist-strs ["[o new-value]"], :doc "Sets the value of o to new-value.", :end-row 867, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-reset!", :ns "cljs.core", :row 866} {:doc "Protocol for adding swapping functionality.", :end-row 872, :filename "cljs/core.cljs", :name "ISwap", :ns "cljs.core", :row 869} {:arglist-strs ["[o f]" "[o f a]" "[o f a b]" "[o f a b xs]"], :doc "Swaps the value of o to be (apply f current-value-of-atom args).", :end-row 872, :filename "cljs/core.cljs", :fixed-arities #{4 3 2 5}, :name "-swap!", :ns "cljs.core", :row 871} {:doc "Protocol for adding volatile functionality.", :end-row 878, :filename "cljs/core.cljs", :name "IVolatile", :ns "cljs.core", :row 874} {:arglist-strs ["[o new-value]"], :doc "Sets the value of volatile o to new-value without regard for the\n     current value. Returns new-value.", :end-row 878, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-vreset!", :ns "cljs.core", :row 876} {:doc "Protocol for iterating over a collection.", :end-row 883, :filename "cljs/core.cljs", :name "IIterable", :ns "cljs.core", :row 880} {:arglist-strs ["[coll]"], :doc "Returns an iterator for coll.", :end-row 883, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-iterator", :ns "cljs.core", :row 882} {:end-row 890, :filename "cljs/core.cljs", :name "StringBufferWriter", :ns "cljs.core", :row 887} {:arglist-strs ["[sb]"], :end-row 890, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->StringBufferWriter", :ns "cljs.core", :row 887} {:arglist-strs ["[obj]"], :doc "Support so that collections can implement toString without\n   loading all the printing machinery.", :end-row 900, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pr-str*", :ns "cljs.core", :row 892} {:arglist-strs ["[x n]"], :end-row 908, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "int-rotate-left", :ns "cljs.core", :row 905} {:arglist-strs ["[a b]"], :end-row 913, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "imul", :ns "cljs.core", :row 913} {:arglist-strs ["[a b]"], :end-row 922, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "imul", :ns "cljs.core", :row 914} {:end-row 925, :filename "cljs/core.cljs", :name "m3-seed", :ns "cljs.core", :row 925} {:end-row 926, :filename "cljs/core.cljs", :name "m3-C1", :ns "cljs.core", :row 926} {:end-row 927, :filename "cljs/core.cljs", :name "m3-C2", :ns "cljs.core", :row 927} {:arglist-strs ["[k1]"], :end-row 930, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "m3-mix-K1", :ns "cljs.core", :row 929} {:arglist-strs ["[h1 k1]"], :end-row 933, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "m3-mix-H1", :ns "cljs.core", :row 932} {:arglist-strs ["[h1 len]"], :end-row 942, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "m3-fmix", :ns "cljs.core", :row 935} {:arglist-strs ["[in]"], :end-row 949, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "m3-hash-int", :ns "cljs.core", :row 944} {:arglist-strs ["[in]"], :end-row 963, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "m3-hash-unencoded-chars", :ns "cljs.core", :row 951} {:end-row 967, :filename "cljs/core.cljs", :name "list", :ns "cljs.core", :row 967} {:end-row 967, :filename "cljs/core.cljs", :name "Symbol", :ns "cljs.core", :row 967} {:end-row 967, :filename "cljs/core.cljs", :name "=", :ns "cljs.core", :row 967} {:end-row 967, :filename "cljs/core.cljs", :name "compare", :ns "cljs.core", :row 967} {:end-row 970, :filename "cljs/core.cljs", :name "string-hash-cache", :ns "cljs.core", :row 970} {:end-row 971, :filename "cljs/core.cljs", :name "string-hash-cache-count", :ns "cljs.core", :row 971} {:arglist-strs ["[s]"], :end-row 983, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-string*", :ns "cljs.core", :row 974} {:arglist-strs ["[k]"], :end-row 989, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "add-to-string-hash-cache", :ns "cljs.core", :row 985} {:arglist-strs ["[k]"], :end-row 1000, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-string", :ns "cljs.core", :row 991} {:arglist-strs ["[o]"], :doc "Returns the hash code of its argument. Note this is the hash code\n   consistent with =.", :end-row 1036, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash", :ns "cljs.core", :row 1002} {:arglist-strs ["[seed hash]"], :end-row 1043, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "hash-combine", :ns "cljs.core", :row 1038} {:arglist-strs ["[c x]"], :doc "Evaluates x and tests if it is an instance of the type\n  c. Returns true or false", :end-row 1049, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "instance?", :ns "cljs.core", :row 1045} {:arglist-strs ["[x]"], :doc "Return true if x is a Symbol", :end-row 1054, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "symbol?", :ns "cljs.core", :row 1051} {:arglist-strs ["[sym]"], :end-row 1059, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-symbol", :ns "cljs.core", :private true, :row 1056} {:arglist-strs ["[a b]"], :end-row 1071, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "compare-symbols", :ns "cljs.core", :private true, :row 1061} {:end-row 1073, :filename "cljs/core.cljs", :name "get", :ns "cljs.core", :row 1073} {:end-row 1107, :filename "cljs/core.cljs", :name "Symbol", :ns "cljs.core", :row 1075} {:arglist-strs ["[ns name str _hash _meta]"], :end-row 1107, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Symbol", :ns "cljs.core", :row 1075} {:arglist-strs ["[v]"], :doc "Returns true if v is of type cljs.core.Var", :end-row 1112, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "var?", :ns "cljs.core", :row 1109} {:arglist-strs ["[name]" "[ns name]"], :doc "Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars.", :end-row 1131, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "symbol", :ns "cljs.core", :row 1114} {:end-row 1199, :filename "cljs/core.cljs", :name "Var", :ns "cljs.core", :row 1133} {:arglist-strs ["[val sym _meta]"], :end-row 1199, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->Var", :ns "cljs.core", :row 1133} {:end-row 1203, :filename "cljs/core.cljs", :name "array-seq", :ns "cljs.core", :row 1203} {:end-row 1203, :filename "cljs/core.cljs", :name "prim-seq", :ns "cljs.core", :row 1203} {:end-row 1203, :filename "cljs/core.cljs", :name "IndexedSeq", :ns "cljs.core", :row 1203} {:arglist-strs ["[x]"], :doc "Return true if x implements IIterable protocol.", :end-row 1208, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "iterable?", :ns "cljs.core", :row 1205} {:arglist-strs ["[x]"], :doc "Return true if x has a JavaScript iterator property", :end-row 1214, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js-iterable?", :ns "cljs.core", :row 1210} {:arglist-strs ["[value]"], :doc "Clone the supplied value which must implement ICloneable.", :end-row 1219, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "clone", :ns "cljs.core", :row 1216} {:arglist-strs ["[value]"], :doc "Return true if x implements ICloneable protocol.", :end-row 1224, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "cloneable?", :ns "cljs.core", :row 1221} {:end-row 1226, :filename "cljs/core.cljs", :name "es6-iterator-seq", :ns "cljs.core", :row 1226} {:arglist-strs ["[coll]"], :doc "Returns a seq on the collection. If the collection is\n  empty, returns nil.  (seq nil) returns nil. seq also works on\n  Strings.", :end-row 1253, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seq", :ns "cljs.core", :row 1228} {:arglist-strs ["[coll]"], :doc "Returns the first item in the collection. Calls seq on its\n  argument. If coll is nil, returns nil.", :end-row 1264, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "first", :ns "cljs.core", :row 1255} {:arglist-strs ["[coll]"], :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :end-row 1277, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "rest", :ns "cljs.core", :row 1266} {:arglist-strs ["[coll]"], :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil", :end-row 1286, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "next", :ns "cljs.core", :row 1279} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Equality. Returns true if x equals y, false if not. Compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define -equiv (and thus =) as a value, not an identity,\n  comparison.", :end-row 1304, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "=", :ns "cljs.core", :row 1288} {:end-row 1314, :filename "cljs/core.cljs", :name "ES6Iterator", :ns "cljs.core", :row 1307} {:arglist-strs ["[s]"], :end-row 1314, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->ES6Iterator", :ns "cljs.core", :row 1307} {:arglist-strs ["[coll]"], :doc "EXPERIMENTAL: Return a ES2015 compatible iterator for coll.", :end-row 1319, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "es6-iterator", :ns "cljs.core", :row 1316} {:end-row 1329, :filename "cljs/core.cljs", :name "ES6IteratorSeq", :ns "cljs.core", :row 1321} {:arglist-strs ["[value iter _rest]"], :end-row 1329, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->ES6IteratorSeq", :ns "cljs.core", :row 1321} {:arglist-strs ["[iter]"], :doc "EXPERIMENTAL: Given an ES2015 compatible iterator return a seq.", :end-row 1337, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "es6-iterator-seq", :ns "cljs.core", :row 1331} {:arglist-strs ["[hash-basis count]"], :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :end-row 1351, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "mix-collection-hash", :ns "cljs.core", :row 1341} {:arglist-strs ["[coll]"], :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :end-row 1362, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-ordered-coll", :ns "cljs.core", :row 1353} {:end-row 1365, :filename "cljs/core.cljs", :name "empty-ordered-hash", :ns "cljs.core", :private true, :row 1364} {:arglist-strs ["[coll]"], :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :end-row 1377, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-unordered-coll", :ns "cljs.core", :row 1367} {:end-row 1380, :filename "cljs/core.cljs", :name "empty-unordered-hash", :ns "cljs.core", :private true, :row 1379} {:end-row 1383, :filename "cljs/core.cljs", :name "hash-map", :ns "cljs.core", :row 1383} {:end-row 1383, :filename "cljs/core.cljs", :name "list", :ns "cljs.core", :row 1383} {:end-row 1383, :filename "cljs/core.cljs", :name "equiv-sequential", :ns "cljs.core", :row 1383} {:end-row 1406, :filename "cljs/core.cljs", :name "Inst", :ns "cljs.core", :row 1405} {:arglist-strs ["[inst]"], :end-row 1406, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "inst-ms*", :ns "cljs.core", :row 1406} {:arglist-strs ["[inst]"], :doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", :end-row 1415, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "inst-ms", :ns "cljs.core", :row 1412} {:arglist-strs ["[x]"], :doc "Return true if x satisfies Inst", :end-row 1420, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "inst?", :ns "cljs.core", :row 1417} {:end-row 1426, :filename "cljs/core.cljs", :name "with-meta", :ns "cljs.core", :row 1426} {:arglist-strs ["[x]"], :doc "Returns a number one greater than num.", :end-row 1441, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "inc", :ns "cljs.core", :row 1439} {:end-row 1443, :filename "cljs/core.cljs", :name "deref", :ns "cljs.core", :row 1443} {:end-row 1447, :filename "cljs/core.cljs", :name "Reduced", :ns "cljs.core", :row 1445} {:arglist-strs ["[val]"], :end-row 1447, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Reduced", :ns "cljs.core", :row 1445} {:arglist-strs ["[x]"], :doc "Wraps x in a way such that a reduce will terminate with the value x", :end-row 1452, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reduced", :ns "cljs.core", :row 1449} {:arglist-strs ["[r]"], :doc "Returns true if x is the result of a call to reduced", :end-row 1457, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reduced?", :ns "cljs.core", :row 1454} {:arglist-strs ["[x]"], :doc "If x is already reduced?, returns it, else returns (reduced x)", :end-row 1462, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ensure-reduced", :ns "cljs.core", :row 1459} {:arglist-strs ["[x]"], :doc "If x is reduced?, returns (deref x), else returns x", :end-row 1467, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unreduced", :ns "cljs.core", :row 1464} {:arglist-strs ["[o]"], :doc "Also reader macro: @var/@atom/@delay. Returns the\n   most-recently-committed value of ref. When applied to a var\n   or atom, returns its current state. When applied to a delay, forces\n   it if not already forced. See also - realized?.", :end-row 1477, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "deref", :ns "cljs.core", :row 1471} {:fixed-arities #{3 2}, :end-row 1501, :private true, :ns "cljs.core", :name "ci-reduce", :filename "cljs/core.cljs", :arglist-strs ["[cicoll f]" "[cicoll f val]"], :doc "Accepts any collection which satisfies the ICount and IIndexed protocols and\nreduces them without incurring seq initialization", :row 1479} {:arglist-strs ["[arr f]" "[arr f val]" "[arr f val idx]"], :end-row 1532, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "array-reduce", :ns "cljs.core", :private true, :row 1503} {:end-row 1534, :filename "cljs/core.cljs", :name "hash-coll", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "cons", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "drop", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "count", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "nth", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "RSeq", :ns "cljs.core", :row 1534} {:end-row 1534, :filename "cljs/core.cljs", :name "List", :ns "cljs.core", :row 1534} {:arglist-strs ["[x]"], :doc "Returns true if coll implements count in constant time", :end-row 1538, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "counted?", :ns "cljs.core", :row 1536} {:arglist-strs ["[x]"], :doc "Returns true if coll implements nth in constant time", :end-row 1542, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "indexed?", :ns "cljs.core", :row 1540} {:arglist-strs ["[coll x]" "[coll x start]"], :end-row 1559, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-indexOf", :ns "cljs.core", :private true, :row 1544} {:arglist-strs ["[coll x]" "[coll x start]"], :end-row 1576, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "-lastIndexOf", :ns "cljs.core", :private true, :row 1561} {:end-row 1585, :filename "cljs/core.cljs", :name "IndexedSeqIterator", :ns "cljs.core", :row 1578} {:arglist-strs ["[arr i]"], :end-row 1585, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->IndexedSeqIterator", :ns "cljs.core", :row 1578} {:end-row 1673, :filename "cljs/core.cljs", :name "IndexedSeq", :ns "cljs.core", :row 1587} {:arglist-strs ["[arr i meta]"], :end-row 1673, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->IndexedSeq", :ns "cljs.core", :row 1587} {:arglist-strs ["[prim]" "[prim i]"], :doc "Create seq from a primitive JavaScript Array-like.", :end-row 1683, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "prim-seq", :ns "cljs.core", :row 1677} {:arglist-strs ["[array]" "[array i]"], :doc "Create a seq from a JavaScript array.", :end-row 1690, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "array-seq", :ns "cljs.core", :row 1685} {:end-row 1692, :filename "cljs/core.cljs", :name "with-meta", :ns "cljs.core", :row 1692} {:end-row 1692, :filename "cljs/core.cljs", :name "seq-reduce", :ns "cljs.core", :row 1692} {:end-row 1755, :filename "cljs/core.cljs", :name "RSeq", :ns "cljs.core", :row 1694} {:arglist-strs ["[ci i meta]"], :end-row 1755, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->RSeq", :ns "cljs.core", :row 1694} {:arglist-strs ["[coll]"], :doc "Same as (first (next x))", :end-row 1762, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "second", :ns "cljs.core", :row 1759} {:arglist-strs ["[coll]"], :doc "Same as (first (first x))", :end-row 1767, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ffirst", :ns "cljs.core", :row 1764} {:arglist-strs ["[coll]"], :doc "Same as (next (first x))", :end-row 1772, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "nfirst", :ns "cljs.core", :row 1769} {:arglist-strs ["[coll]"], :doc "Same as (first (next x))", :end-row 1777, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "fnext", :ns "cljs.core", :row 1774} {:arglist-strs ["[coll]"], :doc "Same as (next (next x))", :end-row 1782, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "nnext", :ns "cljs.core", :row 1779} {:arglist-strs ["[s]"], :doc "Return the last item in coll, in linear time", :end-row 1790, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "last", :ns "cljs.core", :row 1784} {:arglist-strs ["[]" "[coll]" "[coll x]" "[coll x & xs]"], :doc "conj[oin]. Returns a new collection with the xs\n  'added'. (conj nil item) returns (item).\n  (conj coll) returns coll. (conj) returns [].\n  The 'addition' may happen at different 'places' depending\n  on the concrete type.", :end-row 1811, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "conj", :ns "cljs.core", :row 1796} {:arglist-strs ["[coll]"], :doc "Returns an empty collection of the same category as coll, or nil", :end-row 1824, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "empty", :ns "cljs.core", :row 1813} {:arglist-strs ["[coll]"], :end-row 1830, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "accumulating-seq-count", :ns "cljs.core", :private true, :row 1826} {:arglist-strs ["[coll]"], :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Maps", :end-row 1851, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "count", :ns "cljs.core", :row 1832} {:arglist-strs ["[coll n]" "[coll n not-found]"], :end-row 1871, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "linear-traversal-nth", :ns "cljs.core", :private true, :row 1853} {:arglist-strs ["[coll n]" "[coll n not-found]"], :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :end-row 1943, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "nth", :ns "cljs.core", :row 1873} {:arglist-strs ["[coll n]"], :doc "Returns the nth rest of coll, coll when n is 0.", :end-row 1951, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "nthrest", :ns "cljs.core", :row 1945} {:arglist-strs ["[o k]" "[o k not-found]"], :doc "Returns the value mapped to key, not-found or nil if key not present\n  in associative collection, set, string, array, or ILookup instance.", :end-row 1994, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "get", :ns "cljs.core", :row 1953} {:end-row 1996, :filename "cljs/core.cljs", :name "PersistentHashMap", :ns "cljs.core", :row 1996} {:end-row 1996, :filename "cljs/core.cljs", :name "PersistentArrayMap", :ns "cljs.core", :row 1996} {:end-row 1996, :filename "cljs/core.cljs", :name "MapEntry", :ns "cljs.core", :row 1996} {:arglist-strs ["[coll k v]" "[coll k v & kvs]"], :doc "assoc[iate]. When applied to a map, returns a new map of the\n   same (hashed/sorted) type, that contains the mapping of key(s) to\n   val(s). When applied to a vector, returns a new vector that\n   contains val at index. Note - index must be <= (count vector).", :end-row 2013, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "assoc", :ns "cljs.core", :row 1998} {:arglist-strs ["[coll]" "[coll k]" "[coll k & ks]"], :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :end-row 2027, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "dissoc", :ns "cljs.core", :row 2015} {:arglist-strs ["[f]"], :doc "Return true if f is a JavaScript function or satisfies the Fn protocol.", :end-row 2032, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "fn?", :ns "cljs.core", :row 2029} {:end-row 2085, :filename "cljs/core.cljs", :name "MetaFn", :ns "cljs.core", :row 2034} {:arglist-strs ["[afn meta]"], :end-row 2085, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->MetaFn", :ns "cljs.core", :row 2034} {:arglist-strs ["[o meta]"], :doc "Returns an object of the same type and value as obj, with\n  map m as its metadata.", :end-row 2094, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "with-meta", :ns "cljs.core", :row 2087} {:arglist-strs ["[o]"], :doc "Returns the metadata of obj, returns nil if there is no metadata.", :end-row 2101, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "meta", :ns "cljs.core", :row 2096} {:arglist-strs ["[coll]"], :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :end-row 2108, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "peek", :ns "cljs.core", :row 2103} {:arglist-strs ["[coll]"], :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item.\n  Note - not the same as next/butlast.", :end-row 2116, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pop", :ns "cljs.core", :row 2110} {:arglist-strs ["[coll]" "[coll k]" "[coll k & ks]"], :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :end-row 2130, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "disj", :ns "cljs.core", :row 2118} {:arglist-strs ["[coll]"], :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :end-row 2136, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "empty?", :ns "cljs.core", :row 2132} {:arglist-strs ["[x]"], :doc "Returns true if x satisfies ICollection", :end-row 2143, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "coll?", :ns "cljs.core", :row 2138} {:arglist-strs ["[x]"], :doc "Returns true if x satisfies ISet", :end-row 2150, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set?", :ns "cljs.core", :row 2145} {:arglist-strs ["[x]"], :doc "Returns true if coll implements IAssociative", :end-row 2154, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "associative?", :ns "cljs.core", :row 2152} {:arglist-strs ["[x]"], :doc "Returns true if coll implements IFind", :end-row 2158, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ifind?", :ns "cljs.core", :row 2156} {:arglist-strs ["[x]"], :doc "Returns true if coll satisfies ISequential", :end-row 2162, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "sequential?", :ns "cljs.core", :row 2160} {:arglist-strs ["[x]"], :doc "Returns true if coll satisfies ISorted", :end-row 2166, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "sorted?", :ns "cljs.core", :row 2164} {:arglist-strs ["[x]"], :doc "Returns true if coll satisfies IReduce", :end-row 2170, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reduceable?", :ns "cljs.core", :row 2168} {:arglist-strs ["[x]"], :doc "Return true if x satisfies IMap", :end-row 2177, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "map?", :ns "cljs.core", :row 2172} {:arglist-strs ["[x]"], :doc "Return true if x satisfies IRecord", :end-row 2182, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "record?", :ns "cljs.core", :row 2179} {:arglist-strs ["[x]"], :doc "Return true if x satisfies IVector", :end-row 2186, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "vector?", :ns "cljs.core", :row 2184} {:end-row 2188, :filename "cljs/core.cljs", :name "ChunkedCons", :ns "cljs.core", :row 2188} {:end-row 2188, :filename "cljs/core.cljs", :name "ChunkedSeq", :ns "cljs.core", :row 2188} {:arglist-strs ["[x]"], :doc "Return true if x satisfies IChunkedSeq.", :end-row 2192, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunked-seq?", :ns "cljs.core", :row 2190} {:arglist-strs ["[]" "[& keyvals]"], :doc "Create JavaSript object from an even number arguments representing\n  interleaved keys and values.", :end-row 2201, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "js-obj", :ns "cljs.core", :row 2195} {:arglist-strs ["[obj]"], :doc "Return the JavaScript keys for an object.", :end-row 2206, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js-keys", :ns "cljs.core", :row 2203} {:arglist-strs ["[obj key]"], :doc "Delete a property from a JavaScript object.\n  Returns true upon success, false otherwise.", :end-row 2212, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "js-delete", :ns "cljs.core", :row 2208} {:arglist-strs ["[from i to j len]"], :end-row 2220, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "array-copy", :ns "cljs.core", :private true, :row 2214} {:arglist-strs ["[from i to j len]"], :end-row 2228, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "array-copy-downward", :ns "cljs.core", :private true, :row 2222} {:end-row 2232, :filename "cljs/core.cljs", :name "lookup-sentinel", :ns "cljs.core", :private true, :row 2232} {:arglist-strs ["[x]"], :doc "Returns true if x is the value false, false otherwise.", :end-row 2236, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "false?", :ns "cljs.core", :row 2234} {:arglist-strs ["[x]"], :doc "Returns true if x is the value true, false otherwise.", :end-row 2240, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "true?", :ns "cljs.core", :row 2238} {:arglist-strs ["[x]"], :doc "Return true if x is a Boolean", :end-row 2244, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "boolean?", :ns "cljs.core", :row 2242} {:arglist-strs ["[x]"], :doc "Returns true if x identical to the JavaScript undefined value.", :end-row 2249, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "undefined?", :ns "cljs.core", :row 2246} {:arglist-strs ["[s]"], :doc "Return true if s satisfies ISeq", :end-row 2256, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seq?", :ns "cljs.core", :row 2251} {:arglist-strs ["[s]"], :doc "Return true if the seq function is supported for s", :end-row 2265, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seqable?", :ns "cljs.core", :row 2258} {:arglist-strs ["[x]"], :doc "Coerce to boolean", :end-row 2273, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "boolean", :ns "cljs.core", :row 2267} {:arglist-strs ["[f]"], :doc "Returns true if f returns true for fn? or satisfies IFn.", :end-row 2278, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ifn?", :ns "cljs.core", :row 2275} {:arglist-strs ["[n]"], :doc "Returns true if n is a JavaScript number with no decimal part.", :end-row 2286, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "integer?", :ns "cljs.core", :row 2280} {:doc "INTERNAL: do not use", :end-row 2290, :filename "cljs/core.cljs", :name "LongImpl", :ns "cljs.core", :row 2288} {:arglist-strs ["[x]"], :doc "Return true if x satisfies integer? or is an instance of goog.math.Integer\n   or goog.math.Long.", :end-row 2298, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "int?", :ns "cljs.core", :row 2292} {:arglist-strs ["[x]"], :doc "Return true if x satisfies int? and is positive.", :end-row 2314, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pos-int?", :ns "cljs.core", :row 2300} {:arglist-strs ["[x]"], :doc "Return true if x satisfies int? and is negative.", :end-row 2328, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "neg-int?", :ns "cljs.core", :row 2316} {:arglist-strs ["[x]"], :doc "Return true if x satisfies int? and is a natural integer value.", :end-row 2343, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "nat-int?", :ns "cljs.core", :row 2330} {:arglist-strs ["[x]"], :doc "Returns true for JavaScript numbers, false otherwise.", :end-row 2348, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "float?", :ns "cljs.core", :row 2345} {:arglist-strs ["[x]"], :doc "Returns true for JavaScript numbers, false otherwise.", :end-row 2353, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "double?", :ns "cljs.core", :row 2350} {:arglist-strs ["[x]"], :doc "Returns true for Infinity and -Infinity values.", :end-row 2359, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "infinite?", :ns "cljs.core", :row 2355} {:arglist-strs ["[coll v]"], :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :end-row 2379, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "contains?", :ns "cljs.core", :row 2361} {:arglist-strs ["[coll k]"], :doc "Returns the map entry for key, or nil if key not present.", :end-row 2389, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "find", :ns "cljs.core", :row 2381} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns true if no two of the arguments are =", :end-row 2405, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "distinct?", :ns "cljs.core", :row 2391} {:arglist-strs ["[x y]"], :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Uses IComparable if available and google.array.defaultCompare for objects\n of the same type and special-cases nil to be less than any other object.", :end-row 2433, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "compare", :ns "cljs.core", :row 2409} {:fixed-arities #{4 2}, :end-row 2449, :private true, :ns "cljs.core", :name "compare-indexed", :filename "cljs/core.cljs", :arglist-strs ["[xs ys]" "[xs ys len n]"], :doc "Compare indexed collection.", :row 2435} {:fixed-arities #{1}, :end-row 2463, :private true, :ns "cljs.core", :name "fn->comparator", :filename "cljs/core.cljs", :arglist-strs ["[f]"], :doc "Given a fn that might be boolean valued or a comparator,\n   return a fn that is a comparator.", :row 2451} {:end-row 2465, :filename "cljs/core.cljs", :name "to-array", :ns "cljs.core", :row 2465} {:arglist-strs ["[coll]" "[comp coll]"], :doc "Returns a sorted sequence of the items in coll. Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :end-row 2479, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "sort", :ns "cljs.core", :row 2467} {:arglist-strs ["[keyfn coll]" "[keyfn comp coll]"], :doc "Returns a sorted sequence of the items in coll, where the sort\n   order is determined by comparing (keyfn item).  Comp can be\n   boolean-valued comparison function, or a -/0/+ valued comparator.\n   Comp defaults to compare.", :end-row 2489, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "sort-by", :ns "cljs.core", :row 2481} {:arglist-strs ["[f coll]" "[f val coll]"], :end-row 2504, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "seq-reduce", :ns "cljs.core", :private true, :row 2492} {:end-row 2506, :filename "cljs/core.cljs", :name "vec", :ns "cljs.core", :row 2506} {:arglist-strs ["[coll]"], :doc "Return a random permutation of coll", :end-row 2513, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "shuffle", :ns "cljs.core", :row 2508} {:arglist-strs ["[coll f]" "[coll f init]"], :end-row 2536, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "iter-reduce", :ns "cljs.core", :private true, :row 2515} {:arglist-strs ["[f coll]" "[f val coll]"], :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :end-row 2585, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "reduce", :ns "cljs.core", :row 2538} {:arglist-strs ["[f init coll]"], :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :end-row 2597, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "reduce-kv", :ns "cljs.core", :row 2587} {:arglist-strs ["[x]"], :doc "Returns its argument.", :end-row 2601, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "identity", :ns "cljs.core", :row 2599} {:arglist-strs ["[f]" "[f cf]"], :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :end-row 2612, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "completing", :ns "cljs.core", :row 2603} {:arglist-strs ["[xform f coll]" "[xform f init coll]"], :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :end-row 2627, :filename "cljs/core.cljs", :fixed-arities #{4 3}, :name "transduce", :ns "cljs.core", :row 2614} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the sum of nums. (+) returns 0.", :end-row 2638, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "+", :ns "cljs.core", :row 2632} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :end-row 2645, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "-", :ns "cljs.core", :row 2640} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the product of nums. (*) returns 1.", :end-row 2652, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "*", :ns "cljs.core", :row 2647} {:end-row 2654, :filename "cljs/core.cljs", :name "divide", :ns "cljs.core", :row 2654} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :end-row 2661, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "/", :ns "cljs.core", :row 2656} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :end-row 2673, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "<", :ns "cljs.core", :row 2663} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :end-row 2685, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "<=", :ns "cljs.core", :row 2675} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :end-row 2697, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name ">", :ns "cljs.core", :row 2687} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :end-row 2709, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name ">=", :ns "cljs.core", :row 2699} {:arglist-strs ["[x]"], :doc "Returns a number one less than num.", :end-row 2713, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "dec", :ns "cljs.core", :row 2711} {:arglist-strs ["[a]"], :doc "Returns the absolute value of a.", :end-row 2718, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "abs", :ns "cljs.core", :row 2715} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns the greatest of the nums.", :end-row 2725, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "max", :ns "cljs.core", :row 2720} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns the least of the nums.", :end-row 2732, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "min", :ns "cljs.core", :row 2727} {:arglist-strs ["[x]"], :end-row 2734, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "byte", :ns "cljs.core", :row 2734} {:arglist-strs ["[x]"], :doc "Coerce to char", :end-row 2742, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "char", :ns "cljs.core", :row 2736} {:arglist-strs ["[x]"], :end-row 2744, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "short", :ns "cljs.core", :row 2744} {:arglist-strs ["[x]"], :end-row 2745, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "float", :ns "cljs.core", :row 2745} {:arglist-strs ["[x]"], :end-row 2746, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "double", :ns "cljs.core", :row 2746} {:arglist-strs ["[x]"], :end-row 2748, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-byte", :ns "cljs.core", :row 2748} {:arglist-strs ["[x]"], :end-row 2749, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-char", :ns "cljs.core", :row 2749} {:arglist-strs ["[x]"], :end-row 2750, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-short", :ns "cljs.core", :row 2750} {:arglist-strs ["[x]"], :end-row 2751, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-float", :ns "cljs.core", :row 2751} {:arglist-strs ["[x]"], :end-row 2752, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-double", :ns "cljs.core", :row 2752} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the sum of nums. (+) returns 0.", :end-row 2759, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "unchecked-add", :ns "cljs.core", :row 2754} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the sum of nums. (+) returns 0.", :end-row 2766, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "unchecked-add-int", :ns "cljs.core", :row 2761} {:arglist-strs ["[x]"], :doc "Returns a number one less than x, an int.", :end-row 2771, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-dec", :ns "cljs.core", :row 2768} {:arglist-strs ["[x]"], :doc "Returns a number one less than x, an int.", :end-row 2776, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-dec-int", :ns "cljs.core", :row 2773} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :end-row 2783, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "unchecked-divide-int", :ns "cljs.core", :row 2778} {:arglist-strs ["[x]"], :end-row 2786, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-inc", :ns "cljs.core", :row 2785} {:arglist-strs ["[x]"], :end-row 2789, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-inc-int", :ns "cljs.core", :row 2788} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the product of nums. (*) returns 1.", :end-row 2796, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "unchecked-multiply", :ns "cljs.core", :row 2791} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the product of nums. (*) returns 1.", :end-row 2803, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "unchecked-multiply-int", :ns "cljs.core", :row 2798} {:arglist-strs ["[x]"], :end-row 2806, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-negate", :ns "cljs.core", :row 2805} {:arglist-strs ["[x]"], :end-row 2809, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-negate-int", :ns "cljs.core", :row 2808} {:end-row 2811, :filename "cljs/core.cljs", :name "mod", :ns "cljs.core", :row 2811} {:arglist-strs ["[x n]"], :end-row 2814, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "unchecked-remainder-int", :ns "cljs.core", :row 2813} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :end-row 2821, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "unchecked-subtract", :ns "cljs.core", :row 2816} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result.", :end-row 2828, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "unchecked-subtract-int", :ns "cljs.core", :row 2823} {:arglist-strs ["[q]"], :end-row 2833, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "fix", :ns "cljs.core", :private true, :row 2830} {:arglist-strs ["[x]"], :doc "Coerce to int by stripping decimal places.", :end-row 2838, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "int", :ns "cljs.core", :row 2835} {:arglist-strs ["[x]"], :doc "Coerce to int by stripping decimal places.", :end-row 2843, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-int", :ns "cljs.core", :row 2840} {:arglist-strs ["[x]"], :doc "Coerce to long by stripping decimal places. Identical to `int'.", :end-row 2848, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "long", :ns "cljs.core", :row 2845} {:arglist-strs ["[x]"], :doc "Coerce to long by stripping decimal places. Identical to `int'.", :end-row 2853, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "unchecked-long", :ns "cljs.core", :row 2850} {:arglist-strs ["[x]"], :end-row 2855, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "booleans", :ns "cljs.core", :row 2855} {:arglist-strs ["[x]"], :end-row 2856, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "bytes", :ns "cljs.core", :row 2856} {:arglist-strs ["[x]"], :end-row 2857, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chars", :ns "cljs.core", :row 2857} {:arglist-strs ["[x]"], :end-row 2858, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "shorts", :ns "cljs.core", :row 2858} {:arglist-strs ["[x]"], :end-row 2859, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ints", :ns "cljs.core", :row 2859} {:arglist-strs ["[x]"], :end-row 2860, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "floats", :ns "cljs.core", :row 2860} {:arglist-strs ["[x]"], :end-row 2861, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "doubles", :ns "cljs.core", :row 2861} {:arglist-strs ["[x]"], :end-row 2862, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "longs", :ns "cljs.core", :row 2862} {:arglist-strs ["[n d]"], :doc "Modulus of num and div with original javascript behavior. i.e. bug for negative numbers", :end-row 2867, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "js-mod", :ns "cljs.core", :row 2864} {:arglist-strs ["[n d]"], :doc "Modulus of num and div. Truncates toward negative infinity.", :end-row 2872, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "mod", :ns "cljs.core", :row 2869} {:arglist-strs ["[n d]"], :doc "quot[ient] of dividing numerator by denominator.", :end-row 2878, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "quot", :ns "cljs.core", :row 2874} {:arglist-strs ["[n d]"], :doc "remainder of dividing numerator by denominator.", :end-row 2884, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "rem", :ns "cljs.core", :row 2880} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise exclusive or", :end-row 2890, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-xor", :ns "cljs.core", :row 2886} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise and", :end-row 2896, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-and", :ns "cljs.core", :row 2892} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise or", :end-row 2902, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-or", :ns "cljs.core", :row 2898} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise and with complement", :end-row 2908, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-and-not", :ns "cljs.core", :row 2904} {:arglist-strs ["[x n]"], :doc "Clear bit at index n", :end-row 2913, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-clear", :ns "cljs.core", :row 2910} {:arglist-strs ["[x n]"], :doc "Flip bit at index n", :end-row 2918, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-flip", :ns "cljs.core", :row 2915} {:arglist-strs ["[x]"], :doc "Bitwise complement", :end-row 2922, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "bit-not", :ns "cljs.core", :row 2920} {:arglist-strs ["[x n]"], :doc "Set bit at index n", :end-row 2927, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-set", :ns "cljs.core", :row 2924} {:arglist-strs ["[x n]"], :doc "Test bit at index n", :end-row 2932, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-test", :ns "cljs.core", :row 2929} {:arglist-strs ["[x n]"], :doc "Bitwise shift left", :end-row 2936, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-shift-left", :ns "cljs.core", :row 2934} {:arglist-strs ["[x n]"], :doc "Bitwise shift right", :end-row 2940, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-shift-right", :ns "cljs.core", :row 2938} {:arglist-strs ["[x n]"], :doc "DEPRECATED: Bitwise shift right with zero fill", :end-row 2944, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bit-shift-right-zero-fill", :ns "cljs.core", :row 2942} {:arglist-strs ["[x n]"], :doc "Bitwise shift right with zero fill", :end-row 2948, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "unsigned-bit-shift-right", :ns "cljs.core", :row 2946} {:arglist-strs ["[v]"], :doc "Counts the number of bits set in n", :end-row 2955, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "bit-count", :ns "cljs.core", :row 2950} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums all have the equivalent\n  value, otherwise false. Behavior on non nums is\n  undefined.", :end-row 2968, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "==", :ns "cljs.core", :row 2957} {:arglist-strs ["[x]"], :doc "Returns true if num is greater than zero, else false", :end-row 2972, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pos?", :ns "cljs.core", :row 2970} {:arglist-strs ["[x]"], :doc "Returns true if num is zero, else false", :end-row 2977, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "zero?", :ns "cljs.core", :row 2974} {:arglist-strs ["[x]"], :doc "Returns true if num is less than zero, else false", :end-row 2981, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "neg?", :ns "cljs.core", :row 2979} {:arglist-strs ["[coll n]"], :doc "Returns the nth next of coll, (seq coll) when n is 0.", :end-row 2991, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "nthnext", :ns "cljs.core", :row 2985} {:arglist-strs ["[]" "[x]" "[x & ys]"], :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :end-row 3007, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "str", :ns "cljs.core", :row 2995} {:arglist-strs ["[s start]" "[s start end]"], :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :end-row 3013, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "subs", :ns "cljs.core", :row 3009} {:end-row 3015, :filename "cljs/core.cljs", :name "map", :ns "cljs.core", :row 3015} {:end-row 3015, :filename "cljs/core.cljs", :name "name", :ns "cljs.core", :row 3015} {:fixed-arities #{2}, :end-row 3030, :private true, :ns "cljs.core", :name "equiv-sequential", :filename "cljs/core.cljs", :arglist-strs ["[x y]"], :doc "Assumes x is sequential. Returns true if x equals y, otherwise\n  returns false.", :row 3017} {:arglist-strs ["[coll]"], :end-row 3038, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-coll", :ns "cljs.core", :private true, :row 3032} {:end-row 3040, :filename "cljs/core.cljs", :name "key", :ns "cljs.core", :row 3040} {:end-row 3040, :filename "cljs/core.cljs", :name "val", :ns "cljs.core", :row 3040} {:arglist-strs ["[m]"], :end-row 3050, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-imap", :ns "cljs.core", :private true, :row 3042} {:arglist-strs ["[s]"], :end-row 3059, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-iset", :ns "cljs.core", :private true, :row 3052} {:end-row 3061, :filename "cljs/core.cljs", :name "name", :ns "cljs.core", :row 3061} {:end-row 3061, :filename "cljs/core.cljs", :name "chunk-first", :ns "cljs.core", :row 3061} {:end-row 3061, :filename "cljs/core.cljs", :name "chunk-rest", :ns "cljs.core", :row 3061} {:fixed-arities #{2}, :end-row 3072, :private true, :ns "cljs.core", :name "extend-object!", :filename "cljs/core.cljs", :arglist-strs ["[obj fn-map]"], :doc "Takes a JavaScript object and a map of names to functions and\n  attaches said functions as methods on the object.  Any references to\n  JavaScript's implicit this (via the this-as macro) will resolve to the\n  object that the function is attached.", :row 3063} {:end-row 3143, :filename "cljs/core.cljs", :name "List", :ns "cljs.core", :row 3075} {:arglist-strs ["[meta first rest count __hash]"], :end-row 3143, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->List", :ns "cljs.core", :row 3075} {:arglist-strs ["[x]"], :doc "Returns true if x implements IList", :end-row 3148, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "list?", :ns "cljs.core", :row 3145} {:end-row 3217, :filename "cljs/core.cljs", :name "EmptyList", :ns "cljs.core", :row 3152} {:arglist-strs ["[meta]"], :end-row 3217, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->EmptyList", :ns "cljs.core", :row 3152} {:arglist-strs ["[coll]"], :doc "Returns true if coll satisfies? IReversible.", :end-row 3226, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reversible?", :ns "cljs.core", :row 3223} {:arglist-strs ["[rev]"], :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :end-row 3232, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "rseq", :ns "cljs.core", :row 3228} {:arglist-strs ["[coll]"], :doc "Returns a seq of the items in coll in reverse order. Not lazy.", :end-row 3239, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "reverse", :ns "cljs.core", :row 3234} {:arglist-strs ["[& xs]"], :doc "Creates a new list containing the items.", :end-row 3256, :filename "cljs/core.cljs", :name "list", :ns "cljs.core", :row 3241} {:end-row 3314, :filename "cljs/core.cljs", :name "Cons", :ns "cljs.core", :row 3258} {:arglist-strs ["[meta first rest __hash]"], :end-row 3314, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->Cons", :ns "cljs.core", :row 3258} {:arglist-strs ["[x coll]"], :doc "Returns a new seq where x is the first element and coll is the rest.", :end-row 3324, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "cons", :ns "cljs.core", :row 3318} {:arglist-strs ["[k]"], :end-row 3327, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "hash-keyword", :ns "cljs.core", :row 3326} {:arglist-strs ["[a b]"], :end-row 3339, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "compare-keywords", :ns "cljs.core", :private true, :row 3329} {:end-row 3367, :filename "cljs/core.cljs", :name "Keyword", :ns "cljs.core", :row 3341} {:arglist-strs ["[ns name fqn _hash]"], :end-row 3367, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->Keyword", :ns "cljs.core", :row 3341} {:arglist-strs ["[x]"], :doc "Return true if x is a Keyword", :end-row 3372, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "keyword?", :ns "cljs.core", :row 3369} {:arglist-strs ["[x y]"], :doc "Efficient test to determine that two keywords are identical.", :end-row 3381, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "keyword-identical?", :ns "cljs.core", :row 3374} {:arglist-strs ["[x y]"], :doc "Efficient test to determine that two symbols are identical.", :end-row 3390, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "symbol-identical?", :ns "cljs.core", :row 3383} {:arglist-strs ["[x]"], :doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :end-row 3397, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "namespace", :ns "cljs.core", :row 3392} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol or keyword", :end-row 3401, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ident?", :ns "cljs.core", :row 3399} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol or keyword without a namespace", :end-row 3405, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "simple-ident?", :ns "cljs.core", :row 3403} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol or keyword with a namespace", :end-row 3409, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "qualified-ident?", :ns "cljs.core", :row 3407} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol without a namespace", :end-row 3413, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "simple-symbol?", :ns "cljs.core", :row 3411} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol with a namespace", :end-row 3417, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "qualified-symbol?", :ns "cljs.core", :row 3415} {:arglist-strs ["[x]"], :doc "Return true if x is a keyword without a namespace", :end-row 3421, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "simple-keyword?", :ns "cljs.core", :row 3419} {:arglist-strs ["[x]"], :doc "Return true if x is a keyword with a namespace", :end-row 3425, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "qualified-keyword?", :ns "cljs.core", :row 3423} {:arglist-strs ["[name]" "[ns name]"], :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :end-row 3449, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "keyword", :ns "cljs.core", :row 3427} {:end-row 3529, :filename "cljs/core.cljs", :name "LazySeq", :ns "cljs.core", :row 3452} {:arglist-strs ["[meta fn s __hash]"], :end-row 3529, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->LazySeq", :ns "cljs.core", :row 3452} {:end-row 3533, :filename "cljs/core.cljs", :name "ArrayChunk", :ns "cljs.core", :row 3533} {:end-row 3547, :filename "cljs/core.cljs", :name "ChunkBuffer", :ns "cljs.core", :row 3535} {:arglist-strs ["[buf end]"], :end-row 3547, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->ChunkBuffer", :ns "cljs.core", :row 3535} {:arglist-strs ["[capacity]"], :end-row 3550, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk-buffer", :ns "cljs.core", :row 3549} {:end-row 3574, :filename "cljs/core.cljs", :name "ArrayChunk", :ns "cljs.core", :row 3552} {:arglist-strs ["[arr off end]"], :end-row 3574, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->ArrayChunk", :ns "cljs.core", :row 3552} {:arglist-strs ["[arr]" "[arr off]" "[arr off end]"], :end-row 3582, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "array-chunk", :ns "cljs.core", :row 3576} {:end-row 3653, :filename "cljs/core.cljs", :name "ChunkedCons", :ns "cljs.core", :row 3584} {:arglist-strs ["[chunk more meta __hash]"], :end-row 3653, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->ChunkedCons", :ns "cljs.core", :row 3584} {:arglist-strs ["[chunk rest]"], :end-row 3660, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "chunk-cons", :ns "cljs.core", :row 3657} {:arglist-strs ["[b x]"], :end-row 3663, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "chunk-append", :ns "cljs.core", :row 3662} {:arglist-strs ["[b]"], :end-row 3666, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk", :ns "cljs.core", :row 3665} {:arglist-strs ["[s]"], :end-row 3669, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk-first", :ns "cljs.core", :row 3668} {:arglist-strs ["[s]"], :end-row 3672, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk-rest", :ns "cljs.core", :row 3671} {:arglist-strs ["[s]"], :end-row 3677, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunk-next", :ns "cljs.core", :row 3674} {:arglist-strs ["[coll]"], :doc "Returns an array containing the contents of coll.", :end-row 3689, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "to-array", :ns "cljs.core", :row 3681} {:arglist-strs ["[coll]"], :doc "Returns a (potentially-ragged) 2-dimensional array\n  containing the contents of coll.", :end-row 3700, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "to-array-2d", :ns "cljs.core", :row 3691} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of ints. Does not coerce array, provided for compatibility\n  with Clojure.", :end-row 3722, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "int-array", :ns "cljs.core", :row 3702} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of longs. Does not coerce array, provided for compatibility\n  with Clojure.", :end-row 3744, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "long-array", :ns "cljs.core", :row 3724} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of doubles. Does not coerce array, provided for compatibility\n  with Clojure.", :end-row 3766, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "double-array", :ns "cljs.core", :row 3746} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of objects. Does not coerce array, provided for compatibility\n  with Clojure.", :end-row 3788, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "object-array", :ns "cljs.core", :row 3768} {:arglist-strs ["[n coll]"], :doc "If coll is counted? returns its count, else will count at most the first n\n   elements of coll using its seq", :end-row 3800, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bounded-count", :ns "cljs.core", :row 3790} {:arglist-strs ["[arglist]"], :end-row 3809, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "spread", :ns "cljs.core", :row 3802} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & zs]"], :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :end-row 3834, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "concat", :ns "cljs.core", :row 3811} {:arglist-strs ["[args]" "[a args]" "[a b args]" "[a b c args]" "[a b c d & more]"], :doc "Creates a new list containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :end-row 3844, :filename "cljs/core.cljs", :fixed-arities #{1 4 3 2}, :name "list*", :ns "cljs.core", :row 3836} {:arglist-strs ["[coll]"], :doc "Returns a new, transient version of the collection, in constant time.", :end-row 3852, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "transient", :ns "cljs.core", :row 3849} {:arglist-strs ["[tcoll]"], :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :end-row 3859, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "persistent!", :ns "cljs.core", :row 3854} {:arglist-strs ["[]" "[tcoll]" "[tcoll val]" "[tcoll val & vals]"], :doc "Adds val to the transient collection, and return tcoll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :end-row 3872, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "conj!", :ns "cljs.core", :row 3861} {:arglist-strs ["[tcoll key val]" "[tcoll key val & kvs]"], :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :end-row 3884, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "assoc!", :ns "cljs.core", :row 3874} {:arglist-strs ["[tcoll key]" "[tcoll key & ks]"], :doc "Returns a transient map that doesn't contain a mapping for key(s).", :end-row 3894, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "dissoc!", :ns "cljs.core", :row 3886} {:arglist-strs ["[tcoll]"], :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns tcoll", :end-row 3900, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pop!", :ns "cljs.core", :row 3896} {:arglist-strs ["[tcoll val]" "[tcoll val & vals]"], :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :end-row 3911, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "disj!", :ns "cljs.core", :row 3902} {:fixed-arities #{1}, :end-row 3926, :private true, :ns "cljs.core", :name "next*", :filename "cljs/core.cljs", :arglist-strs ["[coll]"], :doc "Internal. DO NOT USE! Next without the nil? check.", :row 3921} {:fixed-arities #{4 6 3 2 5}, :end-row 3960, :private true, :ns "cljs.core", :name "apply-to-simple", :filename "cljs/core.cljs", :arglist-strs ["[f args]" "[f a0 args]" "[f a0 a1 args]" "[f a0 a1 a2 args]" "[f a0 a1 a2 a3 args]"], :doc "Internal. DO NOT USE!\n  Assumes args was already called with seq beforehand!", :row 3928} {:arglist-strs ["[f args]" "[f x args]" "[f x y args]" "[f x y z args]" "[f a b c d & args]"], :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :end-row 4008, :filename "cljs/core.cljs", :fixed-arities #{4 3 2 5}, :name "apply", :ns "cljs.core", :row 3962} {:arglist-strs ["[gmap]"], :end-row 4021, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "--destructure-map", :ns "cljs.core", :row 4014} {:arglist-strs ["[obj f]" "[obj f a]" "[obj f a b]" "[obj f a b c]" "[obj f a b c d]" "[obj f a b c d & args]"], :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :end-row 4037, :filename "cljs/core.cljs", :fixed-arities #{4 6 3 2 5}, :name "vary-meta", :ns "cljs.core", :row 4023} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Same as (not (= obj1 obj2))", :end-row 4044, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "not=", :ns "cljs.core", :row 4039} {:arglist-strs ["[coll]"], :doc "If coll is empty, returns nil, else coll", :end-row 4048, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "not-empty", :ns "cljs.core", :row 4046} {:arglist-strs ["[]"], :end-row 4055, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "nil-iter", :ns "cljs.core", :row 4050} {:end-row 4064, :filename "cljs/core.cljs", :name "StringIter", :ns "cljs.core", :row 4057} {:arglist-strs ["[s i]"], :end-row 4064, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->StringIter", :ns "cljs.core", :row 4057} {:arglist-strs ["[x]"], :end-row 4067, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "string-iter", :ns "cljs.core", :row 4066} {:end-row 4076, :filename "cljs/core.cljs", :name "ArrayIter", :ns "cljs.core", :row 4069} {:arglist-strs ["[arr i]"], :end-row 4076, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->ArrayIter", :ns "cljs.core", :row 4069} {:arglist-strs ["[x]"], :end-row 4079, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "array-iter", :ns "cljs.core", :row 4078} {:end-row 4081, :filename "cljs/core.cljs", :name "INIT", :ns "cljs.core", :row 4081} {:end-row 4082, :filename "cljs/core.cljs", :name "START", :ns "cljs.core", :row 4082} {:end-row 4100, :filename "cljs/core.cljs", :name "SeqIter", :ns "cljs.core", :row 4084} {:arglist-strs ["[_seq _next]"], :end-row 4100, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->SeqIter", :ns "cljs.core", :row 4084} {:arglist-strs ["[coll]"], :end-row 4103, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seq-iter", :ns "cljs.core", :row 4102} {:arglist-strs ["[coll]"], :end-row 4112, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "iter", :ns "cljs.core", :row 4105} {:end-row 4124, :filename "cljs/core.cljs", :name "Many", :ns "cljs.core", :row 4114} {:arglist-strs ["[vals]"], :end-row 4124, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Many", :ns "cljs.core", :row 4114} {:end-row 4126, :filename "cljs/core.cljs", :name "NONE", :ns "cljs.core", :private true, :row 4126} {:end-row 4145, :filename "cljs/core.cljs", :name "Single", :ns "cljs.core", :row 4128} {:arglist-strs ["[val]"], :end-row 4145, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Single", :ns "cljs.core", :row 4128} {:end-row 4156, :filename "cljs/core.cljs", :name "Empty", :ns "cljs.core", :row 4147} {:arglist-strs ["[]"], :end-row 4156, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "->Empty", :ns "cljs.core", :row 4147} {:end-row 4158, :filename "cljs/core.cljs", :name "EMPTY", :ns "cljs.core", :private true, :row 4158} {:end-row 4174, :filename "cljs/core.cljs", :name "MultiIterator", :ns "cljs.core", :row 4160} {:arglist-strs ["[iters]"], :end-row 4174, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->MultiIterator", :ns "cljs.core", :row 4160} {:arglist-strs ["[iter]"], :end-row 4185, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "chunkIteratorSeq", :ns "cljs.core", :private true, :row 4176} {:end-row 4222, :filename "cljs/core.cljs", :name "TransformerIterator", :ns "cljs.core", :row 4187} {:arglist-strs ["[buffer _next completed xf sourceIter multi]"], :end-row 4222, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->TransformerIterator", :ns "cljs.core", :row 4187} {:arglist-strs ["[xform sourceIter multi]"], :end-row 4236, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "transformer-iterator", :ns "cljs.core", :row 4226} {:arglist-strs ["[coll]" "[xform coll]" "[xform coll & colls]"], :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :end-row 4266, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "sequence", :ns "cljs.core", :row 4246} {:arglist-strs ["[pred coll]"], :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :end-row 4275, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "every?", :ns "cljs.core", :row 4268} {:arglist-strs ["[pred coll]"], :doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :end-row 4280, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "not-every?", :ns "cljs.core", :row 4277} {:arglist-strs ["[pred coll]"], :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :end-row 4289, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "some", :ns "cljs.core", :row 4282} {:arglist-strs ["[pred coll]"], :doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :end-row 4294, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "not-any?", :ns "cljs.core", :row 4291} {:arglist-strs ["[n]"], :doc "Returns true if n is even, throws an exception if n is not an integer", :end-row 4300, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "even?", :ns "cljs.core", :row 4296} {:arglist-strs ["[n]"], :doc "Returns true if n is odd, throws an exception if n is not an integer", :end-row 4304, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "odd?", :ns "cljs.core", :row 4302} {:arglist-strs ["[f]"], :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :end-row 4314, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "complement", :ns "cljs.core", :row 4306} {:arglist-strs ["[x]"], :doc "Returns a function that takes any number of arguments and returns x.", :end-row 4318, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "constantly", :ns "cljs.core", :row 4316} {:arglist-strs ["[]" "[f]" "[f g]" "[f g h]" "[f1 f2 f3 & fs]"], :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :end-row 4347, :filename "cljs/core.cljs", :fixed-arities #{0 1 3 2}, :name "comp", :ns "cljs.core", :row 4320} {:arglist-strs ["[f]" "[f arg1]" "[f arg1 arg2]" "[f arg1 arg2 arg3]" "[f arg1 arg2 arg3 & more]"], :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :end-row 4376, :filename "cljs/core.cljs", :fixed-arities #{1 4 3 2}, :name "partial", :ns "cljs.core", :row 4349} {:arglist-strs ["[f x]" "[f x y]" "[f x y z]"], :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :end-row 4399, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "fnil", :ns "cljs.core", :row 4378} {:end-row 4401, :filename "cljs/core.cljs", :name "volatile!", :ns "cljs.core", :row 4401} {:arglist-strs ["[f]" "[f coll]"], :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :end-row 4429, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "map-indexed", :ns "cljs.core", :row 4403} {:arglist-strs ["[f]" "[f coll]"], :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :end-row 4460, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "keep", :ns "cljs.core", :row 4431} {:end-row 4492, :filename "cljs/core.cljs", :name "Atom", :ns "cljs.core", :row 4465} {:arglist-strs ["[state meta validator watches]"], :end-row 4492, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->Atom", :ns "cljs.core", :row 4465} {:arglist-strs ["[x]" "[x & {:keys [meta validator]}]"], :doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an Error.  If either of these error conditions\n  occur, then the value of the atom will not change.", :end-row 4509, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "atom", :ns "cljs.core", :row 4494} {:end-row 4511, :filename "cljs/core.cljs", :name "pr-str", :ns "cljs.core", :row 4511} {:arglist-strs ["[a new-value]"], :doc "Sets the value of atom to newval without regard for the\n  current value. Returns new-value.", :end-row 4527, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "reset!", :ns "cljs.core", :row 4513} {:arglist-strs ["[a new-value]"], :doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :end-row 4542, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "reset-vals!", :ns "cljs.core", :row 4529} {:arglist-strs ["[a f]" "[a f x]" "[a f x y]" "[a f x y & more]"], :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :end-row 4564, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "swap!", :ns "cljs.core", :row 4544} {:arglist-strs ["[a f]" "[a f x]" "[a f x y]" "[a f x y & more]"], :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :end-row 4579, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "swap-vals!", :ns "cljs.core", :row 4566} {:arglist-strs ["[a oldval newval]"], :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is equal to oldval. Returns true if\n  set happened, else false.", :end-row 4588, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "compare-and-set!", :ns "cljs.core", :row 4581} {:arglist-strs ["[iref val]"], :doc "Sets the validator-fn for an atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an Error. If the current state\n  is not acceptable to the new validator, an Error will be thrown and the\n  validator will not be changed.", :end-row 4601, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "set-validator!", :ns "cljs.core", :row 4590} {:arglist-strs ["[iref]"], :doc "Gets the validator-fn for a var/ref/agent/atom.", :end-row 4606, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "get-validator", :ns "cljs.core", :row 4603} {:end-row 4614, :filename "cljs/core.cljs", :name "Volatile", :ns "cljs.core", :row 4608} {:arglist-strs ["[state]"], :end-row 4614, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Volatile", :ns "cljs.core", :row 4608} {:arglist-strs ["[val]"], :doc "Creates and returns a Volatile with an initial value of val.", :end-row 4619, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "volatile!", :ns "cljs.core", :row 4616} {:arglist-strs ["[x]"], :doc "Returns true if x is a volatile.", :end-row 4623, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "volatile?", :ns "cljs.core", :row 4621} {:arglist-strs ["[vol newval]"], :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :end-row 4628, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "vreset!", :ns "cljs.core", :row 4625} {:arglist-strs ["[f]" "[f coll]"], :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :end-row 4664, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "keep-indexed", :ns "cljs.core", :row 4630} {:arglist-strs ["[p]" "[p1 p2]" "[p1 p2 p3]" "[p1 p2 p3 & ps]"], :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :end-row 4703, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "every-pred", :ns "cljs.core", :row 4666} {:arglist-strs ["[p]" "[p1 p2]" "[p1 p2 p3]" "[p1 p2 p3 & ps]"], :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :end-row 4742, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "some-fn", :ns "cljs.core", :row 4705} {:arglist-strs ["[f]" "[f coll]" "[f c1 c2]" "[f c1 c2 c3]" "[f c1 c2 c3 & colls]"], :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :end-row 4789, :filename "cljs/core.cljs", :fixed-arities #{1 4 3 2}, :name "map", :ns "cljs.core", :row 4744} {:arglist-strs ["[n]" "[n coll]"], :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :end-row 4816, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "take", :ns "cljs.core", :row 4791} {:arglist-strs ["[n]" "[n coll]"], :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :end-row 4841, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "drop", :ns "cljs.core", :row 4818} {:arglist-strs ["[s]" "[n s]"], :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :end-row 4846, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "drop-last", :ns "cljs.core", :row 4843} {:arglist-strs ["[n coll]"], :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :end-row 4855, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "take-last", :ns "cljs.core", :row 4848} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :end-row 4880, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "drop-while", :ns "cljs.core", :row 4857} {:end-row 4941, :filename "cljs/core.cljs", :name "Cycle", :ns "cljs.core", :row 4882} {:arglist-strs ["[meta all prev current _next]"], :end-row 4941, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Cycle", :ns "cljs.core", :row 4882} {:arglist-strs ["[coll]"], :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :end-row 4947, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "cycle", :ns "cljs.core", :row 4943} {:arglist-strs ["[n coll]"], :doc "Returns a vector of [(take n coll) (drop n coll)]", :end-row 4952, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "split-at", :ns "cljs.core", :row 4949} {:end-row 5049, :filename "cljs/core.cljs", :name "Repeat", :ns "cljs.core", :row 4954} {:arglist-strs ["[meta count val next __hash]"], :end-row 5049, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Repeat", :ns "cljs.core", :row 4954} {:arglist-strs ["[x]" "[n x]"], :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :end-row 5056, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "repeat", :ns "cljs.core", :row 5051} {:arglist-strs ["[n x]"], :doc "DEPRECATED: Use 'repeat' instead.\n  Returns a lazy seq of n xs.", :end-row 5061, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "replicate", :ns "cljs.core", :row 5058} {:arglist-strs ["[f]" "[n f]"], :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :end-row 5068, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "repeatedly", :ns "cljs.core", :row 5063} {:end-row 5070, :filename "cljs/core.cljs", :name "UNREALIZED-SEED", :ns "cljs.core", :private true, :row 5070} {:end-row 5129, :filename "cljs/core.cljs", :name "Iterate", :ns "cljs.core", :row 5072} {:arglist-strs ["[meta f prev-seed seed next]"], :end-row 5129, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Iterate", :ns "cljs.core", :row 5072} {:arglist-strs ["[f x]"], :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :end-row 5134, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "iterate", :ns "cljs.core", :row 5131} {:arglist-strs ["[]" "[c1]" "[c1 c2]" "[c1 c2 & colls]"], :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :end-row 5150, :filename "cljs/core.cljs", :fixed-arities #{0 1 2}, :name "interleave", :ns "cljs.core", :row 5136} {:arglist-strs ["[sep]" "[sep coll]"], :doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :end-row 5170, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "interpose", :ns "cljs.core", :row 5152} {:fixed-arities #{1}, :end-row 5184, :private true, :ns "cljs.core", :name "flatten1", :filename "cljs/core.cljs", :arglist-strs ["[colls]"], :doc "Take a collection of collections, and return a lazy seq\n  of items from the inner collection", :row 5174} {:end-row 5186, :filename "cljs/core.cljs", :name "cat", :ns "cljs.core", :row 5186} {:arglist-strs ["[f]" "[f & colls]"], :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :end-row 5196, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "mapcat", :ns "cljs.core", :row 5188} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-row 5225, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "filter", :ns "cljs.core", :row 5198} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-row 5233, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "remove", :ns "cljs.core", :row 5227} {:arglist-strs ["[branch? children root]"], :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n  branch? must be a fn of one arg that returns true if passed a node\n  that can have children (but may not).  children must be a fn of one\n  arg that returns a sequence of the children. Will only be called on\n  nodes for which branch? returns true. Root is the root node of the\n  tree.", :end-row 5248, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "tree-seq", :ns "cljs.core", :row 5235} {:arglist-strs ["[x]"], :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat sequence.\n  (flatten nil) returns nil.", :end-row 5256, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "flatten", :ns "cljs.core", :row 5250} {:arglist-strs ["[]" "[to]" "[to from]" "[to xform from]"], :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :end-row 5276, :filename "cljs/core.cljs", :fixed-arities #{0 1 3 2}, :name "into", :ns "cljs.core", :row 5258} {:arglist-strs ["[f coll]" "[f c1 c2]" "[f c1 c2 c3]" "[f c1 c2 c3 & colls]"], :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :end-row 5292, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "mapv", :ns "cljs.core", :row 5278} {:arglist-strs ["[pred coll]"], :doc "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.", :end-row 5301, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "filterv", :ns "cljs.core", :row 5294} {:arglist-strs ["[n coll]" "[n step coll]" "[n step pad coll]"], :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition up to n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :end-row 5323, :filename "cljs/core.cljs", :fixed-arities #{4 3 2}, :name "partition", :ns "cljs.core", :row 5303} {:arglist-strs ["[m ks]" "[m ks not-found]"], :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key is not present,\n  or the not-found value if supplied.", :end-row 5342, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "get-in", :ns "cljs.core", :row 5325} {:arglist-strs ["[m [k & ks] v]"], :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :end-row 5351, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "assoc-in", :ns "cljs.core", :row 5344} {:arglist-strs ["[m [k & ks] f]" "[m [k & ks] f a]" "[m [k & ks] f a b]" "[m [k & ks] f a b c]" "[m [k & ks] f a b c & args]"], :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :end-row 5378, :filename "cljs/core.cljs", :fixed-arities #{4 6 3 5}, :name "update-in", :ns "cljs.core", :row 5353} {:arglist-strs ["[m k f]" "[m k f x]" "[m k f x y]" "[m k f x y z]" "[m k f x y z & more]"], :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :end-row 5394, :filename "cljs/core.cljs", :fixed-arities #{4 6 3 5}, :name "update", :ns "cljs.core", :row 5380} {:end-row 5398, :filename "cljs/core.cljs", :name "VectorNode", :ns "cljs.core", :row 5398} {:arglist-strs ["[edit arr]"], :end-row 5398, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->VectorNode", :ns "cljs.core", :row 5398} {:arglist-strs ["[edit]"], :end-row 5401, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pv-fresh-node", :ns "cljs.core", :private true, :row 5400} {:arglist-strs ["[node idx]"], :end-row 5404, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "pv-aget", :ns "cljs.core", :private true, :row 5403} {:arglist-strs ["[node idx val]"], :end-row 5407, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pv-aset", :ns "cljs.core", :private true, :row 5406} {:arglist-strs ["[node]"], :end-row 5410, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pv-clone-node", :ns "cljs.core", :private true, :row 5409} {:arglist-strs ["[pv]"], :end-row 5416, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tail-off", :ns "cljs.core", :private true, :row 5412} {:arglist-strs ["[edit level node]"], :end-row 5426, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "new-path", :ns "cljs.core", :private true, :row 5418} {:arglist-strs ["[pv level parent tailnode]"], :end-row 5442, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "push-tail", :ns "cljs.core", :private true, :row 5428} {:arglist-strs ["[i cnt]"], :end-row 5445, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "vector-index-out-of-bounds", :ns "cljs.core", :private true, :row 5444} {:arglist-strs ["[pv]"], :end-row 5453, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "first-array-for-longvec", :ns "cljs.core", :private true, :row 5447} {:arglist-strs ["[pv i]"], :end-row 5464, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "unchecked-array-for", :ns "cljs.core", :private true, :row 5455} {:arglist-strs ["[pv i]"], :end-row 5469, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-for", :ns "cljs.core", :private true, :row 5466} {:arglist-strs ["[pv level node i val]"], :end-row 5479, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "do-assoc", :ns "cljs.core", :private true, :row 5471} {:arglist-strs ["[pv level node]"], :end-row 5493, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pop-tail", :ns "cljs.core", :private true, :row 5481} {:end-row 5505, :filename "cljs/core.cljs", :name "RangedIterator", :ns "cljs.core", :row 5495} {:arglist-strs ["[i base arr v start end]"], :end-row 5505, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->RangedIterator", :ns "cljs.core", :row 5495} {:arglist-strs ["[v start end]"], :end-row 5512, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "ranged-iterator", :ns "cljs.core", :row 5507} {:arglist-strs ["[pv f start end]" "[pv f init start end]"], :end-row 5528, :filename "cljs/core.cljs", :fixed-arities #{4 5}, :name "pv-reduce", :ns "cljs.core", :private true, :row 5514} {:end-row 5531, :filename "cljs/core.cljs", :name "tv-editable-root", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "tv-editable-tail", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "TransientVector", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "deref", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "pr-sequential-writer", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "pr-writer", :ns "cljs.core", :row 5530} {:end-row 5531, :filename "cljs/core.cljs", :name "chunked-seq", :ns "cljs.core", :row 5530} {:doc "Marker protocol", :end-row 5534, :filename "cljs/core.cljs", :name "APersistentVector", :ns "cljs.core", :row 5533} {:end-row 5731, :filename "cljs/core.cljs", :name "PersistentVector", :ns "cljs.core", :row 5536} {:arglist-strs ["[meta cnt shift root tail __hash]"], :end-row 5731, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->PersistentVector", :ns "cljs.core", :row 5536} {:end-row 5753, :filename "cljs/core.cljs", :name "map-entry?", :ns "cljs.core", :row 5753} {:arglist-strs ["[coll]"], :doc "Creates a new vector containing the contents of coll. JavaScript arrays\n  will be aliased and should not be modified.", :end-row 5773, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "vec", :ns "cljs.core", :row 5755} {:arglist-strs ["[& args]"], :doc "Creates a new vector containing the args.", :end-row 5780, :filename "cljs/core.cljs", :name "vector", :ns "cljs.core", :row 5775} {:end-row 5782, :filename "cljs/core.cljs", :name "subvec", :ns "cljs.core", :row 5782} {:end-row 5866, :filename "cljs/core.cljs", :name "ChunkedSeq", :ns "cljs.core", :row 5784} {:arglist-strs ["[vec node i off meta __hash]"], :end-row 5866, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->ChunkedSeq", :ns "cljs.core", :row 5784} {:arglist-strs ["[vec i off]" "[vec node i off]" "[vec node i off meta]"], :end-row 5874, :filename "cljs/core.cljs", :fixed-arities #{4 3 5}, :name "chunked-seq", :ns "cljs.core", :row 5870} {:end-row 5876, :filename "cljs/core.cljs", :name "build-subvec", :ns "cljs.core", :row 5876} {:end-row 6015, :filename "cljs/core.cljs", :name "Subvec", :ns "cljs.core", :row 5878} {:arglist-strs ["[meta v start end __hash]"], :end-row 6015, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->Subvec", :ns "cljs.core", :row 5878} {:arglist-strs ["[meta v start end __hash]"], :end-row 6029, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "build-subvec", :ns "cljs.core", :private true, :row 6019} {:arglist-strs ["[v start]" "[v start end]"], :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :end-row 6041, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "subvec", :ns "cljs.core", :row 6031} {:arglist-strs ["[edit node]"], :end-row 6046, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "tv-ensure-editable", :ns "cljs.core", :private true, :row 6043} {:arglist-strs ["[node]"], :end-row 6049, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tv-editable-root", :ns "cljs.core", :private true, :row 6048} {:arglist-strs ["[tl]"], :end-row 6054, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tv-editable-tail", :ns "cljs.core", :private true, :row 6051} {:arglist-strs ["[tv level parent tail-node]"], :end-row 6066, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "tv-push-tail", :ns "cljs.core", :private true, :row 6056} {:arglist-strs ["[tv level node]"], :end-row 6080, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "tv-pop-tail", :ns "cljs.core", :private true, :row 6068} {:arglist-strs ["[tv i]"], :end-row 6096, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "unchecked-editable-array-for", :ns "cljs.core", :private true, :row 6082} {:end-row 6229, :filename "cljs/core.cljs", :name "TransientVector", :ns "cljs.core", :row 6098} {:arglist-strs ["[cnt shift root tail]"], :end-row 6229, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->TransientVector", :ns "cljs.core", :row 6098} {:end-row 6246, :filename "cljs/core.cljs", :name "PersistentQueueIter", :ns "cljs.core", :row 6233} {:arglist-strs ["[fseq riter]"], :end-row 6246, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->PersistentQueueIter", :ns "cljs.core", :row 6233} {:end-row 6302, :filename "cljs/core.cljs", :name "PersistentQueueSeq", :ns "cljs.core", :row 6248} {:arglist-strs ["[meta front rear __hash]"], :end-row 6302, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->PersistentQueueSeq", :ns "cljs.core", :row 6248} {:end-row 6373, :filename "cljs/core.cljs", :name "PersistentQueue", :ns "cljs.core", :row 6306} {:arglist-strs ["[meta count front rear __hash]"], :end-row 6373, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->PersistentQueue", :ns "cljs.core", :row 6306} {:end-row 6384, :filename "cljs/core.cljs", :name "NeverEquiv", :ns "cljs.core", :row 6379} {:arglist-strs ["[]"], :end-row 6384, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "->NeverEquiv", :ns "cljs.core", :row 6379} {:end-row 6386, :filename "cljs/core.cljs", :name "never-equiv", :ns "cljs.core", :private true, :row 6386} {:arglist-strs ["[x y]"], :doc "Test map equivalence. Returns true if x equals y, otherwise returns false.", :end-row 6405, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "equiv-map", :ns "cljs.core", :row 6388} {:arglist-strs ["[incr k array]"], :end-row 6414, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "scan-array", :ns "cljs.core", :private true, :row 6408} {:arglist-strs ["[a b]"], :end-row 6428, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "obj-map-compare-keys", :ns "cljs.core", :private true, :row 6422} {:arglist-strs ["[m k v]"], :end-row 6440, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "obj-map->hash-map", :ns "cljs.core", :private true, :row 6430} {:arglist-strs ["[obj ks]"], :end-row 6452, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "obj-clone", :ns "cljs.core", :private true, :row 6444} {:end-row 6565, :filename "cljs/core.cljs", :name "ObjMap", :ns "cljs.core", :row 6454} {:arglist-strs ["[meta keys strobj update-count __hash]"], :end-row 6565, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->ObjMap", :ns "cljs.core", :row 6454} {:end-row 6584, :filename "cljs/core.cljs", :name "RecordIter", :ns "cljs.core", :row 6574} {:arglist-strs ["[i record base-count fields ext-map-iter]"], :end-row 6584, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->RecordIter", :ns "cljs.core", :row 6574} {:end-row 6594, :filename "cljs/core.cljs", :name "ES6EntriesIterator", :ns "cljs.core", :row 6587} {:arglist-strs ["[s]"], :end-row 6594, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->ES6EntriesIterator", :ns "cljs.core", :row 6587} {:arglist-strs ["[coll]"], :end-row 6597, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "es6-entries-iterator", :ns "cljs.core", :row 6596} {:end-row 6607, :filename "cljs/core.cljs", :name "ES6SetEntriesIterator", :ns "cljs.core", :row 6600} {:arglist-strs ["[s]"], :end-row 6607, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->ES6SetEntriesIterator", :ns "cljs.core", :row 6600} {:arglist-strs ["[coll]"], :end-row 6610, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "es6-set-entries-iterator", :ns "cljs.core", :row 6609} {:arglist-strs ["[arr]"], :end-row 6620, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "array-index-of-nil?", :ns "cljs.core", :private true, :row 6614} {:arglist-strs ["[arr k]"], :end-row 6630, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of-keyword?", :ns "cljs.core", :private true, :row 6622} {:arglist-strs ["[arr k]"], :end-row 6640, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of-symbol?", :ns "cljs.core", :private true, :row 6632} {:arglist-strs ["[arr k]"], :end-row 6648, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of-identical?", :ns "cljs.core", :private true, :row 6642} {:arglist-strs ["[arr k]"], :end-row 6656, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of-equiv?", :ns "cljs.core", :private true, :row 6650} {:arglist-strs ["[arr k]"], :end-row 6670, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-index-of", :ns "cljs.core", :row 6658} {:arglist-strs ["[m k]"], :end-row 6673, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array-map-index-of", :ns "cljs.core", :private true, :row 6672} {:arglist-strs ["[arr k v]"], :end-row 6684, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "array-extend-kv", :ns "cljs.core", :private true, :row 6675} {:arglist-strs ["[m k v]"], :end-row 6687, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "array-map-extend-kv", :ns "cljs.core", :private true, :row 6686} {:end-row 6689, :filename "cljs/core.cljs", :name "TransientArrayMap", :ns "cljs.core", :row 6689} {:end-row 6784, :filename "cljs/core.cljs", :name "MapEntry", :ns "cljs.core", :row 6691} {:arglist-strs ["[key val __hash]"], :end-row 6784, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->MapEntry", :ns "cljs.core", :row 6691} {:arglist-strs ["[x]"], :doc "Returns true if x satisfies IMapEntry", :end-row 6789, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "map-entry?", :ns "cljs.core", :row 6786} {:end-row 6852, :filename "cljs/core.cljs", :name "PersistentArrayMapSeq", :ns "cljs.core", :row 6791} {:arglist-strs ["[arr i _meta]"], :end-row 6852, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->PersistentArrayMapSeq", :ns "cljs.core", :row 6791} {:arglist-strs ["[arr i _meta]"], :end-row 6858, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "persistent-array-map-seq", :ns "cljs.core", :row 6856} {:end-row 6860, :filename "cljs/core.cljs", :name "keys", :ns "cljs.core", :row 6860} {:end-row 6860, :filename "cljs/core.cljs", :name "vals", :ns "cljs.core", :row 6860} {:end-row 6869, :filename "cljs/core.cljs", :name "PersistentArrayMapIterator", :ns "cljs.core", :row 6862} {:arglist-strs ["[arr i cnt]"], :end-row 6869, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->PersistentArrayMapIterator", :ns "cljs.core", :row 6862} {:end-row 7036, :filename "cljs/core.cljs", :name "PersistentArrayMap", :ns "cljs.core", :row 6871} {:arglist-strs ["[meta cnt arr __hash]"], :end-row 7036, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->PersistentArrayMap", :ns "cljs.core", :row 6871} {:arglist-strs ["[key other]"], :end-row 7080, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "key-test", :ns "cljs.core", :row 7076} {:arglist-strs ["[arr]"], :end-row 7092, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pam-dupes?", :ns "cljs.core", :private true, :row 7082} {:arglist-strs ["[arr]"], :end-row 7104, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "pam-new-size", :ns "cljs.core", :private true, :row 7094} {:arglist-strs ["[seed trailing]"], :end-row 7117, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "pam-grow-seed-array", :ns "cljs.core", :private true, :row 7106} {:end-row 7164, :filename "cljs/core.cljs", :name "array->transient-hash-map", :ns "cljs.core", :row 7164} {:end-row 7244, :filename "cljs/core.cljs", :name "TransientArrayMap", :ns "cljs.core", :row 7166} {:arglist-strs ["[editable? len arr]"], :end-row 7244, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->TransientArrayMap", :ns "cljs.core", :row 7166} {:end-row 7246, :filename "cljs/core.cljs", :name "TransientHashMap", :ns "cljs.core", :row 7246} {:arglist-strs ["[len arr]"], :end-row 7253, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "array->transient-hash-map", :ns "cljs.core", :private true, :row 7248} {:end-row 7257, :filename "cljs/core.cljs", :name "Box", :ns "cljs.core", :row 7257} {:arglist-strs ["[val]"], :end-row 7257, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->Box", :ns "cljs.core", :row 7257} {:end-row 7259, :filename "cljs/core.cljs", :name "create-inode-seq", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "create-array-node-seq", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "reset!", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "create-node", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "atom", :ns "cljs.core", :row 7259} {:end-row 7259, :filename "cljs/core.cljs", :name "deref", :ns "cljs.core", :row 7259} {:arglist-strs ["[hash shift]"], :end-row 7262, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "mask", :ns "cljs.core", :private true, :row 7261} {:arglist-strs ["[arr i a]" "[arr i a j b]"], :end-row 7271, :filename "cljs/core.cljs", :fixed-arities #{3 5}, :name "clone-and-set", :ns "cljs.core", :private true, :row 7264} {:arglist-strs ["[arr i]"], :end-row 7277, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "remove-pair", :ns "cljs.core", :private true, :row 7273} {:arglist-strs ["[bitmap bit]"], :end-row 7280, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bitmap-indexed-node-index", :ns "cljs.core", :private true, :row 7279} {:arglist-strs ["[hash shift]"], :end-row 7283, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "bitpos", :ns "cljs.core", :private true, :row 7282} {:arglist-strs ["[inode edit i a]" "[inode edit i a j b]"], :end-row 7294, :filename "cljs/core.cljs", :fixed-arities #{4 6}, :name "edit-and-set", :ns "cljs.core", :private true, :row 7285} {:arglist-strs ["[arr f init]"], :end-row 7310, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "inode-kv-reduce", :ns "cljs.core", :private true, :row 7296} {:end-row 7312, :filename "cljs/core.cljs", :name "ArrayNode", :ns "cljs.core", :row 7312} {:end-row 7350, :filename "cljs/core.cljs", :name "NodeIterator", :ns "cljs.core", :row 7314} {:arglist-strs ["[arr i next-entry next-iter]"], :end-row 7350, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->NodeIterator", :ns "cljs.core", :row 7314} {:end-row 7552, :filename "cljs/core.cljs", :name "BitmapIndexedNode", :ns "cljs.core", :row 7352} {:arglist-strs ["[edit bitmap arr]"], :end-row 7552, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->BitmapIndexedNode", :ns "cljs.core", :row 7352} {:arglist-strs ["[array-node edit idx]"], :end-row 7567, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pack-array-node", :ns "cljs.core", :private true, :row 7556} {:end-row 7587, :filename "cljs/core.cljs", :name "ArrayNodeIterator", :ns "cljs.core", :row 7569} {:arglist-strs ["[arr i next-iter]"], :end-row 7587, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->ArrayNodeIterator", :ns "cljs.core", :row 7569} {:end-row 7688, :filename "cljs/core.cljs", :name "ArrayNode", :ns "cljs.core", :row 7589} {:arglist-strs ["[edit cnt arr]"], :end-row 7688, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->ArrayNode", :ns "cljs.core", :row 7589} {:arglist-strs ["[arr cnt key]"], :end-row 7697, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "hash-collision-node-find-index", :ns "cljs.core", :private true, :row 7690} {:end-row 7799, :filename "cljs/core.cljs", :name "HashCollisionNode", :ns "cljs.core", :row 7699} {:arglist-strs ["[edit collision-hash cnt arr]"], :end-row 7799, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "->HashCollisionNode", :ns "cljs.core", :row 7699} {:arglist-strs ["[shift key1 val1 key2hash key2 val2]" "[edit shift key1 val1 key2hash key2 val2]"], :end-row 7817, :filename "cljs/core.cljs", :fixed-arities #{7 6}, :name "create-node", :ns "cljs.core", :private true, :row 7801} {:end-row 7879, :filename "cljs/core.cljs", :name "NodeSeq", :ns "cljs.core", :row 7819} {:arglist-strs ["[meta nodes i s __hash]"], :end-row 7879, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->NodeSeq", :ns "cljs.core", :row 7819} {:arglist-strs ["[nodes]" "[nodes i s]"], :end-row 7898, :filename "cljs/core.cljs", :fixed-arities #{1 3}, :name "create-inode-seq", :ns "cljs.core", :private true, :row 7883} {:end-row 7952, :filename "cljs/core.cljs", :name "ArrayNodeSeq", :ns "cljs.core", :row 7900} {:arglist-strs ["[meta nodes i s __hash]"], :end-row 7952, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->ArrayNodeSeq", :ns "cljs.core", :row 7900} {:arglist-strs ["[nodes]" "[nodes i s]"], :end-row 7968, :filename "cljs/core.cljs", :fixed-arities #{1 3}, :name "create-array-node-seq", :ns "cljs.core", :private true, :row 7956} {:end-row 7980, :filename "cljs/core.cljs", :name "HashMapIter", :ns "cljs.core", :row 7970} {:arglist-strs ["[nil-val root-iter seen]"], :end-row 7980, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->HashMapIter", :ns "cljs.core", :row 7970} {:end-row 8124, :filename "cljs/core.cljs", :name "PersistentHashMap", :ns "cljs.core", :row 7982} {:arglist-strs ["[meta cnt root has-nil? nil-val __hash]"], :end-row 8124, :filename "cljs/core.cljs", :fixed-arities #{6}, :name "->PersistentHashMap", :ns "cljs.core", :row 7982} {:end-row 8275, :filename "cljs/core.cljs", :name "TransientHashMap", :ns "cljs.core", :row 8162} {:arglist-strs ["[edit root count has-nil? nil-val]"], :end-row 8275, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->TransientHashMap", :ns "cljs.core", :row 8162} {:arglist-strs ["[node stack ascending?]"], :end-row 8284, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "tree-map-seq-push", :ns "cljs.core", :private true, :row 8279} {:end-row 8353, :filename "cljs/core.cljs", :name "PersistentTreeMapSeq", :ns "cljs.core", :row 8286} {:arglist-strs ["[meta stack ascending? cnt __hash]"], :end-row 8353, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->PersistentTreeMapSeq", :ns "cljs.core", :row 8286} {:arglist-strs ["[tree ascending? cnt]"], :end-row 8358, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "create-tree-map-seq", :ns "cljs.core", :private true, :row 8357} {:end-row 8360, :filename "cljs/core.cljs", :name "RedNode", :ns "cljs.core", :row 8360} {:end-row 8360, :filename "cljs/core.cljs", :name "BlackNode", :ns "cljs.core", :row 8360} {:arglist-strs ["[key val ins right]"], :end-row 8385, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "balance-left", :ns "cljs.core", :private true, :row 8362} {:arglist-strs ["[key val left ins]"], :end-row 8407, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "balance-right", :ns "cljs.core", :private true, :row 8387} {:arglist-strs ["[key val del right]"], :end-row 8426, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "balance-left-del", :ns "cljs.core", :private true, :row 8409} {:arglist-strs ["[key val left del]"], :end-row 8445, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "balance-right-del", :ns "cljs.core", :private true, :row 8428} {:arglist-strs ["[node f init]"], :end-row 8458, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "tree-map-kv-reduce", :ns "cljs.core", :private true, :row 8447} {:end-row 8581, :filename "cljs/core.cljs", :name "BlackNode", :ns "cljs.core", :row 8460} {:arglist-strs ["[key val left right __hash]"], :end-row 8581, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->BlackNode", :ns "cljs.core", :row 8460} {:end-row 8745, :filename "cljs/core.cljs", :name "RedNode", :ns "cljs.core", :row 8585} {:arglist-strs ["[key val left right __hash]"], :end-row 8745, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->RedNode", :ns "cljs.core", :row 8585} {:arglist-strs ["[comp tree k v found]"], :end-row 8766, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "tree-map-add", :ns "cljs.core", :private true, :row 8749} {:arglist-strs ["[left right]"], :end-row 8823, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "tree-map-append", :ns "cljs.core", :private true, :row 8768} {:arglist-strs ["[comp tree k found]"], :end-row 8845, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "tree-map-remove", :ns "cljs.core", :private true, :row 8825} {:arglist-strs ["[comp tree k v]"], :end-row 8852, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "tree-map-replace", :ns "cljs.core", :private true, :row 8847} {:end-row 8854, :filename "cljs/core.cljs", :name "key", :ns "cljs.core", :row 8854} {:end-row 9007, :filename "cljs/core.cljs", :name "PersistentTreeMap", :ns "cljs.core", :row 8856} {:arglist-strs ["[comp tree cnt meta __hash]"], :end-row 9007, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "->PersistentTreeMap", :ns "cljs.core", :row 8856} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new hash map with supplied mappings.", :end-row 9023, :filename "cljs/core.cljs", :name "hash-map", :ns "cljs.core", :row 9013} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new array map with supplied mappings.", :end-row 9034, :filename "cljs/core.cljs", :name "array-map", :ns "cljs.core", :row 9025} {:arglist-strs ["[s]"], :doc "Builds a map from a seq as described in\n  https://clojure.org/reference/special_forms#keyword-arguments", :end-row 9042, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "seq-to-map-for-destructuring", :ns "cljs.core", :row 9036} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new object map with supplied mappings.", :end-row 9055, :filename "cljs/core.cljs", :name "obj-map", :ns "cljs.core", :row 9044} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.", :end-row 9064, :filename "cljs/core.cljs", :name "sorted-map", :ns "cljs.core", :row 9057} {:arglist-strs ["[comparator & keyvals]"], :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied comparator.", :end-row 9074, :filename "cljs/core.cljs", :name "sorted-map-by", :ns "cljs.core", :row 9066} {:end-row 9140, :filename "cljs/core.cljs", :name "KeySeq", :ns "cljs.core", :row 9076} {:arglist-strs ["[mseq _meta]"], :end-row 9140, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->KeySeq", :ns "cljs.core", :row 9076} {:arglist-strs ["[map]"], :doc "Returns a sequence of the map's keys, in the same order as (seq map).", :end-row 9148, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "keys", :ns "cljs.core", :row 9144} {:arglist-strs ["[map-entry]"], :doc "Returns the key of the map entry.", :end-row 9153, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "key", :ns "cljs.core", :row 9150} {:end-row 9219, :filename "cljs/core.cljs", :name "ValSeq", :ns "cljs.core", :row 9155} {:arglist-strs ["[mseq _meta]"], :end-row 9219, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->ValSeq", :ns "cljs.core", :row 9155} {:arglist-strs ["[map]"], :doc "Returns a sequence of the map's values, in the same order as (seq map).", :end-row 9227, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "vals", :ns "cljs.core", :row 9223} {:arglist-strs ["[map-entry]"], :doc "Returns the value in the map entry.", :end-row 9232, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "val", :ns "cljs.core", :row 9229} {:arglist-strs ["[& maps]"], :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :end-row 9240, :filename "cljs/core.cljs", :name "merge", :ns "cljs.core", :row 9234} {:arglist-strs ["[f & maps]"], :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :end-row 9256, :filename "cljs/core.cljs", :name "merge-with", :ns "cljs.core", :row 9242} {:arglist-strs ["[map keyseq]"], :doc "Returns a map containing only those entries in map whose key is in keys", :end-row 9270, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "select-keys", :ns "cljs.core", :row 9258} {:end-row 9274, :filename "cljs/core.cljs", :name "TransientHashSet", :ns "cljs.core", :row 9274} {:end-row 9284, :filename "cljs/core.cljs", :name "HashSetIter", :ns "cljs.core", :row 9276} {:arglist-strs ["[iter]"], :end-row 9284, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->HashSetIter", :ns "cljs.core", :row 9276} {:end-row 9370, :filename "cljs/core.cljs", :name "PersistentHashSet", :ns "cljs.core", :row 9286} {:arglist-strs ["[meta hash-map __hash]"], :end-row 9370, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->PersistentHashSet", :ns "cljs.core", :row 9286} {:end-row 9445, :filename "cljs/core.cljs", :name "TransientHashSet", :ns "cljs.core", :row 9410} {:arglist-strs ["[transient-map]"], :end-row 9445, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->TransientHashSet", :ns "cljs.core", :row 9410} {:end-row 9541, :filename "cljs/core.cljs", :name "PersistentTreeSet", :ns "cljs.core", :row 9447} {:arglist-strs ["[meta tree-map __hash]"], :end-row 9541, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->PersistentTreeSet", :ns "cljs.core", :row 9447} {:arglist-strs ["[iseq]"], :end-row 9552, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set-from-indexed-seq", :ns "cljs.core", :row 9548} {:arglist-strs ["[coll]"], :doc "Returns a set of the distinct elements of coll.", :end-row 9571, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "set", :ns "cljs.core", :row 9554} {:arglist-strs ["[]" "[& keys]"], :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :end-row 9577, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "hash-set", :ns "cljs.core", :row 9573} {:arglist-strs ["[& keys]"], :doc "Returns a new sorted set with supplied keys.", :end-row 9582, :filename "cljs/core.cljs", :name "sorted-set", :ns "cljs.core", :row 9579} {:arglist-strs ["[comparator & keys]"], :doc "Returns a new sorted set with supplied keys, using the supplied comparator.", :end-row 9589, :filename "cljs/core.cljs", :name "sorted-set-by", :ns "cljs.core", :row 9584} {:arglist-strs ["[smap]" "[smap coll]"], :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :end-row 9606, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "replace", :ns "cljs.core", :row 9591} {:arglist-strs ["[]" "[coll]"], :doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", :end-row 9631, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "distinct", :ns "cljs.core", :row 9608} {:arglist-strs ["[s]"], :doc "Return a seq of all but the last item in coll, in linear time", :end-row 9640, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "butlast", :ns "cljs.core", :row 9634} {:arglist-strs ["[x]"], :doc "Returns the name String of a string, symbol or keyword.", :end-row 9649, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "name", :ns "cljs.core", :row 9642} {:arglist-strs ["[keys vals]"], :doc "Returns a map with the keys mapped to the corresponding vals.", :end-row 9661, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "zipmap", :ns "cljs.core", :row 9651} {:arglist-strs ["[k x]" "[k x y]" "[k x y & more]"], :doc "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned.", :end-row 9670, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "max-key", :ns "cljs.core", :row 9663} {:arglist-strs ["[k x]" "[k x y]" "[k x y & more]"], :doc "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.", :end-row 9679, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "min-key", :ns "cljs.core", :row 9672} {:end-row 9687, :filename "cljs/core.cljs", :name "ArrayList", :ns "cljs.core", :row 9681} {:arglist-strs ["[arr]"], :end-row 9687, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "->ArrayList", :ns "cljs.core", :row 9681} {:arglist-strs ["[]"], :end-row 9690, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "array-list", :ns "cljs.core", :row 9689} {:arglist-strs ["[n]" "[n coll]" "[n step coll]"], :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :end-row 9721, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "partition-all", :ns "cljs.core", :row 9692} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-row 9740, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "take-while", :ns "cljs.core", :row 9723} {:arglist-strs ["[sc test key]"], :end-row 9746, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "mk-bound-fn", :ns "cljs.core", :row 9742} {:arglist-strs ["[sc test key]" "[sc start-test start-key end-test end-key]"], :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :end-row 9761, :filename "cljs/core.cljs", :fixed-arities #{3 5}, :name "subseq", :ns "cljs.core", :row 9748} {:arglist-strs ["[sc test key]" "[sc start-test start-key end-test end-key]"], :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :end-row 9776, :filename "cljs/core.cljs", :fixed-arities #{3 5}, :name "rsubseq", :ns "cljs.core", :row 9763} {:end-row 9797, :filename "cljs/core.cljs", :name "IntegerRangeChunk", :ns "cljs.core", :row 9778} {:arglist-strs ["[start step count]"], :end-row 9797, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->IntegerRangeChunk", :ns "cljs.core", :row 9778} {:end-row 9808, :filename "cljs/core.cljs", :name "RangeIterator", :ns "cljs.core", :row 9799} {:arglist-strs ["[i end step]"], :end-row 9808, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "->RangeIterator", :ns "cljs.core", :row 9799} {:end-row 9922, :filename "cljs/core.cljs", :name "IntegerRange", :ns "cljs.core", :row 9810} {:arglist-strs ["[meta start end step chunk chunk-next __hash]"], :end-row 9922, :filename "cljs/core.cljs", :fixed-arities #{7}, :name "->IntegerRange", :ns "cljs.core", :row 9810} {:end-row 10029, :filename "cljs/core.cljs", :name "Range", :ns "cljs.core", :row 9926} {:arglist-strs ["[meta start end step chunk chunk-next __hash]"], :end-row 10029, :filename "cljs/core.cljs", :fixed-arities #{7}, :name "->Range", :ns "cljs.core", :row 9926} {:arglist-strs ["[]" "[end]" "[start end]" "[start end step]"], :doc "Returns a lazy seq of nums from start (inclusive) to end\n   (exclusive), by step, where start defaults to 0, step to 1,\n   and end to infinity.", :end-row 10059, :filename "cljs/core.cljs", :fixed-arities #{0 1 3 2}, :name "range", :ns "cljs.core", :row 10033} {:arglist-strs ["[n]" "[n coll]"], :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :end-row 10080, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "take-nth", :ns "cljs.core", :row 10061} {:arglist-strs ["[pred coll]"], :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", :end-row 10085, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "split-with", :ns "cljs.core", :row 10082} {:arglist-strs ["[f]" "[f coll]"], :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :end-row 10126, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "partition-by", :ns "cljs.core", :row 10087} {:arglist-strs ["[coll]"], :doc "Returns a map from distinct items in coll to the number of times\n  they appear.", :end-row 10135, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "frequencies", :ns "cljs.core", :row 10128} {:arglist-strs ["[f coll]" "[f init coll]"], :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :end-row 10151, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "reductions", :ns "cljs.core", :row 10137} {:arglist-strs ["[f]" "[f g]" "[f g h]" "[f g h & fs]"], :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :end-row 10187, :filename "cljs/core.cljs", :fixed-arities #{1 3 2}, :name "juxt", :ns "cljs.core", :row 10153} {:arglist-strs ["[coll]" "[n coll]"], :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :end-row 10200, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "dorun", :ns "cljs.core", :row 10189} {:arglist-strs ["[coll]" "[n coll]"], :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :end-row 10214, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "doall", :ns "cljs.core", :row 10202} {:arglist-strs ["[x]"], :doc "Returns true if x is a JavaScript RegExp instance.", :end-row 10221, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "regexp?", :ns "cljs.core", :row 10218} {:arglist-strs ["[re s]"], :doc "Returns the result of (re-find re s) if re fully matches s.", :end-row 10233, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "re-matches", :ns "cljs.core", :row 10223} {:arglist-strs ["[re s]"], :doc "Returns the first regex match, if any, of s to re, using\n  re.exec(s). Returns a vector, containing first the matching\n  substring, then any capturing groups if the regular expression contains\n  capturing groups.", :end-row 10248, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "re-find", :ns "cljs.core", :row 10236} {:arglist-strs ["[re s]"], :end-row 10261, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "re-seq*", :ns "cljs.core", :private true, :row 10250} {:arglist-strs ["[re s]"], :doc "Returns a lazy sequence of successive matches of re in s.", :end-row 10268, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "re-seq", :ns "cljs.core", :row 10263} {:arglist-strs ["[s]"], :doc "Returns an instance of RegExp which has compiled the provided string.", :end-row 10279, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "re-pattern", :ns "cljs.core", :row 10270} {:arglist-strs ["[writer print-one begin sep end opts coll]"], :end-row 10304, :filename "cljs/core.cljs", :fixed-arities #{7}, :name "pr-sequential-writer", :ns "cljs.core", :row 10283} {:arglist-strs ["[writer & ss]"], :end-row 10308, :filename "cljs/core.cljs", :name "write-all", :ns "cljs.core", :row 10306} {:arglist-strs ["[x]"], :end-row 10314, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "string-print", :ns "cljs.core", :row 10310} {:arglist-strs ["[]"], :end-row 10317, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "flush", :ns "cljs.core", :row 10316} {:end-row 10327, :filename "cljs/core.cljs", :name "char-escapes", :ns "cljs.core", :private true, :row 10319} {:arglist-strs ["[s]"], :end-row 10334, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "quote-string", :ns "cljs.core", :private true, :row 10329} {:end-row 10336, :filename "cljs/core.cljs", :name "print-map", :ns "cljs.core", :row 10336} {:arglist-strs ["[opts obj]"], :end-row 10341, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "print-meta?", :ns "cljs.core", :row 10338} {:arglist-strs ["[obj writer opts]"], :end-row 10433, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pr-writer-impl", :ns "cljs.core", :private true, :row 10343} {:fixed-arities #{3}, :end-row 10442, :private true, :ns "cljs.core", :name "pr-writer", :filename "cljs/core.cljs", :arglist-strs ["[obj writer opts]"], :doc "Prefer this to pr-seq, because it makes the printing function\n   configurable, allowing efficient implementations such as appending\n   to a StringBuffer.", :row 10435} {:arglist-strs ["[objs writer opts]"], :end-row 10448, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pr-seq-writer", :ns "cljs.core", :row 10444} {:arglist-strs ["[objs opts]"], :end-row 10455, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "pr-sb-with-opts", :ns "cljs.core", :private true, :row 10450} {:arglist-strs ["[objs opts]"], :doc "Prints a sequence of objects to a string, observing all the\n  options given in opts", :end-row 10463, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "pr-str-with-opts", :ns "cljs.core", :row 10457} {:arglist-strs ["[objs opts]"], :doc "Same as pr-str-with-opts followed by (newline)", :end-row 10472, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "prn-str-with-opts", :ns "cljs.core", :row 10465} {:fixed-arities #{2}, :end-row 10478, :private true, :ns "cljs.core", :name "pr-with-opts", :filename "cljs/core.cljs", :arglist-strs ["[objs opts]"], :doc "Prints a sequence of objects using string-print, observing all\n  the options given in opts", :row 10474} {:arglist-strs ["[]" "[opts]"], :doc "Prints a newline using *print-fn*", :end-row 10486, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "newline", :ns "cljs.core", :row 10480} {:arglist-strs ["[& objs]"], :doc "pr to a string, returning it. Fundamental entrypoint to IPrintWithWriter.", :end-row 10491, :filename "cljs/core.cljs", :name "pr-str", :ns "cljs.core", :row 10488} {:arglist-strs ["[& objs]"], :doc "Same as pr-str followed by (newline)", :end-row 10496, :filename "cljs/core.cljs", :name "prn-str", :ns "cljs.core", :row 10493} {:arglist-strs ["[& objs]"], :doc "Prints the object(s) using string-print.  Prints the\n  object(s), separated by spaces if there is more than one.\n  By default, pr and prn print in a way that objects can be\n  read by the reader", :end-row 10504, :filename "cljs/core.cljs", :name "pr", :ns "cljs.core", :row 10498} {:arglist-strs ["[& objs]"], :doc "Prints the object(s) using string-print.\n  print and println produce output for human consumption.", :end-row 10511, :filename "cljs/core.cljs", :fixed-arities #{}, :name "print", :ns "cljs.core", :row 10506} {:arglist-strs ["[& objs]"], :doc "print to a string, returning it", :end-row 10516, :filename "cljs/core.cljs", :name "print-str", :ns "cljs.core", :row 10513} {:arglist-strs ["[& objs]"], :doc "Same as print followed by (newline)", :end-row 10523, :filename "cljs/core.cljs", :name "println", :ns "cljs.core", :row 10518} {:arglist-strs ["[& objs]"], :doc "println to a string, returning it", :end-row 10528, :filename "cljs/core.cljs", :name "println-str", :ns "cljs.core", :row 10525} {:arglist-strs ["[& objs]"], :doc "Same as pr followed by (newline).", :end-row 10535, :filename "cljs/core.cljs", :name "prn", :ns "cljs.core", :row 10530} {:arglist-strs ["[named]"], :end-row 10541, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "strip-ns", :ns "cljs.core", :private true, :row 10537} {:fixed-arities #{1}, :end-row 10557, :private true, :ns "cljs.core", :name "lift-ns", :filename "cljs/core.cljs", :arglist-strs ["[m]"], :doc "Returns [lifted-ns lifted-map] or nil if m can't be lifted.", :row 10543} {:arglist-strs ["[prefix m print-one writer opts]"], :end-row 10567, :filename "cljs/core.cljs", :fixed-arities #{5}, :name "print-prefix-map", :ns "cljs.core", :row 10559} {:arglist-strs ["[m print-one writer opts]"], :end-row 10574, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "print-map", :ns "cljs.core", :row 10569} {:arglist-strs ["[iref f & args]"], :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :end-row 10753, :filename "cljs/core.cljs", :name "alter-meta!", :ns "cljs.core", :row 10746} {:arglist-strs ["[iref m]"], :doc "Atomically resets the metadata for an atom", :end-row 10758, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "reset-meta!", :ns "cljs.core", :row 10755} {:arglist-strs ["[iref key f]"], :doc "Adds a watch function to an atom reference. The watch fn must be a\n  fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch\n  fn will be called synchronously. Note that an atom's state\n  may have changed again prior to the fn call, so use old/new-state\n  rather than derefing the reference. Keys must be unique per\n  reference, and can be used to remove the watch with remove-watch,\n  but are otherwise considered opaque by the watch mechanism.  Bear in\n  mind that regardless of the result or action of the watch fns the\n  atom's value will change.  Example:\n\n      (def a (atom 0))\n      (add-watch a :inc (fn [k r o n] (assert (== 0 n))))\n      (swap! a inc)\n      ;; Assertion Error\n      (deref a)\n      ;=> 1", :end-row 10781, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "add-watch", :ns "cljs.core", :row 10760} {:arglist-strs ["[iref key]"], :doc "Removes a watch (set by add-watch) from a reference", :end-row 10787, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "remove-watch", :ns "cljs.core", :row 10783} {:end-row 10793, :filename "cljs/core.cljs", :name "gensym_counter", :ns "cljs.core", :row 10791} {:arglist-strs ["[]" "[prefix-string]"], :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :end-row 10803, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "gensym", :ns "cljs.core", :row 10795} {:end-row 10823, :filename "cljs/core.cljs", :name "Delay", :ns "cljs.core", :row 10807} {:arglist-strs ["[f value]"], :end-row 10823, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->Delay", :ns "cljs.core", :row 10807} {:arglist-strs ["[x]"], :doc "returns true if x is a Delay created with delay", :end-row 10827, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "delay?", :ns "cljs.core", :row 10825} {:arglist-strs ["[x]"], :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", :end-row 10834, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "force", :ns "cljs.core", :row 10829} {:arglist-strs ["[x]"], :doc "Returns true if a value has been produced for a delay or lazy sequence.", :end-row 10839, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "realized?", :ns "cljs.core", :row 10836} {:arglist-strs ["[rf]"], :end-row 10846, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "preserving-reduced", :ns "cljs.core", :private true, :row 10841} {:arglist-strs ["[rf]"], :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :end-row 10858, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "cat", :ns "cljs.core", :row 10848} {:arglist-strs ["[pred]" "[pred retf]"], :doc "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", :end-row 10882, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "halt-when", :ns "cljs.core", :row 10860} {:arglist-strs ["[]" "[coll]"], :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :end-row 10899, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "dedupe", :ns "cljs.core", :row 10884} {:end-row 10901, :filename "cljs/core.cljs", :name "rand", :ns "cljs.core", :row 10901} {:arglist-strs ["[prob]" "[prob coll]"], :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :end-row 10909, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "random-sample", :ns "cljs.core", :row 10903} {:end-row 10937, :filename "cljs/core.cljs", :name "Eduction", :ns "cljs.core", :row 10911} {:arglist-strs ["[xform coll]"], :end-row 10937, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->Eduction", :ns "cljs.core", :row 10911} {:arglist-strs ["[& xforms]"], :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.", :end-row 10948, :filename "cljs/core.cljs", :name "eduction", :ns "cljs.core", :row 10941} {:arglist-strs ["[proc coll]"], :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", :end-row 10955, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "run!", :ns "cljs.core", :row 10950} {:arglist-strs ["[step & {:keys [somef vf kf initk] :or {vf identity kf identity somef some? initk nil}}]"], :doc "Creates a seqable/reducible via repeated calls to step,\n  a function of some (continuation token) 'k'. The first call to step\n  will be passed initk, returning 'ret'. Iff (somef ret) is true,\n  (vf ret) will be included in the iteration, else iteration will\n  terminate and vf/kf will not be called. If (kf ret) is non-nil it\n  will be passed to the next step call, else iteration will terminate.\n  This can be used e.g. to consume APIs that return paginated or batched data.\n   step - (possibly impure) fn of 'k' -> 'ret'\n   :somef - fn of 'ret' -> logical true/false, default 'some?'\n   :vf - fn of 'ret' -> 'v', a value produced by the iteration, default 'identity'\n   :kf - fn of 'ret' -> 'next-k' or nil (signaling 'do not continue'), default 'identity'\n   :initk - the first value passed to step, default 'nil'\n  It is presumed that step with non-initk is unreproducible/non-idempotent.\n  If step with initk is unreproducible it is on the consumer to not consume twice.", :end-row 10998, :filename "cljs/core.cljs", :name "iteration", :ns "cljs.core", :row 10957} {:end-row 11003, :filename "cljs/core.cljs", :name "IEncodeJS", :ns "cljs.core", :row 11000} {:arglist-strs ["[x]"], :doc "Recursively transforms clj values to JavaScript", :end-row 11001, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-clj->js", :ns "cljs.core", :row 11001} {:arglist-strs ["[x]"], :doc "Transforms map keys to valid JavaScript keys. Arbitrary keys are\n  encoded to their string representation via (pr-str x)", :end-row 11003, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-key->js", :ns "cljs.core", :row 11002} {:end-row 11005, :filename "cljs/core.cljs", :name "clj->js", :ns "cljs.core", :row 11005} {:arglist-strs ["[k]" "[k primitive-fn]"], :end-row 11016, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "key->js", :ns "cljs.core", :row 11007} {:arglist-strs ["[x & {:keys [keyword-fn] :or {keyword-fn name} :as options}]"], :doc "Recursively transforms ClojureScript values to JavaScript.\n  sets/vectors/lists become Arrays, Keywords and Symbol become Strings,\n  Maps become Objects. Arbitrary keys are encoded to by `key->js`.\n  Options is a key-value pair, where the only valid key is\n  :keyword-fn, which should point to a single-argument function to be\n  called on keyword keys. Default to `name`.", :end-row 11043, :filename "cljs/core.cljs", :name "clj->js", :ns "cljs.core", :row 11018} {:end-row 11047, :filename "cljs/core.cljs", :name "IEncodeClojure", :ns "cljs.core", :row 11046} {:arglist-strs ["[x options]"], :doc "Transforms JavaScript values to Clojure", :end-row 11047, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-js->clj", :ns "cljs.core", :row 11047} {:arglist-strs ["[x]" "[x & opts]"], :doc "Recursively transforms JavaScript arrays into ClojureScript\n  vectors, and JavaScript objects into ClojureScript maps.  With\n  option ':keywordize-keys true' will convert object fields from\n  strings to keywords.", :end-row 11082, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js->clj", :ns "cljs.core", :row 11049} {:arglist-strs ["[f]"], :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", :end-row 11097, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "memoize", :ns "cljs.core", :row 11084} {:arglist-strs ["[f]" "[f & args]"], :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :end-row 11113, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "trampoline", :ns "cljs.core", :row 11099} {:arglist-strs ["[]" "[n]"], :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :end-row 11119, :filename "cljs/core.cljs", :fixed-arities #{0 1}, :name "rand", :ns "cljs.core", :row 11115} {:arglist-strs ["[n]"], :doc "Returns a random integer between 0 (inclusive) and n (exclusive).", :end-row 11123, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "rand-int", :ns "cljs.core", :row 11121} {:arglist-strs ["[coll]"], :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", :end-row 11130, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "rand-nth", :ns "cljs.core", :row 11125} {:arglist-strs ["[f coll]"], :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", :end-row 11142, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "group-by", :ns "cljs.core", :row 11132} {:arglist-strs ["[]"], :doc "Creates a hierarchy object for use with derive, isa? etc.", :end-row 11146, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "make-hierarchy", :ns "cljs.core", :row 11144} {:end-row 11151, :filename "cljs/core.cljs", :name "-global-hierarchy", :ns "cljs.core", :private true, :row 11148} {:arglist-strs ["[]"], :end-row 11156, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "get-global-hierarchy", :ns "cljs.core", :private true, :row 11153} {:arglist-strs ["[f & args]"], :end-row 11159, :filename "cljs/core.cljs", :name "swap-global-hierarchy!", :ns "cljs.core", :private true, :row 11158} {:arglist-strs ["[child parent]" "[h child parent]"], :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a JavaScript type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :end-row 11179, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "isa?", :ns "cljs.core", :row 11161} {:arglist-strs ["[tag]" "[h tag]"], :doc "Returns the immediate parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :end-row 11187, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "parents", :ns "cljs.core", :row 11181} {:arglist-strs ["[tag]" "[h tag]"], :doc "Returns the immediate and indirect parents of tag, either via a JavaScript type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :end-row 11195, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "ancestors", :ns "cljs.core", :row 11189} {:arglist-strs ["[tag]" "[h tag]"], :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on JavaScript type inheritance\n  relationships.", :end-row 11204, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "descendants", :ns "cljs.core", :row 11197} {:arglist-strs ["[tag parent]" "[h tag parent]"], :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :end-row 11238, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "derive", :ns "cljs.core", :row 11206} {:arglist-strs ["[tag parent]" "[h tag parent]"], :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :end-row 11259, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "underive", :ns "cljs.core", :row 11240} {:arglist-strs ["[method-cache method-table cached-hierarchy hierarchy]"], :end-row 11264, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "reset-cache", :ns "cljs.core", :private true, :row 11261} {:arglist-strs ["[x y prefer-table]"], :end-row 11282, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "prefers*", :ns "cljs.core", :private true, :row 11266} {:arglist-strs ["[x y prefer-table hierarchy]"], :end-row 11286, :filename "cljs/core.cljs", :fixed-arities #{4}, :name "dominates", :ns "cljs.core", :private true, :row 11284} {:arglist-strs ["[name dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy default-dispatch-val]"], :end-row 11314, :filename "cljs/core.cljs", :fixed-arities #{8}, :name "find-and-cache-best-method", :ns "cljs.core", :private true, :row 11288} {:end-row 11325, :filename "cljs/core.cljs", :name "IMultiFn", :ns "cljs.core", :row 11316} {:arglist-strs ["[mf]"], :end-row 11317, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-reset", :ns "cljs.core", :row 11317} {:arglist-strs ["[mf dispatch-val method]"], :end-row 11318, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-add-method", :ns "cljs.core", :row 11318} {:arglist-strs ["[mf dispatch-val]"], :end-row 11319, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-remove-method", :ns "cljs.core", :row 11319} {:arglist-strs ["[mf dispatch-val dispatch-val-y]"], :end-row 11320, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "-prefer-method", :ns "cljs.core", :row 11320} {:arglist-strs ["[mf dispatch-val]"], :end-row 11321, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "-get-method", :ns "cljs.core", :row 11321} {:arglist-strs ["[mf]"], :end-row 11322, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-methods", :ns "cljs.core", :row 11322} {:arglist-strs ["[mf]"], :end-row 11323, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-prefers", :ns "cljs.core", :row 11323} {:arglist-strs ["[mf]"], :end-row 11324, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-default-dispatch-val", :ns "cljs.core", :row 11324} {:arglist-strs ["[mf]"], :end-row 11325, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "-dispatch-fn", :ns "cljs.core", :row 11325} {:arglist-strs ["[name dispatch-val]"], :end-row 11328, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "throw-no-method-error", :ns "cljs.core", :private true, :row 11327} {:end-row 11513, :filename "cljs/core.cljs", :name "MultiFn", :ns "cljs.core", :row 11330} {:arglist-strs ["[name dispatch-fn default-dispatch-val hierarchy method-table prefer-table method-cache cached-hierarchy]"], :end-row 11513, :filename "cljs/core.cljs", :fixed-arities #{8}, :name "->MultiFn", :ns "cljs.core", :row 11330} {:arglist-strs ["[multifn]"], :doc "Removes all of the methods of multimethod.", :end-row 11518, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "remove-all-methods", :ns "cljs.core", :row 11515} {:arglist-strs ["[multifn dispatch-val]"], :doc "Removes the method of multimethod associated with dispatch-value.", :end-row 11523, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "remove-method", :ns "cljs.core", :row 11520} {:arglist-strs ["[multifn dispatch-val-x dispatch-val-y]"], :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y\n   when there is a conflict", :end-row 11529, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "prefer-method", :ns "cljs.core", :row 11525} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns", :end-row 11533, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "methods", :ns "cljs.core", :row 11531} {:arglist-strs ["[multifn dispatch-val]"], :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", :end-row 11538, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "get-method", :ns "cljs.core", :row 11535} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, returns a map of preferred value -> set of other values", :end-row 11542, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "prefers", :ns "cljs.core", :row 11540} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, return its default-dispatch-val.", :end-row 11546, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "default-dispatch-val", :ns "cljs.core", :row 11544} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, return its dispatch-fn.", :end-row 11550, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "dispatch-fn", :ns "cljs.core", :row 11548} {:doc "A marker protocol for UUIDs", :end-row 11553, :filename "cljs/core.cljs", :name "IUUID", :ns "cljs.core", :row 11553} {:end-row 11581, :filename "cljs/core.cljs", :name "UUID", :ns "cljs.core", :row 11555} {:arglist-strs ["[uuid __hash]"], :end-row 11581, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->UUID", :ns "cljs.core", :row 11555} {:arglist-strs ["[s]"], :doc "Returns a UUID consistent with the string s.", :end-row 11587, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "uuid", :ns "cljs.core", :row 11583} {:arglist-strs ["[]"], :doc "Returns a pseudo-randomly generated UUID instance (i.e. type 4).", :end-row 11602, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "random-uuid", :ns "cljs.core", :row 11589} {:arglist-strs ["[x]"], :doc "Return true if x is a UUID.", :end-row 11606, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "uuid?", :ns "cljs.core", :row 11604} {:arglist-strs ["[obj writer opts]"], :end-row 11619, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "pr-writer-ex-info", :ns "cljs.core", :private true, :row 11610} {:arglist-strs ["[message data cause]"], :end-row 11637, :filename "cljs/core.cljs", :fixed-arities #{3}, :name "ExceptionInfo", :ns "cljs.core", :row 11621} {:arglist-strs ["[msg data]" "[msg data cause]"], :doc "Create an instance of ExceptionInfo, an Error type that carries a\n  map of additional data.", :end-row 11655, :filename "cljs/core.cljs", :fixed-arities #{3 2}, :name "ex-info", :ns "cljs.core", :row 11650} {:arglist-strs ["[ex]"], :doc "Returns exception data (a map) if ex is an ExceptionInfo.\n  Otherwise returns nil.", :end-row 11662, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ex-data", :ns "cljs.core", :row 11657} {:arglist-strs ["[ex]"], :doc "Returns the message attached to the given Error / ExceptionInfo object.\n  For non-Errors returns nil.", :end-row 11669, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ex-message", :ns "cljs.core", :row 11664} {:arglist-strs ["[ex]"], :doc "Returns exception cause (an Error / ExceptionInfo) if ex is an\n  ExceptionInfo.\n  Otherwise returns nil.", :end-row 11677, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ex-cause", :ns "cljs.core", :row 11671} {:arglist-strs ["[pred]"], :doc "Returns an JavaScript compatible comparator based upon pred.", :end-row 11683, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "comparator", :ns "cljs.core", :row 11679} {:arglist-strs ["[x]"], :doc "Returns true if x names a special form", :end-row 11691, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "special-symbol?", :ns "cljs.core", :row 11685} {:arglist-strs ["[v]"], :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", :end-row 11700, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "test", :ns "cljs.core", :row 11693} {:end-row 11731, :filename "cljs/core.cljs", :name "TaggedLiteral", :ns "cljs.core", :row 11703} {:arglist-strs ["[tag form]"], :end-row 11731, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->TaggedLiteral", :ns "cljs.core", :row 11703} {:arglist-strs ["[value]"], :doc "Return true if the value is the data representation of a tagged literal", :end-row 11736, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tagged-literal?", :ns "cljs.core", :row 11733} {:arglist-strs ["[tag form]"], :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form.", :end-row 11743, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "tagged-literal", :ns "cljs.core", :row 11738} {:end-row 11761, :filename "cljs/core.cljs", :name "js-reserved-arr", :ns "cljs.core", :private true, :row 11745} {:end-row 11765, :filename "cljs/core.cljs", :name "js-reserved", :ns "cljs.core", :row 11763} {:arglist-strs ["[x]"], :end-row 11772, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "js-reserved?", :ns "cljs.core", :private true, :row 11767} {:arglist-strs ["[]"], :end-row 11788, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "demunge-pattern", :ns "cljs.core", :private true, :row 11774} {:arglist-strs ["[name]"], :end-row 11800, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "munge-str", :ns "cljs.core", :private true, :row 11790} {:arglist-strs ["[name]"], :end-row 11810, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "munge", :ns "cljs.core", :row 11802} {:arglist-strs ["[munged-name]"], :end-row 11827, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "demunge-str", :ns "cljs.core", :private true, :row 11812} {:arglist-strs ["[name]"], :end-row 11834, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "demunge", :ns "cljs.core", :row 11829} {:end-row 11837, :filename "cljs/core.cljs", :name "tapset", :ns "cljs.core", :private true, :row 11836} {:arglist-strs ["[]"], :end-row 11841, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "maybe-init-tapset", :ns "cljs.core", :private true, :row 11839} {:arglist-strs ["[f]"], :doc "Adds f, a fn of one argument, to the tap set. This function will be called with\n  anything sent via tap>. Remember f in order to remove-tap", :end-row 11849, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "add-tap", :ns "cljs.core", :row 11843} {:arglist-strs ["[f]"], :doc "Remove f from the tap set.", :end-row 11856, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "remove-tap", :ns "cljs.core", :row 11851} {:arglist-strs ["[x]"], :doc "Sends x to any taps. Returns the result of *exec-tap-fn*, a Boolean value.", :end-row 11867, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "tap>", :ns "cljs.core", :row 11858} {:arglist-strs ["[m f]"], :doc "m f => {k (f v) ...}\n  Given a map m and a function f of 1-argument, returns a new map where the keys of m\n  are mapped to result of applying f to the corresponding values of m.", :end-row 11882, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "update-vals", :ns "cljs.core", :row 11869} {:arglist-strs ["[m f]"], :doc "m f => {(f k) v ...}\n  Given a map m and a function f of 1-argument, returns a new map whose\n  keys are the result of applying f to the keys of m, mapped to the\n  corresponding values of m.\n  f must return a unique key for each key of m, else the behavior is undefined.", :end-row 11896, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "update-keys", :ns "cljs.core", :row 11884} {:fixed-arities #{2}, :end-row 11904, :private true, :ns "cljs.core", :name "ns-lookup", :filename "cljs/core.cljs", :arglist-strs ["[ns-obj k]"], :doc "Bootstrap only.", :row 11901} {:end-row 11925, :filename "cljs/core.cljs", :name "Namespace", :ns "cljs.core", :row 11907} {:arglist-strs ["[obj name]"], :end-row 11925, :filename "cljs/core.cljs", :fixed-arities #{2}, :name "->Namespace", :ns "cljs.core", :row 11907} {:doc "Bootstrap only.", :end-row 11929, :filename "cljs/core.cljs", :name "NS_CACHE", :ns "cljs.core", :row 11927} {:fixed-arities #{2}, :end-row 11937, :private true, :ns "cljs.core", :name "find-ns-obj*", :filename "cljs/core.cljs", :arglist-strs ["[ctxt xs]"], :doc "Bootstrap only.", :row 11931} {:arglist-strs ["[ns]"], :doc "Bootstrap only.", :end-row 11960, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "find-ns-obj", :ns "cljs.core", :row 11939} {:arglist-strs ["[sym]"], :doc "Returns a map of the intern mappings for the namespace.\n  Bootstrap only.", :end-row 11973, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ns-interns*", :ns "cljs.core", :row 11962} {:arglist-strs ["[sym]" "[sym ns-obj]"], :doc "Create a new namespace named by the symbol. Bootstrap only.", :end-row 11980, :filename "cljs/core.cljs", :fixed-arities #{1 2}, :name "create-ns", :ns "cljs.core", :row 11975} {:arglist-strs ["[ns]"], :doc "Returns the namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only.", :end-row 11995, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "find-ns", :ns "cljs.core", :row 11982} {:arglist-strs ["[ns]"], :doc "Returns the macros namespace named by the symbol or nil if it doesn't exist.\n  Bootstrap only.", :end-row 12014, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "find-macros-ns", :ns "cljs.core", :row 11997} {:arglist-strs ["[ns-obj]"], :doc "Returns the name of the namespace, a Namespace object.\n  Bootstrap only.", :end-row 12020, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "ns-name", :ns "cljs.core", :row 12016} {:arglist-strs ["[x]"], :doc "Returns true x is a goog.Uri instance.", :end-row 12026, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "uri?", :ns "cljs.core", :row 12022} {:arglist-strs ["[val]"], :doc "Returns true if num is NaN, else false", :end-row 12031, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "NaN?", :ns "cljs.core", :row 12028} {:fixed-arities #{1}, :end-row 12036, :private true, :ns "cljs.core", :name "parsing-err", :filename "cljs/core.cljs", :arglist-strs ["[val]"], :doc "Construct message for parsing for non-string parsing error", :row 12033} {:arglist-strs ["[s]"], :doc "Parse string of decimal digits with optional leading -/+ and return an\n  integer value, or nil if parse fails", :end-row 12048, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "parse-long", :ns "cljs.core", :row 12038} {:arglist-strs ["[s]"], :doc "Parse string with floating point components and return a floating point value,\n  or nil if parse fails.\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String-", :end-row 12062, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "parse-double", :ns "cljs.core", :row 12050} {:end-row 12065, :filename "cljs/core.cljs", :name "uuid-regex", :ns "cljs.core", :private true, :row 12064} {:arglist-strs ["[s]"], :doc "Parse a string representing a UUID and return a UUID instance,\n  or nil if parse fails.\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#toString--", :end-row 12075, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "parse-uuid", :ns "cljs.core", :row 12067} {:arglist-strs ["[s]"], :doc "Parse strings \"true\" or \"false\" and return a boolean, or nil if invalid. Note that this explicitly\n  excludes strings with different cases, or space characters.", :end-row 12086, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "parse-boolean", :ns "cljs.core", :row 12077} {:arglist-strs ["[]"], :end-row 12106, :filename "cljs/core.cljs", :fixed-arities #{0}, :name "maybe-enable-print!", :ns "cljs.core", :private true, :row 12088} {:doc "Runtime environments may provide a way to evaluate ClojureScript\n  forms. Whatever function *eval* is bound to will be passed any forms which\n  should be evaluated.", :end-row 12116, :filename "cljs/core.cljs", :name "*eval*", :ns "cljs.core", :row 12110} {:arglist-strs ["[form]"], :doc "Evaluates the form data structure (not text!) and returns the result.\n  Delegates to cljs.core/*eval*. Intended for use in self-hosted ClojureScript,\n  which sets up an implementation of cljs.core/*eval* for that environment.", :end-row 12123, :filename "cljs/core.cljs", :fixed-arities #{1}, :name "eval", :ns "cljs.core", :row 12118}]} {:end-row 10, :filename "cljs/analyzer/passes/and_or.cljc", :lang :clj, :name "cljs.analyzer.passes.and-or", :row 9, :ns nil, :var-definitions [{:end-row 13, :filename "cljs/analyzer/passes/and_or.cljc", :lang :clj, :name "simple-ops", :ns "cljs.analyzer.passes.and-or", :row 12} {:arglist-strs ["[ast]"], :end-row 16, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "->expr-env", :ns "cljs.analyzer.passes.and-or", :row 15} {:arglist-strs ["[ast]"], :end-row 19, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "simple-op?", :ns "cljs.analyzer.passes.and-or", :row 18} {:arglist-strs ["[{:keys [op] :as ast}]"], :end-row 28, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "simple-test-expr?", :ns "cljs.analyzer.passes.and-or", :row 21} {:arglist-strs ["[ast]"], :end-row 32, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "single-binding-let?", :ns "cljs.analyzer.passes.and-or", :row 30} {:arglist-strs ["[let-ast]"], :end-row 35, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "no-statements?", :ns "cljs.analyzer.passes.and-or", :row 34} {:arglist-strs ["[let-ast]"], :end-row 38, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "returns-if?", :ns "cljs.analyzer.passes.and-or", :row 37} {:arglist-strs ["[ast]"], :end-row 44, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "simple-test-binding-let?", :ns "cljs.analyzer.passes.and-or", :row 40} {:arglist-strs ["[if-ast]"], :end-row 50, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "test=then?", :ns "cljs.analyzer.passes.and-or", :row 46} {:arglist-strs ["[if-ast]"], :end-row 56, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "test=else?", :ns "cljs.analyzer.passes.and-or", :row 52} {:arglist-strs ["[ast]"], :end-row 60, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "simple-and?", :ns "cljs.analyzer.passes.and-or", :row 58} {:arglist-strs ["[ast]"], :end-row 64, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "simple-or?", :ns "cljs.analyzer.passes.and-or", :row 62} {:arglist-strs ["[ast]"], :end-row 68, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "optimizable-and?", :ns "cljs.analyzer.passes.and-or", :row 66} {:arglist-strs ["[ast]"], :end-row 72, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "optimizable-or?", :ns "cljs.analyzer.passes.and-or", :row 70} {:arglist-strs ["[fn-ast local]"], :end-row 81, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{2}, :lang :clj, :name "remove-loop-let", :ns "cljs.analyzer.passes.and-or", :row 74} {:arglist-strs ["[local]"], :end-row 86, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "remove-local-pass", :ns "cljs.analyzer.passes.and-or", :row 83} {:arglist-strs ["[ast]"], :end-row 99, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "optimize-and", :ns "cljs.analyzer.passes.and-or", :row 88} {:arglist-strs ["[ast]"], :end-row 112, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "optimize-or", :ns "cljs.analyzer.passes.and-or", :row 101} {:arglist-strs ["[env ast _]"], :end-row 118, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{3}, :lang :clj, :name "optimize", :ns "cljs.analyzer.passes.and-or", :row 114} {:end-row 13, :filename "cljs/analyzer/passes/and_or.cljc", :lang :cljs, :name "simple-ops", :ns "cljs.analyzer.passes.and-or", :row 12} {:arglist-strs ["[ast]"], :end-row 16, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "->expr-env", :ns "cljs.analyzer.passes.and-or", :row 15} {:arglist-strs ["[ast]"], :end-row 19, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "simple-op?", :ns "cljs.analyzer.passes.and-or", :row 18} {:arglist-strs ["[{:keys [op] :as ast}]"], :end-row 28, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "simple-test-expr?", :ns "cljs.analyzer.passes.and-or", :row 21} {:arglist-strs ["[ast]"], :end-row 32, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "single-binding-let?", :ns "cljs.analyzer.passes.and-or", :row 30} {:arglist-strs ["[let-ast]"], :end-row 35, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "no-statements?", :ns "cljs.analyzer.passes.and-or", :row 34} {:arglist-strs ["[let-ast]"], :end-row 38, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "returns-if?", :ns "cljs.analyzer.passes.and-or", :row 37} {:arglist-strs ["[ast]"], :end-row 44, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "simple-test-binding-let?", :ns "cljs.analyzer.passes.and-or", :row 40} {:arglist-strs ["[if-ast]"], :end-row 50, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "test=then?", :ns "cljs.analyzer.passes.and-or", :row 46} {:arglist-strs ["[if-ast]"], :end-row 56, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "test=else?", :ns "cljs.analyzer.passes.and-or", :row 52} {:arglist-strs ["[ast]"], :end-row 60, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "simple-and?", :ns "cljs.analyzer.passes.and-or", :row 58} {:arglist-strs ["[ast]"], :end-row 64, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "simple-or?", :ns "cljs.analyzer.passes.and-or", :row 62} {:arglist-strs ["[ast]"], :end-row 68, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "optimizable-and?", :ns "cljs.analyzer.passes.and-or", :row 66} {:arglist-strs ["[ast]"], :end-row 72, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "optimizable-or?", :ns "cljs.analyzer.passes.and-or", :row 70} {:arglist-strs ["[fn-ast local]"], :end-row 81, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{2}, :lang :cljs, :name "remove-loop-let", :ns "cljs.analyzer.passes.and-or", :row 74} {:arglist-strs ["[local]"], :end-row 86, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "remove-local-pass", :ns "cljs.analyzer.passes.and-or", :row 83} {:arglist-strs ["[ast]"], :end-row 99, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "optimize-and", :ns "cljs.analyzer.passes.and-or", :row 88} {:arglist-strs ["[ast]"], :end-row 112, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "optimize-or", :ns "cljs.analyzer.passes.and-or", :row 101} {:arglist-strs ["[env ast _]"], :end-row 118, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{3}, :lang :cljs, :name "optimize", :ns "cljs.analyzer.passes.and-or", :row 114}]} {:end-row 10, :filename "cljs/analyzer/passes/and_or.cljc", :lang :cljs, :name "cljs.analyzer.passes.and-or", :row 9, :ns nil, :var-definitions [{:end-row 13, :filename "cljs/analyzer/passes/and_or.cljc", :lang :clj, :name "simple-ops", :ns "cljs.analyzer.passes.and-or", :row 12} {:arglist-strs ["[ast]"], :end-row 16, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "->expr-env", :ns "cljs.analyzer.passes.and-or", :row 15} {:arglist-strs ["[ast]"], :end-row 19, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "simple-op?", :ns "cljs.analyzer.passes.and-or", :row 18} {:arglist-strs ["[{:keys [op] :as ast}]"], :end-row 28, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "simple-test-expr?", :ns "cljs.analyzer.passes.and-or", :row 21} {:arglist-strs ["[ast]"], :end-row 32, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "single-binding-let?", :ns "cljs.analyzer.passes.and-or", :row 30} {:arglist-strs ["[let-ast]"], :end-row 35, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "no-statements?", :ns "cljs.analyzer.passes.and-or", :row 34} {:arglist-strs ["[let-ast]"], :end-row 38, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "returns-if?", :ns "cljs.analyzer.passes.and-or", :row 37} {:arglist-strs ["[ast]"], :end-row 44, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "simple-test-binding-let?", :ns "cljs.analyzer.passes.and-or", :row 40} {:arglist-strs ["[if-ast]"], :end-row 50, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "test=then?", :ns "cljs.analyzer.passes.and-or", :row 46} {:arglist-strs ["[if-ast]"], :end-row 56, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "test=else?", :ns "cljs.analyzer.passes.and-or", :row 52} {:arglist-strs ["[ast]"], :end-row 60, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "simple-and?", :ns "cljs.analyzer.passes.and-or", :row 58} {:arglist-strs ["[ast]"], :end-row 64, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "simple-or?", :ns "cljs.analyzer.passes.and-or", :row 62} {:arglist-strs ["[ast]"], :end-row 68, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "optimizable-and?", :ns "cljs.analyzer.passes.and-or", :row 66} {:arglist-strs ["[ast]"], :end-row 72, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "optimizable-or?", :ns "cljs.analyzer.passes.and-or", :row 70} {:arglist-strs ["[fn-ast local]"], :end-row 81, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{2}, :lang :clj, :name "remove-loop-let", :ns "cljs.analyzer.passes.and-or", :row 74} {:arglist-strs ["[local]"], :end-row 86, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "remove-local-pass", :ns "cljs.analyzer.passes.and-or", :row 83} {:arglist-strs ["[ast]"], :end-row 99, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "optimize-and", :ns "cljs.analyzer.passes.and-or", :row 88} {:arglist-strs ["[ast]"], :end-row 112, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :clj, :name "optimize-or", :ns "cljs.analyzer.passes.and-or", :row 101} {:arglist-strs ["[env ast _]"], :end-row 118, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{3}, :lang :clj, :name "optimize", :ns "cljs.analyzer.passes.and-or", :row 114} {:end-row 13, :filename "cljs/analyzer/passes/and_or.cljc", :lang :cljs, :name "simple-ops", :ns "cljs.analyzer.passes.and-or", :row 12} {:arglist-strs ["[ast]"], :end-row 16, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "->expr-env", :ns "cljs.analyzer.passes.and-or", :row 15} {:arglist-strs ["[ast]"], :end-row 19, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "simple-op?", :ns "cljs.analyzer.passes.and-or", :row 18} {:arglist-strs ["[{:keys [op] :as ast}]"], :end-row 28, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "simple-test-expr?", :ns "cljs.analyzer.passes.and-or", :row 21} {:arglist-strs ["[ast]"], :end-row 32, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "single-binding-let?", :ns "cljs.analyzer.passes.and-or", :row 30} {:arglist-strs ["[let-ast]"], :end-row 35, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "no-statements?", :ns "cljs.analyzer.passes.and-or", :row 34} {:arglist-strs ["[let-ast]"], :end-row 38, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "returns-if?", :ns "cljs.analyzer.passes.and-or", :row 37} {:arglist-strs ["[ast]"], :end-row 44, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "simple-test-binding-let?", :ns "cljs.analyzer.passes.and-or", :row 40} {:arglist-strs ["[if-ast]"], :end-row 50, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "test=then?", :ns "cljs.analyzer.passes.and-or", :row 46} {:arglist-strs ["[if-ast]"], :end-row 56, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "test=else?", :ns "cljs.analyzer.passes.and-or", :row 52} {:arglist-strs ["[ast]"], :end-row 60, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "simple-and?", :ns "cljs.analyzer.passes.and-or", :row 58} {:arglist-strs ["[ast]"], :end-row 64, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "simple-or?", :ns "cljs.analyzer.passes.and-or", :row 62} {:arglist-strs ["[ast]"], :end-row 68, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "optimizable-and?", :ns "cljs.analyzer.passes.and-or", :row 66} {:arglist-strs ["[ast]"], :end-row 72, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "optimizable-or?", :ns "cljs.analyzer.passes.and-or", :row 70} {:arglist-strs ["[fn-ast local]"], :end-row 81, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{2}, :lang :cljs, :name "remove-loop-let", :ns "cljs.analyzer.passes.and-or", :row 74} {:arglist-strs ["[local]"], :end-row 86, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "remove-local-pass", :ns "cljs.analyzer.passes.and-or", :row 83} {:arglist-strs ["[ast]"], :end-row 99, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "optimize-and", :ns "cljs.analyzer.passes.and-or", :row 88} {:arglist-strs ["[ast]"], :end-row 112, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{1}, :lang :cljs, :name "optimize-or", :ns "cljs.analyzer.passes.and-or", :row 101} {:arglist-strs ["[env ast _]"], :end-row 118, :filename "cljs/analyzer/passes/and_or.cljc", :fixed-arities #{3}, :lang :cljs, :name "optimize", :ns "cljs.analyzer.passes.and-or", :row 114}]} {:doc "This is intended to be a stable api for those who need programmatic access\n  to the analyzer.", :end-row 20, :filename "cljs/analyzer/api.cljc", :lang :clj, :name "cljs.analyzer.api", :row 9, :ns nil, :var-definitions [{:fixed-arities #{0 1}, :end-row 34, :ns "cljs.analyzer.api", :name "empty-state", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[opts]"], :doc "Creates an empty compilation state Atom<Map>. The optional opts arg is a map\n   representing the compiler configuration. See the documentation\n   for details: https://clojurescript.org/reference/compiler-options", :row 25} {:fixed-arities #{0}, :end-row 39, :ns "cljs.analyzer.api", :name "current-state", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Return the current compiler state atom.", :row 36} {:fixed-arities #{0}, :end-row 44, :ns "cljs.analyzer.api", :name "current-file", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Return the current file under analysis or compilation.", :row 41} {:fixed-arities #{0}, :end-row 49, :ns "cljs.analyzer.api", :name "current-ns", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Return the current ns under analysis or compilation.", :row 46} {:end-row 55, :ns "cljs.analyzer.api", :name "with-state", :lang :clj, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[state & body]"], :doc "Run the body with the given compilation state Atom<Map>.", :row 51} {:fixed-arities #{0}, :end-row 60, :ns "cljs.analyzer.api", :name "empty-env", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Creates an empty analysis environment.", :row 57} {:end-row 67, :ns "cljs.analyzer.api", :name "no-warn", :lang :clj, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Disable analyzer warnings for any analysis executed in body.", :row 62} {:fixed-arities #{1}, :end-row 72, :ns "cljs.analyzer.api", :name "warning-enabled?", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[warning-type]"], :doc "Test if the given warning-type is enabled.", :row 69} {:fixed-arities #{3}, :end-row 79, :ns "cljs.analyzer.api", :name "default-warning-handler", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[warning-type env extra]"], :doc "The default warning handler.\n\n   Outputs the warning messages to *err*.", :row 74} {:end-row 89, :ns "cljs.analyzer.api", :name "with-warning-handlers", :lang :clj, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[handlers & body]"], :doc "Helper macro for custom handling of emitted warnings. Handlers should be\n   a vector of functions. The signature of these functions is\n   [warn-type env warn-info]. warn-type is a keyword describing the warning,\n   env is the analysis environment, and warn-info is a map of extra useful\n   information for a particular warning type.", :row 81} {:fixed-arities #{2}, :end-row 95, :ns "cljs.analyzer.api", :name "warning-message", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[warn-type warn-info]"], :doc "Helper for generating the standard analyzer messages for warnings. Should be\n  passed warn-type and warn-info. See with-warning-handlers.", :row 91} {:fixed-arities #{0}, :end-row 100, :ns "cljs.analyzer.api", :name "enabled-warnings", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Get the enabled warning types.", :row 97} {:fixed-arities #{0 1}, :end-row 106, :ns "cljs.analyzer.api", :name "get-options", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[state]"], :doc "Return the compiler options from compiler state.", :row 102} {:fixed-arities #{0 1}, :end-row 113, :ns "cljs.analyzer.api", :name "get-js-index", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[state]"], :doc "Return the currently computed Google Closure js dependency index from the\n  compiler state.", :row 108} {:doc "ClojureScript's default analysis passes.", :end-row 117, :filename "cljs/analyzer/api.cljc", :lang :clj, :name "default-passes", :ns "cljs.analyzer.api", :row 115} {:end-row 123, :ns "cljs.analyzer.api", :name "with-passes", :lang :clj, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[passes & body]"], :doc "Evaluate the body with the provided sequence of compiler passes.", :row 119} {:fixed-arities #{4 3 2 5}, :end-row 141, :ns "cljs.analyzer.api", :name "analyze", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[env form]" "[env form name]" "[env form name opts]" "[state env form name opts]"], :doc "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n     (one of :statement, :expr, :return), :ns (a symbol naming the\n     compilation ns)}, and form, returns an expression object (a map\n     containing at least :form, :op and :env keys). If expr has any (immediately)\n     nested exprs, must have :children entry. This must be a vector of keywords naming\n     the immediately nested fields mapped to an expr or vector of exprs. This will\n     facilitate code walking without knowing the details of the op set.", :row 126} {:fixed-arities #{1 2}, :end-row 148, :ns "cljs.analyzer.api", :name "forms-seq", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[rdr]" "[rdr filename]"], :doc "Seq of Clojure/ClojureScript forms from rdr, a java.io.Reader. Optionally\n     accepts a filename argument which will be used in any emitted errors.", :row 144} {:fixed-arities #{1 4 3 2}, :end-row 168, :ns "cljs.analyzer.api", :name "parse-ns", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[src]" "[src opts]" "[src dest opts]" "[state src dest opts]"], :doc "Helper for parsing only the essential namespace information from a\n      ClojureScript source file and returning a cljs.closure/IJavaScript compatible\n      map _not_ a namespace AST node.\n\n      By default does not load macros or perform any analysis of dependencies. If\n      opts parameter provided :analyze-deps and :load-macros keys their values will\n      be used for *analyze-deps* and *load-macros* bindings respectively. This\n      function does _not_ side-effect the ambient compilation environment unless\n      requested via opts where :restore is false.", :row 151} {:fixed-arities #{1 3 2}, :end-row 186, :ns "cljs.analyzer.api", :name "analyze-file", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[f]" "[f opts]" "[state f opts]"], :doc "Given a java.io.File, java.net.URL or a string identifying a resource on the\n      classpath attempt to analyze it.\n\n      This function side-effects the ambient compilation environment\n      `cljs.env/*compiler*` to aggregate analysis information. opts argument is\n      compiler options, if :cache-analysis true will cache analysis to\n      \":output-dir/some/ns/foo.cljs.cache.edn\". This function does not return a\n      meaningful value.", :row 171} {:fixed-arities #{1}, :end-row 196, :ns "cljs.analyzer.api", :name "read-analysis-cache", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[cache-file]"], :doc "Read an analysis cache.", :row 189} {:fixed-arities #{2}, :end-row 211, :ns "cljs.analyzer.api", :name "resolve", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[env sym]"], :doc "Given an analysis environment resolve a var. Analogous to\n   clojure.core/resolve", :row 201} {:fixed-arities #{0 1}, :end-row 219, :ns "cljs.analyzer.api", :name "all-ns", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[state]"], :doc "Return all namespaces. Analagous to clojure.core/all-ns but\n  returns symbols identifying namespaces not Namespace instances.", :row 213} {:fixed-arities #{1 2}, :end-row 228, :ns "cljs.analyzer.api", :name "find-ns", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[sym]" "[state sym]"], :doc "Given a namespace return the corresponding namespace analysis map. Analagous\n  to clojure.core/find-ns.", :row 221} {:fixed-arities #{1 2}, :end-row 239, :ns "cljs.analyzer.api", :name "ns-interns", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns]" "[state ns]"], :doc "Given a namespace return all the var analysis maps. Analagous to\n  clojure.core/ns-interns but returns var analysis maps not vars.", :row 230} {:fixed-arities #{1 2}, :end-row 252, :ns "cljs.analyzer.api", :name "ns-publics", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns]" "[state ns]"], :doc "Given a namespace return all the public var analysis maps. Analagous to\n  clojure.core/ns-publics but returns var analysis maps not vars.", :row 241} {:fixed-arities #{3 2}, :end-row 261, :ns "cljs.analyzer.api", :name "ns-resolve", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns sym]" "[state ns sym]"], :doc "Given a namespace and a symbol return the corresponding var analysis map.\n  Analagous to clojure.core/ns-resolve but returns var analysis map not Var.", :row 254} {:fixed-arities #{1 2}, :end-row 269, :ns "cljs.analyzer.api", :name "remove-ns", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns]" "[state ns]"], :doc "Removes the namespace named by the symbol.", :row 263} {:end-row 277, :ns "cljs.analyzer.api", :name "in-cljs-user", :lang :clj, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[env & body]"], :doc "Binds cljs.analyzer/*cljs-ns* to 'cljs.user and uses the given compilation\n  environment atom and runs body.", :row 271} {:fixed-arities #{0 1}, :end-row 34, :ns "cljs.analyzer.api", :name "empty-state", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[opts]"], :doc "Creates an empty compilation state Atom<Map>. The optional opts arg is a map\n   representing the compiler configuration. See the documentation\n   for details: https://clojurescript.org/reference/compiler-options", :row 25} {:fixed-arities #{0}, :end-row 39, :ns "cljs.analyzer.api", :name "current-state", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Return the current compiler state atom.", :row 36} {:fixed-arities #{0}, :end-row 44, :ns "cljs.analyzer.api", :name "current-file", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Return the current file under analysis or compilation.", :row 41} {:fixed-arities #{0}, :end-row 49, :ns "cljs.analyzer.api", :name "current-ns", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Return the current ns under analysis or compilation.", :row 46} {:end-row 55, :ns "cljs.analyzer.api", :name "with-state", :lang :cljs, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[state & body]"], :doc "Run the body with the given compilation state Atom<Map>.", :row 51} {:fixed-arities #{0}, :end-row 60, :ns "cljs.analyzer.api", :name "empty-env", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Creates an empty analysis environment.", :row 57} {:end-row 67, :ns "cljs.analyzer.api", :name "no-warn", :lang :cljs, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Disable analyzer warnings for any analysis executed in body.", :row 62} {:fixed-arities #{1}, :end-row 72, :ns "cljs.analyzer.api", :name "warning-enabled?", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[warning-type]"], :doc "Test if the given warning-type is enabled.", :row 69} {:fixed-arities #{3}, :end-row 79, :ns "cljs.analyzer.api", :name "default-warning-handler", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[warning-type env extra]"], :doc "The default warning handler.\n\n   Outputs the warning messages to *err*.", :row 74} {:end-row 89, :ns "cljs.analyzer.api", :name "with-warning-handlers", :lang :cljs, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[handlers & body]"], :doc "Helper macro for custom handling of emitted warnings. Handlers should be\n   a vector of functions. The signature of these functions is\n   [warn-type env warn-info]. warn-type is a keyword describing the warning,\n   env is the analysis environment, and warn-info is a map of extra useful\n   information for a particular warning type.", :row 81} {:fixed-arities #{2}, :end-row 95, :ns "cljs.analyzer.api", :name "warning-message", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[warn-type warn-info]"], :doc "Helper for generating the standard analyzer messages for warnings. Should be\n  passed warn-type and warn-info. See with-warning-handlers.", :row 91} {:fixed-arities #{0}, :end-row 100, :ns "cljs.analyzer.api", :name "enabled-warnings", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Get the enabled warning types.", :row 97} {:fixed-arities #{0 1}, :end-row 106, :ns "cljs.analyzer.api", :name "get-options", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[state]"], :doc "Return the compiler options from compiler state.", :row 102} {:fixed-arities #{0 1}, :end-row 113, :ns "cljs.analyzer.api", :name "get-js-index", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[state]"], :doc "Return the currently computed Google Closure js dependency index from the\n  compiler state.", :row 108} {:doc "ClojureScript's default analysis passes.", :end-row 117, :filename "cljs/analyzer/api.cljc", :lang :cljs, :name "default-passes", :ns "cljs.analyzer.api", :row 115} {:end-row 123, :ns "cljs.analyzer.api", :name "with-passes", :lang :cljs, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[passes & body]"], :doc "Evaluate the body with the provided sequence of compiler passes.", :row 119} {:fixed-arities #{2}, :end-row 211, :ns "cljs.analyzer.api", :name "resolve", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[env sym]"], :doc "Given an analysis environment resolve a var. Analogous to\n   clojure.core/resolve", :row 201} {:fixed-arities #{0 1}, :end-row 219, :ns "cljs.analyzer.api", :name "all-ns", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[state]"], :doc "Return all namespaces. Analagous to clojure.core/all-ns but\n  returns symbols identifying namespaces not Namespace instances.", :row 213} {:fixed-arities #{1 2}, :end-row 228, :ns "cljs.analyzer.api", :name "find-ns", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[sym]" "[state sym]"], :doc "Given a namespace return the corresponding namespace analysis map. Analagous\n  to clojure.core/find-ns.", :row 221} {:fixed-arities #{1 2}, :end-row 239, :ns "cljs.analyzer.api", :name "ns-interns", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns]" "[state ns]"], :doc "Given a namespace return all the var analysis maps. Analagous to\n  clojure.core/ns-interns but returns var analysis maps not vars.", :row 230} {:fixed-arities #{1 2}, :end-row 252, :ns "cljs.analyzer.api", :name "ns-publics", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns]" "[state ns]"], :doc "Given a namespace return all the public var analysis maps. Analagous to\n  clojure.core/ns-publics but returns var analysis maps not vars.", :row 241} {:fixed-arities #{3 2}, :end-row 261, :ns "cljs.analyzer.api", :name "ns-resolve", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns sym]" "[state ns sym]"], :doc "Given a namespace and a symbol return the corresponding var analysis map.\n  Analagous to clojure.core/ns-resolve but returns var analysis map not Var.", :row 254} {:fixed-arities #{1 2}, :end-row 269, :ns "cljs.analyzer.api", :name "remove-ns", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns]" "[state ns]"], :doc "Removes the namespace named by the symbol.", :row 263} {:end-row 277, :ns "cljs.analyzer.api", :name "in-cljs-user", :lang :cljs, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[env & body]"], :doc "Binds cljs.analyzer/*cljs-ns* to 'cljs.user and uses the given compilation\n  environment atom and runs body.", :row 271}]} {:doc "This is intended to be a stable api for those who need programmatic access\n  to the analyzer.", :end-row 20, :filename "cljs/analyzer/api.cljc", :lang :cljs, :name "cljs.analyzer.api", :row 9, :ns nil, :var-definitions [{:fixed-arities #{0 1}, :end-row 34, :ns "cljs.analyzer.api", :name "empty-state", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[opts]"], :doc "Creates an empty compilation state Atom<Map>. The optional opts arg is a map\n   representing the compiler configuration. See the documentation\n   for details: https://clojurescript.org/reference/compiler-options", :row 25} {:fixed-arities #{0}, :end-row 39, :ns "cljs.analyzer.api", :name "current-state", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Return the current compiler state atom.", :row 36} {:fixed-arities #{0}, :end-row 44, :ns "cljs.analyzer.api", :name "current-file", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Return the current file under analysis or compilation.", :row 41} {:fixed-arities #{0}, :end-row 49, :ns "cljs.analyzer.api", :name "current-ns", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Return the current ns under analysis or compilation.", :row 46} {:end-row 55, :ns "cljs.analyzer.api", :name "with-state", :lang :clj, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[state & body]"], :doc "Run the body with the given compilation state Atom<Map>.", :row 51} {:fixed-arities #{0}, :end-row 60, :ns "cljs.analyzer.api", :name "empty-env", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Creates an empty analysis environment.", :row 57} {:end-row 67, :ns "cljs.analyzer.api", :name "no-warn", :lang :clj, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Disable analyzer warnings for any analysis executed in body.", :row 62} {:fixed-arities #{1}, :end-row 72, :ns "cljs.analyzer.api", :name "warning-enabled?", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[warning-type]"], :doc "Test if the given warning-type is enabled.", :row 69} {:fixed-arities #{3}, :end-row 79, :ns "cljs.analyzer.api", :name "default-warning-handler", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[warning-type env extra]"], :doc "The default warning handler.\n\n   Outputs the warning messages to *err*.", :row 74} {:end-row 89, :ns "cljs.analyzer.api", :name "with-warning-handlers", :lang :clj, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[handlers & body]"], :doc "Helper macro for custom handling of emitted warnings. Handlers should be\n   a vector of functions. The signature of these functions is\n   [warn-type env warn-info]. warn-type is a keyword describing the warning,\n   env is the analysis environment, and warn-info is a map of extra useful\n   information for a particular warning type.", :row 81} {:fixed-arities #{2}, :end-row 95, :ns "cljs.analyzer.api", :name "warning-message", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[warn-type warn-info]"], :doc "Helper for generating the standard analyzer messages for warnings. Should be\n  passed warn-type and warn-info. See with-warning-handlers.", :row 91} {:fixed-arities #{0}, :end-row 100, :ns "cljs.analyzer.api", :name "enabled-warnings", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Get the enabled warning types.", :row 97} {:fixed-arities #{0 1}, :end-row 106, :ns "cljs.analyzer.api", :name "get-options", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[state]"], :doc "Return the compiler options from compiler state.", :row 102} {:fixed-arities #{0 1}, :end-row 113, :ns "cljs.analyzer.api", :name "get-js-index", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[state]"], :doc "Return the currently computed Google Closure js dependency index from the\n  compiler state.", :row 108} {:doc "ClojureScript's default analysis passes.", :end-row 117, :filename "cljs/analyzer/api.cljc", :lang :clj, :name "default-passes", :ns "cljs.analyzer.api", :row 115} {:end-row 123, :ns "cljs.analyzer.api", :name "with-passes", :lang :clj, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[passes & body]"], :doc "Evaluate the body with the provided sequence of compiler passes.", :row 119} {:fixed-arities #{4 3 2 5}, :end-row 141, :ns "cljs.analyzer.api", :name "analyze", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[env form]" "[env form name]" "[env form name opts]" "[state env form name opts]"], :doc "Given an environment, a map containing {:locals (mapping of names to bindings), :context\n     (one of :statement, :expr, :return), :ns (a symbol naming the\n     compilation ns)}, and form, returns an expression object (a map\n     containing at least :form, :op and :env keys). If expr has any (immediately)\n     nested exprs, must have :children entry. This must be a vector of keywords naming\n     the immediately nested fields mapped to an expr or vector of exprs. This will\n     facilitate code walking without knowing the details of the op set.", :row 126} {:fixed-arities #{1 2}, :end-row 148, :ns "cljs.analyzer.api", :name "forms-seq", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[rdr]" "[rdr filename]"], :doc "Seq of Clojure/ClojureScript forms from rdr, a java.io.Reader. Optionally\n     accepts a filename argument which will be used in any emitted errors.", :row 144} {:fixed-arities #{1 4 3 2}, :end-row 168, :ns "cljs.analyzer.api", :name "parse-ns", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[src]" "[src opts]" "[src dest opts]" "[state src dest opts]"], :doc "Helper for parsing only the essential namespace information from a\n      ClojureScript source file and returning a cljs.closure/IJavaScript compatible\n      map _not_ a namespace AST node.\n\n      By default does not load macros or perform any analysis of dependencies. If\n      opts parameter provided :analyze-deps and :load-macros keys their values will\n      be used for *analyze-deps* and *load-macros* bindings respectively. This\n      function does _not_ side-effect the ambient compilation environment unless\n      requested via opts where :restore is false.", :row 151} {:fixed-arities #{1 3 2}, :end-row 186, :ns "cljs.analyzer.api", :name "analyze-file", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[f]" "[f opts]" "[state f opts]"], :doc "Given a java.io.File, java.net.URL or a string identifying a resource on the\n      classpath attempt to analyze it.\n\n      This function side-effects the ambient compilation environment\n      `cljs.env/*compiler*` to aggregate analysis information. opts argument is\n      compiler options, if :cache-analysis true will cache analysis to\n      \":output-dir/some/ns/foo.cljs.cache.edn\". This function does not return a\n      meaningful value.", :row 171} {:fixed-arities #{1}, :end-row 196, :ns "cljs.analyzer.api", :name "read-analysis-cache", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[cache-file]"], :doc "Read an analysis cache.", :row 189} {:fixed-arities #{2}, :end-row 211, :ns "cljs.analyzer.api", :name "resolve", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[env sym]"], :doc "Given an analysis environment resolve a var. Analogous to\n   clojure.core/resolve", :row 201} {:fixed-arities #{0 1}, :end-row 219, :ns "cljs.analyzer.api", :name "all-ns", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[state]"], :doc "Return all namespaces. Analagous to clojure.core/all-ns but\n  returns symbols identifying namespaces not Namespace instances.", :row 213} {:fixed-arities #{1 2}, :end-row 228, :ns "cljs.analyzer.api", :name "find-ns", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[sym]" "[state sym]"], :doc "Given a namespace return the corresponding namespace analysis map. Analagous\n  to clojure.core/find-ns.", :row 221} {:fixed-arities #{1 2}, :end-row 239, :ns "cljs.analyzer.api", :name "ns-interns", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns]" "[state ns]"], :doc "Given a namespace return all the var analysis maps. Analagous to\n  clojure.core/ns-interns but returns var analysis maps not vars.", :row 230} {:fixed-arities #{1 2}, :end-row 252, :ns "cljs.analyzer.api", :name "ns-publics", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns]" "[state ns]"], :doc "Given a namespace return all the public var analysis maps. Analagous to\n  clojure.core/ns-publics but returns var analysis maps not vars.", :row 241} {:fixed-arities #{3 2}, :end-row 261, :ns "cljs.analyzer.api", :name "ns-resolve", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns sym]" "[state ns sym]"], :doc "Given a namespace and a symbol return the corresponding var analysis map.\n  Analagous to clojure.core/ns-resolve but returns var analysis map not Var.", :row 254} {:fixed-arities #{1 2}, :end-row 269, :ns "cljs.analyzer.api", :name "remove-ns", :lang :clj, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns]" "[state ns]"], :doc "Removes the namespace named by the symbol.", :row 263} {:end-row 277, :ns "cljs.analyzer.api", :name "in-cljs-user", :lang :clj, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[env & body]"], :doc "Binds cljs.analyzer/*cljs-ns* to 'cljs.user and uses the given compilation\n  environment atom and runs body.", :row 271} {:fixed-arities #{0 1}, :end-row 34, :ns "cljs.analyzer.api", :name "empty-state", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[opts]"], :doc "Creates an empty compilation state Atom<Map>. The optional opts arg is a map\n   representing the compiler configuration. See the documentation\n   for details: https://clojurescript.org/reference/compiler-options", :row 25} {:fixed-arities #{0}, :end-row 39, :ns "cljs.analyzer.api", :name "current-state", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Return the current compiler state atom.", :row 36} {:fixed-arities #{0}, :end-row 44, :ns "cljs.analyzer.api", :name "current-file", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Return the current file under analysis or compilation.", :row 41} {:fixed-arities #{0}, :end-row 49, :ns "cljs.analyzer.api", :name "current-ns", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Return the current ns under analysis or compilation.", :row 46} {:end-row 55, :ns "cljs.analyzer.api", :name "with-state", :lang :cljs, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[state & body]"], :doc "Run the body with the given compilation state Atom<Map>.", :row 51} {:fixed-arities #{0}, :end-row 60, :ns "cljs.analyzer.api", :name "empty-env", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Creates an empty analysis environment.", :row 57} {:end-row 67, :ns "cljs.analyzer.api", :name "no-warn", :lang :cljs, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Disable analyzer warnings for any analysis executed in body.", :row 62} {:fixed-arities #{1}, :end-row 72, :ns "cljs.analyzer.api", :name "warning-enabled?", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[warning-type]"], :doc "Test if the given warning-type is enabled.", :row 69} {:fixed-arities #{3}, :end-row 79, :ns "cljs.analyzer.api", :name "default-warning-handler", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[warning-type env extra]"], :doc "The default warning handler.\n\n   Outputs the warning messages to *err*.", :row 74} {:end-row 89, :ns "cljs.analyzer.api", :name "with-warning-handlers", :lang :cljs, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[handlers & body]"], :doc "Helper macro for custom handling of emitted warnings. Handlers should be\n   a vector of functions. The signature of these functions is\n   [warn-type env warn-info]. warn-type is a keyword describing the warning,\n   env is the analysis environment, and warn-info is a map of extra useful\n   information for a particular warning type.", :row 81} {:fixed-arities #{2}, :end-row 95, :ns "cljs.analyzer.api", :name "warning-message", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[warn-type warn-info]"], :doc "Helper for generating the standard analyzer messages for warnings. Should be\n  passed warn-type and warn-info. See with-warning-handlers.", :row 91} {:fixed-arities #{0}, :end-row 100, :ns "cljs.analyzer.api", :name "enabled-warnings", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]"], :doc "Get the enabled warning types.", :row 97} {:fixed-arities #{0 1}, :end-row 106, :ns "cljs.analyzer.api", :name "get-options", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[state]"], :doc "Return the compiler options from compiler state.", :row 102} {:fixed-arities #{0 1}, :end-row 113, :ns "cljs.analyzer.api", :name "get-js-index", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[state]"], :doc "Return the currently computed Google Closure js dependency index from the\n  compiler state.", :row 108} {:doc "ClojureScript's default analysis passes.", :end-row 117, :filename "cljs/analyzer/api.cljc", :lang :cljs, :name "default-passes", :ns "cljs.analyzer.api", :row 115} {:end-row 123, :ns "cljs.analyzer.api", :name "with-passes", :lang :cljs, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[passes & body]"], :doc "Evaluate the body with the provided sequence of compiler passes.", :row 119} {:fixed-arities #{2}, :end-row 211, :ns "cljs.analyzer.api", :name "resolve", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[env sym]"], :doc "Given an analysis environment resolve a var. Analogous to\n   clojure.core/resolve", :row 201} {:fixed-arities #{0 1}, :end-row 219, :ns "cljs.analyzer.api", :name "all-ns", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[]" "[state]"], :doc "Return all namespaces. Analagous to clojure.core/all-ns but\n  returns symbols identifying namespaces not Namespace instances.", :row 213} {:fixed-arities #{1 2}, :end-row 228, :ns "cljs.analyzer.api", :name "find-ns", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[sym]" "[state sym]"], :doc "Given a namespace return the corresponding namespace analysis map. Analagous\n  to clojure.core/find-ns.", :row 221} {:fixed-arities #{1 2}, :end-row 239, :ns "cljs.analyzer.api", :name "ns-interns", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns]" "[state ns]"], :doc "Given a namespace return all the var analysis maps. Analagous to\n  clojure.core/ns-interns but returns var analysis maps not vars.", :row 230} {:fixed-arities #{1 2}, :end-row 252, :ns "cljs.analyzer.api", :name "ns-publics", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns]" "[state ns]"], :doc "Given a namespace return all the public var analysis maps. Analagous to\n  clojure.core/ns-publics but returns var analysis maps not vars.", :row 241} {:fixed-arities #{3 2}, :end-row 261, :ns "cljs.analyzer.api", :name "ns-resolve", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns sym]" "[state ns sym]"], :doc "Given a namespace and a symbol return the corresponding var analysis map.\n  Analagous to clojure.core/ns-resolve but returns var analysis map not Var.", :row 254} {:fixed-arities #{1 2}, :end-row 269, :ns "cljs.analyzer.api", :name "remove-ns", :lang :cljs, :filename "cljs/analyzer/api.cljc", :arglist-strs ["[ns]" "[state ns]"], :doc "Removes the namespace named by the symbol.", :row 263} {:end-row 277, :ns "cljs.analyzer.api", :name "in-cljs-user", :lang :cljs, :filename "cljs/analyzer/api.cljc", :macro true, :arglist-strs ["[env & body]"], :doc "Binds cljs.analyzer/*cljs-ns* to 'cljs.user and uses the given compilation\n  environment atom and runs body.", :row 271}]} {:end-row 10, :filename "cljs/analyzer/macros.clj", :name "cljs.analyzer.macros", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[handlers & body]"], :end-row 14, :filename "cljs/analyzer/macros.clj", :macro true, :name "with-warning-handlers", :ns "cljs.analyzer.macros", :row 12} {:arglist-strs ["[& body]"], :end-row 19, :filename "cljs/analyzer/macros.clj", :macro true, :name "no-warn", :ns "cljs.analyzer.macros", :row 16} {:arglist-strs ["[path & body]"], :end-row 27, :filename "cljs/analyzer/macros.clj", :macro true, :name "with-core-macros", :ns "cljs.analyzer.macros", :row 21} {:arglist-strs ["[path & body]"], :end-row 36, :filename "cljs/analyzer/macros.clj", :macro true, :name "with-core-macros-file", :ns "cljs.analyzer.macros", :row 29} {:arglist-strs ["[env & body]"], :end-row 45, :filename "cljs/analyzer/macros.clj", :macro true, :name "wrapping-errors", :ns "cljs.analyzer.macros", :row 38} {:arglist-strs ["[& body]"], :end-row 50, :filename "cljs/analyzer/macros.clj", :macro true, :name "disallowing-recur", :ns "cljs.analyzer.macros", :row 47} {:arglist-strs ["[& body]"], :end-row 54, :filename "cljs/analyzer/macros.clj", :macro true, :name "allowing-redef", :ns "cljs.analyzer.macros", :row 52} {:arglist-strs ["[& body]"], :end-row 57, :filename "cljs/analyzer/macros.clj", :macro true, :name "disallowing-ns*", :ns "cljs.analyzer.macros", :row 56}]} {:end-row 9, :filename "cljs/analyzer/impl.cljc", :lang :clj, :name "cljs.analyzer.impl", :row 9, :ns nil, :var-definitions [{:end-row 11, :filename "cljs/analyzer/impl.cljc", :lang :clj, :name "ANY_SYM", :ns "cljs.analyzer.impl", :row 11} {:end-row 13, :filename "cljs/analyzer/impl.cljc", :lang :clj, :name "BOOLEAN_OR_SEQ", :ns "cljs.analyzer.impl", :row 13} {:end-row 15, :filename "cljs/analyzer/impl.cljc", :lang :clj, :name "BOOLEAN_SYM", :ns "cljs.analyzer.impl", :row 15} {:end-row 29, :filename "cljs/analyzer/impl.cljc", :lang :clj, :name "IGNORE_SYM", :ns "cljs.analyzer.impl", :row 29} {:end-row 37, :filename "cljs/analyzer/impl.cljc", :lang :clj, :name "NOT_NATIVE", :ns "cljs.analyzer.impl", :row 37} {:end-row 11, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "ANY_SYM", :ns "cljs.analyzer.impl", :row 11} {:end-row 13, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "BOOLEAN_OR_SEQ", :ns "cljs.analyzer.impl", :row 13} {:end-row 15, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "BOOLEAN_SYM", :ns "cljs.analyzer.impl", :row 15} {:end-row 18, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "CLJ_NIL_SYM", :ns "cljs.analyzer.impl", :row 18} {:end-row 21, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "CLJS_CORE_MACROS_SYM", :ns "cljs.analyzer.impl", :row 21} {:end-row 24, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "CLJS_CORE_SYM", :ns "cljs.analyzer.impl", :row 24} {:end-row 27, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "DOT_SYM", :ns "cljs.analyzer.impl", :row 27} {:end-row 29, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "IGNORE_SYM", :ns "cljs.analyzer.impl", :row 29} {:end-row 32, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "JS_STAR_SYM", :ns "cljs.analyzer.impl", :row 32} {:end-row 35, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "NEW_SYM", :ns "cljs.analyzer.impl", :row 35} {:end-row 37, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "NOT_NATIVE", :ns "cljs.analyzer.impl", :row 37} {:end-row 40, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "NUMBER_SYM", :ns "cljs.analyzer.impl", :row 40} {:end-row 43, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "STRING_SYM", :ns "cljs.analyzer.impl", :row 43} {:arglist-strs ["[x]"], :end-row 47, :filename "cljs/analyzer/impl.cljc", :fixed-arities #{1}, :lang :cljs, :name "cljs-map?", :ns "cljs.analyzer.impl", :row 46} {:arglist-strs ["[x]"], :end-row 51, :filename "cljs/analyzer/impl.cljc", :fixed-arities #{1}, :lang :cljs, :name "cljs-seq?", :ns "cljs.analyzer.impl", :row 50} {:arglist-strs ["[x]"], :end-row 55, :filename "cljs/analyzer/impl.cljc", :fixed-arities #{1}, :lang :cljs, :name "cljs-vector?", :ns "cljs.analyzer.impl", :row 54} {:arglist-strs ["[x]"], :end-row 59, :filename "cljs/analyzer/impl.cljc", :fixed-arities #{1}, :lang :cljs, :name "cljs-set?", :ns "cljs.analyzer.impl", :row 58}]} {:end-row 9, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "cljs.analyzer.impl", :row 9, :ns nil, :var-definitions [{:end-row 11, :filename "cljs/analyzer/impl.cljc", :lang :clj, :name "ANY_SYM", :ns "cljs.analyzer.impl", :row 11} {:end-row 13, :filename "cljs/analyzer/impl.cljc", :lang :clj, :name "BOOLEAN_OR_SEQ", :ns "cljs.analyzer.impl", :row 13} {:end-row 15, :filename "cljs/analyzer/impl.cljc", :lang :clj, :name "BOOLEAN_SYM", :ns "cljs.analyzer.impl", :row 15} {:end-row 29, :filename "cljs/analyzer/impl.cljc", :lang :clj, :name "IGNORE_SYM", :ns "cljs.analyzer.impl", :row 29} {:end-row 37, :filename "cljs/analyzer/impl.cljc", :lang :clj, :name "NOT_NATIVE", :ns "cljs.analyzer.impl", :row 37} {:end-row 11, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "ANY_SYM", :ns "cljs.analyzer.impl", :row 11} {:end-row 13, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "BOOLEAN_OR_SEQ", :ns "cljs.analyzer.impl", :row 13} {:end-row 15, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "BOOLEAN_SYM", :ns "cljs.analyzer.impl", :row 15} {:end-row 18, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "CLJ_NIL_SYM", :ns "cljs.analyzer.impl", :row 18} {:end-row 21, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "CLJS_CORE_MACROS_SYM", :ns "cljs.analyzer.impl", :row 21} {:end-row 24, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "CLJS_CORE_SYM", :ns "cljs.analyzer.impl", :row 24} {:end-row 27, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "DOT_SYM", :ns "cljs.analyzer.impl", :row 27} {:end-row 29, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "IGNORE_SYM", :ns "cljs.analyzer.impl", :row 29} {:end-row 32, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "JS_STAR_SYM", :ns "cljs.analyzer.impl", :row 32} {:end-row 35, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "NEW_SYM", :ns "cljs.analyzer.impl", :row 35} {:end-row 37, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "NOT_NATIVE", :ns "cljs.analyzer.impl", :row 37} {:end-row 40, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "NUMBER_SYM", :ns "cljs.analyzer.impl", :row 40} {:end-row 43, :filename "cljs/analyzer/impl.cljc", :lang :cljs, :name "STRING_SYM", :ns "cljs.analyzer.impl", :row 43} {:arglist-strs ["[x]"], :end-row 47, :filename "cljs/analyzer/impl.cljc", :fixed-arities #{1}, :lang :cljs, :name "cljs-map?", :ns "cljs.analyzer.impl", :row 46} {:arglist-strs ["[x]"], :end-row 51, :filename "cljs/analyzer/impl.cljc", :fixed-arities #{1}, :lang :cljs, :name "cljs-seq?", :ns "cljs.analyzer.impl", :row 50} {:arglist-strs ["[x]"], :end-row 55, :filename "cljs/analyzer/impl.cljc", :fixed-arities #{1}, :lang :cljs, :name "cljs-vector?", :ns "cljs.analyzer.impl", :row 54} {:arglist-strs ["[x]"], :end-row 59, :filename "cljs/analyzer/impl.cljc", :fixed-arities #{1}, :lang :cljs, :name "cljs-set?", :ns "cljs.analyzer.impl", :row 58}]} {:end-row 9, :filename "cljs/analyzer/impl/namespaces.cljc", :lang :clj, :name "cljs.analyzer.impl.namespaces", :row 9, :ns nil, :var-definitions [{:fixed-arities #{1}, :end-row 29, :ns "cljs.analyzer.impl.namespaces", :name "check-and-remove-as-alias", :lang :clj, :filename "cljs/analyzer/impl/namespaces.cljc", :arglist-strs ["[libspec]"], :doc "Given a libspec return a map of :as-alias alias, if was present. Return the\n   libspec with :as-alias elided. If the libspec was *only* :as-alias do not\n   return it.", :row 11} {:arglist-strs ["[as-aliases new-as-aliases]"], :end-row 36, :filename "cljs/analyzer/impl/namespaces.cljc", :fixed-arities #{2}, :lang :clj, :name "check-as-alias-duplicates", :ns "cljs.analyzer.impl.namespaces", :row 31} {:fixed-arities #{1 2}, :end-row 53, :ns "cljs.analyzer.impl.namespaces", :name "elide-aliases-from-libspecs", :lang :clj, :filename "cljs/analyzer/impl/namespaces.cljc", :arglist-strs ["[libspecs]" "[libspecs as-aliases]"], :doc "Given libspecs, elide all :as-alias. Return a map of :libspecs (filtered)\n   and :as-aliases.", :row 38} {:arglist-strs ["[ns-specs]"], :end-row 68, :filename "cljs/analyzer/impl/namespaces.cljc", :fixed-arities #{1}, :lang :clj, :name "elide-aliases-from-ns-specs", :ns "cljs.analyzer.impl.namespaces", :row 55} {:fixed-arities #{1}, :end-row 29, :ns "cljs.analyzer.impl.namespaces", :name "check-and-remove-as-alias", :lang :cljs, :filename "cljs/analyzer/impl/namespaces.cljc", :arglist-strs ["[libspec]"], :doc "Given a libspec return a map of :as-alias alias, if was present. Return the\n   libspec with :as-alias elided. If the libspec was *only* :as-alias do not\n   return it.", :row 11} {:arglist-strs ["[as-aliases new-as-aliases]"], :end-row 36, :filename "cljs/analyzer/impl/namespaces.cljc", :fixed-arities #{2}, :lang :cljs, :name "check-as-alias-duplicates", :ns "cljs.analyzer.impl.namespaces", :row 31} {:fixed-arities #{1 2}, :end-row 53, :ns "cljs.analyzer.impl.namespaces", :name "elide-aliases-from-libspecs", :lang :cljs, :filename "cljs/analyzer/impl/namespaces.cljc", :arglist-strs ["[libspecs]" "[libspecs as-aliases]"], :doc "Given libspecs, elide all :as-alias. Return a map of :libspecs (filtered)\n   and :as-aliases.", :row 38} {:arglist-strs ["[ns-specs]"], :end-row 68, :filename "cljs/analyzer/impl/namespaces.cljc", :fixed-arities #{1}, :lang :cljs, :name "elide-aliases-from-ns-specs", :ns "cljs.analyzer.impl.namespaces", :row 55}]} {:end-row 9, :filename "cljs/analyzer/impl/namespaces.cljc", :lang :cljs, :name "cljs.analyzer.impl.namespaces", :row 9, :ns nil, :var-definitions [{:fixed-arities #{1}, :end-row 29, :ns "cljs.analyzer.impl.namespaces", :name "check-and-remove-as-alias", :lang :clj, :filename "cljs/analyzer/impl/namespaces.cljc", :arglist-strs ["[libspec]"], :doc "Given a libspec return a map of :as-alias alias, if was present. Return the\n   libspec with :as-alias elided. If the libspec was *only* :as-alias do not\n   return it.", :row 11} {:arglist-strs ["[as-aliases new-as-aliases]"], :end-row 36, :filename "cljs/analyzer/impl/namespaces.cljc", :fixed-arities #{2}, :lang :clj, :name "check-as-alias-duplicates", :ns "cljs.analyzer.impl.namespaces", :row 31} {:fixed-arities #{1 2}, :end-row 53, :ns "cljs.analyzer.impl.namespaces", :name "elide-aliases-from-libspecs", :lang :clj, :filename "cljs/analyzer/impl/namespaces.cljc", :arglist-strs ["[libspecs]" "[libspecs as-aliases]"], :doc "Given libspecs, elide all :as-alias. Return a map of :libspecs (filtered)\n   and :as-aliases.", :row 38} {:arglist-strs ["[ns-specs]"], :end-row 68, :filename "cljs/analyzer/impl/namespaces.cljc", :fixed-arities #{1}, :lang :clj, :name "elide-aliases-from-ns-specs", :ns "cljs.analyzer.impl.namespaces", :row 55} {:fixed-arities #{1}, :end-row 29, :ns "cljs.analyzer.impl.namespaces", :name "check-and-remove-as-alias", :lang :cljs, :filename "cljs/analyzer/impl/namespaces.cljc", :arglist-strs ["[libspec]"], :doc "Given a libspec return a map of :as-alias alias, if was present. Return the\n   libspec with :as-alias elided. If the libspec was *only* :as-alias do not\n   return it.", :row 11} {:arglist-strs ["[as-aliases new-as-aliases]"], :end-row 36, :filename "cljs/analyzer/impl/namespaces.cljc", :fixed-arities #{2}, :lang :cljs, :name "check-as-alias-duplicates", :ns "cljs.analyzer.impl.namespaces", :row 31} {:fixed-arities #{1 2}, :end-row 53, :ns "cljs.analyzer.impl.namespaces", :name "elide-aliases-from-libspecs", :lang :cljs, :filename "cljs/analyzer/impl/namespaces.cljc", :arglist-strs ["[libspecs]" "[libspecs as-aliases]"], :doc "Given libspecs, elide all :as-alias. Return a map of :libspecs (filtered)\n   and :as-aliases.", :row 38} {:arglist-strs ["[ns-specs]"], :end-row 68, :filename "cljs/analyzer/impl/namespaces.cljc", :fixed-arities #{1}, :lang :cljs, :name "elide-aliases-from-ns-specs", :ns "cljs.analyzer.impl.namespaces", :row 55}]} {:end-row 10, :filename "cljs/analyzer/utils.clj", :name "cljs.analyzer.utils", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[_ {:keys [op] :as ast}]"], :end-row 19, :filename "cljs/analyzer/utils.clj", :fixed-arities #{2}, :name "simplify-env", :ns "cljs.analyzer.utils", :row 12} {:arglist-strs ["[_ ast]"], :end-row 22, :filename "cljs/analyzer/utils.clj", :fixed-arities #{2}, :name "elide-children", :ns "cljs.analyzer.utils", :row 21} {:arglist-strs ["[form]" "[ns form]"], :end-row 31, :filename "cljs/analyzer/utils.clj", :fixed-arities #{1 2}, :name "to-ast", :ns "cljs.analyzer.utils", :row 24}]} {:end-row 9, :filename "cljs/analyzer/passes.cljc", :lang :clj, :name "cljs.analyzer.passes", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[ast passes]" "[ast passes opts]"], :end-row 18, :filename "cljs/analyzer/passes.cljc", :fixed-arities #{3 2}, :lang :clj, :name "apply-passes", :ns "cljs.analyzer.passes", :row 11} {:arglist-strs ["[ast passes]" "[ast passes opts]"], :end-row 32, :filename "cljs/analyzer/passes.cljc", :fixed-arities #{3 2}, :lang :clj, :name "walk", :ns "cljs.analyzer.passes", :row 20} {:arglist-strs ["[ast passes]" "[ast passes opts]"], :end-row 18, :filename "cljs/analyzer/passes.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "apply-passes", :ns "cljs.analyzer.passes", :row 11} {:arglist-strs ["[ast passes]" "[ast passes opts]"], :end-row 32, :filename "cljs/analyzer/passes.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "walk", :ns "cljs.analyzer.passes", :row 20}]} {:end-row 9, :filename "cljs/analyzer/passes.cljc", :lang :cljs, :name "cljs.analyzer.passes", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[ast passes]" "[ast passes opts]"], :end-row 18, :filename "cljs/analyzer/passes.cljc", :fixed-arities #{3 2}, :lang :clj, :name "apply-passes", :ns "cljs.analyzer.passes", :row 11} {:arglist-strs ["[ast passes]" "[ast passes opts]"], :end-row 32, :filename "cljs/analyzer/passes.cljc", :fixed-arities #{3 2}, :lang :clj, :name "walk", :ns "cljs.analyzer.passes", :row 20} {:arglist-strs ["[ast passes]" "[ast passes opts]"], :end-row 18, :filename "cljs/analyzer/passes.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "apply-passes", :ns "cljs.analyzer.passes", :row 11} {:arglist-strs ["[ast passes]" "[ast passes opts]"], :end-row 32, :filename "cljs/analyzer/passes.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "walk", :ns "cljs.analyzer.passes", :row 20}]} {:end-row 16, :filename "cljs/js_deps.cljc", :lang :clj, :name "cljs.js-deps", :row 9, :ns nil, :var-definitions [{:end-row 18, :filename "cljs/js_deps.cljc", :lang :clj, :name "java-8?", :ns "cljs.js-deps", :private true, :row 18} {:fixed-arities #{0}, :end-row 38, :private true, :ns "cljs.js-deps", :name "classpath-files", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[]"], :doc "Returns a list of classpath files. Under Java 8, walks up the parentage\n  chain of RT/baseLoader, concatenating any URLs it retrieves. Under Java 9 and\n  later, builds file list from the java.class.path system property.", :row 20} {:arglist-strs ["[jar-path]"], :end-row 46, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :clj, :name "zip-file", :ns "cljs.js-deps", :row 40} {:arglist-strs ["[jar-path]"], :end-row 51, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :clj, :name "jar-entry-names*", :ns "cljs.js-deps", :row 48} {:end-row 53, :filename "cljs/js_deps.cljc", :lang :clj, :name "jar-entry-names", :ns "cljs.js-deps", :row 53} {:fixed-arities #{2}, :end-row 62, :ns "cljs.js-deps", :name "find-js-jar", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[jar-path lib-path]"], :doc "Returns a seq of URLs of all JavaScript resources in the given jar", :row 55} {:end-row 64, :filename "cljs/js_deps.cljc", :lang :clj, :name "to-url", :ns "cljs.js-deps", :row 64} {:fixed-arities #{1}, :end-row 77, :ns "cljs.js-deps", :name "find-js-fs", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[path]"], :doc "finds js resources from a path on the files system", :row 72} {:fixed-arities #{1}, :end-row 98, :ns "cljs.js-deps", :name "find-js-classpath", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[path]"], :doc "Returns a seq of URLs of all JavaScript files on the classpath.", :row 79} {:arglist-strs ["[path]"], :end-row 107, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :clj, :name "find-js-resources", :ns "cljs.js-deps", :row 100} {:fixed-arities #{1}, :end-row 135, :ns "cljs.js-deps", :name "parse-js-ns", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[lines]"], :doc "Given the lines from a JavaScript source file, parse the provide\n  and require statements and return them in a map. Assumes that all\n  provide and require statements appear before the first function\n  definition.", :row 109} {:end-row 147, :filename "cljs/js_deps.cljc", :lang :clj, :name "IJavaScript", :ns "cljs.js-deps", :row 137} {:fixed-arities #{1}, :end-row 139, :ns "cljs.js-deps", :name "-foreign?", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "Whether the Javascript represents a foreign\n  library (a js file that not have any goog.provide statement", :row 138} {:fixed-arities #{1}, :end-row 141, :ns "cljs.js-deps", :name "-closure-lib?", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "Whether the Javascript represents a Closure style\n  library", :row 140} {:fixed-arities #{1 2}, :end-row 143, :ns "cljs.js-deps", :name "-url", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]" "[this opts]"], :doc "The URL where this JavaScript is located. Returns nil\n  when JavaScript exists in memory only.", :row 142} {:fixed-arities #{1 2}, :end-row 144, :ns "cljs.js-deps", :name "-relative-path", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]" "[this opts]"], :doc "Relative path for this JavaScript.", :row 144} {:fixed-arities #{1}, :end-row 145, :ns "cljs.js-deps", :name "-provides", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "A list of namespaces that this JavaScript provides.", :row 145} {:fixed-arities #{1}, :end-row 146, :ns "cljs.js-deps", :name "-requires", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "A list of namespaces that this JavaScript requires.", :row 146} {:fixed-arities #{1 2}, :end-row 147, :ns "cljs.js-deps", :name "-source", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]" "[this opts]"], :doc "The JavaScript source string.", :row 147} {:arglist-strs ["[lib-spec index]"], :end-row 152, :filename "cljs/js_deps.cljc", :fixed-arities #{2}, :lang :clj, :name "get-file", :ns "cljs.js-deps", :row 149} {:arglist-strs ["[a b]"], :end-row 157, :filename "cljs/js_deps.cljc", :fixed-arities #{2}, :lang :clj, :name "lib-spec-merge", :ns "cljs.js-deps", :row 154} {:fixed-arities #{1}, :end-row 194, :ns "cljs.js-deps", :name "build-index", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[deps]"], :doc "Index a list of dependencies by namespace and file name. There can\n  be zero or more namespaces provided per file. Upstream foreign libraies\n  will have their options merged with local foreign libraries to support\n  fine-grained overriding.", :row 159} {:arglist-strs ["[state ns-name]" "[state ns-name seen]"], :end-row 211, :filename "cljs/js_deps.cljc", :fixed-arities #{3 2}, :lang :clj, :name "dependency-order-visit", :ns "cljs.js-deps", :row 196} {:fixed-arities #{1}, :end-row 219, :private true, :ns "cljs.js-deps", :name "pack-string", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[s]"], :row 213} {:fixed-arities #{1}, :end-row 222, :private true, :ns "cljs.js-deps", :name "unpack-string", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[m]"], :row 221} {:fixed-arities #{1}, :end-row 230, :ns "cljs.js-deps", :name "dependency-order", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[coll]"], :doc "Topologically sort a collection of dependencies.", :row 224} {:fixed-arities #{1}, :end-row 248, :ns "cljs.js-deps", :name "find-url", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[path-or-url]"], :doc "Given a string, returns a URL. Attempts to resolve as a classpath-relative\n  path, then as a path relative to the working directory or a URL string", :row 240} {:fixed-arities #{1 2}, :end-row 262, :ns "cljs.js-deps", :name "load-foreign-library*", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[lib-spec]" "[lib-spec cp-only?]"], :doc "Given a library spec (a map containing the keys :file\n  and :provides), returns a map containing :provides, :requires, :file\n  and :url", :row 250} {:end-row 264, :filename "cljs/js_deps.cljc", :lang :clj, :name "load-foreign-library", :ns "cljs.js-deps", :row 264} {:fixed-arities #{1 2}, :end-row 276, :private true, :ns "cljs.js-deps", :name "library-graph-node", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[url]" "[url lib-path]"], :doc "Returns a map of :provides, :requires, and :url given a URL to a goog-style\nJavaScript library containing provide/require 'declarations'.", :row 266} {:fixed-arities #{1}, :end-row 285, :ns "cljs.js-deps", :name "load-library*", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[path]"], :doc "Given a path to a JavaScript library, which is a directory\n  containing Javascript files, return a list of maps\n  containing :provides, :requires, :file and :url.", :row 278} {:end-row 287, :filename "cljs/js_deps.cljc", :lang :clj, :name "load-library", :ns "cljs.js-deps", :row 287} {:arglist-strs ["[{libs :libs foreign-libs :foreign-libs ups-libs :ups-libs ups-flibs :ups-foreign-libs}]"], :end-row 298, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :clj, :name "library-dependencies", :ns "cljs.js-deps", :row 289} {:fixed-arities #{0}, :end-row 356, :ns "cljs.js-deps", :name "goog-dependencies*", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[]"], :doc "Create an index of Google dependencies by namespace and file name from\n  goog/deps.js", :row 327} {:end-row 358, :filename "cljs/js_deps.cljc", :lang :clj, :name "goog-dependencies", :ns "cljs.js-deps", :row 358} {:fixed-arities #{1}, :end-row 370, :ns "cljs.js-deps", :name "js-dependency-index", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[opts]"], :doc "Returns the index for all JavaScript dependencies. Lookup by\n  namespace or file name.", :row 360} {:fixed-arities #{1}, :end-row 393, :ns "cljs.js-deps", :name "find-classpath-lib", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[lib]"], :doc "Given [lib], a string or symbol naming a goog-style JavaScript library\n  (i.e. one that uses goog.provide and goog.require), look for a resource on the\n  classpath corresponding to [lib] and return a map via `library-graph-node`\n  that contains its relevant metadata.  The library found on the classpath\n  _must_ contain a `goog.provide` that matches [lib], or this fn will return nil\n  and print a warning.", :row 372} {:end-row 400, :filename "cljs/js_deps.cljc", :lang :clj, :name "native-node-modules", :ns "cljs.js-deps", :row 395} {:end-row 18, :filename "cljs/js_deps.cljc", :lang :cljs, :name "java-8?", :ns "cljs.js-deps", :private true, :row 18} {:fixed-arities #{0}, :end-row 38, :private true, :ns "cljs.js-deps", :name "classpath-files", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[]"], :doc "Returns a list of classpath files. Under Java 8, walks up the parentage\n  chain of RT/baseLoader, concatenating any URLs it retrieves. Under Java 9 and\n  later, builds file list from the java.class.path system property.", :row 20} {:arglist-strs ["[jar-path]"], :end-row 46, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :cljs, :name "zip-file", :ns "cljs.js-deps", :row 40} {:arglist-strs ["[jar-path]"], :end-row 51, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :cljs, :name "jar-entry-names*", :ns "cljs.js-deps", :row 48} {:end-row 53, :filename "cljs/js_deps.cljc", :lang :cljs, :name "jar-entry-names", :ns "cljs.js-deps", :row 53} {:fixed-arities #{2}, :end-row 62, :ns "cljs.js-deps", :name "find-js-jar", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[jar-path lib-path]"], :doc "Returns a seq of URLs of all JavaScript resources in the given jar", :row 55} {:end-row 64, :filename "cljs/js_deps.cljc", :lang :cljs, :name "to-url", :ns "cljs.js-deps", :row 64} {:fixed-arities #{1}, :end-row 77, :ns "cljs.js-deps", :name "find-js-fs", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[path]"], :doc "finds js resources from a path on the files system", :row 72} {:fixed-arities #{1}, :end-row 98, :ns "cljs.js-deps", :name "find-js-classpath", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[path]"], :doc "Returns a seq of URLs of all JavaScript files on the classpath.", :row 79} {:arglist-strs ["[path]"], :end-row 107, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :cljs, :name "find-js-resources", :ns "cljs.js-deps", :row 100} {:fixed-arities #{1}, :end-row 135, :ns "cljs.js-deps", :name "parse-js-ns", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[lines]"], :doc "Given the lines from a JavaScript source file, parse the provide\n  and require statements and return them in a map. Assumes that all\n  provide and require statements appear before the first function\n  definition.", :row 109} {:end-row 147, :filename "cljs/js_deps.cljc", :lang :cljs, :name "IJavaScript", :ns "cljs.js-deps", :row 137} {:fixed-arities #{1}, :end-row 139, :ns "cljs.js-deps", :name "-foreign?", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "Whether the Javascript represents a foreign\n  library (a js file that not have any goog.provide statement", :row 138} {:fixed-arities #{1}, :end-row 141, :ns "cljs.js-deps", :name "-closure-lib?", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "Whether the Javascript represents a Closure style\n  library", :row 140} {:fixed-arities #{1 2}, :end-row 143, :ns "cljs.js-deps", :name "-url", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]" "[this opts]"], :doc "The URL where this JavaScript is located. Returns nil\n  when JavaScript exists in memory only.", :row 142} {:fixed-arities #{1 2}, :end-row 144, :ns "cljs.js-deps", :name "-relative-path", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]" "[this opts]"], :doc "Relative path for this JavaScript.", :row 144} {:fixed-arities #{1}, :end-row 145, :ns "cljs.js-deps", :name "-provides", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "A list of namespaces that this JavaScript provides.", :row 145} {:fixed-arities #{1}, :end-row 146, :ns "cljs.js-deps", :name "-requires", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "A list of namespaces that this JavaScript requires.", :row 146} {:fixed-arities #{1 2}, :end-row 147, :ns "cljs.js-deps", :name "-source", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]" "[this opts]"], :doc "The JavaScript source string.", :row 147} {:arglist-strs ["[lib-spec index]"], :end-row 152, :filename "cljs/js_deps.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-file", :ns "cljs.js-deps", :row 149} {:arglist-strs ["[a b]"], :end-row 157, :filename "cljs/js_deps.cljc", :fixed-arities #{2}, :lang :cljs, :name "lib-spec-merge", :ns "cljs.js-deps", :row 154} {:fixed-arities #{1}, :end-row 194, :ns "cljs.js-deps", :name "build-index", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[deps]"], :doc "Index a list of dependencies by namespace and file name. There can\n  be zero or more namespaces provided per file. Upstream foreign libraies\n  will have their options merged with local foreign libraries to support\n  fine-grained overriding.", :row 159} {:arglist-strs ["[state ns-name]" "[state ns-name seen]"], :end-row 211, :filename "cljs/js_deps.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "dependency-order-visit", :ns "cljs.js-deps", :row 196} {:fixed-arities #{1}, :end-row 219, :private true, :ns "cljs.js-deps", :name "pack-string", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[s]"], :row 213} {:fixed-arities #{1}, :end-row 222, :private true, :ns "cljs.js-deps", :name "unpack-string", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[m]"], :row 221} {:fixed-arities #{1}, :end-row 230, :ns "cljs.js-deps", :name "dependency-order", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[coll]"], :doc "Topologically sort a collection of dependencies.", :row 224} {:fixed-arities #{1}, :end-row 248, :ns "cljs.js-deps", :name "find-url", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[path-or-url]"], :doc "Given a string, returns a URL. Attempts to resolve as a classpath-relative\n  path, then as a path relative to the working directory or a URL string", :row 240} {:fixed-arities #{1 2}, :end-row 262, :ns "cljs.js-deps", :name "load-foreign-library*", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[lib-spec]" "[lib-spec cp-only?]"], :doc "Given a library spec (a map containing the keys :file\n  and :provides), returns a map containing :provides, :requires, :file\n  and :url", :row 250} {:end-row 264, :filename "cljs/js_deps.cljc", :lang :cljs, :name "load-foreign-library", :ns "cljs.js-deps", :row 264} {:fixed-arities #{1 2}, :end-row 276, :private true, :ns "cljs.js-deps", :name "library-graph-node", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[url]" "[url lib-path]"], :doc "Returns a map of :provides, :requires, and :url given a URL to a goog-style\nJavaScript library containing provide/require 'declarations'.", :row 266} {:fixed-arities #{1}, :end-row 285, :ns "cljs.js-deps", :name "load-library*", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[path]"], :doc "Given a path to a JavaScript library, which is a directory\n  containing Javascript files, return a list of maps\n  containing :provides, :requires, :file and :url.", :row 278} {:end-row 287, :filename "cljs/js_deps.cljc", :lang :cljs, :name "load-library", :ns "cljs.js-deps", :row 287} {:arglist-strs ["[{libs :libs foreign-libs :foreign-libs ups-libs :ups-libs ups-flibs :ups-foreign-libs}]"], :end-row 298, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :cljs, :name "library-dependencies", :ns "cljs.js-deps", :row 289} {:fixed-arities #{0}, :end-row 356, :ns "cljs.js-deps", :name "goog-dependencies*", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[]"], :doc "Create an index of Google dependencies by namespace and file name from\n  goog/deps.js", :row 327} {:end-row 358, :filename "cljs/js_deps.cljc", :lang :cljs, :name "goog-dependencies", :ns "cljs.js-deps", :row 358} {:fixed-arities #{1}, :end-row 370, :ns "cljs.js-deps", :name "js-dependency-index", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[opts]"], :doc "Returns the index for all JavaScript dependencies. Lookup by\n  namespace or file name.", :row 360} {:fixed-arities #{1}, :end-row 393, :ns "cljs.js-deps", :name "find-classpath-lib", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[lib]"], :doc "Given [lib], a string or symbol naming a goog-style JavaScript library\n  (i.e. one that uses goog.provide and goog.require), look for a resource on the\n  classpath corresponding to [lib] and return a map via `library-graph-node`\n  that contains its relevant metadata.  The library found on the classpath\n  _must_ contain a `goog.provide` that matches [lib], or this fn will return nil\n  and print a warning.", :row 372} {:end-row 400, :filename "cljs/js_deps.cljc", :lang :cljs, :name "native-node-modules", :ns "cljs.js-deps", :row 395}]} {:end-row 16, :filename "cljs/js_deps.cljc", :lang :cljs, :name "cljs.js-deps", :row 9, :ns nil, :var-definitions [{:end-row 18, :filename "cljs/js_deps.cljc", :lang :clj, :name "java-8?", :ns "cljs.js-deps", :private true, :row 18} {:fixed-arities #{0}, :end-row 38, :private true, :ns "cljs.js-deps", :name "classpath-files", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[]"], :doc "Returns a list of classpath files. Under Java 8, walks up the parentage\n  chain of RT/baseLoader, concatenating any URLs it retrieves. Under Java 9 and\n  later, builds file list from the java.class.path system property.", :row 20} {:arglist-strs ["[jar-path]"], :end-row 46, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :clj, :name "zip-file", :ns "cljs.js-deps", :row 40} {:arglist-strs ["[jar-path]"], :end-row 51, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :clj, :name "jar-entry-names*", :ns "cljs.js-deps", :row 48} {:end-row 53, :filename "cljs/js_deps.cljc", :lang :clj, :name "jar-entry-names", :ns "cljs.js-deps", :row 53} {:fixed-arities #{2}, :end-row 62, :ns "cljs.js-deps", :name "find-js-jar", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[jar-path lib-path]"], :doc "Returns a seq of URLs of all JavaScript resources in the given jar", :row 55} {:end-row 64, :filename "cljs/js_deps.cljc", :lang :clj, :name "to-url", :ns "cljs.js-deps", :row 64} {:fixed-arities #{1}, :end-row 77, :ns "cljs.js-deps", :name "find-js-fs", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[path]"], :doc "finds js resources from a path on the files system", :row 72} {:fixed-arities #{1}, :end-row 98, :ns "cljs.js-deps", :name "find-js-classpath", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[path]"], :doc "Returns a seq of URLs of all JavaScript files on the classpath.", :row 79} {:arglist-strs ["[path]"], :end-row 107, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :clj, :name "find-js-resources", :ns "cljs.js-deps", :row 100} {:fixed-arities #{1}, :end-row 135, :ns "cljs.js-deps", :name "parse-js-ns", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[lines]"], :doc "Given the lines from a JavaScript source file, parse the provide\n  and require statements and return them in a map. Assumes that all\n  provide and require statements appear before the first function\n  definition.", :row 109} {:end-row 147, :filename "cljs/js_deps.cljc", :lang :clj, :name "IJavaScript", :ns "cljs.js-deps", :row 137} {:fixed-arities #{1}, :end-row 139, :ns "cljs.js-deps", :name "-foreign?", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "Whether the Javascript represents a foreign\n  library (a js file that not have any goog.provide statement", :row 138} {:fixed-arities #{1}, :end-row 141, :ns "cljs.js-deps", :name "-closure-lib?", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "Whether the Javascript represents a Closure style\n  library", :row 140} {:fixed-arities #{1 2}, :end-row 143, :ns "cljs.js-deps", :name "-url", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]" "[this opts]"], :doc "The URL where this JavaScript is located. Returns nil\n  when JavaScript exists in memory only.", :row 142} {:fixed-arities #{1 2}, :end-row 144, :ns "cljs.js-deps", :name "-relative-path", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]" "[this opts]"], :doc "Relative path for this JavaScript.", :row 144} {:fixed-arities #{1}, :end-row 145, :ns "cljs.js-deps", :name "-provides", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "A list of namespaces that this JavaScript provides.", :row 145} {:fixed-arities #{1}, :end-row 146, :ns "cljs.js-deps", :name "-requires", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "A list of namespaces that this JavaScript requires.", :row 146} {:fixed-arities #{1 2}, :end-row 147, :ns "cljs.js-deps", :name "-source", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]" "[this opts]"], :doc "The JavaScript source string.", :row 147} {:arglist-strs ["[lib-spec index]"], :end-row 152, :filename "cljs/js_deps.cljc", :fixed-arities #{2}, :lang :clj, :name "get-file", :ns "cljs.js-deps", :row 149} {:arglist-strs ["[a b]"], :end-row 157, :filename "cljs/js_deps.cljc", :fixed-arities #{2}, :lang :clj, :name "lib-spec-merge", :ns "cljs.js-deps", :row 154} {:fixed-arities #{1}, :end-row 194, :ns "cljs.js-deps", :name "build-index", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[deps]"], :doc "Index a list of dependencies by namespace and file name. There can\n  be zero or more namespaces provided per file. Upstream foreign libraies\n  will have their options merged with local foreign libraries to support\n  fine-grained overriding.", :row 159} {:arglist-strs ["[state ns-name]" "[state ns-name seen]"], :end-row 211, :filename "cljs/js_deps.cljc", :fixed-arities #{3 2}, :lang :clj, :name "dependency-order-visit", :ns "cljs.js-deps", :row 196} {:fixed-arities #{1}, :end-row 219, :private true, :ns "cljs.js-deps", :name "pack-string", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[s]"], :row 213} {:fixed-arities #{1}, :end-row 222, :private true, :ns "cljs.js-deps", :name "unpack-string", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[m]"], :row 221} {:fixed-arities #{1}, :end-row 230, :ns "cljs.js-deps", :name "dependency-order", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[coll]"], :doc "Topologically sort a collection of dependencies.", :row 224} {:fixed-arities #{1}, :end-row 248, :ns "cljs.js-deps", :name "find-url", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[path-or-url]"], :doc "Given a string, returns a URL. Attempts to resolve as a classpath-relative\n  path, then as a path relative to the working directory or a URL string", :row 240} {:fixed-arities #{1 2}, :end-row 262, :ns "cljs.js-deps", :name "load-foreign-library*", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[lib-spec]" "[lib-spec cp-only?]"], :doc "Given a library spec (a map containing the keys :file\n  and :provides), returns a map containing :provides, :requires, :file\n  and :url", :row 250} {:end-row 264, :filename "cljs/js_deps.cljc", :lang :clj, :name "load-foreign-library", :ns "cljs.js-deps", :row 264} {:fixed-arities #{1 2}, :end-row 276, :private true, :ns "cljs.js-deps", :name "library-graph-node", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[url]" "[url lib-path]"], :doc "Returns a map of :provides, :requires, and :url given a URL to a goog-style\nJavaScript library containing provide/require 'declarations'.", :row 266} {:fixed-arities #{1}, :end-row 285, :ns "cljs.js-deps", :name "load-library*", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[path]"], :doc "Given a path to a JavaScript library, which is a directory\n  containing Javascript files, return a list of maps\n  containing :provides, :requires, :file and :url.", :row 278} {:end-row 287, :filename "cljs/js_deps.cljc", :lang :clj, :name "load-library", :ns "cljs.js-deps", :row 287} {:arglist-strs ["[{libs :libs foreign-libs :foreign-libs ups-libs :ups-libs ups-flibs :ups-foreign-libs}]"], :end-row 298, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :clj, :name "library-dependencies", :ns "cljs.js-deps", :row 289} {:fixed-arities #{0}, :end-row 356, :ns "cljs.js-deps", :name "goog-dependencies*", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[]"], :doc "Create an index of Google dependencies by namespace and file name from\n  goog/deps.js", :row 327} {:end-row 358, :filename "cljs/js_deps.cljc", :lang :clj, :name "goog-dependencies", :ns "cljs.js-deps", :row 358} {:fixed-arities #{1}, :end-row 370, :ns "cljs.js-deps", :name "js-dependency-index", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[opts]"], :doc "Returns the index for all JavaScript dependencies. Lookup by\n  namespace or file name.", :row 360} {:fixed-arities #{1}, :end-row 393, :ns "cljs.js-deps", :name "find-classpath-lib", :lang :clj, :filename "cljs/js_deps.cljc", :arglist-strs ["[lib]"], :doc "Given [lib], a string or symbol naming a goog-style JavaScript library\n  (i.e. one that uses goog.provide and goog.require), look for a resource on the\n  classpath corresponding to [lib] and return a map via `library-graph-node`\n  that contains its relevant metadata.  The library found on the classpath\n  _must_ contain a `goog.provide` that matches [lib], or this fn will return nil\n  and print a warning.", :row 372} {:end-row 400, :filename "cljs/js_deps.cljc", :lang :clj, :name "native-node-modules", :ns "cljs.js-deps", :row 395} {:end-row 18, :filename "cljs/js_deps.cljc", :lang :cljs, :name "java-8?", :ns "cljs.js-deps", :private true, :row 18} {:fixed-arities #{0}, :end-row 38, :private true, :ns "cljs.js-deps", :name "classpath-files", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[]"], :doc "Returns a list of classpath files. Under Java 8, walks up the parentage\n  chain of RT/baseLoader, concatenating any URLs it retrieves. Under Java 9 and\n  later, builds file list from the java.class.path system property.", :row 20} {:arglist-strs ["[jar-path]"], :end-row 46, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :cljs, :name "zip-file", :ns "cljs.js-deps", :row 40} {:arglist-strs ["[jar-path]"], :end-row 51, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :cljs, :name "jar-entry-names*", :ns "cljs.js-deps", :row 48} {:end-row 53, :filename "cljs/js_deps.cljc", :lang :cljs, :name "jar-entry-names", :ns "cljs.js-deps", :row 53} {:fixed-arities #{2}, :end-row 62, :ns "cljs.js-deps", :name "find-js-jar", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[jar-path lib-path]"], :doc "Returns a seq of URLs of all JavaScript resources in the given jar", :row 55} {:end-row 64, :filename "cljs/js_deps.cljc", :lang :cljs, :name "to-url", :ns "cljs.js-deps", :row 64} {:fixed-arities #{1}, :end-row 77, :ns "cljs.js-deps", :name "find-js-fs", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[path]"], :doc "finds js resources from a path on the files system", :row 72} {:fixed-arities #{1}, :end-row 98, :ns "cljs.js-deps", :name "find-js-classpath", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[path]"], :doc "Returns a seq of URLs of all JavaScript files on the classpath.", :row 79} {:arglist-strs ["[path]"], :end-row 107, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :cljs, :name "find-js-resources", :ns "cljs.js-deps", :row 100} {:fixed-arities #{1}, :end-row 135, :ns "cljs.js-deps", :name "parse-js-ns", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[lines]"], :doc "Given the lines from a JavaScript source file, parse the provide\n  and require statements and return them in a map. Assumes that all\n  provide and require statements appear before the first function\n  definition.", :row 109} {:end-row 147, :filename "cljs/js_deps.cljc", :lang :cljs, :name "IJavaScript", :ns "cljs.js-deps", :row 137} {:fixed-arities #{1}, :end-row 139, :ns "cljs.js-deps", :name "-foreign?", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "Whether the Javascript represents a foreign\n  library (a js file that not have any goog.provide statement", :row 138} {:fixed-arities #{1}, :end-row 141, :ns "cljs.js-deps", :name "-closure-lib?", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "Whether the Javascript represents a Closure style\n  library", :row 140} {:fixed-arities #{1 2}, :end-row 143, :ns "cljs.js-deps", :name "-url", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]" "[this opts]"], :doc "The URL where this JavaScript is located. Returns nil\n  when JavaScript exists in memory only.", :row 142} {:fixed-arities #{1 2}, :end-row 144, :ns "cljs.js-deps", :name "-relative-path", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]" "[this opts]"], :doc "Relative path for this JavaScript.", :row 144} {:fixed-arities #{1}, :end-row 145, :ns "cljs.js-deps", :name "-provides", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "A list of namespaces that this JavaScript provides.", :row 145} {:fixed-arities #{1}, :end-row 146, :ns "cljs.js-deps", :name "-requires", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]"], :doc "A list of namespaces that this JavaScript requires.", :row 146} {:fixed-arities #{1 2}, :end-row 147, :ns "cljs.js-deps", :name "-source", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[this]" "[this opts]"], :doc "The JavaScript source string.", :row 147} {:arglist-strs ["[lib-spec index]"], :end-row 152, :filename "cljs/js_deps.cljc", :fixed-arities #{2}, :lang :cljs, :name "get-file", :ns "cljs.js-deps", :row 149} {:arglist-strs ["[a b]"], :end-row 157, :filename "cljs/js_deps.cljc", :fixed-arities #{2}, :lang :cljs, :name "lib-spec-merge", :ns "cljs.js-deps", :row 154} {:fixed-arities #{1}, :end-row 194, :ns "cljs.js-deps", :name "build-index", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[deps]"], :doc "Index a list of dependencies by namespace and file name. There can\n  be zero or more namespaces provided per file. Upstream foreign libraies\n  will have their options merged with local foreign libraries to support\n  fine-grained overriding.", :row 159} {:arglist-strs ["[state ns-name]" "[state ns-name seen]"], :end-row 211, :filename "cljs/js_deps.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "dependency-order-visit", :ns "cljs.js-deps", :row 196} {:fixed-arities #{1}, :end-row 219, :private true, :ns "cljs.js-deps", :name "pack-string", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[s]"], :row 213} {:fixed-arities #{1}, :end-row 222, :private true, :ns "cljs.js-deps", :name "unpack-string", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[m]"], :row 221} {:fixed-arities #{1}, :end-row 230, :ns "cljs.js-deps", :name "dependency-order", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[coll]"], :doc "Topologically sort a collection of dependencies.", :row 224} {:fixed-arities #{1}, :end-row 248, :ns "cljs.js-deps", :name "find-url", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[path-or-url]"], :doc "Given a string, returns a URL. Attempts to resolve as a classpath-relative\n  path, then as a path relative to the working directory or a URL string", :row 240} {:fixed-arities #{1 2}, :end-row 262, :ns "cljs.js-deps", :name "load-foreign-library*", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[lib-spec]" "[lib-spec cp-only?]"], :doc "Given a library spec (a map containing the keys :file\n  and :provides), returns a map containing :provides, :requires, :file\n  and :url", :row 250} {:end-row 264, :filename "cljs/js_deps.cljc", :lang :cljs, :name "load-foreign-library", :ns "cljs.js-deps", :row 264} {:fixed-arities #{1 2}, :end-row 276, :private true, :ns "cljs.js-deps", :name "library-graph-node", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[url]" "[url lib-path]"], :doc "Returns a map of :provides, :requires, and :url given a URL to a goog-style\nJavaScript library containing provide/require 'declarations'.", :row 266} {:fixed-arities #{1}, :end-row 285, :ns "cljs.js-deps", :name "load-library*", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[path]"], :doc "Given a path to a JavaScript library, which is a directory\n  containing Javascript files, return a list of maps\n  containing :provides, :requires, :file and :url.", :row 278} {:end-row 287, :filename "cljs/js_deps.cljc", :lang :cljs, :name "load-library", :ns "cljs.js-deps", :row 287} {:arglist-strs ["[{libs :libs foreign-libs :foreign-libs ups-libs :ups-libs ups-flibs :ups-foreign-libs}]"], :end-row 298, :filename "cljs/js_deps.cljc", :fixed-arities #{1}, :lang :cljs, :name "library-dependencies", :ns "cljs.js-deps", :row 289} {:fixed-arities #{0}, :end-row 356, :ns "cljs.js-deps", :name "goog-dependencies*", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[]"], :doc "Create an index of Google dependencies by namespace and file name from\n  goog/deps.js", :row 327} {:end-row 358, :filename "cljs/js_deps.cljc", :lang :cljs, :name "goog-dependencies", :ns "cljs.js-deps", :row 358} {:fixed-arities #{1}, :end-row 370, :ns "cljs.js-deps", :name "js-dependency-index", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[opts]"], :doc "Returns the index for all JavaScript dependencies. Lookup by\n  namespace or file name.", :row 360} {:fixed-arities #{1}, :end-row 393, :ns "cljs.js-deps", :name "find-classpath-lib", :lang :cljs, :filename "cljs/js_deps.cljc", :arglist-strs ["[lib]"], :doc "Given [lib], a string or symbol naming a goog-style JavaScript library\n  (i.e. one that uses goog.provide and goog.require), look for a resource on the\n  classpath corresponding to [lib] and return a map via `library-graph-node`\n  that contains its relevant metadata.  The library found on the classpath\n  _must_ contain a `goog.provide` that matches [lib], or this fn will return nil\n  and print a warning.", :row 372} {:end-row 400, :filename "cljs/js_deps.cljc", :lang :cljs, :name "native-node-modules", :ns "cljs.js-deps", :row 395}]} {:end-row 17, :filename "cljs/core/macros.clj", :name "cljs.core.macros", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[x]"], :end-row 31, :filename "cljs/core/macros.clj", :fixed-arities #{1}, :name "source-fn", :ns "cljs.core.macros", :row 19} {:arglist-strs ["[ns [& vars]]"], :end-row 38, :filename "cljs/core/macros.clj", :fixed-arities #{2}, :macro true, :name "import-macros", :ns "cljs.core.macros", :row 33} {:arglist-strs ["[[_ ns] [_ alias]]"], :end-row 43, :filename "cljs/core/macros.clj", :fixed-arities #{2}, :macro true, :name "alias", :ns "cljs.core.macros", :row 40}]} {:end-row 19, :filename "cljs/core/server.clj", :name "cljs.core.server", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[& body]"], :end-row 25, :filename "cljs/core/server.clj", :macro true, :name "with-bindings", :ns "cljs.core.server", :row 21} {:arglist-strs ["[valf]"], :end-row 34, :filename "cljs/core/server.clj", :fixed-arities #{1}, :name "resolve-fn", :ns "cljs.core.server", :private true, :row 27} {:arglist-strs ["[v]"], :end-row 37, :filename "cljs/core/server.clj", :fixed-arities #{1}, :name "repl-quit?", :ns "cljs.core.server", :row 36} {:arglist-strs ["[repl-env {:keys [special-fns] :as opts} in-reader out-fn & {:keys [stdin]}]"], :doc "A REPL with structured output (for programs)\n  reads forms to eval from in-reader (a LineNumberingPushbackReader)\n  Closing the input or passing the form :cljs/quit or :repl/quit will cause it\n  to return\n\n  Calls out-fn with data, one of:\n  {:tag :ret\n   :val string ;;eval result\n   :ns ns-name-string\n   :ms long ;;eval time in milliseconds\n   :form string ;;iff successfully read\n  }\n  {:tag :out\n   :val string} ;chars from during-eval *out*\n  {:tag :err\n   :val string} ;chars from during-eval *err*\n  {:tag :tap\n   :val string} ;values from tap>\n\n  You might get more than one :out or :err per eval, but exactly one :ret\n  tap output can happen at any time (i.e. between evals)\n  If during eval an attempt is made to read *in* it will read from in-reader unless :stdin is supplied\n", :end-row 130, :filename "cljs/core/server.clj", :name "prepl", :ns "cljs.core.server", :row 39} {:arglist-strs ["[& {:keys [valf repl-env opts] :or {valf #(if (string? %) % (pr-str %))}}]"], :doc "prepl bound to *in* and *out*, suitable for use with e.g. server/repl (socket-repl).\n  :ret and :tap vals will be processed by valf, a fn of one argument\n  or a symbol naming same (default identity)", :end-row 146, :filename "cljs/core/server.clj", :name "io-prepl", :ns "cljs.core.server", :row 132} {:arglist-strs ["[form]"], :end-row 153, :filename "cljs/core/server.clj", :fixed-arities #{1}, :macro true, :name "clj-eval", :ns "cljs.core.server", :row 152}]} {:end-row 12, :filename "cljs/core/specs/alpha.cljc", :lang :clj, :name "cljs.core.specs.alpha", :row 9, :ns nil, :var-definitions [{:fixed-arities #{1}, :end-row 61, :ns "cljs.core.specs.alpha", :name "even-number-of-forms?", :lang :clj, :filename "cljs/core/specs/alpha.cljc", :arglist-strs ["[forms]"], :doc "Returns true if there are an even number of forms in a binding vector", :row 58} {:fixed-arities #{1}, :end-row 212, :private true, :ns "cljs.core.specs.alpha", :name "quoted", :lang :clj, :filename "cljs/core/specs/alpha.cljc", :arglist-strs ["[spec]"], :doc "Returns a spec that accepts a (quote ...) form of the spec", :row 209} {:fixed-arities #{1}, :end-row 61, :ns "cljs.core.specs.alpha", :name "even-number-of-forms?", :lang :cljs, :filename "cljs/core/specs/alpha.cljc", :arglist-strs ["[forms]"], :doc "Returns true if there are an even number of forms in a binding vector", :row 58} {:fixed-arities #{1}, :end-row 212, :private true, :ns "cljs.core.specs.alpha", :name "quoted", :lang :cljs, :filename "cljs/core/specs/alpha.cljc", :arglist-strs ["[spec]"], :doc "Returns a spec that accepts a (quote ...) form of the spec", :row 209}]} {:end-row 12, :filename "cljs/core/specs/alpha.cljc", :lang :cljs, :name "cljs.core.specs.alpha", :row 9, :ns nil, :var-definitions [{:fixed-arities #{1}, :end-row 61, :ns "cljs.core.specs.alpha", :name "even-number-of-forms?", :lang :clj, :filename "cljs/core/specs/alpha.cljc", :arglist-strs ["[forms]"], :doc "Returns true if there are an even number of forms in a binding vector", :row 58} {:fixed-arities #{1}, :end-row 212, :private true, :ns "cljs.core.specs.alpha", :name "quoted", :lang :clj, :filename "cljs/core/specs/alpha.cljc", :arglist-strs ["[spec]"], :doc "Returns a spec that accepts a (quote ...) form of the spec", :row 209} {:fixed-arities #{1}, :end-row 61, :ns "cljs.core.specs.alpha", :name "even-number-of-forms?", :lang :cljs, :filename "cljs/core/specs/alpha.cljc", :arglist-strs ["[forms]"], :doc "Returns true if there are an even number of forms in a binding vector", :row 58} {:fixed-arities #{1}, :end-row 212, :private true, :ns "cljs.core.specs.alpha", :name "quoted", :lang :cljs, :filename "cljs/core/specs/alpha.cljc", :arglist-strs ["[spec]"], :doc "Returns a spec that accepts a (quote ...) form of the spec", :row 209}]} {:end-row 10, :filename "cljs/core/specs/alpha.cljs", :name "cljs.core.specs.alpha", :row 9, :ns nil, :var-definitions [{:fixed-arities #{1}, :end-row 61, :ns "cljs.core.specs.alpha", :name "even-number-of-forms?", :lang :clj, :filename "cljs/core/specs/alpha.cljc", :arglist-strs ["[forms]"], :doc "Returns true if there are an even number of forms in a binding vector", :row 58} {:fixed-arities #{1}, :end-row 212, :private true, :ns "cljs.core.specs.alpha", :name "quoted", :lang :clj, :filename "cljs/core/specs/alpha.cljc", :arglist-strs ["[spec]"], :doc "Returns a spec that accepts a (quote ...) form of the spec", :row 209} {:fixed-arities #{1}, :end-row 61, :ns "cljs.core.specs.alpha", :name "even-number-of-forms?", :lang :cljs, :filename "cljs/core/specs/alpha.cljc", :arglist-strs ["[forms]"], :doc "Returns true if there are an even number of forms in a binding vector", :row 58} {:fixed-arities #{1}, :end-row 212, :private true, :ns "cljs.core.specs.alpha", :name "quoted", :lang :cljs, :filename "cljs/core/specs/alpha.cljc", :arglist-strs ["[spec]"], :doc "Returns a spec that accepts a (quote ...) form of the spec", :row 209}]} {:end-row 14, :filename "cljs/reader.cljs", :name "cljs.reader", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[default-readers]"], :end-row 18, :filename "cljs/reader.clj", :fixed-arities #{1}, :macro true, :name "add-data-readers", :ns "cljs.reader", :row 12} {:arglist-strs ["[s width]"], :end-row 24, :filename "cljs/reader.cljs", :fixed-arities #{2}, :name "zero-fill-right-and-truncate", :ns "cljs.reader", :private true, :row 16} {:arglist-strs ["[num div]"], :end-row 28, :filename "cljs/reader.cljs", :fixed-arities #{2}, :name "divisible?", :ns "cljs.reader", :private true, :row 26} {:arglist-strs ["[num div]"], :end-row 32, :filename "cljs/reader.cljs", :fixed-arities #{2}, :name "indivisible?", :ns "cljs.reader", :private true, :row 30} {:arglist-strs ["[year]"], :end-row 38, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "leap-year?", :ns "cljs.reader", :private true, :row 34} {:end-row 44, :filename "cljs/reader.cljs", :name "days-in-month", :ns "cljs.reader", :private true, :row 40} {:end-row 46, :filename "cljs/reader.cljs", :name "timestamp-regex", :ns "cljs.reader", :private true, :row 46} {:arglist-strs ["[s]"], :end-row 51, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "parse-int", :ns "cljs.reader", :private true, :row 48} {:arglist-strs ["[low n high msg]"], :end-row 56, :filename "cljs/reader.cljs", :fixed-arities #{4}, :name "check", :ns "cljs.reader", :private true, :row 53} {:arglist-strs ["[s]"], :end-row 81, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "parse-and-validate-timestamp", :ns "cljs.reader", :row 58} {:arglist-strs ["[ts]"], :end-row 90, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "parse-timestamp", :ns "cljs.reader", :row 83} {:arglist-strs ["[s]"], :end-row 96, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "read-date", :ns "cljs.reader", :private true, :row 92} {:arglist-strs ["[elems]"], :end-row 102, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "read-queue", :ns "cljs.reader", :private true, :row 98} {:arglist-strs ["[form]"], :end-row 123, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "read-js", :ns "cljs.reader", :private true, :row 104} {:arglist-strs ["[uuid]"], :end-row 129, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "read-uuid", :ns "cljs.reader", :private true, :row 125} {:end-row 132, :filename "cljs/reader.cljs", :name "*default-data-reader-fn*", :ns "cljs.reader", :row 131} {:end-row 140, :filename "cljs/reader.cljs", :name "*tag-table*", :ns "cljs.reader", :row 134} {:arglist-strs ["[reader]" "[{:keys [eof] :as opts} reader]" "[reader eof-error? eof opts]"], :doc "Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   cljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.", :end-row 172, :filename "cljs/reader.cljs", :fixed-arities #{1 4 2}, :name "read", :ns "cljs.reader", :row 142} {:arglist-strs ["[s]" "[opts s]"], :doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per cljs.tools.reader.edn/read", :end-row 190, :filename "cljs/reader.cljs", :fixed-arities #{1 2}, :name "read-string", :ns "cljs.reader", :row 174} {:arglist-strs ["[tag f]"], :end-row 196, :filename "cljs/reader.cljs", :fixed-arities #{2}, :name "register-tag-parser!", :ns "cljs.reader", :row 192} {:arglist-strs ["[tag]"], :end-row 202, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "deregister-tag-parser!", :ns "cljs.reader", :row 198} {:arglist-strs ["[f]"], :end-row 208, :filename "cljs/reader.cljs", :fixed-arities #{1}, :name "register-default-tag-parser!", :ns "cljs.reader", :row 204} {:arglist-strs ["[]"], :end-row 214, :filename "cljs/reader.cljs", :fixed-arities #{0}, :name "deregister-default-tag-parser!", :ns "cljs.reader", :row 210}]} {:end-row 13, :filename "cljs/repl.cljs", :name "cljs.repl", :row 9, :ns nil, :var-definitions [{:end-row 34, :filename "cljs/repl.cljc", :lang :clj, :name "*cljs-verbose*", :ns "cljs.repl", :row 34} {:end-row 35, :filename "cljs/repl.cljc", :lang :clj, :name "*repl-opts*", :ns "cljs.repl", :row 35} {:end-row 36, :filename "cljs/repl.cljc", :lang :clj, :name "*repl-env*", :ns "cljs.repl", :row 36} {:doc "Set of all known REPL options.", :end-row 43, :filename "cljs/repl.cljc", :lang :clj, :name "known-repl-opts", :ns "cljs.repl", :row 38} {:end-row 47, :private true, :ns "cljs.repl", :name "err-out", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[& body]"], :row 45} {:fixed-arities #{1}, :end-row 64, :ns "cljs.repl", :name "skip-if-eol", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[s]"], :doc "If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\newline.", :row 52} {:fixed-arities #{1}, :end-row 83, :ns "cljs.repl", :name "skip-whitespace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[s]"], :doc "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.", :row 66} {:fixed-arities #{3 2}, :end-row 110, :ns "cljs.repl", :name "repl-read", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[request-prompt request-exit]" "[request-prompt request-exit opts]"], :doc "Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.", :row 85} {:end-row 116, :filename "cljs/repl.cljc", :lang :clj, :name "IReplEnvOptions", :ns "cljs.repl", :row 115} {:fixed-arities #{1}, :end-row 116, :ns "cljs.repl", :name "-repl-options", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]"], :doc "Return default REPL options for a REPL Env", :row 116} {:arglist-strs ["[repl-env]"], :end-row 119, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "repl-options", :ns "cljs.repl", :row 118} {:end-row 125, :filename "cljs/repl.cljc", :lang :clj, :name "IJavaScriptEnv", :ns "cljs.repl", :row 121} {:fixed-arities #{2}, :end-row 122, :ns "cljs.repl", :name "-setup", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env opts]"], :doc "initialize the environment", :row 122} {:fixed-arities #{4}, :end-row 123, :ns "cljs.repl", :name "-evaluate", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env filename line js]"], :doc "evaluate a javascript string", :row 123} {:fixed-arities #{3}, :end-row 124, :ns "cljs.repl", :name "-load", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env provides url]"], :doc "load code at url into the environment", :row 124} {:fixed-arities #{1}, :end-row 125, :ns "cljs.repl", :name "-tear-down", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]"], :doc "dispose of the environment", :row 125} {:arglist-strs ["[repl-env opts]"], :end-row 128, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "setup", :ns "cljs.repl", :row 127} {:arglist-strs ["[repl-env filename line js]"], :end-row 131, :filename "cljs/repl.cljc", :fixed-arities #{4}, :lang :clj, :name "evaluate", :ns "cljs.repl", :row 130} {:arglist-strs ["[repl-env provides url]"], :end-row 134, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :clj, :name "load", :ns "cljs.repl", :row 133} {:arglist-strs ["[repl-env]"], :end-row 137, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "tear-down", :ns "cljs.repl", :row 136} {:end-row 147, :filename "cljs/repl.cljc", :lang :clj, :name "IParseError", :ns "cljs.repl", :row 144} {:fixed-arities #{3}, :end-row 147, :ns "cljs.repl", :name "-parse-error", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env error build-options]"], :doc "Given the original JavaScript error return the error to actually\n     use.", :row 145} {:end-row 159, :filename "cljs/repl.cljc", :lang :clj, :name "IGetError", :ns "cljs.repl", :row 149} {:fixed-arities #{4}, :end-row 159, :ns "cljs.repl", :name "-get-error", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env name env build-options]"], :doc "Given a symbol representing a var holding an error, an analysis\n     environment, and the REPL/compiler options return the canonical error\n     representation:\n\n     {:value <string>\n      :stacktrace <string>}\n\n    :value should be the host environment JavaScript error message string.\n    :stacktrace should be the host JavaScript environment stacktrace string.", :row 150} {:end-row 174, :filename "cljs/repl.cljc", :lang :clj, :name "IParseStacktrace", :ns "cljs.repl", :row 161} {:fixed-arities #{4}, :end-row 174, :ns "cljs.repl", :name "-parse-stacktrace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env stacktrace error build-options]"], :doc "Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir. If\n     no source file can be supplied (such as REPL defs), :file may be a custom\n     identifier string surrounded by angle brackets, i.e. \"<cljs repl>\".", :row 162} {:end-row 179, :filename "cljs/repl.cljc", :lang :clj, :name "IPrintStacktrace", :ns "cljs.repl", :row 176} {:fixed-arities #{4}, :end-row 179, :ns "cljs.repl", :name "-print-stacktrace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env stacktrace error build-options]"], :doc "Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing.", :row 177} {:fixed-arities #{1 2}, :end-row 191, :private true, :ns "cljs.repl", :name "env->opts", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]" "[repl-env opts]"], :doc "Returns a hash-map containing all of the entries in [repl-env], translating\n:working-dir to :output-dir.", :row 181} {:arglist-strs ["[ijs]"], :end-row 196, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "add-url", :ns "cljs.repl", :row 193} {:arglist-strs ["[ns opts]"], :end-row 204, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "ns->input", :ns "cljs.repl", :row 198} {:arglist-strs ["[input]"], :end-row 207, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "compilable?", :ns "cljs.repl", :row 206} {:fixed-arities #{3}, :end-row 224, :private true, :ns "cljs.repl", :name "load-sources", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env sources opts]"], :doc "Load the compiled `sources` into the REPL.", :row 209} {:fixed-arities #{3}, :end-row 231, :private true, :ns "cljs.repl", :name "load-cljs-loader", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env sources opts]"], :doc "Compile and load the cljs.loader namespace if it's present in `sources`.", :row 226} {:fixed-arities #{3 2}, :end-row 252, :ns "cljs.repl", :name "load-namespace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env ns]" "[repl-env ns opts]"], :doc "Load a namespace and all of its dependencies into the evaluation environment.\n  The environment is responsible for ensuring that each namespace is\n  loaded once and only once. Returns the compiled sources.", :row 233} {:fixed-arities #{3 2}, :end-row 259, :private true, :ns "cljs.repl", :name "load-dependencies", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env requires]" "[repl-env requires opts]"], :doc "Compile and load the given `requires` and return the compiled sources.", :row 254} {:fixed-arities #{1}, :end-row 273, :ns "cljs.repl", :name "js-src->cljs-src", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Map a JavaScript output file back to the original ClojureScript source\n   file (.cljs or .cljc).", :row 261} {:fixed-arities #{1}, :end-row 293, :ns "cljs.repl", :name "read-source-map", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Return the source map for the JavaScript source file.", :row 275} {:fixed-arities #{1}, :end-row 301, :ns "cljs.repl", :name "ns-info", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Given a path to a js source file return the ns info for the corresponding\n   ClojureScript file if it exists.", :row 295} {:fixed-arities #{3}, :end-row 322, :private true, :ns "cljs.repl", :name "mapped-line-column-call", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[source-map line column]"], :doc "Given a cljs.source-map source map data structure map a generated line\n   and column back to the original line, column, and function called.", :row 303} {:fixed-arities #{2}, :end-row 362, :private true, :ns "cljs.repl", :name "mapped-frame", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[{:keys [function file line column]} opts]"], :doc "Given opts and a canonicalized JavaScript stacktrace frame, return the\n  ClojureScript frame.", :row 324} {:fixed-arities #{1 2}, :end-row 392, :ns "cljs.repl", :name "mapped-stacktrace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[stacktrace]" "[stacktrace opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   return the ClojureScript stacktrace. The canonical stacktrace must be\n   in the form:\n\n    [{:file <string>\n      :function <string>\n      :line <integer>\n      :column <integer>}*]\n\n   :file must be a URL path (without protocol) relative to :output-dir or a\n   identifier delimited by angle brackets. The returned mapped stacktrace will\n   also contain :url entries to the original sources if it can be determined\n   from the classpath.", :row 364} {:arglist-strs ["[file {:keys [output-dir temp-output-dir?]}]"], :end-row 403, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "file-display", :ns "cljs.repl", :row 394} {:fixed-arities #{1 2}, :end-row 415, :ns "cljs.repl", :name "print-mapped-stacktrace", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[stacktrace]" "[stacktrace opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   print the ClojureScript stacktrace. See mapped-stacktrace.", :row 405} {:end-row 418, :filename "cljs/repl.cljc", :lang :clj, :name "st", :ns "cljs.repl", :row 418} {:fixed-arities #{4 5}, :end-row 491, :private true, :ns "cljs.repl", :name "display-error", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env ret form opts]" "[repl-env ret form f opts]"], :row 469} {:fixed-arities #{1}, :end-row 496, :private true, :ns "cljs.repl", :name "bytes-to-base64-str", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[bytes]"], :doc "Convert a byte array into a base-64 encoded string.", :row 493} {:fixed-arities #{4 6 5}, :end-row 583, :ns "cljs.repl", :name "evaluate-form", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env env filename form]" "[repl-env env filename form wrap]" "[repl-env env filename form wrap opts]"], :doc "Evaluate a ClojureScript form in the JavaScript environment. Returns a\n  string which is the ClojureScript return value. This string may or may\n  not be readable by the Clojure reader.", :row 498} {:arglist-strs ["[repl-env filename res]"], :end-row 590, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :clj, :name "load-stream", :ns "cljs.repl", :row 585} {:arglist-strs ["[repl-env f]" "[repl-env f opts]"], :end-row 626, :filename "cljs/repl.cljc", :fixed-arities #{3 2}, :lang :clj, :name "load-file", :ns "cljs.repl", :row 592} {:fixed-arities #{1}, :end-row 635, :private true, :ns "cljs.repl", :name "root-resource", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[lib]"], :doc "Returns the root directory path for a lib", :row 628} {:fixed-arities #{1}, :end-row 641, :private true, :ns "cljs.repl", :name "root-directory", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[lib]"], :doc "Returns the root resource path for a lib", :row 637} {:fixed-arities #{1}, :end-row 650, :private true, :ns "cljs.repl", :name "load-path->cp-path", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[path]"], :row 643} {:fixed-arities #{1}, :end-row 671, :private true, :ns "cljs.repl", :name "wrap-fn", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[form]"], :row 652} {:fixed-arities #{1}, :end-row 683, :private true, :ns "cljs.repl", :name "init-wrap-fn", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[form]"], :row 673} {:fixed-arities #{4 3}, :end-row 699, :ns "cljs.repl", :name "eval-cljs", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env env form]" "[repl-env env form opts]"], :doc "Given a REPL evaluation environment, an analysis environment, and a\n   form, evaluate the form and return the result. The result is always the value\n   represented as a string.", :row 685} {:arglist-strs ["[specs]"], :end-row 704, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "decorate-specs", :ns "cljs.repl", :row 701} {:fixed-arities #{1}, :end-row 747, :private true, :ns "cljs.repl", :name "wrap-self", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Takes a self-ish fn and returns it wrapped with exception handling.\n  Compiler state is restored if self-ish fn fails.", :row 734} {:fixed-arities #{2}, :end-row 752, :private true, :ns "cljs.repl", :name "wrap-special-fns", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[wfn fns]"], :row 749} {:end-row 793, :filename "cljs/repl.cljc", :lang :clj, :name "default-special-fns", :ns "cljs.repl", :row 754} {:fixed-arities #{1 2}, :end-row 803, :ns "cljs.repl", :name "analyze-source", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[src-dir]" "[src-dir opts]"], :doc "Given a source directory, analyzes all .cljs files. Used to populate\n  (:cljs.analyzer/namespaces compiler-env) so as to support code reflection.", :row 795} {:arglist-strs ["[]"], :end-row 806, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :clj, :name "repl-title", :ns "cljs.repl", :row 805} {:arglist-strs ["[]"], :end-row 809, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :clj, :name "repl-quit-prompt", :ns "cljs.repl", :row 808} {:arglist-strs ["[]"], :end-row 812, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :clj, :name "repl-prompt", :ns "cljs.repl", :row 811} {:fixed-arities #{1}, :end-row 818, :ns "cljs.repl", :name "demunge", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[fn-name]"], :doc "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", :row 814} {:end-row 824, :filename "cljs/repl.cljc", :lang :clj, :name "core-namespaces", :ns "cljs.repl", :private true, :row 820} {:fixed-arities #{1}, :end-row 830, :private true, :ns "cljs.repl", :name "core-class?", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[class-name]"], :row 826} {:fixed-arities #{1}, :end-row 838, :private true, :ns "cljs.repl", :name "file-name", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[full-path]"], :doc "Helper to get just the file name part of a path or nil", :row 832} {:fixed-arities #{2}, :end-row 848, :private true, :ns "cljs.repl", :name "java-loc->source", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[clazz method]"], :doc "Convert Java class name and method symbol to source symbol, either a\n  Clojure function or Java class and method.", :row 840} {:fixed-arities #{1}, :end-row 905, :ns "cljs.repl", :name "ex-triage", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[datafied-throwable]"], :doc "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error", :row 850} {:fixed-arities #{1}, :end-row 980, :ns "cljs.repl", :name "ex-str", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[{:keys [:clojure.error/phase :clojure.error/source :clojure.error/line :clojure.error/column :clojure.error/symbol :clojure.error/class :clojure.error/cause :clojure.error/spec] :as triage-data}]"], :doc "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.", :row 907} {:arglist-strs ["[e repl-env opts]"], :end-row 998, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :clj, :name "repl-caught", :ns "cljs.repl", :row 982} {:arglist-strs ["[x]"], :end-row 1001, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "repl-nil?", :ns "cljs.repl", :row 1000} {:arglist-strs ["[renv inits]"], :end-row 1017, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "run-inits", :ns "cljs.repl", :row 1003} {:arglist-strs ["[opts]"], :end-row 1026, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :clj, :name "maybe-install-npm-deps", :ns "cljs.repl", :row 1019} {:arglist-strs ["[quit-prompt prompt]"], :end-row 1031, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "initial-prompt", :ns "cljs.repl", :row 1028} {:arglist-strs ["[repl-env {:keys [init inits need-prompt quit-prompt prompt flush read eval print caught reader print-no-newline source-map-inline wrap repl-requires ::fast-initial-prompt? compiler-env bind-err] :or {need-prompt #(if (readers/indexing-reader? *in*) (== (readers/get-column-number *in*) 1) (identity true)) fast-initial-prompt? false quit-prompt repl-title prompt repl-prompt flush flush read repl-read eval eval-cljs print println caught repl-caught reader #(readers/source-logging-push-back-reader *in* 1 \"<NO_SOURCE_FILE>\") print-no-newline print source-map-inline true repl-requires '[[cljs.repl :refer-macros [source doc find-doc apropos dir pst]] [cljs.pprint :refer [pprint] :refer-macros [pp]]] bind-err true} :as opts}]"], :end-row 1226, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :clj, :name "repl*", :ns "cljs.repl", :row 1033} {:arglist-strs ["[repl-env & opts]"], :doc "Generic, reusable, read-eval-print loop. By default, reads from *in* using\n  a c.t.r.reader-types/source-logging-push-back-reader,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  c.t.r.reader-types/PushbackReader or duplicate its behavior of both supporting\n  unread and collapsing CR, LF, and CRLF into a single \\newline. Options\n  are sequential keyword-value pairs. The first argument is the JavaScript\n  evaluation environment, the second argument is an extended version of the\n  standard ClojureScript compiler options. In addition to ClojureScript compiler\n  build options it also take a set of options similar to clojure.main/repl with\n  adjustments for ClojureScript evalution and compilation model:\n\n  Available clojure.main/repl style options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: #(if (c.t.r.readers-types/indexing-reader? *in*)\n                   (== (c.t.r.reader-types/get-column-number *in*) 1)\n                   (identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument. The eval function must take repl-env, the JavaScript evaluation\n       environment, env, the ClojureScript analysis environment, the form\n       and opts, the standard ClojureScript REPL/compiler options.\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: println\n\n     - :caught, function of three arguments, a throwable, called when\n       read, eval, or print throws an exception or error default. The second\n       argument is the JavaScript evaluation environment this permits context\n       sensitive handling if necessary. The third argument is opts, the standard\n       ClojureScript REPL/compiler options. In the case of errors or exception\n       in the JavaScript target, these will be thrown as\n       clojure.lang.IExceptionInfo instances.\n       default: repl-caught\n\n     - :reader, the c.t.r reader to use.\n       default: c.t.r.reader-types/source-logging-push-back-reader\n\n     - :print-no-newline, print without a newline.\n       default: print\n\n     - :source-map-inline, whether inline source maps should be enabled. Most\n       useful in browser context. Implies using a fresh reader for each form.\n       default: true", :end-row 1298, :filename "cljs/repl.cljc", :lang :clj, :name "repl", :ns "cljs.repl", :row 1228} {:end-row 1409, :filename "cljs/repl.cljc", :lang :clj, :name "special-doc-map", :ns "cljs.repl", :row 1303} {:fixed-arities #{1}, :end-row 1414, :private true, :ns "cljs.repl", :name "special-doc", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[name-symbol]"], :row 1411} {:end-row 1424, :filename "cljs/repl.cljc", :lang :clj, :name "repl-special-doc-map", :ns "cljs.repl", :row 1416} {:fixed-arities #{1}, :end-row 1429, :private true, :ns "cljs.repl", :name "repl-special-doc", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[name-symbol]"], :row 1426} {:fixed-arities #{1}, :end-row 1469, :ns "cljs.repl", :name "doc", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[name]"], :doc "Prints documentation for a var or special form given its name,\n  or for a spec if given a keyword", :row 1431} {:fixed-arities #{1}, :end-row 1493, :ns "cljs.repl", :name "find-doc", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[re-string-or-pattern]"], :doc "Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern", :row 1471} {:fixed-arities #{2}, :end-row 1518, :ns "cljs.repl", :name "source-fn", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[env x]"], :doc "Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)", :row 1495} {:end-row 1521, :filename "cljs/repl.cljc", :lang :clj, :name "cenv", :ns "cljs.repl", :row 1521} {:end-row 1522, :filename "cljs/repl.cljc", :lang :clj, :name "aenv", :ns "cljs.repl", :row 1522} {:fixed-arities #{1}, :end-row 1538, :ns "cljs.repl", :name "source", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[n]"], :doc "Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .cljs is in the classpath.\n\n  Example: (source filter)", :row 1531} {:fixed-arities #{1}, :end-row 1545, :private true, :ns "cljs.repl", :name "named-publics-vars", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[ns]"], :doc "Gets the public vars in a namespace that are not anonymous.", :row 1540} {:fixed-arities #{1}, :end-row 1562, :ns "cljs.repl", :name "apropos", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[str-or-pattern]"], :doc "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.", :row 1547} {:fixed-arities #{1}, :end-row 1570, :private true, :ns "cljs.repl", :name "resolve-ns", :lang :clj, :filename "cljs/repl.cljc", :arglist-strs ["[ns-sym]"], :doc "Resolves a namespace symbol to a namespace by first checking to see if it\n  is a namespace alias.", :row 1564} {:fixed-arities #{1}, :end-row 1576, :ns "cljs.repl", :name "dir", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[ns]"], :doc "Prints a sorted directory of public vars in a namespace", :row 1572} {:fixed-arities #{0 1}, :end-row 1595, :ns "cljs.repl", :name "pst", :lang :clj, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[]" "[e]"], :row 1578} {:end-row 34, :filename "cljs/repl.cljc", :lang :cljs, :name "*cljs-verbose*", :ns "cljs.repl", :row 34} {:end-row 35, :filename "cljs/repl.cljc", :lang :cljs, :name "*repl-opts*", :ns "cljs.repl", :row 35} {:end-row 36, :filename "cljs/repl.cljc", :lang :cljs, :name "*repl-env*", :ns "cljs.repl", :row 36} {:doc "Set of all known REPL options.", :end-row 43, :filename "cljs/repl.cljc", :lang :cljs, :name "known-repl-opts", :ns "cljs.repl", :row 38} {:end-row 47, :private true, :ns "cljs.repl", :name "err-out", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[& body]"], :row 45} {:fixed-arities #{1}, :end-row 64, :ns "cljs.repl", :name "skip-if-eol", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[s]"], :doc "If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\newline.", :row 52} {:fixed-arities #{1}, :end-row 83, :ns "cljs.repl", :name "skip-whitespace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[s]"], :doc "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.", :row 66} {:fixed-arities #{3 2}, :end-row 110, :ns "cljs.repl", :name "repl-read", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[request-prompt request-exit]" "[request-prompt request-exit opts]"], :doc "Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.", :row 85} {:end-row 116, :filename "cljs/repl.cljc", :lang :cljs, :name "IReplEnvOptions", :ns "cljs.repl", :row 115} {:fixed-arities #{1}, :end-row 116, :ns "cljs.repl", :name "-repl-options", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]"], :doc "Return default REPL options for a REPL Env", :row 116} {:arglist-strs ["[repl-env]"], :end-row 119, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "repl-options", :ns "cljs.repl", :row 118} {:end-row 125, :filename "cljs/repl.cljc", :lang :cljs, :name "IJavaScriptEnv", :ns "cljs.repl", :row 121} {:fixed-arities #{2}, :end-row 122, :ns "cljs.repl", :name "-setup", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env opts]"], :doc "initialize the environment", :row 122} {:fixed-arities #{4}, :end-row 123, :ns "cljs.repl", :name "-evaluate", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env filename line js]"], :doc "evaluate a javascript string", :row 123} {:fixed-arities #{3}, :end-row 124, :ns "cljs.repl", :name "-load", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env provides url]"], :doc "load code at url into the environment", :row 124} {:fixed-arities #{1}, :end-row 125, :ns "cljs.repl", :name "-tear-down", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]"], :doc "dispose of the environment", :row 125} {:arglist-strs ["[repl-env opts]"], :end-row 128, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "setup", :ns "cljs.repl", :row 127} {:arglist-strs ["[repl-env filename line js]"], :end-row 131, :filename "cljs/repl.cljc", :fixed-arities #{4}, :lang :cljs, :name "evaluate", :ns "cljs.repl", :row 130} {:arglist-strs ["[repl-env provides url]"], :end-row 134, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :cljs, :name "load", :ns "cljs.repl", :row 133} {:arglist-strs ["[repl-env]"], :end-row 137, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "tear-down", :ns "cljs.repl", :row 136} {:end-row 147, :filename "cljs/repl.cljc", :lang :cljs, :name "IParseError", :ns "cljs.repl", :row 144} {:fixed-arities #{3}, :end-row 147, :ns "cljs.repl", :name "-parse-error", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env error build-options]"], :doc "Given the original JavaScript error return the error to actually\n     use.", :row 145} {:end-row 159, :filename "cljs/repl.cljc", :lang :cljs, :name "IGetError", :ns "cljs.repl", :row 149} {:fixed-arities #{4}, :end-row 159, :ns "cljs.repl", :name "-get-error", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env name env build-options]"], :doc "Given a symbol representing a var holding an error, an analysis\n     environment, and the REPL/compiler options return the canonical error\n     representation:\n\n     {:value <string>\n      :stacktrace <string>}\n\n    :value should be the host environment JavaScript error message string.\n    :stacktrace should be the host JavaScript environment stacktrace string.", :row 150} {:end-row 174, :filename "cljs/repl.cljc", :lang :cljs, :name "IParseStacktrace", :ns "cljs.repl", :row 161} {:fixed-arities #{4}, :end-row 174, :ns "cljs.repl", :name "-parse-stacktrace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env stacktrace error build-options]"], :doc "Given the original JavaScript stacktrace string, the entire original error\n     value and current compiler build options, parse the stacktrace into the\n     canonical form:\n\n     [{:file <string>\n       :function <string>\n       :line <integer>\n       :column <integer>}*]\n\n     :file must be a URL path (without protocol) relative to :output-dir. If\n     no source file can be supplied (such as REPL defs), :file may be a custom\n     identifier string surrounded by angle brackets, i.e. \"<cljs repl>\".", :row 162} {:end-row 179, :filename "cljs/repl.cljc", :lang :cljs, :name "IPrintStacktrace", :ns "cljs.repl", :row 176} {:fixed-arities #{4}, :end-row 179, :ns "cljs.repl", :name "-print-stacktrace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env stacktrace error build-options]"], :doc "Implementing REPL evaluation environments are given the opportunity to\n     print the mapped stacktrace themselves. This permits further processing.", :row 177} {:fixed-arities #{1 2}, :end-row 191, :private true, :ns "cljs.repl", :name "env->opts", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env]" "[repl-env opts]"], :doc "Returns a hash-map containing all of the entries in [repl-env], translating\n:working-dir to :output-dir.", :row 181} {:arglist-strs ["[ijs]"], :end-row 196, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "add-url", :ns "cljs.repl", :row 193} {:arglist-strs ["[ns opts]"], :end-row 204, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "ns->input", :ns "cljs.repl", :row 198} {:arglist-strs ["[input]"], :end-row 207, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "compilable?", :ns "cljs.repl", :row 206} {:fixed-arities #{3}, :end-row 224, :private true, :ns "cljs.repl", :name "load-sources", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env sources opts]"], :doc "Load the compiled `sources` into the REPL.", :row 209} {:fixed-arities #{3}, :end-row 231, :private true, :ns "cljs.repl", :name "load-cljs-loader", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env sources opts]"], :doc "Compile and load the cljs.loader namespace if it's present in `sources`.", :row 226} {:fixed-arities #{3 2}, :end-row 252, :ns "cljs.repl", :name "load-namespace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env ns]" "[repl-env ns opts]"], :doc "Load a namespace and all of its dependencies into the evaluation environment.\n  The environment is responsible for ensuring that each namespace is\n  loaded once and only once. Returns the compiled sources.", :row 233} {:fixed-arities #{3 2}, :end-row 259, :private true, :ns "cljs.repl", :name "load-dependencies", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env requires]" "[repl-env requires opts]"], :doc "Compile and load the given `requires` and return the compiled sources.", :row 254} {:fixed-arities #{1}, :end-row 273, :ns "cljs.repl", :name "js-src->cljs-src", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Map a JavaScript output file back to the original ClojureScript source\n   file (.cljs or .cljc).", :row 261} {:fixed-arities #{1}, :end-row 293, :ns "cljs.repl", :name "read-source-map", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Return the source map for the JavaScript source file.", :row 275} {:fixed-arities #{1}, :end-row 301, :ns "cljs.repl", :name "ns-info", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Given a path to a js source file return the ns info for the corresponding\n   ClojureScript file if it exists.", :row 295} {:fixed-arities #{3}, :end-row 322, :private true, :ns "cljs.repl", :name "mapped-line-column-call", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[source-map line column]"], :doc "Given a cljs.source-map source map data structure map a generated line\n   and column back to the original line, column, and function called.", :row 303} {:fixed-arities #{2}, :end-row 362, :private true, :ns "cljs.repl", :name "mapped-frame", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[{:keys [function file line column]} opts]"], :doc "Given opts and a canonicalized JavaScript stacktrace frame, return the\n  ClojureScript frame.", :row 324} {:fixed-arities #{1 2}, :end-row 392, :ns "cljs.repl", :name "mapped-stacktrace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[stacktrace]" "[stacktrace opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   return the ClojureScript stacktrace. The canonical stacktrace must be\n   in the form:\n\n    [{:file <string>\n      :function <string>\n      :line <integer>\n      :column <integer>}*]\n\n   :file must be a URL path (without protocol) relative to :output-dir or a\n   identifier delimited by angle brackets. The returned mapped stacktrace will\n   also contain :url entries to the original sources if it can be determined\n   from the classpath.", :row 364} {:arglist-strs ["[file {:keys [output-dir temp-output-dir?]}]"], :end-row 403, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "file-display", :ns "cljs.repl", :row 394} {:fixed-arities #{1 2}, :end-row 415, :ns "cljs.repl", :name "print-mapped-stacktrace", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[stacktrace]" "[stacktrace opts]"], :doc "Given a vector representing the canonicalized JavaScript stacktrace\n   print the ClojureScript stacktrace. See mapped-stacktrace.", :row 405} {:end-row 418, :filename "cljs/repl.cljc", :lang :cljs, :name "st", :ns "cljs.repl", :row 418} {:fixed-arities #{4 5}, :end-row 491, :private true, :ns "cljs.repl", :name "display-error", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env ret form opts]" "[repl-env ret form f opts]"], :row 469} {:fixed-arities #{1}, :end-row 496, :private true, :ns "cljs.repl", :name "bytes-to-base64-str", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[bytes]"], :doc "Convert a byte array into a base-64 encoded string.", :row 493} {:fixed-arities #{4 6 5}, :end-row 583, :ns "cljs.repl", :name "evaluate-form", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env env filename form]" "[repl-env env filename form wrap]" "[repl-env env filename form wrap opts]"], :doc "Evaluate a ClojureScript form in the JavaScript environment. Returns a\n  string which is the ClojureScript return value. This string may or may\n  not be readable by the Clojure reader.", :row 498} {:arglist-strs ["[repl-env filename res]"], :end-row 590, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :cljs, :name "load-stream", :ns "cljs.repl", :row 585} {:arglist-strs ["[repl-env f]" "[repl-env f opts]"], :end-row 626, :filename "cljs/repl.cljc", :fixed-arities #{3 2}, :lang :cljs, :name "load-file", :ns "cljs.repl", :row 592} {:fixed-arities #{1}, :end-row 635, :private true, :ns "cljs.repl", :name "root-resource", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[lib]"], :doc "Returns the root directory path for a lib", :row 628} {:fixed-arities #{1}, :end-row 641, :private true, :ns "cljs.repl", :name "root-directory", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[lib]"], :doc "Returns the root resource path for a lib", :row 637} {:fixed-arities #{1}, :end-row 650, :private true, :ns "cljs.repl", :name "load-path->cp-path", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[path]"], :row 643} {:fixed-arities #{1}, :end-row 671, :private true, :ns "cljs.repl", :name "wrap-fn", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[form]"], :row 652} {:fixed-arities #{1}, :end-row 683, :private true, :ns "cljs.repl", :name "init-wrap-fn", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[form]"], :row 673} {:fixed-arities #{4 3}, :end-row 699, :ns "cljs.repl", :name "eval-cljs", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[repl-env env form]" "[repl-env env form opts]"], :doc "Given a REPL evaluation environment, an analysis environment, and a\n   form, evaluate the form and return the result. The result is always the value\n   represented as a string.", :row 685} {:arglist-strs ["[specs]"], :end-row 704, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "decorate-specs", :ns "cljs.repl", :row 701} {:fixed-arities #{1}, :end-row 747, :private true, :ns "cljs.repl", :name "wrap-self", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[f]"], :doc "Takes a self-ish fn and returns it wrapped with exception handling.\n  Compiler state is restored if self-ish fn fails.", :row 734} {:fixed-arities #{2}, :end-row 752, :private true, :ns "cljs.repl", :name "wrap-special-fns", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[wfn fns]"], :row 749} {:end-row 793, :filename "cljs/repl.cljc", :lang :cljs, :name "default-special-fns", :ns "cljs.repl", :row 754} {:fixed-arities #{1 2}, :end-row 803, :ns "cljs.repl", :name "analyze-source", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[src-dir]" "[src-dir opts]"], :doc "Given a source directory, analyzes all .cljs files. Used to populate\n  (:cljs.analyzer/namespaces compiler-env) so as to support code reflection.", :row 795} {:arglist-strs ["[]"], :end-row 806, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :cljs, :name "repl-title", :ns "cljs.repl", :row 805} {:arglist-strs ["[]"], :end-row 809, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :cljs, :name "repl-quit-prompt", :ns "cljs.repl", :row 808} {:arglist-strs ["[]"], :end-row 812, :filename "cljs/repl.cljc", :fixed-arities #{0}, :lang :cljs, :name "repl-prompt", :ns "cljs.repl", :row 811} {:fixed-arities #{1}, :end-row 818, :ns "cljs.repl", :name "demunge", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[fn-name]"], :doc "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", :row 814} {:end-row 824, :filename "cljs/repl.cljc", :lang :cljs, :name "core-namespaces", :ns "cljs.repl", :private true, :row 820} {:fixed-arities #{1}, :end-row 830, :private true, :ns "cljs.repl", :name "core-class?", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[class-name]"], :row 826} {:fixed-arities #{1}, :end-row 838, :private true, :ns "cljs.repl", :name "file-name", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[full-path]"], :doc "Helper to get just the file name part of a path or nil", :row 832} {:fixed-arities #{2}, :end-row 848, :private true, :ns "cljs.repl", :name "java-loc->source", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[clazz method]"], :doc "Convert Java class name and method symbol to source symbol, either a\n  Clojure function or Java class and method.", :row 840} {:fixed-arities #{1}, :end-row 905, :ns "cljs.repl", :name "ex-triage", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[datafied-throwable]"], :doc "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error", :row 850} {:fixed-arities #{1}, :end-row 980, :ns "cljs.repl", :name "ex-str", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[{:keys [:clojure.error/phase :clojure.error/source :clojure.error/line :clojure.error/column :clojure.error/symbol :clojure.error/class :clojure.error/cause :clojure.error/spec] :as triage-data}]"], :doc "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.", :row 907} {:arglist-strs ["[e repl-env opts]"], :end-row 998, :filename "cljs/repl.cljc", :fixed-arities #{3}, :lang :cljs, :name "repl-caught", :ns "cljs.repl", :row 982} {:arglist-strs ["[x]"], :end-row 1001, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "repl-nil?", :ns "cljs.repl", :row 1000} {:arglist-strs ["[renv inits]"], :end-row 1017, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "run-inits", :ns "cljs.repl", :row 1003} {:arglist-strs ["[opts]"], :end-row 1026, :filename "cljs/repl.cljc", :fixed-arities #{1}, :lang :cljs, :name "maybe-install-npm-deps", :ns "cljs.repl", :row 1019} {:arglist-strs ["[quit-prompt prompt]"], :end-row 1031, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "initial-prompt", :ns "cljs.repl", :row 1028} {:arglist-strs ["[repl-env {:keys [init inits need-prompt quit-prompt prompt flush read eval print caught reader print-no-newline source-map-inline wrap repl-requires ::fast-initial-prompt? compiler-env bind-err] :or {need-prompt #(if (readers/indexing-reader? *in*) (== (readers/get-column-number *in*) 1) (identity true)) fast-initial-prompt? false quit-prompt repl-title prompt repl-prompt flush flush read repl-read eval eval-cljs print println caught repl-caught reader #(readers/source-logging-push-back-reader *in* 1 \"<NO_SOURCE_FILE>\") print-no-newline print source-map-inline true repl-requires '[[cljs.repl :refer-macros [source doc find-doc apropos dir pst]] [cljs.pprint :refer [pprint] :refer-macros [pp]]] bind-err true} :as opts}]"], :end-row 1226, :filename "cljs/repl.cljc", :fixed-arities #{2}, :lang :cljs, :name "repl*", :ns "cljs.repl", :row 1033} {:arglist-strs ["[repl-env & opts]"], :doc "Generic, reusable, read-eval-print loop. By default, reads from *in* using\n  a c.t.r.reader-types/source-logging-push-back-reader,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  c.t.r.reader-types/PushbackReader or duplicate its behavior of both supporting\n  unread and collapsing CR, LF, and CRLF into a single \\newline. Options\n  are sequential keyword-value pairs. The first argument is the JavaScript\n  evaluation environment, the second argument is an extended version of the\n  standard ClojureScript compiler options. In addition to ClojureScript compiler\n  build options it also take a set of options similar to clojure.main/repl with\n  adjustments for ClojureScript evalution and compilation model:\n\n  Available clojure.main/repl style options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: #(if (c.t.r.readers-types/indexing-reader? *in*)\n                   (== (c.t.r.reader-types/get-column-number *in*) 1)\n                   (identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument. The eval function must take repl-env, the JavaScript evaluation\n       environment, env, the ClojureScript analysis environment, the form\n       and opts, the standard ClojureScript REPL/compiler options.\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: println\n\n     - :caught, function of three arguments, a throwable, called when\n       read, eval, or print throws an exception or error default. The second\n       argument is the JavaScript evaluation environment this permits context\n       sensitive handling if necessary. The third argument is opts, the standard\n       ClojureScript REPL/compiler options. In the case of errors or exception\n       in the JavaScript target, these will be thrown as\n       clojure.lang.IExceptionInfo instances.\n       default: repl-caught\n\n     - :reader, the c.t.r reader to use.\n       default: c.t.r.reader-types/source-logging-push-back-reader\n\n     - :print-no-newline, print without a newline.\n       default: print\n\n     - :source-map-inline, whether inline source maps should be enabled. Most\n       useful in browser context. Implies using a fresh reader for each form.\n       default: true", :end-row 1298, :filename "cljs/repl.cljc", :lang :cljs, :name "repl", :ns "cljs.repl", :row 1228} {:end-row 1409, :filename "cljs/repl.cljc", :lang :cljs, :name "special-doc-map", :ns "cljs.repl", :row 1303} {:fixed-arities #{1}, :end-row 1414, :private true, :ns "cljs.repl", :name "special-doc", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[name-symbol]"], :row 1411} {:end-row 1424, :filename "cljs/repl.cljc", :lang :cljs, :name "repl-special-doc-map", :ns "cljs.repl", :row 1416} {:fixed-arities #{1}, :end-row 1429, :private true, :ns "cljs.repl", :name "repl-special-doc", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[name-symbol]"], :row 1426} {:fixed-arities #{1}, :end-row 1469, :ns "cljs.repl", :name "doc", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[name]"], :doc "Prints documentation for a var or special form given its name,\n  or for a spec if given a keyword", :row 1431} {:fixed-arities #{1}, :end-row 1493, :ns "cljs.repl", :name "find-doc", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[re-string-or-pattern]"], :doc "Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern", :row 1471} {:fixed-arities #{2}, :end-row 1518, :ns "cljs.repl", :name "source-fn", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[env x]"], :doc "Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)", :row 1495} {:end-row 1521, :filename "cljs/repl.cljc", :lang :cljs, :name "cenv", :ns "cljs.repl", :row 1521} {:end-row 1522, :filename "cljs/repl.cljc", :lang :cljs, :name "aenv", :ns "cljs.repl", :row 1522} {:fixed-arities #{1}, :end-row 1538, :ns "cljs.repl", :name "source", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[n]"], :doc "Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .cljs is in the classpath.\n\n  Example: (source filter)", :row 1531} {:fixed-arities #{1}, :end-row 1545, :private true, :ns "cljs.repl", :name "named-publics-vars", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[ns]"], :doc "Gets the public vars in a namespace that are not anonymous.", :row 1540} {:fixed-arities #{1}, :end-row 1562, :ns "cljs.repl", :name "apropos", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[str-or-pattern]"], :doc "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.", :row 1547} {:fixed-arities #{1}, :end-row 1570, :private true, :ns "cljs.repl", :name "resolve-ns", :lang :cljs, :filename "cljs/repl.cljc", :arglist-strs ["[ns-sym]"], :doc "Resolves a namespace symbol to a namespace by first checking to see if it\n  is a namespace alias.", :row 1564} {:fixed-arities #{1}, :end-row 1576, :ns "cljs.repl", :name "dir", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[ns]"], :doc "Prints a sorted directory of public vars in a namespace", :row 1572} {:fixed-arities #{0 1}, :end-row 1595, :ns "cljs.repl", :name "pst", :lang :cljs, :filename "cljs/repl.cljc", :macro true, :arglist-strs ["[]" "[e]"], :row 1578} {:arglist-strs ["[{n :ns nm :name :as m}]"], :end-row 60, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "print-doc", :ns "cljs.repl", :row 15} {:arglist-strs ["[o]"], :doc "Constructs a data representation for a Error with keys:\n    :cause - root cause message\n    :phase - error phase\n    :via - cause chain, with cause keys:\n             :type - exception class symbol\n             :message - exception message\n             :data - ex-data\n             :at - top stack element\n    :trace - root cause stack elements", :end-row 97, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "Error->map", :ns "cljs.repl", :row 62} {:arglist-strs ["[datafied-throwable]"], :doc "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error", :end-row 154, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "ex-triage", :ns "cljs.repl", :row 99} {:arglist-strs ["[{:clojure.error/keys [phase source line column symbol class cause spec] :as triage-data}]"], :doc "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.", :end-row 227, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "ex-str", :ns "cljs.repl", :row 156} {:arglist-strs ["[error]"], :end-row 230, :filename "cljs/repl.cljs", :fixed-arities #{1}, :name "error->str", :ns "cljs.repl", :row 229}]} {:end-row 9, :filename "cljs/support.cljc", :lang :clj, :name "cljs.support", :row 9, :ns nil, :var-definitions [{:end-row 18, :ns "cljs.support", :name "assert-args", :lang :clj, :filename "cljs/support.cljc", :macro true, :arglist-strs ["[fnname & pairs]"], :doc "Internal - do not use!", :row 11} {:end-row 18, :ns "cljs.support", :name "assert-args", :lang :cljs, :filename "cljs/support.cljc", :macro true, :arglist-strs ["[fnname & pairs]"], :doc "Internal - do not use!", :row 11}]} {:end-row 9, :filename "cljs/support.cljc", :lang :cljs, :name "cljs.support", :row 9, :ns nil, :var-definitions [{:end-row 18, :ns "cljs.support", :name "assert-args", :lang :clj, :filename "cljs/support.cljc", :macro true, :arglist-strs ["[fnname & pairs]"], :doc "Internal - do not use!", :row 11} {:end-row 18, :ns "cljs.support", :name "assert-args", :lang :cljs, :filename "cljs/support.cljc", :macro true, :arglist-strs ["[fnname & pairs]"], :doc "Internal - do not use!", :row 11}]} {:end-row 13, :filename "cljs/js.clj", :name "cljs.js", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[& args]"], :end-row 31, :filename "cljs/js.cljs", :name "debug-prn", :ns "cljs.js", :private true, :row 28} {:arglist-strs ["[ns-sym]"], :doc "Given a namespace as a symbol return the relative path sans extension", :end-row 36, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "ns->relpath", :ns "cljs.js", :row 33} {:arglist-strs ["[file]"], :end-row 42, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "file->ns", :ns "cljs.js", :row 38} {:arglist-strs ["[ns-name]"], :end-row 49, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "drop-macros-suffix", :ns "cljs.js", :private true, :row 44} {:arglist-strs ["[sym]"], :end-row 53, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "elide-macros-suffix", :ns "cljs.js", :private true, :row 51} {:arglist-strs ["[sym]"], :end-row 59, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "resolve-symbol", :ns "cljs.js", :private true, :row 55} {:arglist-strs ["[eof rdr]"], :end-row 63, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "read", :ns "cljs.js", :private true, :row 61} {:arglist-strs ["[x]"], :end-row 66, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "atom?", :ns "cljs.js", :private true, :row 65} {:arglist-strs ["[x]"], :end-row 69, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "valid-name?", :ns "cljs.js", :private true, :row 68} {:arglist-strs ["[x]"], :end-row 72, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "valid-opts?", :ns "cljs.js", :private true, :row 71} {:doc "Each runtime environment provides a different way to load a library.\n  Whatever function *load-fn* is bound to will be passed two arguments - a\n  map and a callback function: The map will have the following keys:\n\n  :name   - the name of the library (a symbol)\n  :macros - modifier signaling a macros namespace load\n  :path   - munged relative library path (a string)\n\n  It is up to the implementor to correctly resolve the corresponding .cljs,\n  .cljc, or .js resource (the order must be respected). If :macros is true\n  resolution should only consider .clj or .cljc resources (the order must be\n  respected). Upon resolution the callback should be invoked with a map\n  containing the following keys:\n\n  :lang       - the language, :clj or :js\n  :source     - the source of the library (a string)\n  :file       - optional, the file path, it will be added to AST's :file keyword\n                (but not in :meta)\n  :cache      - optional, if a :clj namespace has been precompiled to :js, can\n                give an analysis cache for faster loads.\n  :source-map - optional, if a :clj namespace has been precompiled to :js, can\n                give a V3 source map JSON\n\n  If the resource could not be resolved, the callback should be invoked with\n  nil.", :end-row 103, :filename "cljs/js.cljs", :name "*load-fn*", :ns "cljs.js", :row 74} {:doc "Each runtime environment provides various ways to eval JavaScript\n  source. Whatever function *eval-fn* is bound to will be passed a map\n  containing the following keys:\n\n  :source - the source of the library (string)\n  :name   - used to unique identify the script (symbol)\n  :cache  - if the source was originally ClojureScript, will be given the\n            analysis cache.\n\n  The result of evaluation should be the return value.", :end-row 119, :filename "cljs/js.cljs", :name "*eval-fn*", :ns "cljs.js", :row 105} {:arglist-strs ["[{:keys [source] :as resource}]"], :doc "A default JavaScript evaluation function.", :end-row 124, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "js-eval", :ns "cljs.js", :row 121} {:arglist-strs ["[ex]"], :end-row 127, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "wrap-error", :ns "cljs.js", :private true, :row 126} {:arglist-strs ["[]" "[init]"], :doc "Construct an empty compiler state. Required to invoke analyze, compile,\n   eval and eval-str.", :end-row 139, :filename "cljs/js.cljs", :fixed-arities #{0 1}, :name "empty-state", :ns "cljs.js", :row 129} {:arglist-strs ["[state ns cache]"], :end-row 142, :filename "cljs/js.cljs", :fixed-arities #{3}, :name "load-analysis-cache!", :ns "cljs.js", :row 141} {:arglist-strs ["[state ns sm-json]"], :end-row 146, :filename "cljs/js.cljs", :fixed-arities #{3}, :name "load-source-map!", :ns "cljs.js", :row 144} {:arglist-strs ["[]"], :end-row 152, :filename "cljs/js.cljs", :fixed-arities #{0}, :name "sm-data", :ns "cljs.js", :private true, :row 148} {:arglist-strs ["[s pre]"], :end-row 155, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "prefix", :ns "cljs.js", :private true, :row 154} {:arglist-strs ["[state name source sb sm-data {:keys [output-dir asset-path source-map-timestamp] :as opts}]"], :end-row 185, :filename "cljs/js.cljs", :fixed-arities #{6}, :name "append-source-map", :ns "cljs.js", :private true, :row 157} {:arglist-strs ["[compiler cljs-ns]"], :end-row 192, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "alias-map", :ns "cljs.js", :private true, :row 187} {:end-row 197, :filename "cljs/js.cljs", :name "eval-str*", :ns "cljs.js", :row 197} {:end-row 199, :filename "cljs/js.cljs", :name "*loaded*", :ns "cljs.js", :row 199} {:fixed-arities #{4}, :end-row 218, :private true, :ns "cljs.js", :name "run-async!", :filename "cljs/js.cljs", :arglist-strs ["[proc coll break? cb]"], :doc "Like cljs.core/run!, but for an async procedure, and with the\n  ability to break prior to processing the entire collection.\n\n  Chains successive calls to the supplied procedure for items in\n  the collection. The procedure should accept an item from the\n  collection and a callback of one argument. If the break? predicate,\n  when applied to the procedure callback value, yields a truthy\n  result, terminates early calling the supplied cb with the callback\n  value. Otherwise, when complete, calls cb with nil.", :row 201} {:end-row 223, :filename "cljs/js.cljs", :name "require", :ns "cljs.js", :row 220} {:arglist-strs ["[bound-vars names opts cb]"], :end-row 231, :filename "cljs/js.cljs", :fixed-arities #{4}, :name "process-deps", :ns "cljs.js", :private true, :row 225} {:arglist-strs ["[bound-vars cache opts cb]"], :end-row 240, :filename "cljs/js.cljs", :fixed-arities #{4}, :name "process-macros-deps", :ns "cljs.js", :private true, :row 233} {:arglist-strs ["[bound-vars cache opts cb]"], :end-row 247, :filename "cljs/js.cljs", :fixed-arities #{4}, :name "process-libs-deps", :ns "cljs.js", :private true, :row 242} {:arglist-strs ["[st name file opts]"], :end-row 257, :filename "cljs/js.cljs", :fixed-arities #{4}, :name "pre-file-side-effects", :ns "cljs.js", :private true, :row 249} {:arglist-strs ["[file opts]"], :end-row 266, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "post-file-side-effects", :ns "cljs.js", :private true, :row 259} {:arglist-strs ["[name cb]" "[name opts cb]" "[bound-vars name opts cb]" "[bound-vars name reload opts cb]"], :end-row 353, :filename "cljs/js.cljs", :fixed-arities #{4 3 2 5}, :name "require", :ns "cljs.js", :row 268} {:arglist-strs ["[compiler in from to]"], :end-row 379, :filename "cljs/js.cljs", :fixed-arities #{4}, :name "patch-alias-map", :ns "cljs.js", :private true, :row 355} {:arglist-strs ["[deps opts]"], :end-row 382, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "self-require?", :ns "cljs.js", :private true, :row 381} {:arglist-strs ["[bound-vars ana-env lib deps cb]" "[bound-vars ana-env lib deps reload opts cb]"], :end-row 430, :filename "cljs/js.cljs", :fixed-arities #{7 5}, :name "load-deps", :ns "cljs.js", :private true, :row 384} {:end-row 432, :filename "cljs/js.cljs", :name "analyze-str*", :ns "cljs.js", :row 432} {:arglist-strs ["[bound-vars ana-env lib deps cb]" "[bound-vars ana-env lib deps opts cb]"], :end-row 489, :filename "cljs/js.cljs", :fixed-arities #{6 5}, :name "analyze-deps", :ns "cljs.js", :private true, :row 434} {:arglist-strs ["[bound-vars k macros lib reload reloads opts cb]"], :end-row 522, :filename "cljs/js.cljs", :fixed-arities #{8}, :name "load-macros", :ns "cljs.js", :private true, :row 491} {:arglist-strs ["[ast smap]" "[ast smap macros?]"], :end-row 551, :filename "cljs/js.cljs", :fixed-arities #{3 2}, :name "rewrite-ns-ast", :ns "cljs.js", :private true, :row 524} {:arglist-strs ["[{:keys [requires name] :as ast} cenv]"], :end-row 564, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "check-macro-autoload-inferring-missing", :ns "cljs.js", :private true, :row 553} {:arglist-strs ["[bound-vars ana-env ast opts cb]" "[load bound-vars ana-env {:keys [op] :as ast} opts cb]"], :end-row 640, :filename "cljs/js.cljs", :fixed-arities #{6 5}, :name "ns-side-effects", :ns "cljs.js", :private true, :row 566} {:arglist-strs ["[bound-vars sb deps ns-name emit-nil-result?]"], :end-row 651, :filename "cljs/js.cljs", :fixed-arities #{5}, :name "node-side-effects", :ns "cljs.js", :private true, :row 642} {:arglist-strs ["[bound-vars sb deps ns-name emit-nil-result?]"], :end-row 662, :filename "cljs/js.cljs", :fixed-arities #{5}, :name "global-exports-side-effects", :ns "cljs.js", :private true, :row 653} {:fixed-arities #{1}, :end-row 669, :private true, :ns "cljs.js", :name "trampoline-safe", :filename "cljs/js.cljs", :arglist-strs ["[f]"], :doc "Returns a new function that calls f but discards any return value,\n  returning nil instead, thus avoiding any inadvertent trampoline continuation\n  if a function happens to be returned.", :row 664} {:arglist-strs ["[bound-vars source name opts cb]"], :end-row 722, :filename "cljs/js.cljs", :fixed-arities #{5}, :name "analyze-str*", :ns "cljs.js", :private true, :row 671} {:arglist-strs ["[state source cb]" "[state source name cb]" "[state source name opts cb]"], :doc "Analyze ClojureScript source. The compiler state will be populated with\n   the results of analyzes. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false).\n                          Defaults to false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:statement`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value, the actual value is not meaningful. If unsuccessful the\n     map will contain a key :error with an ex-info instance describing the cause\n     of failure.", :end-row 785, :filename "cljs/js.cljs", :fixed-arities #{4 3 5}, :name "analyze-str", :ns "cljs.js", :row 724} {:end-row 790, :filename "cljs/js.cljs", :name "clear-fns!", :ns "cljs.js", :row 790} {:arglist-strs ["[bound-vars form opts cb]"], :end-row 848, :filename "cljs/js.cljs", :fixed-arities #{4}, :name "eval*", :ns "cljs.js", :private true, :row 792} {:arglist-strs ["[state form cb]" "[state form opts cb]"], :doc "Evaluate a single ClojureScript form. The parameters:\n\n   state (atom)\n     the compiler state\n\n   form (s-expr)\n     the ClojureScript source\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:statement`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the result of evalution. If unsuccessful the map will\n     contain a key :error with an ex-info instance describing the cause of\n     failure.", :end-row 902, :filename "cljs/js.cljs", :fixed-arities #{4 3}, :name "eval", :ns "cljs.js", :row 850} {:arglist-strs ["[bound-vars source name opts cb]"], :end-row 972, :filename "cljs/js.cljs", :fixed-arities #{5}, :name "compile-str*", :ns "cljs.js", :private true, :row 907} {:arglist-strs ["[state source cb]" "[state source name cb]" "[state source name opts cb]"], :doc "Compile ClojureScript source into JavaScript. The parameters:\n\n   state (atom)\n     the compiler state\n\n   source (string)\n     the ClojureScript source\n\n   name (symbol or string)\n     optional, the name of the source - used as key in :source-maps\n\n   opts (map)\n     compilation options.\n\n      :eval             - eval function to invoke, see *eval-fn*\n      :load             - library resolution function, see *load-fn*\n      :source-map       - set to true to generate inline source map information\n      :def-emits-var    - sets whether def (and derived) forms return either a Var\n                          (if set to true) or the def init value (if false). Default\n                          is false.\n      :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                          to aget/aset. Logs for incorrect values if :warn, throws if\n                          :error. Defaults to false.\n      :static-fns       - employ static dispatch to specific function arities in\n                          emitted JavaScript, as opposed to making use of the\n                          `call` construct. Defaults to false.\n      :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                          unknown functions, but instead direct invokes via\n                          `f(a0,a1...)`. Defaults to `false`.\n      :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                          at the moment.\n      :ns               - optional, the namespace in which to evaluate the source.\n      :verbose          - optional, emit details from compiler activity. Defaults to\n                          false.\n      :context          - optional, sets the context for the source. Possible values\n                          are `:expr`, `:statement` and `:return`. Defaults to\n                          `:statement`.\n\n   cb (function)\n     callback, will be invoked with a map. If successful the map will contain\n     a key :value with the compilation result (string). If unsuccessful the map\n     will contain a key :error with an ex-info instance describing the cause\n     of failure.", :end-row 1034, :filename "cljs/js.cljs", :fixed-arities #{4 3 5}, :name "compile-str", :ns "cljs.js", :row 974} {:arglist-strs ["[bound-vars source name opts cb]"], :end-row 1138, :filename "cljs/js.cljs", :fixed-arities #{5}, :name "eval-str*", :ns "cljs.js", :private true, :row 1039} {:arglist-strs ["[state source cb]" "[state source name cb]" "[state source name opts cb]"], :doc "Evalute ClojureScript source given as a string. The parameters:\n\n  state (atom)\n    the compiler state\n\n  source (string)\n    the ClojureScript source\n\n  name (symbol or string)\n    optional, the name of the source - used as key in :source-maps\n\n  opts (map)\n    compilation options.\n\n    :eval             - eval function to invoke, see *eval-fn*\n    :load             - library resolution function, see *load-fn*\n    :source-map       - set to true to generate inline source map information\n    :cache-source     - optional, a function to run side-effects with the\n                        compilation result prior to actual evalution. This function\n                        takes two arguments, the first is the eval map, the source\n                        will be under :source. The second argument is a callback of\n                        one argument. If an error occurs an :error key should be\n                        supplied.\n    :def-emits-var    - sets whether def (and derived) forms return either a Var\n                        (if set to true) or the def init value (if false). Default\n                        is false.\n    :checked-arrays   - if :warn or :error, checks inferred types and values passed\n                        to aget/aset. Logs for incorrect values if :warn, throws if\n                        :error. Defaults to false.\n    :static-fns       - employ static dispatch to specific function arities in\n                        emitted JavaScript, as opposed to making use of the\n                        `call` construct. Defaults to false.\n    :fn-invoke-direct - if `true`, does not generate `.call(null...)` calls for\n                        unknown functions, but instead direct invokes via\n                        `f(a0,a1...)`. Defaults to `false`.\n    :target           - use `:nodejs` if targeting Node.js. Takes no other options\n                        at the moment.\n    :ns               - optional, the namespace in which to evaluate the source.\n    :verbose          - optional, emit details from compiler activity. Defaults to\n                        false.\n    :context          - optional, sets the context for the source. Possible values\n                     are `:expr`, `:statement` and `:return`. Defaults to\n                      `:statement`.\n\n  cb (function)\n    callback, will be invoked with a map. If succesful the map will contain\n    a :value key with the result of evaluation and :ns the current namespace.\n    If unsuccessful will contain a :error key with an ex-info instance describing\n    the cause of failure.", :end-row 1205, :filename "cljs/js.cljs", :fixed-arities #{4 3 5}, :name "eval-str", :ns "cljs.js", :row 1140} {:end-row 1213, :filename "cljs/js.cljs", :name "fn-index", :ns "cljs.js", :private true, :row 1213} {:end-row 1214, :filename "cljs/js.cljs", :name "fn-refs", :ns "cljs.js", :private true, :row 1214} {:fixed-arities #{0}, :end-row 1219, :private true, :ns "cljs.js", :name "clear-fns!", :filename "cljs/js.cljs", :arglist-strs ["[]"], :doc "Clears saved functions.", :row 1216} {:fixed-arities #{1}, :end-row 1226, :private true, :ns "cljs.js", :name "put-fn", :filename "cljs/js.cljs", :arglist-strs ["[f]"], :doc "Saves a function, returning a numeric representation.", :row 1221} {:fixed-arities #{1}, :end-row 1231, :private true, :ns "cljs.js", :name "get-fn", :filename "cljs/js.cljs", :arglist-strs ["[n]"], :doc "Gets a function, given its numeric representation.", :row 1228} {:arglist-strs ["[f]"], :end-row 1234, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "emit-fn", :ns "cljs.js", :private true, :row 1233} {:arglist-strs ["[form]" "[form ns]"], :end-row 1258, :filename "cljs/js.cljs", :fixed-arities #{1 2}, :name "eval-impl", :ns "cljs.js", :private true, :row 1244} {:end-row 1266, :filename "cljs/js.cljs", :name "vm", :ns "cljs.js", :row 1266} {:end-row 1267, :filename "cljs/js.cljs", :name "fs", :ns "cljs.js", :row 1267} {:end-row 1268, :filename "cljs/js.cljs", :name "st", :ns "cljs.js", :row 1268} {:arglist-strs ["[{:keys [name source]}]"], :end-row 1273, :filename "cljs/js.cljs", :fixed-arities #{1}, :name "node-eval", :ns "cljs.js", :row 1272} {:end-row 1278, :filename "cljs/js.cljs", :name "libs", :ns "cljs.js", :row 1275} {:arglist-strs ["[{:keys [name macros]} cb]"], :end-row 1289, :filename "cljs/js.cljs", :fixed-arities #{2}, :name "node-load", :ns "cljs.js", :row 1280} {:arglist-strs ["[env ast opts]"], :end-row 1292, :filename "cljs/js.cljs", :fixed-arities #{3}, :name "elide-env", :ns "cljs.js", :row 1291} {:arglist-strs ["[state & body]"], :end-row 18, :filename "cljs/js.clj", :macro true, :name "with-state", :ns "cljs.js", :row 15} {:arglist-strs ["[]"], :end-row 24, :filename "cljs/js.clj", :fixed-arities #{0}, :macro true, :name "dump-core", :ns "cljs.js", :row 20}]} {:end-row 15, :filename "cljs/spec/test/alpha.cljc", :lang :clj, :name "cljs.spec.test.alpha", :row 9, :ns nil, :var-definitions [{:end-row 17, :filename "cljs/spec/test/alpha.cljc", :lang :clj, :name "instrumented-vars", :ns "cljs.spec.test.alpha", :private true, :row 17} {:fixed-arities #{1}, :end-row 23, :private true, :ns "cljs.spec.test.alpha", :name "collectionize", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[x]"], :row 19} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.spec.test.alpha", :name "enumerate-namespace*", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :row 25} {:fixed-arities #{1}, :end-row 40, :ns "cljs.spec.test.alpha", :name "enumerate-namespace", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[ns-sym-or-syms]"], :doc "Given a symbol naming an ns, or a collection of such symbols,\nreturns the set of all symbols naming vars in those nses.", :row 36} {:fixed-arities #{1}, :end-row 44, :private true, :ns "cljs.spec.test.alpha", :name "fn-spec-name?", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[s]"], :row 42} {:end-row 58, :ns "cljs.spec.test.alpha", :name "with-instrument-disabled", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Disables instrument's checking of calls, within a scope.", :row 46} {:fixed-arities #{2}, :end-row 72, :ns "cljs.spec.test.alpha", :name "instrument-1", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s] opts]"], :row 60} {:fixed-arities #{1}, :end-row 81, :ns "cljs.spec.test.alpha", :name "unstrument-1", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s]]"], :row 74} {:fixed-arities #{1}, :end-row 96, :private true, :ns "cljs.spec.test.alpha", :name "sym-or-syms->syms", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :row 83} {:fixed-arities #{1}, :end-row 107, :private true, :ns "cljs.spec.test.alpha", :name "form->sym-or-syms", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :doc "Helper for extracting a symbol or symbols from a (potentially\n  user-supplied) quoted form. In the case that the form has ::no-eval meta, we\n  know it was generated by us and we directly extract the result, assuming the\n  shape of the form. This avoids applying eval to extremely large forms in the\n  latter case.", :row 98} {:fixed-arities #{0 1 2}, :end-row 167, :ns "cljs.spec.test.alpha", :name "instrument", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[xs]" "[sym-or-syms opts]"], :doc "Instruments the vars named by sym-or-syms, a symbol or collection\nof symbols, or all instrumentable vars if sym-or-syms is not\nspecified. If a symbol identifies a namespace then all symbols in that\nnamespace will be enumerated.\n\nIf a var has an :args fn-spec, sets the var's root binding to a\nfn that checks arg conformance (throwing an exception on failure)\nbefore delegating to the original fn.\n\nThe opts map can be used to override registered specs, and/or to\nreplace fn implementations entirely. Opts for symbols not included\nin sym-or-syms are ignored. This facilitates sharing a common\noptions map across many different calls to instrument.\n\nThe opts map may have the following keys:\n\n  :spec     a map from var-name symbols to override specs\n  :stub     a set of var-name symbols to be replaced by stubs\n  :gen      a map from spec names to generator overrides\n  :replace  a map from var-name symbols to replacement fns\n\n:spec overrides registered fn-specs with specs your provide. Use\n:spec overrides to provide specs for libraries that do not have\nthem, or to constrain your own use of a fn to a subset of its\nspec'ed contract.\n\n:stub replaces a fn with a stub that checks :args, then uses the\n:ret spec to generate a return value.\n\n:gen overrides are used only for :stub generation.\n\n:replace replaces a fn with a fn that checks args conformance, then\ninvokes the fn you provide, enabling arbitrary stubbing and mocking.\n\n:spec can be used in combination with :stub or :replace.\n\nReturns a collection of syms naming the vars instrumented.", :row 109} {:fixed-arities #{0 1}, :end-row 188, :ns "cljs.spec.test.alpha", :name "unstrument", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[sym-or-syms]"], :doc "Undoes instrument on the vars named by sym-or-syms, specified\nas in instrument. With no args, unstruments all instrumented vars.\nReturns a collection of syms naming the vars unstrumented.", :row 169} {:fixed-arities #{4}, :end-row 222, :ns "cljs.spec.test.alpha", :name "check-1", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s :as qs] f spec opts]"], :row 192} {:fixed-arities #{3 2}, :end-row 232, :ns "cljs.spec.test.alpha", :name "check-fn", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f spec]" "[f spec opts]"], :doc "Runs generative tests for fn f using spec and opts. See\n'check' for options and return.", :row 224} {:fixed-arities #{0}, :end-row 236, :private true, :ns "cljs.spec.test.alpha", :name "registry-ref", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[]"], :row 234} {:arglist-strs ["[]" "[opts]"], :end-row 244, :filename "cljs/spec/test/alpha.cljc", :fixed-arities #{0 1}, :lang :clj, :name "checkable-syms*", :ns "cljs.spec.test.alpha", :row 238} {:fixed-arities #{0 1}, :end-row 256, :ns "cljs.spec.test.alpha", :name "checkable-syms", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[opts]"], :doc "Given an opts map as per check, returns the set of syms that\ncan be checked.", :row 246} {:fixed-arities #{0 1 2}, :end-row 309, :ns "cljs.spec.test.alpha", :name "check", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[sym-or-syms]" "[sym-or-syms opts]"], :doc "Run generative tests for spec conformance on vars named by\nsym-or-syms, a symbol or collection of symbols. If sym-or-syms\nis not specified, check all checkable vars. If a symbol identifies a\nnamespace then all symbols in that namespace will be enumerated.\n\nThe opts map includes the following optional keys, where stc\naliases clojure.spec.test.check:\n\n::stc/opts  opts to flow through test.check/quick-check\n:gen        map from spec names to generator overrides\n\nThe ::stc/opts include :num-tests in addition to the keys\ndocumented by test.check. Generator overrides are passed to\nspec/gen when generating function args.\n\nReturns a lazy sequence of check result maps with the following\nkeys\n\n:spec       the spec tested\n:sym        optional symbol naming the var tested\n:failure    optional test failure\n::stc/ret   optional value returned by test.check/quick-check\n\nThe value for :failure can be any exception. Exceptions thrown by\nspec itself will have an ::s/failure value in ex-data:\n\n:check-failed   at least one checked return did not conform\n:no-args-spec   no :args spec provided\n:no-fn          no fn provided\n:no-fspec       no fspec provided\n:no-gen         unable to generate :args\n:instrument     invalid args detected by instrument\n", :row 258} {:fixed-arities #{4}, :end-row 322, :private true, :ns "cljs.spec.test.alpha", :name "maybe-setup-static-dispatch", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f ret conform! arity]"], :row 311} {:fixed-arities #{4}, :end-row 329, :private true, :ns "cljs.spec.test.alpha", :name "setup-static-dispatches", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f ret conform! max-arity]"], :row 324} {:end-row 17, :filename "cljs/spec/test/alpha.cljc", :lang :cljs, :name "instrumented-vars", :ns "cljs.spec.test.alpha", :private true, :row 17} {:fixed-arities #{1}, :end-row 23, :private true, :ns "cljs.spec.test.alpha", :name "collectionize", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[x]"], :row 19} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.spec.test.alpha", :name "enumerate-namespace*", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :row 25} {:fixed-arities #{1}, :end-row 40, :ns "cljs.spec.test.alpha", :name "enumerate-namespace", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[ns-sym-or-syms]"], :doc "Given a symbol naming an ns, or a collection of such symbols,\nreturns the set of all symbols naming vars in those nses.", :row 36} {:fixed-arities #{1}, :end-row 44, :private true, :ns "cljs.spec.test.alpha", :name "fn-spec-name?", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[s]"], :row 42} {:end-row 58, :ns "cljs.spec.test.alpha", :name "with-instrument-disabled", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Disables instrument's checking of calls, within a scope.", :row 46} {:fixed-arities #{2}, :end-row 72, :ns "cljs.spec.test.alpha", :name "instrument-1", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s] opts]"], :row 60} {:fixed-arities #{1}, :end-row 81, :ns "cljs.spec.test.alpha", :name "unstrument-1", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s]]"], :row 74} {:fixed-arities #{1}, :end-row 96, :private true, :ns "cljs.spec.test.alpha", :name "sym-or-syms->syms", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :row 83} {:fixed-arities #{1}, :end-row 107, :private true, :ns "cljs.spec.test.alpha", :name "form->sym-or-syms", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :doc "Helper for extracting a symbol or symbols from a (potentially\n  user-supplied) quoted form. In the case that the form has ::no-eval meta, we\n  know it was generated by us and we directly extract the result, assuming the\n  shape of the form. This avoids applying eval to extremely large forms in the\n  latter case.", :row 98} {:fixed-arities #{0 1 2}, :end-row 167, :ns "cljs.spec.test.alpha", :name "instrument", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[xs]" "[sym-or-syms opts]"], :doc "Instruments the vars named by sym-or-syms, a symbol or collection\nof symbols, or all instrumentable vars if sym-or-syms is not\nspecified. If a symbol identifies a namespace then all symbols in that\nnamespace will be enumerated.\n\nIf a var has an :args fn-spec, sets the var's root binding to a\nfn that checks arg conformance (throwing an exception on failure)\nbefore delegating to the original fn.\n\nThe opts map can be used to override registered specs, and/or to\nreplace fn implementations entirely. Opts for symbols not included\nin sym-or-syms are ignored. This facilitates sharing a common\noptions map across many different calls to instrument.\n\nThe opts map may have the following keys:\n\n  :spec     a map from var-name symbols to override specs\n  :stub     a set of var-name symbols to be replaced by stubs\n  :gen      a map from spec names to generator overrides\n  :replace  a map from var-name symbols to replacement fns\n\n:spec overrides registered fn-specs with specs your provide. Use\n:spec overrides to provide specs for libraries that do not have\nthem, or to constrain your own use of a fn to a subset of its\nspec'ed contract.\n\n:stub replaces a fn with a stub that checks :args, then uses the\n:ret spec to generate a return value.\n\n:gen overrides are used only for :stub generation.\n\n:replace replaces a fn with a fn that checks args conformance, then\ninvokes the fn you provide, enabling arbitrary stubbing and mocking.\n\n:spec can be used in combination with :stub or :replace.\n\nReturns a collection of syms naming the vars instrumented.", :row 109} {:fixed-arities #{0 1}, :end-row 188, :ns "cljs.spec.test.alpha", :name "unstrument", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[sym-or-syms]"], :doc "Undoes instrument on the vars named by sym-or-syms, specified\nas in instrument. With no args, unstruments all instrumented vars.\nReturns a collection of syms naming the vars unstrumented.", :row 169} {:fixed-arities #{4}, :end-row 222, :ns "cljs.spec.test.alpha", :name "check-1", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s :as qs] f spec opts]"], :row 192} {:fixed-arities #{3 2}, :end-row 232, :ns "cljs.spec.test.alpha", :name "check-fn", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f spec]" "[f spec opts]"], :doc "Runs generative tests for fn f using spec and opts. See\n'check' for options and return.", :row 224} {:fixed-arities #{0}, :end-row 236, :private true, :ns "cljs.spec.test.alpha", :name "registry-ref", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[]"], :row 234} {:arglist-strs ["[]" "[opts]"], :end-row 244, :filename "cljs/spec/test/alpha.cljc", :fixed-arities #{0 1}, :lang :cljs, :name "checkable-syms*", :ns "cljs.spec.test.alpha", :row 238} {:fixed-arities #{0 1}, :end-row 256, :ns "cljs.spec.test.alpha", :name "checkable-syms", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[opts]"], :doc "Given an opts map as per check, returns the set of syms that\ncan be checked.", :row 246} {:fixed-arities #{0 1 2}, :end-row 309, :ns "cljs.spec.test.alpha", :name "check", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[sym-or-syms]" "[sym-or-syms opts]"], :doc "Run generative tests for spec conformance on vars named by\nsym-or-syms, a symbol or collection of symbols. If sym-or-syms\nis not specified, check all checkable vars. If a symbol identifies a\nnamespace then all symbols in that namespace will be enumerated.\n\nThe opts map includes the following optional keys, where stc\naliases clojure.spec.test.check:\n\n::stc/opts  opts to flow through test.check/quick-check\n:gen        map from spec names to generator overrides\n\nThe ::stc/opts include :num-tests in addition to the keys\ndocumented by test.check. Generator overrides are passed to\nspec/gen when generating function args.\n\nReturns a lazy sequence of check result maps with the following\nkeys\n\n:spec       the spec tested\n:sym        optional symbol naming the var tested\n:failure    optional test failure\n::stc/ret   optional value returned by test.check/quick-check\n\nThe value for :failure can be any exception. Exceptions thrown by\nspec itself will have an ::s/failure value in ex-data:\n\n:check-failed   at least one checked return did not conform\n:no-args-spec   no :args spec provided\n:no-fn          no fn provided\n:no-fspec       no fspec provided\n:no-gen         unable to generate :args\n:instrument     invalid args detected by instrument\n", :row 258} {:fixed-arities #{4}, :end-row 322, :private true, :ns "cljs.spec.test.alpha", :name "maybe-setup-static-dispatch", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f ret conform! arity]"], :row 311} {:fixed-arities #{4}, :end-row 329, :private true, :ns "cljs.spec.test.alpha", :name "setup-static-dispatches", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f ret conform! max-arity]"], :row 324} {:arglist-strs ["[f coll]"], :end-row 31, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "distinct-by", :ns "cljs.spec.test.alpha", :row 20} {:arglist-strs ["[x]"], :end-row 35, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "->sym", :ns "cljs.spec.test.alpha", :row 33} {:doc "if false, instrumented fns call straight through", :end-row 41, :filename "cljs/spec/test/alpha.cljs", :name "*instrument-enabled*", :ns "cljs.spec.test.alpha", :private true, :row 39} {:arglist-strs ["[]"], :end-row 47, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{0}, :name "get-host-port", :ns "cljs.spec.test.alpha", :row 43} {:arglist-strs ["[]"], :end-row 56, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{0}, :name "get-ua-product", :ns "cljs.spec.test.alpha", :row 49} {:arglist-strs ["[]"], :end-row 59, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{0}, :name "get-env", :ns "cljs.spec.test.alpha", :row 58} {:fixed-arities #{1}, :end-row 64, :private true, :ns "cljs.spec.test.alpha", :name "fn-spec?", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[m]"], :doc "Fn-spec must include at least :args or :ret specs.", :row 61} {:arglist-strs ["[spec v]"], :end-row 70, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "explain-data*", :ns "cljs.spec.test.alpha", :private true, :row 67} {:arglist-strs ["[st]"], :end-row 81, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "find-caller", :ns "cljs.spec.test.alpha", :private true, :row 72} {:arglist-strs ["[v f fn-spec]"], :end-row 135, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{3}, :name "spec-checking-fn", :ns "cljs.spec.test.alpha", :private true, :row 85} {:arglist-strs ["[v spec]"], :end-row 140, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "no-fspec", :ns "cljs.spec.test.alpha", :private true, :row 137} {:end-row 142, :filename "cljs/spec/test/alpha.cljs", :name "instrumented-vars", :ns "cljs.spec.test.alpha", :private true, :row 142} {:fixed-arities #{4}, :end-row 149, :private true, :ns "cljs.spec.test.alpha", :name "instrument-choose-fn", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[f spec sym {over :gen :keys [stub replace]}]"], :doc "Helper for instrument.", :row 144} {:fixed-arities #{3}, :end-row 154, :private true, :ns "cljs.spec.test.alpha", :name "instrument-choose-spec", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[spec sym {overrides :spec}]"], :doc "Helper for instrument", :row 151} {:arglist-strs ["[s v opts]"], :end-row 167, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{3}, :name "instrument-1*", :ns "cljs.spec.test.alpha", :private true, :row 156} {:arglist-strs ["[s v]"], :end-row 176, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "unstrument-1*", :ns "cljs.spec.test.alpha", :private true, :row 169} {:arglist-strs ["[s]"], :end-row 180, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "fn-spec-name?", :ns "cljs.spec.test.alpha", :private true, :row 178} {:arglist-strs ["[x]"], :end-row 186, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "collectionize", :ns "cljs.spec.test.alpha", :private true, :row 182} {:arglist-strs ["[]" "[opts]"], :doc "Given an opts map as per instrument, returns the set of syms\nthat can be instrumented.", :end-row 197, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{0 1}, :name "instrumentable-syms", :ns "cljs.spec.test.alpha", :row 188} {:arglist-strs ["[args spec v role]"], :end-row 209, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{4}, :name "explain-check", :ns "cljs.spec.test.alpha", :private true, :row 201} {:fixed-arities #{3}, :end-row 226, :private true, :ns "cljs.spec.test.alpha", :name "check-call", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[f specs args]"], :doc "Returns true if call passes specs, otherwise *returns* an exception\nwith explain-data + ::s/failure.", :row 211} {:arglist-strs ["[f specs {gen :gen opts :clojure.spec.test.check/opts}]"], :end-row 235, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{3}, :name "quick-check", :ns "cljs.spec.test.alpha", :private true, :row 228} {:fixed-arities #{4}, :end-row 247, :private true, :ns "cljs.spec.test.alpha", :name "make-check-result", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[check-sym spec test-check-ret tc-ret-key]"], :doc "Builds spec result map.", :row 237} {:arglist-strs ["[opts]"], :end-row 251, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "validate-check-opts", :ns "cljs.spec.test.alpha", :row 249} {:arglist-strs ["[x]"], :end-row 257, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "failure-type", :ns "cljs.spec.test.alpha", :private true, :row 255} {:arglist-strs ["[x]"], :end-row 263, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "unwrap-failure", :ns "cljs.spec.test.alpha", :private true, :row 259} {:fixed-arities #{1}, :end-row 276, :private true, :ns "cljs.spec.test.alpha", :name "result-type", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[ret]"], :doc "Returns the type of the check result. This can be any of the\n::s/failure keywords documented in 'check', or:\n\n  :check-passed   all checked fn returns conformed\n  :check-threw    checked fn threw an exception", :row 265} {:arglist-strs ["[x]"], :doc "Given a check result, returns an abbreviated version\nsuitable for summary use.", :end-row 286, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "abbrev-result", :ns "cljs.spec.test.alpha", :row 278} {:arglist-strs ["[check-results]" "[check-results summary-result]"], :doc "Given a collection of check-results, e.g. from 'check', pretty\nprints the summary-result (default abbrev-result) of each.\n\nReturns a map with :total, the total number of results, plus a\nkey with a count for each different :type of result.", :end-row 303, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1 2}, :name "summarize-results", :ns "cljs.spec.test.alpha", :row 288} {:arglist-strs ["[start end]"], :doc "Returns random int in range start <= rand < end", :end-row 335, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "ranged-rand", :ns "cljs.spec.test.alpha", :row 332} {:arglist-strs ["[a]" "[a b]"], :end-row 361, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1 2}, :name "foo", :ns "cljs.spec.test.alpha", :row 358}]} {:end-row 15, :filename "cljs/spec/test/alpha.cljc", :lang :cljs, :name "cljs.spec.test.alpha", :row 9, :ns nil, :var-definitions [{:end-row 17, :filename "cljs/spec/test/alpha.cljc", :lang :clj, :name "instrumented-vars", :ns "cljs.spec.test.alpha", :private true, :row 17} {:fixed-arities #{1}, :end-row 23, :private true, :ns "cljs.spec.test.alpha", :name "collectionize", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[x]"], :row 19} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.spec.test.alpha", :name "enumerate-namespace*", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :row 25} {:fixed-arities #{1}, :end-row 40, :ns "cljs.spec.test.alpha", :name "enumerate-namespace", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[ns-sym-or-syms]"], :doc "Given a symbol naming an ns, or a collection of such symbols,\nreturns the set of all symbols naming vars in those nses.", :row 36} {:fixed-arities #{1}, :end-row 44, :private true, :ns "cljs.spec.test.alpha", :name "fn-spec-name?", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[s]"], :row 42} {:end-row 58, :ns "cljs.spec.test.alpha", :name "with-instrument-disabled", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Disables instrument's checking of calls, within a scope.", :row 46} {:fixed-arities #{2}, :end-row 72, :ns "cljs.spec.test.alpha", :name "instrument-1", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s] opts]"], :row 60} {:fixed-arities #{1}, :end-row 81, :ns "cljs.spec.test.alpha", :name "unstrument-1", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s]]"], :row 74} {:fixed-arities #{1}, :end-row 96, :private true, :ns "cljs.spec.test.alpha", :name "sym-or-syms->syms", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :row 83} {:fixed-arities #{1}, :end-row 107, :private true, :ns "cljs.spec.test.alpha", :name "form->sym-or-syms", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :doc "Helper for extracting a symbol or symbols from a (potentially\n  user-supplied) quoted form. In the case that the form has ::no-eval meta, we\n  know it was generated by us and we directly extract the result, assuming the\n  shape of the form. This avoids applying eval to extremely large forms in the\n  latter case.", :row 98} {:fixed-arities #{0 1 2}, :end-row 167, :ns "cljs.spec.test.alpha", :name "instrument", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[xs]" "[sym-or-syms opts]"], :doc "Instruments the vars named by sym-or-syms, a symbol or collection\nof symbols, or all instrumentable vars if sym-or-syms is not\nspecified. If a symbol identifies a namespace then all symbols in that\nnamespace will be enumerated.\n\nIf a var has an :args fn-spec, sets the var's root binding to a\nfn that checks arg conformance (throwing an exception on failure)\nbefore delegating to the original fn.\n\nThe opts map can be used to override registered specs, and/or to\nreplace fn implementations entirely. Opts for symbols not included\nin sym-or-syms are ignored. This facilitates sharing a common\noptions map across many different calls to instrument.\n\nThe opts map may have the following keys:\n\n  :spec     a map from var-name symbols to override specs\n  :stub     a set of var-name symbols to be replaced by stubs\n  :gen      a map from spec names to generator overrides\n  :replace  a map from var-name symbols to replacement fns\n\n:spec overrides registered fn-specs with specs your provide. Use\n:spec overrides to provide specs for libraries that do not have\nthem, or to constrain your own use of a fn to a subset of its\nspec'ed contract.\n\n:stub replaces a fn with a stub that checks :args, then uses the\n:ret spec to generate a return value.\n\n:gen overrides are used only for :stub generation.\n\n:replace replaces a fn with a fn that checks args conformance, then\ninvokes the fn you provide, enabling arbitrary stubbing and mocking.\n\n:spec can be used in combination with :stub or :replace.\n\nReturns a collection of syms naming the vars instrumented.", :row 109} {:fixed-arities #{0 1}, :end-row 188, :ns "cljs.spec.test.alpha", :name "unstrument", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[sym-or-syms]"], :doc "Undoes instrument on the vars named by sym-or-syms, specified\nas in instrument. With no args, unstruments all instrumented vars.\nReturns a collection of syms naming the vars unstrumented.", :row 169} {:fixed-arities #{4}, :end-row 222, :ns "cljs.spec.test.alpha", :name "check-1", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s :as qs] f spec opts]"], :row 192} {:fixed-arities #{3 2}, :end-row 232, :ns "cljs.spec.test.alpha", :name "check-fn", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f spec]" "[f spec opts]"], :doc "Runs generative tests for fn f using spec and opts. See\n'check' for options and return.", :row 224} {:fixed-arities #{0}, :end-row 236, :private true, :ns "cljs.spec.test.alpha", :name "registry-ref", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[]"], :row 234} {:arglist-strs ["[]" "[opts]"], :end-row 244, :filename "cljs/spec/test/alpha.cljc", :fixed-arities #{0 1}, :lang :clj, :name "checkable-syms*", :ns "cljs.spec.test.alpha", :row 238} {:fixed-arities #{0 1}, :end-row 256, :ns "cljs.spec.test.alpha", :name "checkable-syms", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[opts]"], :doc "Given an opts map as per check, returns the set of syms that\ncan be checked.", :row 246} {:fixed-arities #{0 1 2}, :end-row 309, :ns "cljs.spec.test.alpha", :name "check", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[sym-or-syms]" "[sym-or-syms opts]"], :doc "Run generative tests for spec conformance on vars named by\nsym-or-syms, a symbol or collection of symbols. If sym-or-syms\nis not specified, check all checkable vars. If a symbol identifies a\nnamespace then all symbols in that namespace will be enumerated.\n\nThe opts map includes the following optional keys, where stc\naliases clojure.spec.test.check:\n\n::stc/opts  opts to flow through test.check/quick-check\n:gen        map from spec names to generator overrides\n\nThe ::stc/opts include :num-tests in addition to the keys\ndocumented by test.check. Generator overrides are passed to\nspec/gen when generating function args.\n\nReturns a lazy sequence of check result maps with the following\nkeys\n\n:spec       the spec tested\n:sym        optional symbol naming the var tested\n:failure    optional test failure\n::stc/ret   optional value returned by test.check/quick-check\n\nThe value for :failure can be any exception. Exceptions thrown by\nspec itself will have an ::s/failure value in ex-data:\n\n:check-failed   at least one checked return did not conform\n:no-args-spec   no :args spec provided\n:no-fn          no fn provided\n:no-fspec       no fspec provided\n:no-gen         unable to generate :args\n:instrument     invalid args detected by instrument\n", :row 258} {:fixed-arities #{4}, :end-row 322, :private true, :ns "cljs.spec.test.alpha", :name "maybe-setup-static-dispatch", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f ret conform! arity]"], :row 311} {:fixed-arities #{4}, :end-row 329, :private true, :ns "cljs.spec.test.alpha", :name "setup-static-dispatches", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f ret conform! max-arity]"], :row 324} {:end-row 17, :filename "cljs/spec/test/alpha.cljc", :lang :cljs, :name "instrumented-vars", :ns "cljs.spec.test.alpha", :private true, :row 17} {:fixed-arities #{1}, :end-row 23, :private true, :ns "cljs.spec.test.alpha", :name "collectionize", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[x]"], :row 19} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.spec.test.alpha", :name "enumerate-namespace*", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :row 25} {:fixed-arities #{1}, :end-row 40, :ns "cljs.spec.test.alpha", :name "enumerate-namespace", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[ns-sym-or-syms]"], :doc "Given a symbol naming an ns, or a collection of such symbols,\nreturns the set of all symbols naming vars in those nses.", :row 36} {:fixed-arities #{1}, :end-row 44, :private true, :ns "cljs.spec.test.alpha", :name "fn-spec-name?", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[s]"], :row 42} {:end-row 58, :ns "cljs.spec.test.alpha", :name "with-instrument-disabled", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Disables instrument's checking of calls, within a scope.", :row 46} {:fixed-arities #{2}, :end-row 72, :ns "cljs.spec.test.alpha", :name "instrument-1", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s] opts]"], :row 60} {:fixed-arities #{1}, :end-row 81, :ns "cljs.spec.test.alpha", :name "unstrument-1", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s]]"], :row 74} {:fixed-arities #{1}, :end-row 96, :private true, :ns "cljs.spec.test.alpha", :name "sym-or-syms->syms", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :row 83} {:fixed-arities #{1}, :end-row 107, :private true, :ns "cljs.spec.test.alpha", :name "form->sym-or-syms", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :doc "Helper for extracting a symbol or symbols from a (potentially\n  user-supplied) quoted form. In the case that the form has ::no-eval meta, we\n  know it was generated by us and we directly extract the result, assuming the\n  shape of the form. This avoids applying eval to extremely large forms in the\n  latter case.", :row 98} {:fixed-arities #{0 1 2}, :end-row 167, :ns "cljs.spec.test.alpha", :name "instrument", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[xs]" "[sym-or-syms opts]"], :doc "Instruments the vars named by sym-or-syms, a symbol or collection\nof symbols, or all instrumentable vars if sym-or-syms is not\nspecified. If a symbol identifies a namespace then all symbols in that\nnamespace will be enumerated.\n\nIf a var has an :args fn-spec, sets the var's root binding to a\nfn that checks arg conformance (throwing an exception on failure)\nbefore delegating to the original fn.\n\nThe opts map can be used to override registered specs, and/or to\nreplace fn implementations entirely. Opts for symbols not included\nin sym-or-syms are ignored. This facilitates sharing a common\noptions map across many different calls to instrument.\n\nThe opts map may have the following keys:\n\n  :spec     a map from var-name symbols to override specs\n  :stub     a set of var-name symbols to be replaced by stubs\n  :gen      a map from spec names to generator overrides\n  :replace  a map from var-name symbols to replacement fns\n\n:spec overrides registered fn-specs with specs your provide. Use\n:spec overrides to provide specs for libraries that do not have\nthem, or to constrain your own use of a fn to a subset of its\nspec'ed contract.\n\n:stub replaces a fn with a stub that checks :args, then uses the\n:ret spec to generate a return value.\n\n:gen overrides are used only for :stub generation.\n\n:replace replaces a fn with a fn that checks args conformance, then\ninvokes the fn you provide, enabling arbitrary stubbing and mocking.\n\n:spec can be used in combination with :stub or :replace.\n\nReturns a collection of syms naming the vars instrumented.", :row 109} {:fixed-arities #{0 1}, :end-row 188, :ns "cljs.spec.test.alpha", :name "unstrument", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[sym-or-syms]"], :doc "Undoes instrument on the vars named by sym-or-syms, specified\nas in instrument. With no args, unstruments all instrumented vars.\nReturns a collection of syms naming the vars unstrumented.", :row 169} {:fixed-arities #{4}, :end-row 222, :ns "cljs.spec.test.alpha", :name "check-1", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s :as qs] f spec opts]"], :row 192} {:fixed-arities #{3 2}, :end-row 232, :ns "cljs.spec.test.alpha", :name "check-fn", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f spec]" "[f spec opts]"], :doc "Runs generative tests for fn f using spec and opts. See\n'check' for options and return.", :row 224} {:fixed-arities #{0}, :end-row 236, :private true, :ns "cljs.spec.test.alpha", :name "registry-ref", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[]"], :row 234} {:arglist-strs ["[]" "[opts]"], :end-row 244, :filename "cljs/spec/test/alpha.cljc", :fixed-arities #{0 1}, :lang :cljs, :name "checkable-syms*", :ns "cljs.spec.test.alpha", :row 238} {:fixed-arities #{0 1}, :end-row 256, :ns "cljs.spec.test.alpha", :name "checkable-syms", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[opts]"], :doc "Given an opts map as per check, returns the set of syms that\ncan be checked.", :row 246} {:fixed-arities #{0 1 2}, :end-row 309, :ns "cljs.spec.test.alpha", :name "check", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[sym-or-syms]" "[sym-or-syms opts]"], :doc "Run generative tests for spec conformance on vars named by\nsym-or-syms, a symbol or collection of symbols. If sym-or-syms\nis not specified, check all checkable vars. If a symbol identifies a\nnamespace then all symbols in that namespace will be enumerated.\n\nThe opts map includes the following optional keys, where stc\naliases clojure.spec.test.check:\n\n::stc/opts  opts to flow through test.check/quick-check\n:gen        map from spec names to generator overrides\n\nThe ::stc/opts include :num-tests in addition to the keys\ndocumented by test.check. Generator overrides are passed to\nspec/gen when generating function args.\n\nReturns a lazy sequence of check result maps with the following\nkeys\n\n:spec       the spec tested\n:sym        optional symbol naming the var tested\n:failure    optional test failure\n::stc/ret   optional value returned by test.check/quick-check\n\nThe value for :failure can be any exception. Exceptions thrown by\nspec itself will have an ::s/failure value in ex-data:\n\n:check-failed   at least one checked return did not conform\n:no-args-spec   no :args spec provided\n:no-fn          no fn provided\n:no-fspec       no fspec provided\n:no-gen         unable to generate :args\n:instrument     invalid args detected by instrument\n", :row 258} {:fixed-arities #{4}, :end-row 322, :private true, :ns "cljs.spec.test.alpha", :name "maybe-setup-static-dispatch", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f ret conform! arity]"], :row 311} {:fixed-arities #{4}, :end-row 329, :private true, :ns "cljs.spec.test.alpha", :name "setup-static-dispatches", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f ret conform! max-arity]"], :row 324} {:arglist-strs ["[f coll]"], :end-row 31, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "distinct-by", :ns "cljs.spec.test.alpha", :row 20} {:arglist-strs ["[x]"], :end-row 35, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "->sym", :ns "cljs.spec.test.alpha", :row 33} {:doc "if false, instrumented fns call straight through", :end-row 41, :filename "cljs/spec/test/alpha.cljs", :name "*instrument-enabled*", :ns "cljs.spec.test.alpha", :private true, :row 39} {:arglist-strs ["[]"], :end-row 47, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{0}, :name "get-host-port", :ns "cljs.spec.test.alpha", :row 43} {:arglist-strs ["[]"], :end-row 56, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{0}, :name "get-ua-product", :ns "cljs.spec.test.alpha", :row 49} {:arglist-strs ["[]"], :end-row 59, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{0}, :name "get-env", :ns "cljs.spec.test.alpha", :row 58} {:fixed-arities #{1}, :end-row 64, :private true, :ns "cljs.spec.test.alpha", :name "fn-spec?", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[m]"], :doc "Fn-spec must include at least :args or :ret specs.", :row 61} {:arglist-strs ["[spec v]"], :end-row 70, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "explain-data*", :ns "cljs.spec.test.alpha", :private true, :row 67} {:arglist-strs ["[st]"], :end-row 81, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "find-caller", :ns "cljs.spec.test.alpha", :private true, :row 72} {:arglist-strs ["[v f fn-spec]"], :end-row 135, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{3}, :name "spec-checking-fn", :ns "cljs.spec.test.alpha", :private true, :row 85} {:arglist-strs ["[v spec]"], :end-row 140, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "no-fspec", :ns "cljs.spec.test.alpha", :private true, :row 137} {:end-row 142, :filename "cljs/spec/test/alpha.cljs", :name "instrumented-vars", :ns "cljs.spec.test.alpha", :private true, :row 142} {:fixed-arities #{4}, :end-row 149, :private true, :ns "cljs.spec.test.alpha", :name "instrument-choose-fn", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[f spec sym {over :gen :keys [stub replace]}]"], :doc "Helper for instrument.", :row 144} {:fixed-arities #{3}, :end-row 154, :private true, :ns "cljs.spec.test.alpha", :name "instrument-choose-spec", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[spec sym {overrides :spec}]"], :doc "Helper for instrument", :row 151} {:arglist-strs ["[s v opts]"], :end-row 167, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{3}, :name "instrument-1*", :ns "cljs.spec.test.alpha", :private true, :row 156} {:arglist-strs ["[s v]"], :end-row 176, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "unstrument-1*", :ns "cljs.spec.test.alpha", :private true, :row 169} {:arglist-strs ["[s]"], :end-row 180, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "fn-spec-name?", :ns "cljs.spec.test.alpha", :private true, :row 178} {:arglist-strs ["[x]"], :end-row 186, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "collectionize", :ns "cljs.spec.test.alpha", :private true, :row 182} {:arglist-strs ["[]" "[opts]"], :doc "Given an opts map as per instrument, returns the set of syms\nthat can be instrumented.", :end-row 197, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{0 1}, :name "instrumentable-syms", :ns "cljs.spec.test.alpha", :row 188} {:arglist-strs ["[args spec v role]"], :end-row 209, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{4}, :name "explain-check", :ns "cljs.spec.test.alpha", :private true, :row 201} {:fixed-arities #{3}, :end-row 226, :private true, :ns "cljs.spec.test.alpha", :name "check-call", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[f specs args]"], :doc "Returns true if call passes specs, otherwise *returns* an exception\nwith explain-data + ::s/failure.", :row 211} {:arglist-strs ["[f specs {gen :gen opts :clojure.spec.test.check/opts}]"], :end-row 235, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{3}, :name "quick-check", :ns "cljs.spec.test.alpha", :private true, :row 228} {:fixed-arities #{4}, :end-row 247, :private true, :ns "cljs.spec.test.alpha", :name "make-check-result", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[check-sym spec test-check-ret tc-ret-key]"], :doc "Builds spec result map.", :row 237} {:arglist-strs ["[opts]"], :end-row 251, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "validate-check-opts", :ns "cljs.spec.test.alpha", :row 249} {:arglist-strs ["[x]"], :end-row 257, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "failure-type", :ns "cljs.spec.test.alpha", :private true, :row 255} {:arglist-strs ["[x]"], :end-row 263, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "unwrap-failure", :ns "cljs.spec.test.alpha", :private true, :row 259} {:fixed-arities #{1}, :end-row 276, :private true, :ns "cljs.spec.test.alpha", :name "result-type", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[ret]"], :doc "Returns the type of the check result. This can be any of the\n::s/failure keywords documented in 'check', or:\n\n  :check-passed   all checked fn returns conformed\n  :check-threw    checked fn threw an exception", :row 265} {:arglist-strs ["[x]"], :doc "Given a check result, returns an abbreviated version\nsuitable for summary use.", :end-row 286, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "abbrev-result", :ns "cljs.spec.test.alpha", :row 278} {:arglist-strs ["[check-results]" "[check-results summary-result]"], :doc "Given a collection of check-results, e.g. from 'check', pretty\nprints the summary-result (default abbrev-result) of each.\n\nReturns a map with :total, the total number of results, plus a\nkey with a count for each different :type of result.", :end-row 303, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1 2}, :name "summarize-results", :ns "cljs.spec.test.alpha", :row 288} {:arglist-strs ["[start end]"], :doc "Returns random int in range start <= rand < end", :end-row 335, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "ranged-rand", :ns "cljs.spec.test.alpha", :row 332} {:arglist-strs ["[a]" "[a b]"], :end-row 361, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1 2}, :name "foo", :ns "cljs.spec.test.alpha", :row 358}]} {:end-row 18, :filename "cljs/spec/test/alpha.cljs", :name "cljs.spec.test.alpha", :row 9, :ns nil, :var-definitions [{:end-row 17, :filename "cljs/spec/test/alpha.cljc", :lang :clj, :name "instrumented-vars", :ns "cljs.spec.test.alpha", :private true, :row 17} {:fixed-arities #{1}, :end-row 23, :private true, :ns "cljs.spec.test.alpha", :name "collectionize", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[x]"], :row 19} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.spec.test.alpha", :name "enumerate-namespace*", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :row 25} {:fixed-arities #{1}, :end-row 40, :ns "cljs.spec.test.alpha", :name "enumerate-namespace", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[ns-sym-or-syms]"], :doc "Given a symbol naming an ns, or a collection of such symbols,\nreturns the set of all symbols naming vars in those nses.", :row 36} {:fixed-arities #{1}, :end-row 44, :private true, :ns "cljs.spec.test.alpha", :name "fn-spec-name?", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[s]"], :row 42} {:end-row 58, :ns "cljs.spec.test.alpha", :name "with-instrument-disabled", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Disables instrument's checking of calls, within a scope.", :row 46} {:fixed-arities #{2}, :end-row 72, :ns "cljs.spec.test.alpha", :name "instrument-1", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s] opts]"], :row 60} {:fixed-arities #{1}, :end-row 81, :ns "cljs.spec.test.alpha", :name "unstrument-1", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s]]"], :row 74} {:fixed-arities #{1}, :end-row 96, :private true, :ns "cljs.spec.test.alpha", :name "sym-or-syms->syms", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :row 83} {:fixed-arities #{1}, :end-row 107, :private true, :ns "cljs.spec.test.alpha", :name "form->sym-or-syms", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :doc "Helper for extracting a symbol or symbols from a (potentially\n  user-supplied) quoted form. In the case that the form has ::no-eval meta, we\n  know it was generated by us and we directly extract the result, assuming the\n  shape of the form. This avoids applying eval to extremely large forms in the\n  latter case.", :row 98} {:fixed-arities #{0 1 2}, :end-row 167, :ns "cljs.spec.test.alpha", :name "instrument", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[xs]" "[sym-or-syms opts]"], :doc "Instruments the vars named by sym-or-syms, a symbol or collection\nof symbols, or all instrumentable vars if sym-or-syms is not\nspecified. If a symbol identifies a namespace then all symbols in that\nnamespace will be enumerated.\n\nIf a var has an :args fn-spec, sets the var's root binding to a\nfn that checks arg conformance (throwing an exception on failure)\nbefore delegating to the original fn.\n\nThe opts map can be used to override registered specs, and/or to\nreplace fn implementations entirely. Opts for symbols not included\nin sym-or-syms are ignored. This facilitates sharing a common\noptions map across many different calls to instrument.\n\nThe opts map may have the following keys:\n\n  :spec     a map from var-name symbols to override specs\n  :stub     a set of var-name symbols to be replaced by stubs\n  :gen      a map from spec names to generator overrides\n  :replace  a map from var-name symbols to replacement fns\n\n:spec overrides registered fn-specs with specs your provide. Use\n:spec overrides to provide specs for libraries that do not have\nthem, or to constrain your own use of a fn to a subset of its\nspec'ed contract.\n\n:stub replaces a fn with a stub that checks :args, then uses the\n:ret spec to generate a return value.\n\n:gen overrides are used only for :stub generation.\n\n:replace replaces a fn with a fn that checks args conformance, then\ninvokes the fn you provide, enabling arbitrary stubbing and mocking.\n\n:spec can be used in combination with :stub or :replace.\n\nReturns a collection of syms naming the vars instrumented.", :row 109} {:fixed-arities #{0 1}, :end-row 188, :ns "cljs.spec.test.alpha", :name "unstrument", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[sym-or-syms]"], :doc "Undoes instrument on the vars named by sym-or-syms, specified\nas in instrument. With no args, unstruments all instrumented vars.\nReturns a collection of syms naming the vars unstrumented.", :row 169} {:fixed-arities #{4}, :end-row 222, :ns "cljs.spec.test.alpha", :name "check-1", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s :as qs] f spec opts]"], :row 192} {:fixed-arities #{3 2}, :end-row 232, :ns "cljs.spec.test.alpha", :name "check-fn", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f spec]" "[f spec opts]"], :doc "Runs generative tests for fn f using spec and opts. See\n'check' for options and return.", :row 224} {:fixed-arities #{0}, :end-row 236, :private true, :ns "cljs.spec.test.alpha", :name "registry-ref", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[]"], :row 234} {:arglist-strs ["[]" "[opts]"], :end-row 244, :filename "cljs/spec/test/alpha.cljc", :fixed-arities #{0 1}, :lang :clj, :name "checkable-syms*", :ns "cljs.spec.test.alpha", :row 238} {:fixed-arities #{0 1}, :end-row 256, :ns "cljs.spec.test.alpha", :name "checkable-syms", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[opts]"], :doc "Given an opts map as per check, returns the set of syms that\ncan be checked.", :row 246} {:fixed-arities #{0 1 2}, :end-row 309, :ns "cljs.spec.test.alpha", :name "check", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[sym-or-syms]" "[sym-or-syms opts]"], :doc "Run generative tests for spec conformance on vars named by\nsym-or-syms, a symbol or collection of symbols. If sym-or-syms\nis not specified, check all checkable vars. If a symbol identifies a\nnamespace then all symbols in that namespace will be enumerated.\n\nThe opts map includes the following optional keys, where stc\naliases clojure.spec.test.check:\n\n::stc/opts  opts to flow through test.check/quick-check\n:gen        map from spec names to generator overrides\n\nThe ::stc/opts include :num-tests in addition to the keys\ndocumented by test.check. Generator overrides are passed to\nspec/gen when generating function args.\n\nReturns a lazy sequence of check result maps with the following\nkeys\n\n:spec       the spec tested\n:sym        optional symbol naming the var tested\n:failure    optional test failure\n::stc/ret   optional value returned by test.check/quick-check\n\nThe value for :failure can be any exception. Exceptions thrown by\nspec itself will have an ::s/failure value in ex-data:\n\n:check-failed   at least one checked return did not conform\n:no-args-spec   no :args spec provided\n:no-fn          no fn provided\n:no-fspec       no fspec provided\n:no-gen         unable to generate :args\n:instrument     invalid args detected by instrument\n", :row 258} {:fixed-arities #{4}, :end-row 322, :private true, :ns "cljs.spec.test.alpha", :name "maybe-setup-static-dispatch", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f ret conform! arity]"], :row 311} {:fixed-arities #{4}, :end-row 329, :private true, :ns "cljs.spec.test.alpha", :name "setup-static-dispatches", :lang :clj, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f ret conform! max-arity]"], :row 324} {:end-row 17, :filename "cljs/spec/test/alpha.cljc", :lang :cljs, :name "instrumented-vars", :ns "cljs.spec.test.alpha", :private true, :row 17} {:fixed-arities #{1}, :end-row 23, :private true, :ns "cljs.spec.test.alpha", :name "collectionize", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[x]"], :row 19} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.spec.test.alpha", :name "enumerate-namespace*", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :row 25} {:fixed-arities #{1}, :end-row 40, :ns "cljs.spec.test.alpha", :name "enumerate-namespace", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[ns-sym-or-syms]"], :doc "Given a symbol naming an ns, or a collection of such symbols,\nreturns the set of all symbols naming vars in those nses.", :row 36} {:fixed-arities #{1}, :end-row 44, :private true, :ns "cljs.spec.test.alpha", :name "fn-spec-name?", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[s]"], :row 42} {:end-row 58, :ns "cljs.spec.test.alpha", :name "with-instrument-disabled", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[& body]"], :doc "Disables instrument's checking of calls, within a scope.", :row 46} {:fixed-arities #{2}, :end-row 72, :ns "cljs.spec.test.alpha", :name "instrument-1", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s] opts]"], :row 60} {:fixed-arities #{1}, :end-row 81, :ns "cljs.spec.test.alpha", :name "unstrument-1", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s]]"], :row 74} {:fixed-arities #{1}, :end-row 96, :private true, :ns "cljs.spec.test.alpha", :name "sym-or-syms->syms", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :row 83} {:fixed-arities #{1}, :end-row 107, :private true, :ns "cljs.spec.test.alpha", :name "form->sym-or-syms", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[sym-or-syms]"], :doc "Helper for extracting a symbol or symbols from a (potentially\n  user-supplied) quoted form. In the case that the form has ::no-eval meta, we\n  know it was generated by us and we directly extract the result, assuming the\n  shape of the form. This avoids applying eval to extremely large forms in the\n  latter case.", :row 98} {:fixed-arities #{0 1 2}, :end-row 167, :ns "cljs.spec.test.alpha", :name "instrument", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[xs]" "[sym-or-syms opts]"], :doc "Instruments the vars named by sym-or-syms, a symbol or collection\nof symbols, or all instrumentable vars if sym-or-syms is not\nspecified. If a symbol identifies a namespace then all symbols in that\nnamespace will be enumerated.\n\nIf a var has an :args fn-spec, sets the var's root binding to a\nfn that checks arg conformance (throwing an exception on failure)\nbefore delegating to the original fn.\n\nThe opts map can be used to override registered specs, and/or to\nreplace fn implementations entirely. Opts for symbols not included\nin sym-or-syms are ignored. This facilitates sharing a common\noptions map across many different calls to instrument.\n\nThe opts map may have the following keys:\n\n  :spec     a map from var-name symbols to override specs\n  :stub     a set of var-name symbols to be replaced by stubs\n  :gen      a map from spec names to generator overrides\n  :replace  a map from var-name symbols to replacement fns\n\n:spec overrides registered fn-specs with specs your provide. Use\n:spec overrides to provide specs for libraries that do not have\nthem, or to constrain your own use of a fn to a subset of its\nspec'ed contract.\n\n:stub replaces a fn with a stub that checks :args, then uses the\n:ret spec to generate a return value.\n\n:gen overrides are used only for :stub generation.\n\n:replace replaces a fn with a fn that checks args conformance, then\ninvokes the fn you provide, enabling arbitrary stubbing and mocking.\n\n:spec can be used in combination with :stub or :replace.\n\nReturns a collection of syms naming the vars instrumented.", :row 109} {:fixed-arities #{0 1}, :end-row 188, :ns "cljs.spec.test.alpha", :name "unstrument", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[sym-or-syms]"], :doc "Undoes instrument on the vars named by sym-or-syms, specified\nas in instrument. With no args, unstruments all instrumented vars.\nReturns a collection of syms naming the vars unstrumented.", :row 169} {:fixed-arities #{4}, :end-row 222, :ns "cljs.spec.test.alpha", :name "check-1", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[[quote s :as qs] f spec opts]"], :row 192} {:fixed-arities #{3 2}, :end-row 232, :ns "cljs.spec.test.alpha", :name "check-fn", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f spec]" "[f spec opts]"], :doc "Runs generative tests for fn f using spec and opts. See\n'check' for options and return.", :row 224} {:fixed-arities #{0}, :end-row 236, :private true, :ns "cljs.spec.test.alpha", :name "registry-ref", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :arglist-strs ["[]"], :row 234} {:arglist-strs ["[]" "[opts]"], :end-row 244, :filename "cljs/spec/test/alpha.cljc", :fixed-arities #{0 1}, :lang :cljs, :name "checkable-syms*", :ns "cljs.spec.test.alpha", :row 238} {:fixed-arities #{0 1}, :end-row 256, :ns "cljs.spec.test.alpha", :name "checkable-syms", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[opts]"], :doc "Given an opts map as per check, returns the set of syms that\ncan be checked.", :row 246} {:fixed-arities #{0 1 2}, :end-row 309, :ns "cljs.spec.test.alpha", :name "check", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[]" "[sym-or-syms]" "[sym-or-syms opts]"], :doc "Run generative tests for spec conformance on vars named by\nsym-or-syms, a symbol or collection of symbols. If sym-or-syms\nis not specified, check all checkable vars. If a symbol identifies a\nnamespace then all symbols in that namespace will be enumerated.\n\nThe opts map includes the following optional keys, where stc\naliases clojure.spec.test.check:\n\n::stc/opts  opts to flow through test.check/quick-check\n:gen        map from spec names to generator overrides\n\nThe ::stc/opts include :num-tests in addition to the keys\ndocumented by test.check. Generator overrides are passed to\nspec/gen when generating function args.\n\nReturns a lazy sequence of check result maps with the following\nkeys\n\n:spec       the spec tested\n:sym        optional symbol naming the var tested\n:failure    optional test failure\n::stc/ret   optional value returned by test.check/quick-check\n\nThe value for :failure can be any exception. Exceptions thrown by\nspec itself will have an ::s/failure value in ex-data:\n\n:check-failed   at least one checked return did not conform\n:no-args-spec   no :args spec provided\n:no-fn          no fn provided\n:no-fspec       no fspec provided\n:no-gen         unable to generate :args\n:instrument     invalid args detected by instrument\n", :row 258} {:fixed-arities #{4}, :end-row 322, :private true, :ns "cljs.spec.test.alpha", :name "maybe-setup-static-dispatch", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f ret conform! arity]"], :row 311} {:fixed-arities #{4}, :end-row 329, :private true, :ns "cljs.spec.test.alpha", :name "setup-static-dispatches", :lang :cljs, :filename "cljs/spec/test/alpha.cljc", :macro true, :arglist-strs ["[f ret conform! max-arity]"], :row 324} {:arglist-strs ["[f coll]"], :end-row 31, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "distinct-by", :ns "cljs.spec.test.alpha", :row 20} {:arglist-strs ["[x]"], :end-row 35, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "->sym", :ns "cljs.spec.test.alpha", :row 33} {:doc "if false, instrumented fns call straight through", :end-row 41, :filename "cljs/spec/test/alpha.cljs", :name "*instrument-enabled*", :ns "cljs.spec.test.alpha", :private true, :row 39} {:arglist-strs ["[]"], :end-row 47, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{0}, :name "get-host-port", :ns "cljs.spec.test.alpha", :row 43} {:arglist-strs ["[]"], :end-row 56, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{0}, :name "get-ua-product", :ns "cljs.spec.test.alpha", :row 49} {:arglist-strs ["[]"], :end-row 59, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{0}, :name "get-env", :ns "cljs.spec.test.alpha", :row 58} {:fixed-arities #{1}, :end-row 64, :private true, :ns "cljs.spec.test.alpha", :name "fn-spec?", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[m]"], :doc "Fn-spec must include at least :args or :ret specs.", :row 61} {:arglist-strs ["[spec v]"], :end-row 70, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "explain-data*", :ns "cljs.spec.test.alpha", :private true, :row 67} {:arglist-strs ["[st]"], :end-row 81, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "find-caller", :ns "cljs.spec.test.alpha", :private true, :row 72} {:arglist-strs ["[v f fn-spec]"], :end-row 135, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{3}, :name "spec-checking-fn", :ns "cljs.spec.test.alpha", :private true, :row 85} {:arglist-strs ["[v spec]"], :end-row 140, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "no-fspec", :ns "cljs.spec.test.alpha", :private true, :row 137} {:end-row 142, :filename "cljs/spec/test/alpha.cljs", :name "instrumented-vars", :ns "cljs.spec.test.alpha", :private true, :row 142} {:fixed-arities #{4}, :end-row 149, :private true, :ns "cljs.spec.test.alpha", :name "instrument-choose-fn", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[f spec sym {over :gen :keys [stub replace]}]"], :doc "Helper for instrument.", :row 144} {:fixed-arities #{3}, :end-row 154, :private true, :ns "cljs.spec.test.alpha", :name "instrument-choose-spec", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[spec sym {overrides :spec}]"], :doc "Helper for instrument", :row 151} {:arglist-strs ["[s v opts]"], :end-row 167, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{3}, :name "instrument-1*", :ns "cljs.spec.test.alpha", :private true, :row 156} {:arglist-strs ["[s v]"], :end-row 176, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "unstrument-1*", :ns "cljs.spec.test.alpha", :private true, :row 169} {:arglist-strs ["[s]"], :end-row 180, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "fn-spec-name?", :ns "cljs.spec.test.alpha", :private true, :row 178} {:arglist-strs ["[x]"], :end-row 186, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "collectionize", :ns "cljs.spec.test.alpha", :private true, :row 182} {:arglist-strs ["[]" "[opts]"], :doc "Given an opts map as per instrument, returns the set of syms\nthat can be instrumented.", :end-row 197, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{0 1}, :name "instrumentable-syms", :ns "cljs.spec.test.alpha", :row 188} {:arglist-strs ["[args spec v role]"], :end-row 209, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{4}, :name "explain-check", :ns "cljs.spec.test.alpha", :private true, :row 201} {:fixed-arities #{3}, :end-row 226, :private true, :ns "cljs.spec.test.alpha", :name "check-call", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[f specs args]"], :doc "Returns true if call passes specs, otherwise *returns* an exception\nwith explain-data + ::s/failure.", :row 211} {:arglist-strs ["[f specs {gen :gen opts :clojure.spec.test.check/opts}]"], :end-row 235, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{3}, :name "quick-check", :ns "cljs.spec.test.alpha", :private true, :row 228} {:fixed-arities #{4}, :end-row 247, :private true, :ns "cljs.spec.test.alpha", :name "make-check-result", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[check-sym spec test-check-ret tc-ret-key]"], :doc "Builds spec result map.", :row 237} {:arglist-strs ["[opts]"], :end-row 251, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "validate-check-opts", :ns "cljs.spec.test.alpha", :row 249} {:arglist-strs ["[x]"], :end-row 257, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "failure-type", :ns "cljs.spec.test.alpha", :private true, :row 255} {:arglist-strs ["[x]"], :end-row 263, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "unwrap-failure", :ns "cljs.spec.test.alpha", :private true, :row 259} {:fixed-arities #{1}, :end-row 276, :private true, :ns "cljs.spec.test.alpha", :name "result-type", :filename "cljs/spec/test/alpha.cljs", :arglist-strs ["[ret]"], :doc "Returns the type of the check result. This can be any of the\n::s/failure keywords documented in 'check', or:\n\n  :check-passed   all checked fn returns conformed\n  :check-threw    checked fn threw an exception", :row 265} {:arglist-strs ["[x]"], :doc "Given a check result, returns an abbreviated version\nsuitable for summary use.", :end-row 286, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1}, :name "abbrev-result", :ns "cljs.spec.test.alpha", :row 278} {:arglist-strs ["[check-results]" "[check-results summary-result]"], :doc "Given a collection of check-results, e.g. from 'check', pretty\nprints the summary-result (default abbrev-result) of each.\n\nReturns a map with :total, the total number of results, plus a\nkey with a count for each different :type of result.", :end-row 303, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1 2}, :name "summarize-results", :ns "cljs.spec.test.alpha", :row 288} {:arglist-strs ["[start end]"], :doc "Returns random int in range start <= rand < end", :end-row 335, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{2}, :name "ranged-rand", :ns "cljs.spec.test.alpha", :row 332} {:arglist-strs ["[a]" "[a b]"], :end-row 361, :filename "cljs/spec/test/alpha.cljs", :fixed-arities #{1 2}, :name "foo", :ns "cljs.spec.test.alpha", :row 358}]} {:end-row 17, :filename "cljs/spec/alpha.cljc", :lang :clj, :name "cljs.spec.alpha", :row 9, :ns nil, :var-definitions [{:end-row 19, :filename "cljs/spec/alpha.cljc", :lang :clj, :name "registry-ref", :ns "cljs.spec.alpha", :row 19} {:fixed-arities #{1}, :end-row 26, :private true, :ns "cljs.spec.alpha", :name "->sym", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[x]"], :doc "Returns a symbol from a symbol or var", :row 21} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.spec.alpha", :name "unfn", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[expr]"], :row 28} {:fixed-arities #{2}, :end-row 48, :private true, :ns "cljs.spec.alpha", :name "res", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env form]"], :row 36} {:fixed-arities #{1}, :end-row 53, :private true, :ns "cljs.spec.alpha", :name "mres", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[form]"], :doc "a compile time res, for use in cljs/spec/alpha.cljs", :row 50} {:fixed-arities #{2}, :end-row 61, :private true, :ns "cljs.spec.alpha", :name "ns-qualify", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env s]"], :doc "Qualify symbol s by resolving it or using the current *ns*.", :row 55} {:end-row 63, :filename "cljs/spec/alpha.cljc", :lang :clj, :name "_speced_vars", :ns "cljs.spec.alpha", :private true, :row 63} {:arglist-strs ["[]"], :end-row 66, :filename "cljs/spec/alpha.cljc", :fixed-arities #{0}, :lang :clj, :name "speced-vars", :ns "cljs.spec.alpha", :row 65} {:fixed-arities #{2}, :end-row 85, :ns "cljs.spec.alpha", :name "def", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[k spec-form]"], :doc "Given a namespace-qualified keyword or resolveable symbol k, and a\n  spec, spec-name, predicate or regex-op makes an entry in the\n  registry mapping k to the spec. Use nil to remove an entry in\n  the registry for k.", :row 68} {:end-row 104, :ns "cljs.spec.alpha", :name "spec", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[form & {:keys [gen]}]"], :doc "Takes a single predicate form, e.g. can be the name of a predicate,\n  like even?, or a fn literal like #(< % 42). Note that it is not\n  generally necessary to wrap predicates in spec when using the rest\n  of the spec macros, only to attach a unique generator\n\n  Can also be passed the result of one of the regex ops -\n  cat, alt, *, +, ?, in which case it will return a regex-conforming\n  spec, useful when nesting an independent regex.\n  ---\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\n\n  Returns a spec.", :row 87} {:fixed-arities #{2}, :end-row 133, :ns "cljs.spec.alpha", :name "multi-spec", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[mm retag]"], :doc "Takes the name of a spec/predicate-returning multimethod and a\n  tag-restoring keyword or fn (retag).  Returns a spec that when\n  conforming or explaining data will pass it to the multimethod to get\n  an appropriate spec. You can e.g. use multi-spec to dynamically and\n  extensibly associate specs with 'tagged' data (i.e. data where one\n  of the fields indicates the shape of the rest of the structure).\n\n  (defmulti mspec :tag)\n\n  The methods should ignore their argument and return a predicate/spec:\n  (defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\n  retag is used during generation to retag generated values with\n  matching tags. retag can either be a keyword, at which key the\n  dispatch-tag will be assoc'ed, or a fn of generated value and\n  dispatch-tag that should return an appropriately retagged value.\n\n  Note that because the tags themselves comprise an open set,\n  the tag key spec cannot enumerate the values, but can e.g.\n  test for keyword?.\n\n  Note also that the dispatch values of the multimethod will be\n  included in the path, i.e. in reporting and gen overrides, even\n  though those values are not evident in the spec.\n", :row 106} {:end-row 195, :ns "cljs.spec.alpha", :name "keys", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [req req-un opt opt-un gen]}]"], :doc "Creates and returns a map validating spec. :req and :opt are both\n  vectors of namespaced-qualified keywords. The validator will ensure\n  the :req keys are present. The :opt keys serve as documentation and\n  may be used by the generator.\n\n  The :req key vector supports 'and' and 'or' for key groups:\n\n  (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\n  There are also -un versions of :req and :opt. These allow\n  you to connect unqualified keys to specs.  In each case, fully\n  qualfied keywords are passed, which name the specs, but unqualified\n  keys (with the same name component) are expected and checked at\n  conform-time, and generated during gen:\n\n  (s/keys :req-un [:my.ns/x :my.ns/y])\n\n  The above says keys :x and :y are required, and will be validated\n  and generated by specs (if they exist) named :my.ns/x :my.ns/y\n  respectively.\n\n  In addition, the values of *all* namespace-qualified keys will be validated\n  (and possibly destructured) by any registered specs. Note: there is\n  no support for inline value specification, by design.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.", :row 135} {:end-row 212, :ns "cljs.spec.alpha", :name "or", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/or :even even? :small #(< % 42))\n\n  Returns a destructuring spec that returns a map entry containing the\n  key of the first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :row 197} {:end-row 222, :ns "cljs.spec.alpha", :name "and", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& pred-forms]"], :doc "Takes predicate/spec-forms, e.g.\n\n  (s/and even? #(< % 42))\n\n  Returns a spec that returns the conformed value. Successive\n  conformed values propagate through rest of predicates.", :row 214} {:fixed-arities #{2}, :end-row 231, :private true, :ns "cljs.spec.alpha", :name "res-kind", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env opts]"], :row 224} {:end-row 279, :ns "cljs.spec.alpha", :name "every", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred & {:keys [into kind count max-count min-count distinct gen-max gen-into gen] :as opts}]"], :doc "takes a pred and validates collection elements against that pred.\n\n  Note that 'every' does not do exhaustive checking, rather it samples\n  *coll-check-limit* elements. Nor (as a result) does it do any\n  conforming of elements. 'explain' will report at most *coll-error-limit*\n  problems.  Thus 'every' should be suitable for potentially large\n  collections.\n\n  Takes several kwargs options that further constrain the collection:\n\n  :kind - a pred that the collection type must satisfy, e.g. vector?\n          (default nil) Note that if :kind is specified and :into is\n          not, this pred must generate in order for every to generate.\n  :count - specifies coll has exactly this count (default nil)\n  :min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n  :distinct - all the elements are distinct (default nil)\n\n  And additional args that control gen\n\n  :gen-max - the maximum coll size to generate (default 20)\n  :into - one of [], (), {}, #{} - the default collection to generate into\n      (default same as :kind if supplied, else []\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator\n\n  See also - coll-of, every-kv\n", :row 233} {:end-row 290, :ns "cljs.spec.alpha", :name "every-kv", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[kpred vpred & opts]"], :doc "like 'every' but takes separate key and val preds and works on associative collections.\n\n  Same options as 'every', :into defaults to {}\n\n  See also - map-of", :row 281} {:end-row 305, :ns "cljs.spec.alpha", :name "coll-of", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred & opts]"], :doc "Returns a spec for a collection of items satisfying pred. Unlike\n  generator will fill an empty init-coll.\n\n  Same options as 'every'. conform will produce a collection\n  corresponding to :into if supplied, else will match the input collection,\n  avoiding rebuilding when possible.\n\n  Same options as 'every'.\n\n  See also - every, map-of", :row 292} {:end-row 319, :ns "cljs.spec.alpha", :name "map-of", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[kpred vpred & opts]"], :doc "Returns a spec for a map whose keys satisfy kpred and vals satisfy\n  vpred. Unlike 'every-kv', map-of will exhaustively conform every\n  value.\n\n  Same options as 'every', :kind defaults to map?, with the addition of:\n\n  :conform-keys - conform keys as well as values (default false)\n\n  See also - every-kv", :row 307} {:fixed-arities #{1}, :end-row 325, :ns "cljs.spec.alpha", :name "*", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches zero or more values matching\n  pred. Produces a vector of matches iff there is at least one match", :row 321} {:fixed-arities #{1}, :end-row 331, :ns "cljs.spec.alpha", :name "+", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches one or more values matching\n  pred. Produces a vector of matches", :row 327} {:fixed-arities #{1}, :end-row 337, :ns "cljs.spec.alpha", :name "?", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches zero or one value matching\n  pred. Produces a single value (not a collection) if matched.", :row 333} {:end-row 354, :ns "cljs.spec.alpha", :name "alt", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/alt :even even? :small #(< % 42))\n\n  Returns a regex op that returns a map entry containing the key of the\n  first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :row 339} {:end-row 370, :ns "cljs.spec.alpha", :name "cat", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/cat :e even? :o odd?)\n\n  Returns a regex op that matches (all) values in sequence, returning a map\n  containing the keys of each pred and the corresponding value.", :row 356} {:end-row 378, :ns "cljs.spec.alpha", :name "&", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[re & preds]"], :doc "takes a regex op re, and predicates. Returns a regex-op that consumes\n  input as per re but subjects the resulting value to the\n  conjunction of the predicates, and any conforming they might perform.", :row 372} {:fixed-arities #{1 2}, :end-row 386, :ns "cljs.spec.alpha", :name "conformer", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[f]" "[f unf]"], :doc "takes a predicate function with the semantics of conform i.e. it should return either a\n  (possibly converted) value or :cljs.spec.alpha/invalid, and returns a\n  spec that uses it as a predicate/conformer. Optionally takes a\n  second fn that does unform of result of first", :row 380} {:end-row 406, :ns "cljs.spec.alpha", :name "fspec", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [args ret fn gen] :or {ret `cljs.core/any?}}]"], :doc "takes :args :ret and (optional) :fn kwargs whose values are preds\n  and returns a spec whose conform/explain take a fn and validates it\n  using generative testing. The conformed value is always the fn itself.\n\n  See 'fdef' for a single operation that creates an fspec and\n  registers it, as well as a full description of :args, :ret and :fn\n\n  fspecs can generate functions that validate the arguments and\n  fabricate a return value compliant with the :ret spec, ignoring\n  the :fn spec if present.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args\n  that returns a test.check generator.", :row 388} {:end-row 414, :ns "cljs.spec.alpha", :name "tuple", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& preds]"], :doc "takes one or more preds and returns a spec for a tuple, a vector\n  where each element conforms to the corresponding pred. Each element\n  will be referred to in paths using its ordinal.", :row 408} {:end-row 449, :ns "cljs.spec.alpha", :name "fdef", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[fn-sym & specs]"], :doc "Takes a symbol naming a function, and one or more of the following:\n\n  :args A regex spec for the function arguments as they were a list to be\n    passed to apply - in this way, a single spec can handle functions with\n    multiple arities\n  :ret A spec for the function's return value\n  :fn A spec of the relationship between args and ret - the\n    value passed is {:args conformed-args :ret conformed-ret} and is\n    expected to contain predicates that relate those values\n\n  Qualifies fn-sym with resolve, or using *ns* if no resolution found.\n  Registers an fspec in the global registry, where it can be retrieved\n  by calling get-spec with the var or fully-qualified symbol.\n\n  Once registered, function specs are included in doc, checked by\n  instrument, tested by the runner cljs.spec.test.alpha/check, and (if\n  a macro) used to explain errors during macroexpansion.\n\n  Note that :fn specs require the presence of :args and :ret specs to\n  conform values, and so :fn specs will be ignored if :args or :ret\n  are missing.\n\n  Returns the qualified fn-sym.\n\n  For example, to register function specs for the symbol function:\n\n  (s/fdef cljs.core/symbol\n    :args (s/alt :separate (s/cat :ns string? :n string?)\n                 :str string?\n                 :sym symbol?)\n    :ret symbol?)", :row 416} {:end-row 468, :ns "cljs.spec.alpha", :name "keys*", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& kspecs]"], :doc "takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\n  converts them into a map, and conforms that map with a corresponding\n  spec/keys call:\n\n  user=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n  {:a 1, :c 2}\n  user=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n  {:a 1, :c 2}\n\n  the resulting regex op can be composed into a larger regex:\n\n  user=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n  {:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}", :row 451} {:fixed-arities #{1}, :end-row 474, :ns "cljs.spec.alpha", :name "nilable", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred]"], :doc "returns a spec that accepts nil and values satisfiying pred", :row 470} {:fixed-arities #{2}, :end-row 486, :ns "cljs.spec.alpha", :name "inst-in", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[start end]"], :doc "Returns a spec that validates insts in the range from start\n  (inclusive) to end (exclusive).", :row 476} {:fixed-arities #{2}, :end-row 493, :ns "cljs.spec.alpha", :name "int-in", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[start end]"], :doc "Returns a spec that validates fixed precision integers in the\n  range from start (inclusive) to end (exclusive).", :row 488} {:end-row 510, :ns "cljs.spec.alpha", :name "double-in", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [infinite? NaN? min max] :or {infinite? true NaN? true} :as m}]"], :doc "Specs a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity allowed (default true)\n    :NaN?      - whether NaN allowed (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)", :row 495} {:end-row 519, :ns "cljs.spec.alpha", :name "merge", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& pred-forms]"], :doc "Takes map-validating specs (e.g. 'keys' specs) and\n  returns a spec that returns a conformed map satisfying all of the\n  specs.  Successive conformed values propagate through rest of\n  predicates. Unlike 'and', merge can generate maps satisfying the\n  union of the predicates.", :row 512} {:fixed-arities #{1 3 2}, :end-row 542, :ns "cljs.spec.alpha", :name "exercise-fn", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[sym]" "[sym n]" "[sym n fspec]"], :doc "exercises the fn named by sym (a symbol) by applying it to\n  n (default 10) generated samples of its args spec. When fspec is\n  supplied its arg spec is used, and sym-or-f can be a fn.  Returns a\n  sequence of tuples of [args ret]. ", :row 521} {:fixed-arities #{0}, :end-row 546, :private true, :ns "cljs.spec.alpha", :name "init-compile-asserts", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[]"], :row 544} {:fixed-arities #{2}, :end-row 564, :ns "cljs.spec.alpha", :name "assert", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[spec x]"], :doc "spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an error with explain-data plus ::failure of\n:assertion-failed.\nCan be disabled at either compile time or runtime:\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto the negation value of the ':elide-asserts' compiler option, or true if\nnot set.\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'cljs.spec.alpha/*runtime-asserts*', or false if not set. You can\ntoggle check-asserts? with (check-asserts bool).", :row 548} {:end-row 19, :filename "cljs/spec/alpha.cljc", :lang :cljs, :name "registry-ref", :ns "cljs.spec.alpha", :row 19} {:fixed-arities #{1}, :end-row 26, :private true, :ns "cljs.spec.alpha", :name "->sym", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[x]"], :doc "Returns a symbol from a symbol or var", :row 21} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.spec.alpha", :name "unfn", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[expr]"], :row 28} {:fixed-arities #{2}, :end-row 48, :private true, :ns "cljs.spec.alpha", :name "res", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env form]"], :row 36} {:fixed-arities #{1}, :end-row 53, :private true, :ns "cljs.spec.alpha", :name "mres", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[form]"], :doc "a compile time res, for use in cljs/spec/alpha.cljs", :row 50} {:fixed-arities #{2}, :end-row 61, :private true, :ns "cljs.spec.alpha", :name "ns-qualify", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env s]"], :doc "Qualify symbol s by resolving it or using the current *ns*.", :row 55} {:end-row 63, :filename "cljs/spec/alpha.cljc", :lang :cljs, :name "_speced_vars", :ns "cljs.spec.alpha", :private true, :row 63} {:arglist-strs ["[]"], :end-row 66, :filename "cljs/spec/alpha.cljc", :fixed-arities #{0}, :lang :cljs, :name "speced-vars", :ns "cljs.spec.alpha", :row 65} {:fixed-arities #{2}, :end-row 85, :ns "cljs.spec.alpha", :name "def", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[k spec-form]"], :doc "Given a namespace-qualified keyword or resolveable symbol k, and a\n  spec, spec-name, predicate or regex-op makes an entry in the\n  registry mapping k to the spec. Use nil to remove an entry in\n  the registry for k.", :row 68} {:end-row 104, :ns "cljs.spec.alpha", :name "spec", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[form & {:keys [gen]}]"], :doc "Takes a single predicate form, e.g. can be the name of a predicate,\n  like even?, or a fn literal like #(< % 42). Note that it is not\n  generally necessary to wrap predicates in spec when using the rest\n  of the spec macros, only to attach a unique generator\n\n  Can also be passed the result of one of the regex ops -\n  cat, alt, *, +, ?, in which case it will return a regex-conforming\n  spec, useful when nesting an independent regex.\n  ---\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\n\n  Returns a spec.", :row 87} {:fixed-arities #{2}, :end-row 133, :ns "cljs.spec.alpha", :name "multi-spec", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[mm retag]"], :doc "Takes the name of a spec/predicate-returning multimethod and a\n  tag-restoring keyword or fn (retag).  Returns a spec that when\n  conforming or explaining data will pass it to the multimethod to get\n  an appropriate spec. You can e.g. use multi-spec to dynamically and\n  extensibly associate specs with 'tagged' data (i.e. data where one\n  of the fields indicates the shape of the rest of the structure).\n\n  (defmulti mspec :tag)\n\n  The methods should ignore their argument and return a predicate/spec:\n  (defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\n  retag is used during generation to retag generated values with\n  matching tags. retag can either be a keyword, at which key the\n  dispatch-tag will be assoc'ed, or a fn of generated value and\n  dispatch-tag that should return an appropriately retagged value.\n\n  Note that because the tags themselves comprise an open set,\n  the tag key spec cannot enumerate the values, but can e.g.\n  test for keyword?.\n\n  Note also that the dispatch values of the multimethod will be\n  included in the path, i.e. in reporting and gen overrides, even\n  though those values are not evident in the spec.\n", :row 106} {:end-row 195, :ns "cljs.spec.alpha", :name "keys", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [req req-un opt opt-un gen]}]"], :doc "Creates and returns a map validating spec. :req and :opt are both\n  vectors of namespaced-qualified keywords. The validator will ensure\n  the :req keys are present. The :opt keys serve as documentation and\n  may be used by the generator.\n\n  The :req key vector supports 'and' and 'or' for key groups:\n\n  (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\n  There are also -un versions of :req and :opt. These allow\n  you to connect unqualified keys to specs.  In each case, fully\n  qualfied keywords are passed, which name the specs, but unqualified\n  keys (with the same name component) are expected and checked at\n  conform-time, and generated during gen:\n\n  (s/keys :req-un [:my.ns/x :my.ns/y])\n\n  The above says keys :x and :y are required, and will be validated\n  and generated by specs (if they exist) named :my.ns/x :my.ns/y\n  respectively.\n\n  In addition, the values of *all* namespace-qualified keys will be validated\n  (and possibly destructured) by any registered specs. Note: there is\n  no support for inline value specification, by design.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.", :row 135} {:end-row 212, :ns "cljs.spec.alpha", :name "or", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/or :even even? :small #(< % 42))\n\n  Returns a destructuring spec that returns a map entry containing the\n  key of the first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :row 197} {:end-row 222, :ns "cljs.spec.alpha", :name "and", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& pred-forms]"], :doc "Takes predicate/spec-forms, e.g.\n\n  (s/and even? #(< % 42))\n\n  Returns a spec that returns the conformed value. Successive\n  conformed values propagate through rest of predicates.", :row 214} {:fixed-arities #{2}, :end-row 231, :private true, :ns "cljs.spec.alpha", :name "res-kind", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env opts]"], :row 224} {:end-row 279, :ns "cljs.spec.alpha", :name "every", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred & {:keys [into kind count max-count min-count distinct gen-max gen-into gen] :as opts}]"], :doc "takes a pred and validates collection elements against that pred.\n\n  Note that 'every' does not do exhaustive checking, rather it samples\n  *coll-check-limit* elements. Nor (as a result) does it do any\n  conforming of elements. 'explain' will report at most *coll-error-limit*\n  problems.  Thus 'every' should be suitable for potentially large\n  collections.\n\n  Takes several kwargs options that further constrain the collection:\n\n  :kind - a pred that the collection type must satisfy, e.g. vector?\n          (default nil) Note that if :kind is specified and :into is\n          not, this pred must generate in order for every to generate.\n  :count - specifies coll has exactly this count (default nil)\n  :min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n  :distinct - all the elements are distinct (default nil)\n\n  And additional args that control gen\n\n  :gen-max - the maximum coll size to generate (default 20)\n  :into - one of [], (), {}, #{} - the default collection to generate into\n      (default same as :kind if supplied, else []\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator\n\n  See also - coll-of, every-kv\n", :row 233} {:end-row 290, :ns "cljs.spec.alpha", :name "every-kv", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[kpred vpred & opts]"], :doc "like 'every' but takes separate key and val preds and works on associative collections.\n\n  Same options as 'every', :into defaults to {}\n\n  See also - map-of", :row 281} {:end-row 305, :ns "cljs.spec.alpha", :name "coll-of", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred & opts]"], :doc "Returns a spec for a collection of items satisfying pred. Unlike\n  generator will fill an empty init-coll.\n\n  Same options as 'every'. conform will produce a collection\n  corresponding to :into if supplied, else will match the input collection,\n  avoiding rebuilding when possible.\n\n  Same options as 'every'.\n\n  See also - every, map-of", :row 292} {:end-row 319, :ns "cljs.spec.alpha", :name "map-of", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[kpred vpred & opts]"], :doc "Returns a spec for a map whose keys satisfy kpred and vals satisfy\n  vpred. Unlike 'every-kv', map-of will exhaustively conform every\n  value.\n\n  Same options as 'every', :kind defaults to map?, with the addition of:\n\n  :conform-keys - conform keys as well as values (default false)\n\n  See also - every-kv", :row 307} {:fixed-arities #{1}, :end-row 325, :ns "cljs.spec.alpha", :name "*", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches zero or more values matching\n  pred. Produces a vector of matches iff there is at least one match", :row 321} {:fixed-arities #{1}, :end-row 331, :ns "cljs.spec.alpha", :name "+", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches one or more values matching\n  pred. Produces a vector of matches", :row 327} {:fixed-arities #{1}, :end-row 337, :ns "cljs.spec.alpha", :name "?", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches zero or one value matching\n  pred. Produces a single value (not a collection) if matched.", :row 333} {:end-row 354, :ns "cljs.spec.alpha", :name "alt", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/alt :even even? :small #(< % 42))\n\n  Returns a regex op that returns a map entry containing the key of the\n  first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :row 339} {:end-row 370, :ns "cljs.spec.alpha", :name "cat", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/cat :e even? :o odd?)\n\n  Returns a regex op that matches (all) values in sequence, returning a map\n  containing the keys of each pred and the corresponding value.", :row 356} {:end-row 378, :ns "cljs.spec.alpha", :name "&", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[re & preds]"], :doc "takes a regex op re, and predicates. Returns a regex-op that consumes\n  input as per re but subjects the resulting value to the\n  conjunction of the predicates, and any conforming they might perform.", :row 372} {:fixed-arities #{1 2}, :end-row 386, :ns "cljs.spec.alpha", :name "conformer", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[f]" "[f unf]"], :doc "takes a predicate function with the semantics of conform i.e. it should return either a\n  (possibly converted) value or :cljs.spec.alpha/invalid, and returns a\n  spec that uses it as a predicate/conformer. Optionally takes a\n  second fn that does unform of result of first", :row 380} {:end-row 406, :ns "cljs.spec.alpha", :name "fspec", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [args ret fn gen] :or {ret `cljs.core/any?}}]"], :doc "takes :args :ret and (optional) :fn kwargs whose values are preds\n  and returns a spec whose conform/explain take a fn and validates it\n  using generative testing. The conformed value is always the fn itself.\n\n  See 'fdef' for a single operation that creates an fspec and\n  registers it, as well as a full description of :args, :ret and :fn\n\n  fspecs can generate functions that validate the arguments and\n  fabricate a return value compliant with the :ret spec, ignoring\n  the :fn spec if present.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args\n  that returns a test.check generator.", :row 388} {:end-row 414, :ns "cljs.spec.alpha", :name "tuple", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& preds]"], :doc "takes one or more preds and returns a spec for a tuple, a vector\n  where each element conforms to the corresponding pred. Each element\n  will be referred to in paths using its ordinal.", :row 408} {:end-row 449, :ns "cljs.spec.alpha", :name "fdef", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[fn-sym & specs]"], :doc "Takes a symbol naming a function, and one or more of the following:\n\n  :args A regex spec for the function arguments as they were a list to be\n    passed to apply - in this way, a single spec can handle functions with\n    multiple arities\n  :ret A spec for the function's return value\n  :fn A spec of the relationship between args and ret - the\n    value passed is {:args conformed-args :ret conformed-ret} and is\n    expected to contain predicates that relate those values\n\n  Qualifies fn-sym with resolve, or using *ns* if no resolution found.\n  Registers an fspec in the global registry, where it can be retrieved\n  by calling get-spec with the var or fully-qualified symbol.\n\n  Once registered, function specs are included in doc, checked by\n  instrument, tested by the runner cljs.spec.test.alpha/check, and (if\n  a macro) used to explain errors during macroexpansion.\n\n  Note that :fn specs require the presence of :args and :ret specs to\n  conform values, and so :fn specs will be ignored if :args or :ret\n  are missing.\n\n  Returns the qualified fn-sym.\n\n  For example, to register function specs for the symbol function:\n\n  (s/fdef cljs.core/symbol\n    :args (s/alt :separate (s/cat :ns string? :n string?)\n                 :str string?\n                 :sym symbol?)\n    :ret symbol?)", :row 416} {:end-row 468, :ns "cljs.spec.alpha", :name "keys*", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& kspecs]"], :doc "takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\n  converts them into a map, and conforms that map with a corresponding\n  spec/keys call:\n\n  user=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n  {:a 1, :c 2}\n  user=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n  {:a 1, :c 2}\n\n  the resulting regex op can be composed into a larger regex:\n\n  user=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n  {:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}", :row 451} {:fixed-arities #{1}, :end-row 474, :ns "cljs.spec.alpha", :name "nilable", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred]"], :doc "returns a spec that accepts nil and values satisfiying pred", :row 470} {:fixed-arities #{2}, :end-row 486, :ns "cljs.spec.alpha", :name "inst-in", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[start end]"], :doc "Returns a spec that validates insts in the range from start\n  (inclusive) to end (exclusive).", :row 476} {:fixed-arities #{2}, :end-row 493, :ns "cljs.spec.alpha", :name "int-in", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[start end]"], :doc "Returns a spec that validates fixed precision integers in the\n  range from start (inclusive) to end (exclusive).", :row 488} {:end-row 510, :ns "cljs.spec.alpha", :name "double-in", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [infinite? NaN? min max] :or {infinite? true NaN? true} :as m}]"], :doc "Specs a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity allowed (default true)\n    :NaN?      - whether NaN allowed (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)", :row 495} {:end-row 519, :ns "cljs.spec.alpha", :name "merge", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& pred-forms]"], :doc "Takes map-validating specs (e.g. 'keys' specs) and\n  returns a spec that returns a conformed map satisfying all of the\n  specs.  Successive conformed values propagate through rest of\n  predicates. Unlike 'and', merge can generate maps satisfying the\n  union of the predicates.", :row 512} {:fixed-arities #{1 3 2}, :end-row 542, :ns "cljs.spec.alpha", :name "exercise-fn", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[sym]" "[sym n]" "[sym n fspec]"], :doc "exercises the fn named by sym (a symbol) by applying it to\n  n (default 10) generated samples of its args spec. When fspec is\n  supplied its arg spec is used, and sym-or-f can be a fn.  Returns a\n  sequence of tuples of [args ret]. ", :row 521} {:fixed-arities #{0}, :end-row 546, :private true, :ns "cljs.spec.alpha", :name "init-compile-asserts", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[]"], :row 544} {:fixed-arities #{2}, :end-row 564, :ns "cljs.spec.alpha", :name "assert", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[spec x]"], :doc "spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an error with explain-data plus ::failure of\n:assertion-failed.\nCan be disabled at either compile time or runtime:\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto the negation value of the ':elide-asserts' compiler option, or true if\nnot set.\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'cljs.spec.alpha/*runtime-asserts*', or false if not set. You can\ntoggle check-asserts? with (check-asserts bool).", :row 548} {:end-row 19, :filename "cljs/spec/alpha.cljs", :name "MAX_INT", :ns "cljs.spec.alpha", :row 19} {:doc "A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\n  can be recursed through during generation. After this a\n  non-recursive branch will be chosen.", :end-row 25, :filename "cljs/spec/alpha.cljs", :name "*recursion-limit*", :ns "cljs.spec.alpha", :row 21} {:doc "The number of times an anonymous fn specified by fspec will be (generatively) tested during conform", :end-row 29, :filename "cljs/spec/alpha.cljs", :name "*fspec-iterations*", :ns "cljs.spec.alpha", :row 27} {:doc "The number of items validated in a collection spec'ed with 'every'", :end-row 33, :filename "cljs/spec/alpha.cljs", :name "*coll-check-limit*", :ns "cljs.spec.alpha", :row 31} {:doc "The number of errors reported by explain in a collection spec'ed with 'every'", :end-row 37, :filename "cljs/spec/alpha.cljs", :name "*coll-error-limit*", :ns "cljs.spec.alpha", :row 35} {:end-row 45, :filename "cljs/spec/alpha.cljs", :name "Spec", :ns "cljs.spec.alpha", :row 39} {:arglist-strs ["[spec x]"], :end-row 40, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "conform*", :ns "cljs.spec.alpha", :row 40} {:arglist-strs ["[spec y]"], :end-row 41, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "unform*", :ns "cljs.spec.alpha", :row 41} {:arglist-strs ["[spec path via in x]"], :end-row 42, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "explain*", :ns "cljs.spec.alpha", :row 42} {:arglist-strs ["[spec overrides path rmap]"], :end-row 43, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "gen*", :ns "cljs.spec.alpha", :row 43} {:arglist-strs ["[spec gfn]"], :end-row 44, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "with-gen*", :ns "cljs.spec.alpha", :row 44} {:arglist-strs ["[spec]"], :end-row 45, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "describe*", :ns "cljs.spec.alpha", :row 45} {:end-row 47, :filename "cljs/spec/alpha.cljs", :name "registry-ref", :ns "cljs.spec.alpha", :private true, :row 47} {:arglist-strs ["[reg k]"], :end-row 53, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "deep-resolve", :ns "cljs.spec.alpha", :private true, :row 49} {:fixed-arities #{1}, :end-row 64, :private true, :ns "cljs.spec.alpha", :name "reg-resolve", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[k]"], :doc "returns the spec/regex at end of alias chain starting with k, nil if not found, k if k not ident", :row 55} {:fixed-arities #{1}, :end-row 72, :private true, :ns "cljs.spec.alpha", :name "reg-resolve!", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[k]"], :doc "returns the spec/regex at end of alias chain starting with k, throws if not found, k if k not ident", :row 66} {:arglist-strs ["[x]"], :doc "returns x if x is a spec object, else logical false", :end-row 78, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "spec?", :ns "cljs.spec.alpha", :row 74} {:arglist-strs ["[x]"], :doc "returns x if x is a (cljs.spec.alpha) regex op, else logical false", :end-row 83, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "regex?", :ns "cljs.spec.alpha", :row 80} {:arglist-strs ["[spec name]"], :end-row 91, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "with-name", :ns "cljs.spec.alpha", :private true, :row 85} {:arglist-strs ["[spec]"], :end-row 100, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "spec-name", :ns "cljs.spec.alpha", :private true, :row 93} {:end-row 102, :filename "cljs/spec/alpha.cljs", :name "spec-impl", :ns "cljs.spec.alpha", :row 102} {:end-row 103, :filename "cljs/spec/alpha.cljs", :name "regex-spec-impl", :ns "cljs.spec.alpha", :row 103} {:fixed-arities #{1}, :end-row 114, :private true, :ns "cljs.spec.alpha", :name "maybe-spec", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[spec-or-k]"], :doc "spec-or-k must be a spec, regex or resolvable kw/sym, else returns nil.", :row 105} {:fixed-arities #{1}, :end-row 121, :private true, :ns "cljs.spec.alpha", :name "the-spec", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[spec-or-k]"], :doc "spec-or-k must be a spec, regex or kw/sym, else returns nil. Throws if unresolvable kw/sym", :row 116} {:arglist-strs ["[f-n]"], :end-row 129, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "fn-sym", :ns "cljs.spec.alpha", :private true, :row 123} {:end-row 132, :filename "cljs/spec/alpha.cljs", :name "Specize", :ns "cljs.spec.alpha", :row 131} {:arglist-strs ["[_]" "[_ form]"], :end-row 132, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1 2}, :name "specize*", :ns "cljs.spec.alpha", :row 132} {:arglist-strs ["[s]" "[s form]"], :end-row 161, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1 2}, :name "specize", :ns "cljs.spec.alpha", :private true, :row 159} {:arglist-strs ["[ret]"], :doc "tests the validity of a conform return value", :end-row 166, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "invalid?", :ns "cljs.spec.alpha", :row 163} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\n  not match spec, else the (possibly destructured) value.", :end-row 172, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "conform", :ns "cljs.spec.alpha", :row 168} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value created by or compliant with a call to\n  'conform' with the same spec, returns a value with all conform\n   destructuring undone.", :end-row 179, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "unform", :ns "cljs.spec.alpha", :row 174} {:arglist-strs ["[spec]"], :doc "returns the spec as data", :end-row 185, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "form", :ns "cljs.spec.alpha", :row 181} {:arglist-strs ["[form]"], :end-row 204, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "abbrev", :ns "cljs.spec.alpha", :row 187} {:arglist-strs ["[spec]"], :doc "returns an abbreviated description of the spec as data", :end-row 209, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "describe", :ns "cljs.spec.alpha", :row 206} {:arglist-strs ["[spec gen-fn]"], :doc "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator", :end-row 217, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "with-gen", :ns "cljs.spec.alpha", :row 211} {:arglist-strs ["[spec path via in x]"], :end-row 224, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "explain-data*", :ns "cljs.spec.alpha", :row 219} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path.", :end-row 233, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "explain-data", :ns "cljs.spec.alpha", :row 226} {:arglist-strs ["[ed]"], :doc "Default printer for explain-data. nil indicates a successful validation.", :end-row 260, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "explain-printer", :ns "cljs.spec.alpha", :row 235} {:end-row 262, :filename "cljs/spec/alpha.cljs", :name "*explain-out*", :ns "cljs.spec.alpha", :row 262} {:arglist-strs ["[ed]"], :doc "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n    by default explain-printer.", :end-row 268, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "explain-out", :ns "cljs.spec.alpha", :row 264} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value that fails to conform, prints an explanation to *out*.", :end-row 273, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "explain", :ns "cljs.spec.alpha", :row 270} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value that fails to conform, returns an explanation as a string.", :end-row 278, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "explain-str", :ns "cljs.spec.alpha", :row 275} {:end-row 280, :filename "cljs/spec/alpha.cljs", :name "valid?", :ns "cljs.spec.alpha", :row 280} {:arglist-strs ["[spec overrides path rmap form]"], :end-row 291, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "gensub", :ns "cljs.spec.alpha", :private true, :row 282} {:arglist-strs ["[spec]" "[spec overrides]"], :doc "Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)", :end-row 304, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1 2}, :name "gen", :ns "cljs.spec.alpha", :row 293} {:arglist-strs ["[k form spec]"], :doc "Do not call this directly, use 'def'", :end-row 316, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "def-impl", :ns "cljs.spec.alpha", :row 306} {:arglist-strs ["[]"], :doc "returns the registry map, prefer 'get-spec' to lookup a spec by name", :end-row 321, :filename "cljs/spec/alpha.cljs", :fixed-arities #{0}, :name "registry", :ns "cljs.spec.alpha", :row 318} {:fixed-arities #{1}, :end-row 328, :private true, :ns "cljs.spec.alpha", :name "->sym", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[x]"], :doc "Returns a symbol from a symbol or var", :row 323} {:arglist-strs ["[k]"], :doc "Returns spec registered for keyword/symbol/var k, or nil.", :end-row 333, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "get-spec", :ns "cljs.spec.alpha", :row 330} {:end-row 335, :filename "cljs/spec/alpha.cljs", :name "map-spec", :ns "cljs.spec.alpha", :row 335} {:arglist-strs ["[v args]"], :end-row 348, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "macroexpand-check", :ns "cljs.spec.alpha", :private true, :row 337} {:arglist-strs ["[rmap id path k]"], :end-row 353, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "recur-limit?", :ns "cljs.spec.alpha", :private true, :row 351} {:arglist-strs ["[m k]"], :end-row 356, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "inck", :ns "cljs.spec.alpha", :private true, :row 355} {:arglist-strs ["[pred x form]" "[pred x form cpred?]"], :end-row 369, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4 3}, :name "dt", :ns "cljs.spec.alpha", :private true, :row 358} {:arglist-strs ["[spec x]" "[spec x form]"], :doc "Helper function that returns true when x is valid for spec.", :end-row 378, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3 2}, :name "valid?", :ns "cljs.spec.alpha", :row 371} {:fixed-arities #{3 2}, :end-row 385, :private true, :ns "cljs.spec.alpha", :name "pvalid?", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[pred x]" "[pred x form]"], :doc "internal helper function that returns true when x is valid for spec.", :row 380} {:arglist-strs ["[form pred path via in v]"], :end-row 392, :filename "cljs/spec/alpha.cljs", :fixed-arities #{6}, :name "explain-1", :ns "cljs.spec.alpha", :private true, :row 387} {:end-row 395, :filename "cljs/spec/alpha.cljs", :name "or-k-gen", :ns "cljs.spec.alpha", :row 394} {:end-row 395, :filename "cljs/spec/alpha.cljs", :name "and-k-gen", :ns "cljs.spec.alpha", :row 394} {:fixed-arities #{1}, :end-row 404, :private true, :ns "cljs.spec.alpha", :name "k-gen", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[f]"], :doc "returns a generator for form f, which can be a keyword or a list\n  starting with 'or or 'and.", :row 397} {:fixed-arities #{1 2}, :end-row 415, :private true, :ns "cljs.spec.alpha", :name "or-k-gen", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[s]" "[min-count s]"], :doc "returns a tuple generator made up of generators for a random subset\n  of min-count (default 0) to all elements in s.", :row 406} {:fixed-arities #{1}, :end-row 421, :private true, :ns "cljs.spec.alpha", :name "and-k-gen", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[s]"], :doc "returns a tuple generator made up of generators for every element\n  in s.", :row 417} {:arglist-strs ["[{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn] :as argm}]"], :doc "Do not call this directly, use 'spec' with a map argument", :end-row 509, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "map-spec-impl", :ns "cljs.spec.alpha", :row 423} {:arglist-strs ["[form pred gfn cpred?]" "[form pred gfn cpred? unc]"], :doc "Do not call this directly, use 'spec'", :end-row 542, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4 5}, :name "spec-impl", :ns "cljs.spec.alpha", :row 511} {:arglist-strs ["[form mmvar retag]" "[form mmvar retag gfn]"], :doc "Do not call this directly, use 'multi-spec'", :end-row 592, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4 3}, :name "multi-spec-impl", :ns "cljs.spec.alpha", :row 544} {:arglist-strs ["[forms preds]" "[forms preds gfn]"], :doc "Do not call this directly, use 'tuple'", :end-row 654, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3 2}, :name "tuple-impl", :ns "cljs.spec.alpha", :row 594} {:arglist-strs ["[tag ret]"], :end-row 657, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "tagged-ret", :ns "cljs.spec.alpha", :private true, :row 656} {:arglist-strs ["[keys forms preds gfn]"], :doc "Do not call this directly, use 'or'", :end-row 724, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "or-spec-impl", :ns "cljs.spec.alpha", :row 659} {:arglist-strs ["[x preds forms]"], :end-row 736, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "and-preds", :ns "cljs.spec.alpha", :private true, :row 726} {:arglist-strs ["[forms preds path via in x]"], :end-row 747, :filename "cljs/spec/alpha.cljs", :fixed-arities #{6}, :name "explain-pred-list", :ns "cljs.spec.alpha", :private true, :row 738} {:arglist-strs ["[forms preds gfn]"], :doc "Do not call this directly, use 'and'", :end-row 791, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "and-spec-impl", :ns "cljs.spec.alpha", :row 749} {:arglist-strs ["[x kfn kform distinct count min-count max-count path via in]"], :end-row 811, :filename "cljs/spec/alpha.cljs", :fixed-arities #{10}, :name "coll-prob", :ns "cljs.spec.alpha", :private true, :row 793} {:arglist-strs ["[forms preds gfn]"], :doc "Do not call this directly, use 'merge'", :end-row 839, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "merge-spec-impl", :ns "cljs.spec.alpha", :row 813} {:end-row 841, :filename "cljs/spec/alpha.cljs", :name "empty-coll", :ns "cljs.spec.alpha", :private true, :row 841} {:arglist-strs ["[form pred opts]" "[form pred {conform-into :into describe-form ::describe :keys [kind ::kind-form count max-count min-count distinct gen-max ::kfn ::cpred conform-keys ::conform-all] :or {gen-max 20} :as opts} gfn]"], :doc "Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'", :end-row 969, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4 3}, :name "every-impl", :ns "cljs.spec.alpha", :row 843} {:arglist-strs ["[x]"], :end-row 977, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "accept", :ns "cljs.spec.alpha", :private true, :row 977} {:arglist-strs ["[{:keys [::op]}]"], :end-row 980, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "accept?", :ns "cljs.spec.alpha", :private true, :row 979} {:arglist-strs ["[{[p1 & pr :as ps] :ps [k1 & kr :as ks] :ks [f1 & fr :as forms] :forms ret :ret rep+ :rep+}]"], :end-row 990, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "pcat*", :ns "cljs.spec.alpha", :private true, :row 982} {:arglist-strs ["[& ps]"], :end-row 992, :filename "cljs/spec/alpha.cljs", :name "pcat", :ns "cljs.spec.alpha", :private true, :row 992} {:arglist-strs ["[ks ps forms]"], :doc "Do not call this directly, use 'cat'", :end-row 997, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "cat-impl", :ns "cljs.spec.alpha", :row 994} {:arglist-strs ["[p1 p2 ret splice form]"], :end-row 1004, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "rep*", :ns "cljs.spec.alpha", :private true, :row 999} {:arglist-strs ["[form p]"], :doc "Do not call this directly, use '*'", :end-row 1008, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "rep-impl", :ns "cljs.spec.alpha", :row 1006} {:arglist-strs ["[form p]"], :doc "Do not call this directly, use '+'", :end-row 1013, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "rep+impl", :ns "cljs.spec.alpha", :row 1010} {:arglist-strs ["[re re-form preds pred-forms]"], :doc "Do not call this directly, use '&'", :end-row 1018, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "amp-impl", :ns "cljs.spec.alpha", :row 1015} {:arglist-strs ["[ps ks forms f]"], :end-row 1027, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "filter-alt", :ns "cljs.spec.alpha", :private true, :row 1020} {:arglist-strs ["[ps ks forms]"], :end-row 1039, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "alt*", :ns "cljs.spec.alpha", :private true, :row 1029} {:arglist-strs ["[& ps]"], :end-row 1041, :filename "cljs/spec/alpha.cljs", :name "alts", :ns "cljs.spec.alpha", :private true, :row 1041} {:arglist-strs ["[p1 p2]"], :end-row 1042, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "alt2", :ns "cljs.spec.alpha", :private true, :row 1042} {:arglist-strs ["[ks ps forms]"], :doc "Do not call this directly, use 'alt'", :end-row 1046, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "alt-impl", :ns "cljs.spec.alpha", :row 1044} {:arglist-strs ["[p form]"], :doc "Do not call this directly, use '?'", :end-row 1050, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "maybe-impl", :ns "cljs.spec.alpha", :row 1048} {:arglist-strs ["[p1 pret]"], :end-row 1056, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "noret?", :ns "cljs.spec.alpha", :private true, :row 1052} {:end-row 1058, :filename "cljs/spec/alpha.cljs", :name "preturn", :ns "cljs.spec.alpha", :row 1058} {:arglist-strs ["[p]"], :end-row 1070, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "accept-nil?", :ns "cljs.spec.alpha", :private true, :row 1060} {:end-row 1072, :filename "cljs/spec/alpha.cljs", :name "add-ret", :ns "cljs.spec.alpha", :row 1072} {:arglist-strs ["[p]"], :end-row 1087, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "preturn", :ns "cljs.spec.alpha", :private true, :row 1074} {:arglist-strs ["[p x]"], :end-row 1108, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "op-unform", :ns "cljs.spec.alpha", :private true, :row 1089} {:arglist-strs ["[p r k]"], :end-row 1121, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "add-ret", :ns "cljs.spec.alpha", :private true, :row 1110} {:arglist-strs ["[p x]"], :end-row 1141, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "deriv", :ns "cljs.spec.alpha", :private true, :row 1123} {:arglist-strs ["[p]"], :end-row 1157, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "op-describe", :ns "cljs.spec.alpha", :private true, :row 1143} {:arglist-strs ["[form p path via in input]"], :end-row 1212, :filename "cljs/spec/alpha.cljs", :fixed-arities #{6}, :name "op-explain", :ns "cljs.spec.alpha", :private true, :row 1159} {:arglist-strs ["[p overrides path rmap f]"], :end-row 1253, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "re-gen", :ns "cljs.spec.alpha", :private true, :row 1214} {:arglist-strs ["[p [x & xs :as data]]"], :end-row 1266, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "re-conform", :ns "cljs.spec.alpha", :private true, :row 1255} {:arglist-strs ["[path via in re input]"], :end-row 1292, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "re-explain", :ns "cljs.spec.alpha", :private true, :row 1268} {:arglist-strs ["[re gfn]"], :doc "Do not call this directly, use 'spec' with a regex op argument", :end-row 1317, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "regex-spec-impl", :ns "cljs.spec.alpha", :row 1294} {:arglist-strs ["[f specs args]"], :end-row 1330, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "call-valid?", :ns "cljs.spec.alpha", :private true, :row 1321} {:fixed-arities #{3}, :end-row 1340, :private true, :ns "cljs.spec.alpha", :name "validate-fn", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[f specs iters]"], :doc "returns f if valid, else smallest", :row 1332} {:arglist-strs ["[argspec aform retspec rform fnspec fform gfn]"], :doc "Do not call this directly, use 'fspec'", :end-row 1384, :filename "cljs/spec/alpha.cljs", :fixed-arities #{7}, :name "fspec-impl", :ns "cljs.spec.alpha", :row 1342} {:arglist-strs ["[spec]"], :doc "takes a spec and returns a spec that has the same properties except\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.", :end-row 1408, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "nonconforming", :ns "cljs.spec.alpha", :row 1389} {:arglist-strs ["[form pred gfn]"], :doc "Do not call this directly, use 'nilable'", :end-row 1434, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "nilable-impl", :ns "cljs.spec.alpha", :row 1410} {:arglist-strs ["[spec]" "[spec n]" "[spec n overrides]"], :doc "generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen", :end-row 1443, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1 3 2}, :name "exercise", :ns "cljs.spec.alpha", :row 1436} {:arglist-strs ["[start end inst]"], :doc "Return true if inst at or after start and before end", :end-row 1450, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "inst-in-range?", :ns "cljs.spec.alpha", :row 1445} {:arglist-strs ["[start end val]"], :doc "Return true if start <= val, val < end and val is a fixed\n  precision integer.", :end-row 1467, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "int-in-range?", :ns "cljs.spec.alpha", :row 1452} {:doc "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true.", :end-row 1478, :filename "cljs/spec/alpha.cljs", :name "*compile-asserts*", :ns "cljs.spec.alpha", :row 1470} {:end-row 1483, :filename "cljs/spec/alpha.cljs", :name "*runtime-asserts*", :ns "cljs.spec.alpha", :private true, :row 1480} {:arglist-strs ["[]"], :doc "Returns the value set by check-asserts.", :end-row 1488, :filename "cljs/spec/alpha.cljs", :fixed-arities #{0}, :name "check-asserts?", :ns "cljs.spec.alpha", :row 1485} {:arglist-strs ["[flag]"], :doc "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\nDefaults to false.", :end-row 1496, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "check-asserts", :ns "cljs.spec.alpha", :row 1490} {:arglist-strs ["[spec x]"], :doc "Do not call this directly, use 'assert'.", :end-row 1506, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "assert*", :ns "cljs.spec.alpha", :row 1498}]} {:end-row 17, :filename "cljs/spec/alpha.cljc", :lang :cljs, :name "cljs.spec.alpha", :row 9, :ns nil, :var-definitions [{:end-row 19, :filename "cljs/spec/alpha.cljc", :lang :clj, :name "registry-ref", :ns "cljs.spec.alpha", :row 19} {:fixed-arities #{1}, :end-row 26, :private true, :ns "cljs.spec.alpha", :name "->sym", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[x]"], :doc "Returns a symbol from a symbol or var", :row 21} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.spec.alpha", :name "unfn", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[expr]"], :row 28} {:fixed-arities #{2}, :end-row 48, :private true, :ns "cljs.spec.alpha", :name "res", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env form]"], :row 36} {:fixed-arities #{1}, :end-row 53, :private true, :ns "cljs.spec.alpha", :name "mres", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[form]"], :doc "a compile time res, for use in cljs/spec/alpha.cljs", :row 50} {:fixed-arities #{2}, :end-row 61, :private true, :ns "cljs.spec.alpha", :name "ns-qualify", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env s]"], :doc "Qualify symbol s by resolving it or using the current *ns*.", :row 55} {:end-row 63, :filename "cljs/spec/alpha.cljc", :lang :clj, :name "_speced_vars", :ns "cljs.spec.alpha", :private true, :row 63} {:arglist-strs ["[]"], :end-row 66, :filename "cljs/spec/alpha.cljc", :fixed-arities #{0}, :lang :clj, :name "speced-vars", :ns "cljs.spec.alpha", :row 65} {:fixed-arities #{2}, :end-row 85, :ns "cljs.spec.alpha", :name "def", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[k spec-form]"], :doc "Given a namespace-qualified keyword or resolveable symbol k, and a\n  spec, spec-name, predicate or regex-op makes an entry in the\n  registry mapping k to the spec. Use nil to remove an entry in\n  the registry for k.", :row 68} {:end-row 104, :ns "cljs.spec.alpha", :name "spec", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[form & {:keys [gen]}]"], :doc "Takes a single predicate form, e.g. can be the name of a predicate,\n  like even?, or a fn literal like #(< % 42). Note that it is not\n  generally necessary to wrap predicates in spec when using the rest\n  of the spec macros, only to attach a unique generator\n\n  Can also be passed the result of one of the regex ops -\n  cat, alt, *, +, ?, in which case it will return a regex-conforming\n  spec, useful when nesting an independent regex.\n  ---\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\n\n  Returns a spec.", :row 87} {:fixed-arities #{2}, :end-row 133, :ns "cljs.spec.alpha", :name "multi-spec", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[mm retag]"], :doc "Takes the name of a spec/predicate-returning multimethod and a\n  tag-restoring keyword or fn (retag).  Returns a spec that when\n  conforming or explaining data will pass it to the multimethod to get\n  an appropriate spec. You can e.g. use multi-spec to dynamically and\n  extensibly associate specs with 'tagged' data (i.e. data where one\n  of the fields indicates the shape of the rest of the structure).\n\n  (defmulti mspec :tag)\n\n  The methods should ignore their argument and return a predicate/spec:\n  (defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\n  retag is used during generation to retag generated values with\n  matching tags. retag can either be a keyword, at which key the\n  dispatch-tag will be assoc'ed, or a fn of generated value and\n  dispatch-tag that should return an appropriately retagged value.\n\n  Note that because the tags themselves comprise an open set,\n  the tag key spec cannot enumerate the values, but can e.g.\n  test for keyword?.\n\n  Note also that the dispatch values of the multimethod will be\n  included in the path, i.e. in reporting and gen overrides, even\n  though those values are not evident in the spec.\n", :row 106} {:end-row 195, :ns "cljs.spec.alpha", :name "keys", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [req req-un opt opt-un gen]}]"], :doc "Creates and returns a map validating spec. :req and :opt are both\n  vectors of namespaced-qualified keywords. The validator will ensure\n  the :req keys are present. The :opt keys serve as documentation and\n  may be used by the generator.\n\n  The :req key vector supports 'and' and 'or' for key groups:\n\n  (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\n  There are also -un versions of :req and :opt. These allow\n  you to connect unqualified keys to specs.  In each case, fully\n  qualfied keywords are passed, which name the specs, but unqualified\n  keys (with the same name component) are expected and checked at\n  conform-time, and generated during gen:\n\n  (s/keys :req-un [:my.ns/x :my.ns/y])\n\n  The above says keys :x and :y are required, and will be validated\n  and generated by specs (if they exist) named :my.ns/x :my.ns/y\n  respectively.\n\n  In addition, the values of *all* namespace-qualified keys will be validated\n  (and possibly destructured) by any registered specs. Note: there is\n  no support for inline value specification, by design.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.", :row 135} {:end-row 212, :ns "cljs.spec.alpha", :name "or", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/or :even even? :small #(< % 42))\n\n  Returns a destructuring spec that returns a map entry containing the\n  key of the first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :row 197} {:end-row 222, :ns "cljs.spec.alpha", :name "and", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& pred-forms]"], :doc "Takes predicate/spec-forms, e.g.\n\n  (s/and even? #(< % 42))\n\n  Returns a spec that returns the conformed value. Successive\n  conformed values propagate through rest of predicates.", :row 214} {:fixed-arities #{2}, :end-row 231, :private true, :ns "cljs.spec.alpha", :name "res-kind", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env opts]"], :row 224} {:end-row 279, :ns "cljs.spec.alpha", :name "every", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred & {:keys [into kind count max-count min-count distinct gen-max gen-into gen] :as opts}]"], :doc "takes a pred and validates collection elements against that pred.\n\n  Note that 'every' does not do exhaustive checking, rather it samples\n  *coll-check-limit* elements. Nor (as a result) does it do any\n  conforming of elements. 'explain' will report at most *coll-error-limit*\n  problems.  Thus 'every' should be suitable for potentially large\n  collections.\n\n  Takes several kwargs options that further constrain the collection:\n\n  :kind - a pred that the collection type must satisfy, e.g. vector?\n          (default nil) Note that if :kind is specified and :into is\n          not, this pred must generate in order for every to generate.\n  :count - specifies coll has exactly this count (default nil)\n  :min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n  :distinct - all the elements are distinct (default nil)\n\n  And additional args that control gen\n\n  :gen-max - the maximum coll size to generate (default 20)\n  :into - one of [], (), {}, #{} - the default collection to generate into\n      (default same as :kind if supplied, else []\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator\n\n  See also - coll-of, every-kv\n", :row 233} {:end-row 290, :ns "cljs.spec.alpha", :name "every-kv", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[kpred vpred & opts]"], :doc "like 'every' but takes separate key and val preds and works on associative collections.\n\n  Same options as 'every', :into defaults to {}\n\n  See also - map-of", :row 281} {:end-row 305, :ns "cljs.spec.alpha", :name "coll-of", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred & opts]"], :doc "Returns a spec for a collection of items satisfying pred. Unlike\n  generator will fill an empty init-coll.\n\n  Same options as 'every'. conform will produce a collection\n  corresponding to :into if supplied, else will match the input collection,\n  avoiding rebuilding when possible.\n\n  Same options as 'every'.\n\n  See also - every, map-of", :row 292} {:end-row 319, :ns "cljs.spec.alpha", :name "map-of", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[kpred vpred & opts]"], :doc "Returns a spec for a map whose keys satisfy kpred and vals satisfy\n  vpred. Unlike 'every-kv', map-of will exhaustively conform every\n  value.\n\n  Same options as 'every', :kind defaults to map?, with the addition of:\n\n  :conform-keys - conform keys as well as values (default false)\n\n  See also - every-kv", :row 307} {:fixed-arities #{1}, :end-row 325, :ns "cljs.spec.alpha", :name "*", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches zero or more values matching\n  pred. Produces a vector of matches iff there is at least one match", :row 321} {:fixed-arities #{1}, :end-row 331, :ns "cljs.spec.alpha", :name "+", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches one or more values matching\n  pred. Produces a vector of matches", :row 327} {:fixed-arities #{1}, :end-row 337, :ns "cljs.spec.alpha", :name "?", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches zero or one value matching\n  pred. Produces a single value (not a collection) if matched.", :row 333} {:end-row 354, :ns "cljs.spec.alpha", :name "alt", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/alt :even even? :small #(< % 42))\n\n  Returns a regex op that returns a map entry containing the key of the\n  first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :row 339} {:end-row 370, :ns "cljs.spec.alpha", :name "cat", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/cat :e even? :o odd?)\n\n  Returns a regex op that matches (all) values in sequence, returning a map\n  containing the keys of each pred and the corresponding value.", :row 356} {:end-row 378, :ns "cljs.spec.alpha", :name "&", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[re & preds]"], :doc "takes a regex op re, and predicates. Returns a regex-op that consumes\n  input as per re but subjects the resulting value to the\n  conjunction of the predicates, and any conforming they might perform.", :row 372} {:fixed-arities #{1 2}, :end-row 386, :ns "cljs.spec.alpha", :name "conformer", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[f]" "[f unf]"], :doc "takes a predicate function with the semantics of conform i.e. it should return either a\n  (possibly converted) value or :cljs.spec.alpha/invalid, and returns a\n  spec that uses it as a predicate/conformer. Optionally takes a\n  second fn that does unform of result of first", :row 380} {:end-row 406, :ns "cljs.spec.alpha", :name "fspec", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [args ret fn gen] :or {ret `cljs.core/any?}}]"], :doc "takes :args :ret and (optional) :fn kwargs whose values are preds\n  and returns a spec whose conform/explain take a fn and validates it\n  using generative testing. The conformed value is always the fn itself.\n\n  See 'fdef' for a single operation that creates an fspec and\n  registers it, as well as a full description of :args, :ret and :fn\n\n  fspecs can generate functions that validate the arguments and\n  fabricate a return value compliant with the :ret spec, ignoring\n  the :fn spec if present.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args\n  that returns a test.check generator.", :row 388} {:end-row 414, :ns "cljs.spec.alpha", :name "tuple", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& preds]"], :doc "takes one or more preds and returns a spec for a tuple, a vector\n  where each element conforms to the corresponding pred. Each element\n  will be referred to in paths using its ordinal.", :row 408} {:end-row 449, :ns "cljs.spec.alpha", :name "fdef", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[fn-sym & specs]"], :doc "Takes a symbol naming a function, and one or more of the following:\n\n  :args A regex spec for the function arguments as they were a list to be\n    passed to apply - in this way, a single spec can handle functions with\n    multiple arities\n  :ret A spec for the function's return value\n  :fn A spec of the relationship between args and ret - the\n    value passed is {:args conformed-args :ret conformed-ret} and is\n    expected to contain predicates that relate those values\n\n  Qualifies fn-sym with resolve, or using *ns* if no resolution found.\n  Registers an fspec in the global registry, where it can be retrieved\n  by calling get-spec with the var or fully-qualified symbol.\n\n  Once registered, function specs are included in doc, checked by\n  instrument, tested by the runner cljs.spec.test.alpha/check, and (if\n  a macro) used to explain errors during macroexpansion.\n\n  Note that :fn specs require the presence of :args and :ret specs to\n  conform values, and so :fn specs will be ignored if :args or :ret\n  are missing.\n\n  Returns the qualified fn-sym.\n\n  For example, to register function specs for the symbol function:\n\n  (s/fdef cljs.core/symbol\n    :args (s/alt :separate (s/cat :ns string? :n string?)\n                 :str string?\n                 :sym symbol?)\n    :ret symbol?)", :row 416} {:end-row 468, :ns "cljs.spec.alpha", :name "keys*", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& kspecs]"], :doc "takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\n  converts them into a map, and conforms that map with a corresponding\n  spec/keys call:\n\n  user=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n  {:a 1, :c 2}\n  user=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n  {:a 1, :c 2}\n\n  the resulting regex op can be composed into a larger regex:\n\n  user=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n  {:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}", :row 451} {:fixed-arities #{1}, :end-row 474, :ns "cljs.spec.alpha", :name "nilable", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred]"], :doc "returns a spec that accepts nil and values satisfiying pred", :row 470} {:fixed-arities #{2}, :end-row 486, :ns "cljs.spec.alpha", :name "inst-in", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[start end]"], :doc "Returns a spec that validates insts in the range from start\n  (inclusive) to end (exclusive).", :row 476} {:fixed-arities #{2}, :end-row 493, :ns "cljs.spec.alpha", :name "int-in", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[start end]"], :doc "Returns a spec that validates fixed precision integers in the\n  range from start (inclusive) to end (exclusive).", :row 488} {:end-row 510, :ns "cljs.spec.alpha", :name "double-in", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [infinite? NaN? min max] :or {infinite? true NaN? true} :as m}]"], :doc "Specs a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity allowed (default true)\n    :NaN?      - whether NaN allowed (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)", :row 495} {:end-row 519, :ns "cljs.spec.alpha", :name "merge", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& pred-forms]"], :doc "Takes map-validating specs (e.g. 'keys' specs) and\n  returns a spec that returns a conformed map satisfying all of the\n  specs.  Successive conformed values propagate through rest of\n  predicates. Unlike 'and', merge can generate maps satisfying the\n  union of the predicates.", :row 512} {:fixed-arities #{1 3 2}, :end-row 542, :ns "cljs.spec.alpha", :name "exercise-fn", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[sym]" "[sym n]" "[sym n fspec]"], :doc "exercises the fn named by sym (a symbol) by applying it to\n  n (default 10) generated samples of its args spec. When fspec is\n  supplied its arg spec is used, and sym-or-f can be a fn.  Returns a\n  sequence of tuples of [args ret]. ", :row 521} {:fixed-arities #{0}, :end-row 546, :private true, :ns "cljs.spec.alpha", :name "init-compile-asserts", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[]"], :row 544} {:fixed-arities #{2}, :end-row 564, :ns "cljs.spec.alpha", :name "assert", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[spec x]"], :doc "spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an error with explain-data plus ::failure of\n:assertion-failed.\nCan be disabled at either compile time or runtime:\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto the negation value of the ':elide-asserts' compiler option, or true if\nnot set.\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'cljs.spec.alpha/*runtime-asserts*', or false if not set. You can\ntoggle check-asserts? with (check-asserts bool).", :row 548} {:end-row 19, :filename "cljs/spec/alpha.cljc", :lang :cljs, :name "registry-ref", :ns "cljs.spec.alpha", :row 19} {:fixed-arities #{1}, :end-row 26, :private true, :ns "cljs.spec.alpha", :name "->sym", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[x]"], :doc "Returns a symbol from a symbol or var", :row 21} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.spec.alpha", :name "unfn", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[expr]"], :row 28} {:fixed-arities #{2}, :end-row 48, :private true, :ns "cljs.spec.alpha", :name "res", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env form]"], :row 36} {:fixed-arities #{1}, :end-row 53, :private true, :ns "cljs.spec.alpha", :name "mres", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[form]"], :doc "a compile time res, for use in cljs/spec/alpha.cljs", :row 50} {:fixed-arities #{2}, :end-row 61, :private true, :ns "cljs.spec.alpha", :name "ns-qualify", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env s]"], :doc "Qualify symbol s by resolving it or using the current *ns*.", :row 55} {:end-row 63, :filename "cljs/spec/alpha.cljc", :lang :cljs, :name "_speced_vars", :ns "cljs.spec.alpha", :private true, :row 63} {:arglist-strs ["[]"], :end-row 66, :filename "cljs/spec/alpha.cljc", :fixed-arities #{0}, :lang :cljs, :name "speced-vars", :ns "cljs.spec.alpha", :row 65} {:fixed-arities #{2}, :end-row 85, :ns "cljs.spec.alpha", :name "def", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[k spec-form]"], :doc "Given a namespace-qualified keyword or resolveable symbol k, and a\n  spec, spec-name, predicate or regex-op makes an entry in the\n  registry mapping k to the spec. Use nil to remove an entry in\n  the registry for k.", :row 68} {:end-row 104, :ns "cljs.spec.alpha", :name "spec", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[form & {:keys [gen]}]"], :doc "Takes a single predicate form, e.g. can be the name of a predicate,\n  like even?, or a fn literal like #(< % 42). Note that it is not\n  generally necessary to wrap predicates in spec when using the rest\n  of the spec macros, only to attach a unique generator\n\n  Can also be passed the result of one of the regex ops -\n  cat, alt, *, +, ?, in which case it will return a regex-conforming\n  spec, useful when nesting an independent regex.\n  ---\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\n\n  Returns a spec.", :row 87} {:fixed-arities #{2}, :end-row 133, :ns "cljs.spec.alpha", :name "multi-spec", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[mm retag]"], :doc "Takes the name of a spec/predicate-returning multimethod and a\n  tag-restoring keyword or fn (retag).  Returns a spec that when\n  conforming or explaining data will pass it to the multimethod to get\n  an appropriate spec. You can e.g. use multi-spec to dynamically and\n  extensibly associate specs with 'tagged' data (i.e. data where one\n  of the fields indicates the shape of the rest of the structure).\n\n  (defmulti mspec :tag)\n\n  The methods should ignore their argument and return a predicate/spec:\n  (defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\n  retag is used during generation to retag generated values with\n  matching tags. retag can either be a keyword, at which key the\n  dispatch-tag will be assoc'ed, or a fn of generated value and\n  dispatch-tag that should return an appropriately retagged value.\n\n  Note that because the tags themselves comprise an open set,\n  the tag key spec cannot enumerate the values, but can e.g.\n  test for keyword?.\n\n  Note also that the dispatch values of the multimethod will be\n  included in the path, i.e. in reporting and gen overrides, even\n  though those values are not evident in the spec.\n", :row 106} {:end-row 195, :ns "cljs.spec.alpha", :name "keys", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [req req-un opt opt-un gen]}]"], :doc "Creates and returns a map validating spec. :req and :opt are both\n  vectors of namespaced-qualified keywords. The validator will ensure\n  the :req keys are present. The :opt keys serve as documentation and\n  may be used by the generator.\n\n  The :req key vector supports 'and' and 'or' for key groups:\n\n  (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\n  There are also -un versions of :req and :opt. These allow\n  you to connect unqualified keys to specs.  In each case, fully\n  qualfied keywords are passed, which name the specs, but unqualified\n  keys (with the same name component) are expected and checked at\n  conform-time, and generated during gen:\n\n  (s/keys :req-un [:my.ns/x :my.ns/y])\n\n  The above says keys :x and :y are required, and will be validated\n  and generated by specs (if they exist) named :my.ns/x :my.ns/y\n  respectively.\n\n  In addition, the values of *all* namespace-qualified keys will be validated\n  (and possibly destructured) by any registered specs. Note: there is\n  no support for inline value specification, by design.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.", :row 135} {:end-row 212, :ns "cljs.spec.alpha", :name "or", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/or :even even? :small #(< % 42))\n\n  Returns a destructuring spec that returns a map entry containing the\n  key of the first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :row 197} {:end-row 222, :ns "cljs.spec.alpha", :name "and", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& pred-forms]"], :doc "Takes predicate/spec-forms, e.g.\n\n  (s/and even? #(< % 42))\n\n  Returns a spec that returns the conformed value. Successive\n  conformed values propagate through rest of predicates.", :row 214} {:fixed-arities #{2}, :end-row 231, :private true, :ns "cljs.spec.alpha", :name "res-kind", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env opts]"], :row 224} {:end-row 279, :ns "cljs.spec.alpha", :name "every", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred & {:keys [into kind count max-count min-count distinct gen-max gen-into gen] :as opts}]"], :doc "takes a pred and validates collection elements against that pred.\n\n  Note that 'every' does not do exhaustive checking, rather it samples\n  *coll-check-limit* elements. Nor (as a result) does it do any\n  conforming of elements. 'explain' will report at most *coll-error-limit*\n  problems.  Thus 'every' should be suitable for potentially large\n  collections.\n\n  Takes several kwargs options that further constrain the collection:\n\n  :kind - a pred that the collection type must satisfy, e.g. vector?\n          (default nil) Note that if :kind is specified and :into is\n          not, this pred must generate in order for every to generate.\n  :count - specifies coll has exactly this count (default nil)\n  :min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n  :distinct - all the elements are distinct (default nil)\n\n  And additional args that control gen\n\n  :gen-max - the maximum coll size to generate (default 20)\n  :into - one of [], (), {}, #{} - the default collection to generate into\n      (default same as :kind if supplied, else []\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator\n\n  See also - coll-of, every-kv\n", :row 233} {:end-row 290, :ns "cljs.spec.alpha", :name "every-kv", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[kpred vpred & opts]"], :doc "like 'every' but takes separate key and val preds and works on associative collections.\n\n  Same options as 'every', :into defaults to {}\n\n  See also - map-of", :row 281} {:end-row 305, :ns "cljs.spec.alpha", :name "coll-of", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred & opts]"], :doc "Returns a spec for a collection of items satisfying pred. Unlike\n  generator will fill an empty init-coll.\n\n  Same options as 'every'. conform will produce a collection\n  corresponding to :into if supplied, else will match the input collection,\n  avoiding rebuilding when possible.\n\n  Same options as 'every'.\n\n  See also - every, map-of", :row 292} {:end-row 319, :ns "cljs.spec.alpha", :name "map-of", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[kpred vpred & opts]"], :doc "Returns a spec for a map whose keys satisfy kpred and vals satisfy\n  vpred. Unlike 'every-kv', map-of will exhaustively conform every\n  value.\n\n  Same options as 'every', :kind defaults to map?, with the addition of:\n\n  :conform-keys - conform keys as well as values (default false)\n\n  See also - every-kv", :row 307} {:fixed-arities #{1}, :end-row 325, :ns "cljs.spec.alpha", :name "*", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches zero or more values matching\n  pred. Produces a vector of matches iff there is at least one match", :row 321} {:fixed-arities #{1}, :end-row 331, :ns "cljs.spec.alpha", :name "+", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches one or more values matching\n  pred. Produces a vector of matches", :row 327} {:fixed-arities #{1}, :end-row 337, :ns "cljs.spec.alpha", :name "?", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches zero or one value matching\n  pred. Produces a single value (not a collection) if matched.", :row 333} {:end-row 354, :ns "cljs.spec.alpha", :name "alt", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/alt :even even? :small #(< % 42))\n\n  Returns a regex op that returns a map entry containing the key of the\n  first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :row 339} {:end-row 370, :ns "cljs.spec.alpha", :name "cat", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/cat :e even? :o odd?)\n\n  Returns a regex op that matches (all) values in sequence, returning a map\n  containing the keys of each pred and the corresponding value.", :row 356} {:end-row 378, :ns "cljs.spec.alpha", :name "&", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[re & preds]"], :doc "takes a regex op re, and predicates. Returns a regex-op that consumes\n  input as per re but subjects the resulting value to the\n  conjunction of the predicates, and any conforming they might perform.", :row 372} {:fixed-arities #{1 2}, :end-row 386, :ns "cljs.spec.alpha", :name "conformer", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[f]" "[f unf]"], :doc "takes a predicate function with the semantics of conform i.e. it should return either a\n  (possibly converted) value or :cljs.spec.alpha/invalid, and returns a\n  spec that uses it as a predicate/conformer. Optionally takes a\n  second fn that does unform of result of first", :row 380} {:end-row 406, :ns "cljs.spec.alpha", :name "fspec", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [args ret fn gen] :or {ret `cljs.core/any?}}]"], :doc "takes :args :ret and (optional) :fn kwargs whose values are preds\n  and returns a spec whose conform/explain take a fn and validates it\n  using generative testing. The conformed value is always the fn itself.\n\n  See 'fdef' for a single operation that creates an fspec and\n  registers it, as well as a full description of :args, :ret and :fn\n\n  fspecs can generate functions that validate the arguments and\n  fabricate a return value compliant with the :ret spec, ignoring\n  the :fn spec if present.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args\n  that returns a test.check generator.", :row 388} {:end-row 414, :ns "cljs.spec.alpha", :name "tuple", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& preds]"], :doc "takes one or more preds and returns a spec for a tuple, a vector\n  where each element conforms to the corresponding pred. Each element\n  will be referred to in paths using its ordinal.", :row 408} {:end-row 449, :ns "cljs.spec.alpha", :name "fdef", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[fn-sym & specs]"], :doc "Takes a symbol naming a function, and one or more of the following:\n\n  :args A regex spec for the function arguments as they were a list to be\n    passed to apply - in this way, a single spec can handle functions with\n    multiple arities\n  :ret A spec for the function's return value\n  :fn A spec of the relationship between args and ret - the\n    value passed is {:args conformed-args :ret conformed-ret} and is\n    expected to contain predicates that relate those values\n\n  Qualifies fn-sym with resolve, or using *ns* if no resolution found.\n  Registers an fspec in the global registry, where it can be retrieved\n  by calling get-spec with the var or fully-qualified symbol.\n\n  Once registered, function specs are included in doc, checked by\n  instrument, tested by the runner cljs.spec.test.alpha/check, and (if\n  a macro) used to explain errors during macroexpansion.\n\n  Note that :fn specs require the presence of :args and :ret specs to\n  conform values, and so :fn specs will be ignored if :args or :ret\n  are missing.\n\n  Returns the qualified fn-sym.\n\n  For example, to register function specs for the symbol function:\n\n  (s/fdef cljs.core/symbol\n    :args (s/alt :separate (s/cat :ns string? :n string?)\n                 :str string?\n                 :sym symbol?)\n    :ret symbol?)", :row 416} {:end-row 468, :ns "cljs.spec.alpha", :name "keys*", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& kspecs]"], :doc "takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\n  converts them into a map, and conforms that map with a corresponding\n  spec/keys call:\n\n  user=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n  {:a 1, :c 2}\n  user=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n  {:a 1, :c 2}\n\n  the resulting regex op can be composed into a larger regex:\n\n  user=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n  {:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}", :row 451} {:fixed-arities #{1}, :end-row 474, :ns "cljs.spec.alpha", :name "nilable", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred]"], :doc "returns a spec that accepts nil and values satisfiying pred", :row 470} {:fixed-arities #{2}, :end-row 486, :ns "cljs.spec.alpha", :name "inst-in", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[start end]"], :doc "Returns a spec that validates insts in the range from start\n  (inclusive) to end (exclusive).", :row 476} {:fixed-arities #{2}, :end-row 493, :ns "cljs.spec.alpha", :name "int-in", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[start end]"], :doc "Returns a spec that validates fixed precision integers in the\n  range from start (inclusive) to end (exclusive).", :row 488} {:end-row 510, :ns "cljs.spec.alpha", :name "double-in", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [infinite? NaN? min max] :or {infinite? true NaN? true} :as m}]"], :doc "Specs a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity allowed (default true)\n    :NaN?      - whether NaN allowed (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)", :row 495} {:end-row 519, :ns "cljs.spec.alpha", :name "merge", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& pred-forms]"], :doc "Takes map-validating specs (e.g. 'keys' specs) and\n  returns a spec that returns a conformed map satisfying all of the\n  specs.  Successive conformed values propagate through rest of\n  predicates. Unlike 'and', merge can generate maps satisfying the\n  union of the predicates.", :row 512} {:fixed-arities #{1 3 2}, :end-row 542, :ns "cljs.spec.alpha", :name "exercise-fn", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[sym]" "[sym n]" "[sym n fspec]"], :doc "exercises the fn named by sym (a symbol) by applying it to\n  n (default 10) generated samples of its args spec. When fspec is\n  supplied its arg spec is used, and sym-or-f can be a fn.  Returns a\n  sequence of tuples of [args ret]. ", :row 521} {:fixed-arities #{0}, :end-row 546, :private true, :ns "cljs.spec.alpha", :name "init-compile-asserts", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[]"], :row 544} {:fixed-arities #{2}, :end-row 564, :ns "cljs.spec.alpha", :name "assert", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[spec x]"], :doc "spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an error with explain-data plus ::failure of\n:assertion-failed.\nCan be disabled at either compile time or runtime:\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto the negation value of the ':elide-asserts' compiler option, or true if\nnot set.\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'cljs.spec.alpha/*runtime-asserts*', or false if not set. You can\ntoggle check-asserts? with (check-asserts bool).", :row 548} {:end-row 19, :filename "cljs/spec/alpha.cljs", :name "MAX_INT", :ns "cljs.spec.alpha", :row 19} {:doc "A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\n  can be recursed through during generation. After this a\n  non-recursive branch will be chosen.", :end-row 25, :filename "cljs/spec/alpha.cljs", :name "*recursion-limit*", :ns "cljs.spec.alpha", :row 21} {:doc "The number of times an anonymous fn specified by fspec will be (generatively) tested during conform", :end-row 29, :filename "cljs/spec/alpha.cljs", :name "*fspec-iterations*", :ns "cljs.spec.alpha", :row 27} {:doc "The number of items validated in a collection spec'ed with 'every'", :end-row 33, :filename "cljs/spec/alpha.cljs", :name "*coll-check-limit*", :ns "cljs.spec.alpha", :row 31} {:doc "The number of errors reported by explain in a collection spec'ed with 'every'", :end-row 37, :filename "cljs/spec/alpha.cljs", :name "*coll-error-limit*", :ns "cljs.spec.alpha", :row 35} {:end-row 45, :filename "cljs/spec/alpha.cljs", :name "Spec", :ns "cljs.spec.alpha", :row 39} {:arglist-strs ["[spec x]"], :end-row 40, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "conform*", :ns "cljs.spec.alpha", :row 40} {:arglist-strs ["[spec y]"], :end-row 41, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "unform*", :ns "cljs.spec.alpha", :row 41} {:arglist-strs ["[spec path via in x]"], :end-row 42, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "explain*", :ns "cljs.spec.alpha", :row 42} {:arglist-strs ["[spec overrides path rmap]"], :end-row 43, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "gen*", :ns "cljs.spec.alpha", :row 43} {:arglist-strs ["[spec gfn]"], :end-row 44, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "with-gen*", :ns "cljs.spec.alpha", :row 44} {:arglist-strs ["[spec]"], :end-row 45, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "describe*", :ns "cljs.spec.alpha", :row 45} {:end-row 47, :filename "cljs/spec/alpha.cljs", :name "registry-ref", :ns "cljs.spec.alpha", :private true, :row 47} {:arglist-strs ["[reg k]"], :end-row 53, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "deep-resolve", :ns "cljs.spec.alpha", :private true, :row 49} {:fixed-arities #{1}, :end-row 64, :private true, :ns "cljs.spec.alpha", :name "reg-resolve", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[k]"], :doc "returns the spec/regex at end of alias chain starting with k, nil if not found, k if k not ident", :row 55} {:fixed-arities #{1}, :end-row 72, :private true, :ns "cljs.spec.alpha", :name "reg-resolve!", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[k]"], :doc "returns the spec/regex at end of alias chain starting with k, throws if not found, k if k not ident", :row 66} {:arglist-strs ["[x]"], :doc "returns x if x is a spec object, else logical false", :end-row 78, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "spec?", :ns "cljs.spec.alpha", :row 74} {:arglist-strs ["[x]"], :doc "returns x if x is a (cljs.spec.alpha) regex op, else logical false", :end-row 83, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "regex?", :ns "cljs.spec.alpha", :row 80} {:arglist-strs ["[spec name]"], :end-row 91, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "with-name", :ns "cljs.spec.alpha", :private true, :row 85} {:arglist-strs ["[spec]"], :end-row 100, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "spec-name", :ns "cljs.spec.alpha", :private true, :row 93} {:end-row 102, :filename "cljs/spec/alpha.cljs", :name "spec-impl", :ns "cljs.spec.alpha", :row 102} {:end-row 103, :filename "cljs/spec/alpha.cljs", :name "regex-spec-impl", :ns "cljs.spec.alpha", :row 103} {:fixed-arities #{1}, :end-row 114, :private true, :ns "cljs.spec.alpha", :name "maybe-spec", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[spec-or-k]"], :doc "spec-or-k must be a spec, regex or resolvable kw/sym, else returns nil.", :row 105} {:fixed-arities #{1}, :end-row 121, :private true, :ns "cljs.spec.alpha", :name "the-spec", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[spec-or-k]"], :doc "spec-or-k must be a spec, regex or kw/sym, else returns nil. Throws if unresolvable kw/sym", :row 116} {:arglist-strs ["[f-n]"], :end-row 129, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "fn-sym", :ns "cljs.spec.alpha", :private true, :row 123} {:end-row 132, :filename "cljs/spec/alpha.cljs", :name "Specize", :ns "cljs.spec.alpha", :row 131} {:arglist-strs ["[_]" "[_ form]"], :end-row 132, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1 2}, :name "specize*", :ns "cljs.spec.alpha", :row 132} {:arglist-strs ["[s]" "[s form]"], :end-row 161, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1 2}, :name "specize", :ns "cljs.spec.alpha", :private true, :row 159} {:arglist-strs ["[ret]"], :doc "tests the validity of a conform return value", :end-row 166, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "invalid?", :ns "cljs.spec.alpha", :row 163} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\n  not match spec, else the (possibly destructured) value.", :end-row 172, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "conform", :ns "cljs.spec.alpha", :row 168} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value created by or compliant with a call to\n  'conform' with the same spec, returns a value with all conform\n   destructuring undone.", :end-row 179, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "unform", :ns "cljs.spec.alpha", :row 174} {:arglist-strs ["[spec]"], :doc "returns the spec as data", :end-row 185, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "form", :ns "cljs.spec.alpha", :row 181} {:arglist-strs ["[form]"], :end-row 204, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "abbrev", :ns "cljs.spec.alpha", :row 187} {:arglist-strs ["[spec]"], :doc "returns an abbreviated description of the spec as data", :end-row 209, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "describe", :ns "cljs.spec.alpha", :row 206} {:arglist-strs ["[spec gen-fn]"], :doc "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator", :end-row 217, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "with-gen", :ns "cljs.spec.alpha", :row 211} {:arglist-strs ["[spec path via in x]"], :end-row 224, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "explain-data*", :ns "cljs.spec.alpha", :row 219} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path.", :end-row 233, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "explain-data", :ns "cljs.spec.alpha", :row 226} {:arglist-strs ["[ed]"], :doc "Default printer for explain-data. nil indicates a successful validation.", :end-row 260, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "explain-printer", :ns "cljs.spec.alpha", :row 235} {:end-row 262, :filename "cljs/spec/alpha.cljs", :name "*explain-out*", :ns "cljs.spec.alpha", :row 262} {:arglist-strs ["[ed]"], :doc "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n    by default explain-printer.", :end-row 268, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "explain-out", :ns "cljs.spec.alpha", :row 264} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value that fails to conform, prints an explanation to *out*.", :end-row 273, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "explain", :ns "cljs.spec.alpha", :row 270} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value that fails to conform, returns an explanation as a string.", :end-row 278, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "explain-str", :ns "cljs.spec.alpha", :row 275} {:end-row 280, :filename "cljs/spec/alpha.cljs", :name "valid?", :ns "cljs.spec.alpha", :row 280} {:arglist-strs ["[spec overrides path rmap form]"], :end-row 291, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "gensub", :ns "cljs.spec.alpha", :private true, :row 282} {:arglist-strs ["[spec]" "[spec overrides]"], :doc "Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)", :end-row 304, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1 2}, :name "gen", :ns "cljs.spec.alpha", :row 293} {:arglist-strs ["[k form spec]"], :doc "Do not call this directly, use 'def'", :end-row 316, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "def-impl", :ns "cljs.spec.alpha", :row 306} {:arglist-strs ["[]"], :doc "returns the registry map, prefer 'get-spec' to lookup a spec by name", :end-row 321, :filename "cljs/spec/alpha.cljs", :fixed-arities #{0}, :name "registry", :ns "cljs.spec.alpha", :row 318} {:fixed-arities #{1}, :end-row 328, :private true, :ns "cljs.spec.alpha", :name "->sym", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[x]"], :doc "Returns a symbol from a symbol or var", :row 323} {:arglist-strs ["[k]"], :doc "Returns spec registered for keyword/symbol/var k, or nil.", :end-row 333, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "get-spec", :ns "cljs.spec.alpha", :row 330} {:end-row 335, :filename "cljs/spec/alpha.cljs", :name "map-spec", :ns "cljs.spec.alpha", :row 335} {:arglist-strs ["[v args]"], :end-row 348, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "macroexpand-check", :ns "cljs.spec.alpha", :private true, :row 337} {:arglist-strs ["[rmap id path k]"], :end-row 353, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "recur-limit?", :ns "cljs.spec.alpha", :private true, :row 351} {:arglist-strs ["[m k]"], :end-row 356, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "inck", :ns "cljs.spec.alpha", :private true, :row 355} {:arglist-strs ["[pred x form]" "[pred x form cpred?]"], :end-row 369, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4 3}, :name "dt", :ns "cljs.spec.alpha", :private true, :row 358} {:arglist-strs ["[spec x]" "[spec x form]"], :doc "Helper function that returns true when x is valid for spec.", :end-row 378, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3 2}, :name "valid?", :ns "cljs.spec.alpha", :row 371} {:fixed-arities #{3 2}, :end-row 385, :private true, :ns "cljs.spec.alpha", :name "pvalid?", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[pred x]" "[pred x form]"], :doc "internal helper function that returns true when x is valid for spec.", :row 380} {:arglist-strs ["[form pred path via in v]"], :end-row 392, :filename "cljs/spec/alpha.cljs", :fixed-arities #{6}, :name "explain-1", :ns "cljs.spec.alpha", :private true, :row 387} {:end-row 395, :filename "cljs/spec/alpha.cljs", :name "or-k-gen", :ns "cljs.spec.alpha", :row 394} {:end-row 395, :filename "cljs/spec/alpha.cljs", :name "and-k-gen", :ns "cljs.spec.alpha", :row 394} {:fixed-arities #{1}, :end-row 404, :private true, :ns "cljs.spec.alpha", :name "k-gen", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[f]"], :doc "returns a generator for form f, which can be a keyword or a list\n  starting with 'or or 'and.", :row 397} {:fixed-arities #{1 2}, :end-row 415, :private true, :ns "cljs.spec.alpha", :name "or-k-gen", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[s]" "[min-count s]"], :doc "returns a tuple generator made up of generators for a random subset\n  of min-count (default 0) to all elements in s.", :row 406} {:fixed-arities #{1}, :end-row 421, :private true, :ns "cljs.spec.alpha", :name "and-k-gen", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[s]"], :doc "returns a tuple generator made up of generators for every element\n  in s.", :row 417} {:arglist-strs ["[{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn] :as argm}]"], :doc "Do not call this directly, use 'spec' with a map argument", :end-row 509, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "map-spec-impl", :ns "cljs.spec.alpha", :row 423} {:arglist-strs ["[form pred gfn cpred?]" "[form pred gfn cpred? unc]"], :doc "Do not call this directly, use 'spec'", :end-row 542, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4 5}, :name "spec-impl", :ns "cljs.spec.alpha", :row 511} {:arglist-strs ["[form mmvar retag]" "[form mmvar retag gfn]"], :doc "Do not call this directly, use 'multi-spec'", :end-row 592, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4 3}, :name "multi-spec-impl", :ns "cljs.spec.alpha", :row 544} {:arglist-strs ["[forms preds]" "[forms preds gfn]"], :doc "Do not call this directly, use 'tuple'", :end-row 654, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3 2}, :name "tuple-impl", :ns "cljs.spec.alpha", :row 594} {:arglist-strs ["[tag ret]"], :end-row 657, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "tagged-ret", :ns "cljs.spec.alpha", :private true, :row 656} {:arglist-strs ["[keys forms preds gfn]"], :doc "Do not call this directly, use 'or'", :end-row 724, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "or-spec-impl", :ns "cljs.spec.alpha", :row 659} {:arglist-strs ["[x preds forms]"], :end-row 736, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "and-preds", :ns "cljs.spec.alpha", :private true, :row 726} {:arglist-strs ["[forms preds path via in x]"], :end-row 747, :filename "cljs/spec/alpha.cljs", :fixed-arities #{6}, :name "explain-pred-list", :ns "cljs.spec.alpha", :private true, :row 738} {:arglist-strs ["[forms preds gfn]"], :doc "Do not call this directly, use 'and'", :end-row 791, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "and-spec-impl", :ns "cljs.spec.alpha", :row 749} {:arglist-strs ["[x kfn kform distinct count min-count max-count path via in]"], :end-row 811, :filename "cljs/spec/alpha.cljs", :fixed-arities #{10}, :name "coll-prob", :ns "cljs.spec.alpha", :private true, :row 793} {:arglist-strs ["[forms preds gfn]"], :doc "Do not call this directly, use 'merge'", :end-row 839, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "merge-spec-impl", :ns "cljs.spec.alpha", :row 813} {:end-row 841, :filename "cljs/spec/alpha.cljs", :name "empty-coll", :ns "cljs.spec.alpha", :private true, :row 841} {:arglist-strs ["[form pred opts]" "[form pred {conform-into :into describe-form ::describe :keys [kind ::kind-form count max-count min-count distinct gen-max ::kfn ::cpred conform-keys ::conform-all] :or {gen-max 20} :as opts} gfn]"], :doc "Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'", :end-row 969, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4 3}, :name "every-impl", :ns "cljs.spec.alpha", :row 843} {:arglist-strs ["[x]"], :end-row 977, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "accept", :ns "cljs.spec.alpha", :private true, :row 977} {:arglist-strs ["[{:keys [::op]}]"], :end-row 980, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "accept?", :ns "cljs.spec.alpha", :private true, :row 979} {:arglist-strs ["[{[p1 & pr :as ps] :ps [k1 & kr :as ks] :ks [f1 & fr :as forms] :forms ret :ret rep+ :rep+}]"], :end-row 990, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "pcat*", :ns "cljs.spec.alpha", :private true, :row 982} {:arglist-strs ["[& ps]"], :end-row 992, :filename "cljs/spec/alpha.cljs", :name "pcat", :ns "cljs.spec.alpha", :private true, :row 992} {:arglist-strs ["[ks ps forms]"], :doc "Do not call this directly, use 'cat'", :end-row 997, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "cat-impl", :ns "cljs.spec.alpha", :row 994} {:arglist-strs ["[p1 p2 ret splice form]"], :end-row 1004, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "rep*", :ns "cljs.spec.alpha", :private true, :row 999} {:arglist-strs ["[form p]"], :doc "Do not call this directly, use '*'", :end-row 1008, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "rep-impl", :ns "cljs.spec.alpha", :row 1006} {:arglist-strs ["[form p]"], :doc "Do not call this directly, use '+'", :end-row 1013, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "rep+impl", :ns "cljs.spec.alpha", :row 1010} {:arglist-strs ["[re re-form preds pred-forms]"], :doc "Do not call this directly, use '&'", :end-row 1018, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "amp-impl", :ns "cljs.spec.alpha", :row 1015} {:arglist-strs ["[ps ks forms f]"], :end-row 1027, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "filter-alt", :ns "cljs.spec.alpha", :private true, :row 1020} {:arglist-strs ["[ps ks forms]"], :end-row 1039, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "alt*", :ns "cljs.spec.alpha", :private true, :row 1029} {:arglist-strs ["[& ps]"], :end-row 1041, :filename "cljs/spec/alpha.cljs", :name "alts", :ns "cljs.spec.alpha", :private true, :row 1041} {:arglist-strs ["[p1 p2]"], :end-row 1042, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "alt2", :ns "cljs.spec.alpha", :private true, :row 1042} {:arglist-strs ["[ks ps forms]"], :doc "Do not call this directly, use 'alt'", :end-row 1046, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "alt-impl", :ns "cljs.spec.alpha", :row 1044} {:arglist-strs ["[p form]"], :doc "Do not call this directly, use '?'", :end-row 1050, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "maybe-impl", :ns "cljs.spec.alpha", :row 1048} {:arglist-strs ["[p1 pret]"], :end-row 1056, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "noret?", :ns "cljs.spec.alpha", :private true, :row 1052} {:end-row 1058, :filename "cljs/spec/alpha.cljs", :name "preturn", :ns "cljs.spec.alpha", :row 1058} {:arglist-strs ["[p]"], :end-row 1070, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "accept-nil?", :ns "cljs.spec.alpha", :private true, :row 1060} {:end-row 1072, :filename "cljs/spec/alpha.cljs", :name "add-ret", :ns "cljs.spec.alpha", :row 1072} {:arglist-strs ["[p]"], :end-row 1087, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "preturn", :ns "cljs.spec.alpha", :private true, :row 1074} {:arglist-strs ["[p x]"], :end-row 1108, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "op-unform", :ns "cljs.spec.alpha", :private true, :row 1089} {:arglist-strs ["[p r k]"], :end-row 1121, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "add-ret", :ns "cljs.spec.alpha", :private true, :row 1110} {:arglist-strs ["[p x]"], :end-row 1141, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "deriv", :ns "cljs.spec.alpha", :private true, :row 1123} {:arglist-strs ["[p]"], :end-row 1157, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "op-describe", :ns "cljs.spec.alpha", :private true, :row 1143} {:arglist-strs ["[form p path via in input]"], :end-row 1212, :filename "cljs/spec/alpha.cljs", :fixed-arities #{6}, :name "op-explain", :ns "cljs.spec.alpha", :private true, :row 1159} {:arglist-strs ["[p overrides path rmap f]"], :end-row 1253, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "re-gen", :ns "cljs.spec.alpha", :private true, :row 1214} {:arglist-strs ["[p [x & xs :as data]]"], :end-row 1266, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "re-conform", :ns "cljs.spec.alpha", :private true, :row 1255} {:arglist-strs ["[path via in re input]"], :end-row 1292, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "re-explain", :ns "cljs.spec.alpha", :private true, :row 1268} {:arglist-strs ["[re gfn]"], :doc "Do not call this directly, use 'spec' with a regex op argument", :end-row 1317, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "regex-spec-impl", :ns "cljs.spec.alpha", :row 1294} {:arglist-strs ["[f specs args]"], :end-row 1330, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "call-valid?", :ns "cljs.spec.alpha", :private true, :row 1321} {:fixed-arities #{3}, :end-row 1340, :private true, :ns "cljs.spec.alpha", :name "validate-fn", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[f specs iters]"], :doc "returns f if valid, else smallest", :row 1332} {:arglist-strs ["[argspec aform retspec rform fnspec fform gfn]"], :doc "Do not call this directly, use 'fspec'", :end-row 1384, :filename "cljs/spec/alpha.cljs", :fixed-arities #{7}, :name "fspec-impl", :ns "cljs.spec.alpha", :row 1342} {:arglist-strs ["[spec]"], :doc "takes a spec and returns a spec that has the same properties except\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.", :end-row 1408, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "nonconforming", :ns "cljs.spec.alpha", :row 1389} {:arglist-strs ["[form pred gfn]"], :doc "Do not call this directly, use 'nilable'", :end-row 1434, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "nilable-impl", :ns "cljs.spec.alpha", :row 1410} {:arglist-strs ["[spec]" "[spec n]" "[spec n overrides]"], :doc "generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen", :end-row 1443, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1 3 2}, :name "exercise", :ns "cljs.spec.alpha", :row 1436} {:arglist-strs ["[start end inst]"], :doc "Return true if inst at or after start and before end", :end-row 1450, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "inst-in-range?", :ns "cljs.spec.alpha", :row 1445} {:arglist-strs ["[start end val]"], :doc "Return true if start <= val, val < end and val is a fixed\n  precision integer.", :end-row 1467, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "int-in-range?", :ns "cljs.spec.alpha", :row 1452} {:doc "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true.", :end-row 1478, :filename "cljs/spec/alpha.cljs", :name "*compile-asserts*", :ns "cljs.spec.alpha", :row 1470} {:end-row 1483, :filename "cljs/spec/alpha.cljs", :name "*runtime-asserts*", :ns "cljs.spec.alpha", :private true, :row 1480} {:arglist-strs ["[]"], :doc "Returns the value set by check-asserts.", :end-row 1488, :filename "cljs/spec/alpha.cljs", :fixed-arities #{0}, :name "check-asserts?", :ns "cljs.spec.alpha", :row 1485} {:arglist-strs ["[flag]"], :doc "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\nDefaults to false.", :end-row 1496, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "check-asserts", :ns "cljs.spec.alpha", :row 1490} {:arglist-strs ["[spec x]"], :doc "Do not call this directly, use 'assert'.", :end-row 1506, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "assert*", :ns "cljs.spec.alpha", :row 1498}]} {:end-row 12, :filename "cljs/spec/gen/alpha.cljc", :lang :clj, :name "cljs.spec.gen.alpha", :row 9, :ns nil, :var-definitions [{:fixed-arities #{1}, :end-row 23, :ns "cljs.spec.gen.alpha", :name "dynaload", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[[quote s]]"], :row 14} {:end-row 30, :ns "cljs.spec.gen.alpha", :name "delay", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& body]"], :doc "given body that returns a generator, returns a\n  generator that delegates to that, but delays\n  creation until used.", :row 25} {:fixed-arities #{1}, :end-row 41, :ns "cljs.spec.gen.alpha", :name "lazy-combinator", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[s]"], :doc "Implementation macro, do not call directly.", :row 32} {:end-row 49, :ns "cljs.spec.gen.alpha", :name "lazy-combinators", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& syms]"], :doc "Implementation macro, do not call directly.", :row 43} {:fixed-arities #{1}, :end-row 60, :ns "cljs.spec.gen.alpha", :name "lazy-prim", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[s]"], :doc "Implementation macro, do not call directly.", :row 51} {:end-row 68, :ns "cljs.spec.gen.alpha", :name "lazy-prims", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& syms]"], :doc "Implementation macro, do not call directly.", :row 62} {:fixed-arities #{1}, :end-row 23, :ns "cljs.spec.gen.alpha", :name "dynaload", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[[quote s]]"], :row 14} {:end-row 30, :ns "cljs.spec.gen.alpha", :name "delay", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& body]"], :doc "given body that returns a generator, returns a\n  generator that delegates to that, but delays\n  creation until used.", :row 25} {:fixed-arities #{1}, :end-row 41, :ns "cljs.spec.gen.alpha", :name "lazy-combinator", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[s]"], :doc "Implementation macro, do not call directly.", :row 32} {:end-row 49, :ns "cljs.spec.gen.alpha", :name "lazy-combinators", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& syms]"], :doc "Implementation macro, do not call directly.", :row 43} {:fixed-arities #{1}, :end-row 60, :ns "cljs.spec.gen.alpha", :name "lazy-prim", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[s]"], :doc "Implementation macro, do not call directly.", :row 51} {:end-row 68, :ns "cljs.spec.gen.alpha", :name "lazy-prims", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& syms]"], :doc "Implementation macro, do not call directly.", :row 62} {:end-row 25, :filename "cljs/spec/gen/alpha.cljs", :name "LazyVar", :ns "cljs.spec.gen.alpha", :row 17} {:arglist-strs ["[f cached]"], :end-row 25, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{2}, :name "->LazyVar", :ns "cljs.spec.gen.alpha", :row 17} {:end-row 28, :filename "cljs/spec/gen/alpha.cljs", :name "quick-check-ref", :ns "cljs.spec.gen.alpha", :private true, :row 27} {:arglist-strs ["[& args]"], :end-row 32, :filename "cljs/spec/gen/alpha.cljs", :name "quick-check", :ns "cljs.spec.gen.alpha", :row 30} {:end-row 35, :filename "cljs/spec/gen/alpha.cljs", :name "for-all*-ref", :ns "cljs.spec.gen.alpha", :private true, :row 34} {:arglist-strs ["[& args]"], :doc "Dynamically loaded clojure.test.check.properties/for-all*.", :end-row 40, :filename "cljs/spec/gen/alpha.cljs", :name "for-all*", :ns "cljs.spec.gen.alpha", :row 37} {:arglist-strs ["[x]"], :end-row 47, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "generator?", :ns "cljs.spec.gen.alpha", :private true, :row 45} {:arglist-strs ["[gfn]"], :end-row 50, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "generator", :ns "cljs.spec.gen.alpha", :private true, :row 48} {:arglist-strs ["[generator]"], :doc "Generate a single value using generator.", :end-row 54, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "generate", :ns "cljs.spec.gen.alpha", :row 51} {:arglist-strs ["[gfnd]"], :end-row 60, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "delay-impl", :ns "cljs.spec.gen.alpha", :row 56} {:arglist-strs ["[& gens]"], :doc "Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential.", :end-row 83, :filename "cljs/spec/gen/alpha.cljs", :name "cat", :ns "cljs.spec.gen.alpha", :row 78} {:arglist-strs ["[ident]"], :end-row 85, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "qualified?", :ns "cljs.spec.gen.alpha", :private true, :row 85} {:end-row 142, :filename "cljs/spec/gen/alpha.cljs", :name "gen-builtins", :ns "cljs.spec.gen.alpha", :private true, :row 87} {:arglist-strs ["[pred]"], :doc "Given a predicate, returns a built-in generator if one exists.", :end-row 149, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "gen-for-pred", :ns "cljs.spec.gen.alpha", :row 144}]} {:end-row 12, :filename "cljs/spec/gen/alpha.cljc", :lang :cljs, :name "cljs.spec.gen.alpha", :row 9, :ns nil, :var-definitions [{:fixed-arities #{1}, :end-row 23, :ns "cljs.spec.gen.alpha", :name "dynaload", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[[quote s]]"], :row 14} {:end-row 30, :ns "cljs.spec.gen.alpha", :name "delay", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& body]"], :doc "given body that returns a generator, returns a\n  generator that delegates to that, but delays\n  creation until used.", :row 25} {:fixed-arities #{1}, :end-row 41, :ns "cljs.spec.gen.alpha", :name "lazy-combinator", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[s]"], :doc "Implementation macro, do not call directly.", :row 32} {:end-row 49, :ns "cljs.spec.gen.alpha", :name "lazy-combinators", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& syms]"], :doc "Implementation macro, do not call directly.", :row 43} {:fixed-arities #{1}, :end-row 60, :ns "cljs.spec.gen.alpha", :name "lazy-prim", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[s]"], :doc "Implementation macro, do not call directly.", :row 51} {:end-row 68, :ns "cljs.spec.gen.alpha", :name "lazy-prims", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& syms]"], :doc "Implementation macro, do not call directly.", :row 62} {:fixed-arities #{1}, :end-row 23, :ns "cljs.spec.gen.alpha", :name "dynaload", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[[quote s]]"], :row 14} {:end-row 30, :ns "cljs.spec.gen.alpha", :name "delay", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& body]"], :doc "given body that returns a generator, returns a\n  generator that delegates to that, but delays\n  creation until used.", :row 25} {:fixed-arities #{1}, :end-row 41, :ns "cljs.spec.gen.alpha", :name "lazy-combinator", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[s]"], :doc "Implementation macro, do not call directly.", :row 32} {:end-row 49, :ns "cljs.spec.gen.alpha", :name "lazy-combinators", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& syms]"], :doc "Implementation macro, do not call directly.", :row 43} {:fixed-arities #{1}, :end-row 60, :ns "cljs.spec.gen.alpha", :name "lazy-prim", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[s]"], :doc "Implementation macro, do not call directly.", :row 51} {:end-row 68, :ns "cljs.spec.gen.alpha", :name "lazy-prims", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& syms]"], :doc "Implementation macro, do not call directly.", :row 62} {:end-row 25, :filename "cljs/spec/gen/alpha.cljs", :name "LazyVar", :ns "cljs.spec.gen.alpha", :row 17} {:arglist-strs ["[f cached]"], :end-row 25, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{2}, :name "->LazyVar", :ns "cljs.spec.gen.alpha", :row 17} {:end-row 28, :filename "cljs/spec/gen/alpha.cljs", :name "quick-check-ref", :ns "cljs.spec.gen.alpha", :private true, :row 27} {:arglist-strs ["[& args]"], :end-row 32, :filename "cljs/spec/gen/alpha.cljs", :name "quick-check", :ns "cljs.spec.gen.alpha", :row 30} {:end-row 35, :filename "cljs/spec/gen/alpha.cljs", :name "for-all*-ref", :ns "cljs.spec.gen.alpha", :private true, :row 34} {:arglist-strs ["[& args]"], :doc "Dynamically loaded clojure.test.check.properties/for-all*.", :end-row 40, :filename "cljs/spec/gen/alpha.cljs", :name "for-all*", :ns "cljs.spec.gen.alpha", :row 37} {:arglist-strs ["[x]"], :end-row 47, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "generator?", :ns "cljs.spec.gen.alpha", :private true, :row 45} {:arglist-strs ["[gfn]"], :end-row 50, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "generator", :ns "cljs.spec.gen.alpha", :private true, :row 48} {:arglist-strs ["[generator]"], :doc "Generate a single value using generator.", :end-row 54, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "generate", :ns "cljs.spec.gen.alpha", :row 51} {:arglist-strs ["[gfnd]"], :end-row 60, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "delay-impl", :ns "cljs.spec.gen.alpha", :row 56} {:arglist-strs ["[& gens]"], :doc "Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential.", :end-row 83, :filename "cljs/spec/gen/alpha.cljs", :name "cat", :ns "cljs.spec.gen.alpha", :row 78} {:arglist-strs ["[ident]"], :end-row 85, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "qualified?", :ns "cljs.spec.gen.alpha", :private true, :row 85} {:end-row 142, :filename "cljs/spec/gen/alpha.cljs", :name "gen-builtins", :ns "cljs.spec.gen.alpha", :private true, :row 87} {:arglist-strs ["[pred]"], :doc "Given a predicate, returns a built-in generator if one exists.", :end-row 149, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "gen-for-pred", :ns "cljs.spec.gen.alpha", :row 144}]} {:end-row 15, :filename "cljs/spec/gen/alpha.cljs", :name "cljs.spec.gen.alpha", :row 9, :ns nil, :var-definitions [{:fixed-arities #{1}, :end-row 23, :ns "cljs.spec.gen.alpha", :name "dynaload", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[[quote s]]"], :row 14} {:end-row 30, :ns "cljs.spec.gen.alpha", :name "delay", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& body]"], :doc "given body that returns a generator, returns a\n  generator that delegates to that, but delays\n  creation until used.", :row 25} {:fixed-arities #{1}, :end-row 41, :ns "cljs.spec.gen.alpha", :name "lazy-combinator", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[s]"], :doc "Implementation macro, do not call directly.", :row 32} {:end-row 49, :ns "cljs.spec.gen.alpha", :name "lazy-combinators", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& syms]"], :doc "Implementation macro, do not call directly.", :row 43} {:fixed-arities #{1}, :end-row 60, :ns "cljs.spec.gen.alpha", :name "lazy-prim", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[s]"], :doc "Implementation macro, do not call directly.", :row 51} {:end-row 68, :ns "cljs.spec.gen.alpha", :name "lazy-prims", :lang :clj, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& syms]"], :doc "Implementation macro, do not call directly.", :row 62} {:fixed-arities #{1}, :end-row 23, :ns "cljs.spec.gen.alpha", :name "dynaload", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[[quote s]]"], :row 14} {:end-row 30, :ns "cljs.spec.gen.alpha", :name "delay", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& body]"], :doc "given body that returns a generator, returns a\n  generator that delegates to that, but delays\n  creation until used.", :row 25} {:fixed-arities #{1}, :end-row 41, :ns "cljs.spec.gen.alpha", :name "lazy-combinator", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[s]"], :doc "Implementation macro, do not call directly.", :row 32} {:end-row 49, :ns "cljs.spec.gen.alpha", :name "lazy-combinators", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& syms]"], :doc "Implementation macro, do not call directly.", :row 43} {:fixed-arities #{1}, :end-row 60, :ns "cljs.spec.gen.alpha", :name "lazy-prim", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[s]"], :doc "Implementation macro, do not call directly.", :row 51} {:end-row 68, :ns "cljs.spec.gen.alpha", :name "lazy-prims", :lang :cljs, :filename "cljs/spec/gen/alpha.cljc", :macro true, :arglist-strs ["[& syms]"], :doc "Implementation macro, do not call directly.", :row 62} {:end-row 25, :filename "cljs/spec/gen/alpha.cljs", :name "LazyVar", :ns "cljs.spec.gen.alpha", :row 17} {:arglist-strs ["[f cached]"], :end-row 25, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{2}, :name "->LazyVar", :ns "cljs.spec.gen.alpha", :row 17} {:end-row 28, :filename "cljs/spec/gen/alpha.cljs", :name "quick-check-ref", :ns "cljs.spec.gen.alpha", :private true, :row 27} {:arglist-strs ["[& args]"], :end-row 32, :filename "cljs/spec/gen/alpha.cljs", :name "quick-check", :ns "cljs.spec.gen.alpha", :row 30} {:end-row 35, :filename "cljs/spec/gen/alpha.cljs", :name "for-all*-ref", :ns "cljs.spec.gen.alpha", :private true, :row 34} {:arglist-strs ["[& args]"], :doc "Dynamically loaded clojure.test.check.properties/for-all*.", :end-row 40, :filename "cljs/spec/gen/alpha.cljs", :name "for-all*", :ns "cljs.spec.gen.alpha", :row 37} {:arglist-strs ["[x]"], :end-row 47, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "generator?", :ns "cljs.spec.gen.alpha", :private true, :row 45} {:arglist-strs ["[gfn]"], :end-row 50, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "generator", :ns "cljs.spec.gen.alpha", :private true, :row 48} {:arglist-strs ["[generator]"], :doc "Generate a single value using generator.", :end-row 54, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "generate", :ns "cljs.spec.gen.alpha", :row 51} {:arglist-strs ["[gfnd]"], :end-row 60, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "delay-impl", :ns "cljs.spec.gen.alpha", :row 56} {:arglist-strs ["[& gens]"], :doc "Returns a generator of a sequence catenated from results of\ngens, each of which should generate something sequential.", :end-row 83, :filename "cljs/spec/gen/alpha.cljs", :name "cat", :ns "cljs.spec.gen.alpha", :row 78} {:arglist-strs ["[ident]"], :end-row 85, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "qualified?", :ns "cljs.spec.gen.alpha", :private true, :row 85} {:end-row 142, :filename "cljs/spec/gen/alpha.cljs", :name "gen-builtins", :ns "cljs.spec.gen.alpha", :private true, :row 87} {:arglist-strs ["[pred]"], :doc "Given a predicate, returns a built-in generator if one exists.", :end-row 149, :filename "cljs/spec/gen/alpha.cljs", :fixed-arities #{1}, :name "gen-for-pred", :ns "cljs.spec.gen.alpha", :row 144}]} {:end-row 17, :filename "cljs/spec/alpha.cljs", :name "cljs.spec.alpha", :row 9, :ns nil, :var-definitions [{:end-row 19, :filename "cljs/spec/alpha.cljc", :lang :clj, :name "registry-ref", :ns "cljs.spec.alpha", :row 19} {:fixed-arities #{1}, :end-row 26, :private true, :ns "cljs.spec.alpha", :name "->sym", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[x]"], :doc "Returns a symbol from a symbol or var", :row 21} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.spec.alpha", :name "unfn", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[expr]"], :row 28} {:fixed-arities #{2}, :end-row 48, :private true, :ns "cljs.spec.alpha", :name "res", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env form]"], :row 36} {:fixed-arities #{1}, :end-row 53, :private true, :ns "cljs.spec.alpha", :name "mres", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[form]"], :doc "a compile time res, for use in cljs/spec/alpha.cljs", :row 50} {:fixed-arities #{2}, :end-row 61, :private true, :ns "cljs.spec.alpha", :name "ns-qualify", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env s]"], :doc "Qualify symbol s by resolving it or using the current *ns*.", :row 55} {:end-row 63, :filename "cljs/spec/alpha.cljc", :lang :clj, :name "_speced_vars", :ns "cljs.spec.alpha", :private true, :row 63} {:arglist-strs ["[]"], :end-row 66, :filename "cljs/spec/alpha.cljc", :fixed-arities #{0}, :lang :clj, :name "speced-vars", :ns "cljs.spec.alpha", :row 65} {:fixed-arities #{2}, :end-row 85, :ns "cljs.spec.alpha", :name "def", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[k spec-form]"], :doc "Given a namespace-qualified keyword or resolveable symbol k, and a\n  spec, spec-name, predicate or regex-op makes an entry in the\n  registry mapping k to the spec. Use nil to remove an entry in\n  the registry for k.", :row 68} {:end-row 104, :ns "cljs.spec.alpha", :name "spec", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[form & {:keys [gen]}]"], :doc "Takes a single predicate form, e.g. can be the name of a predicate,\n  like even?, or a fn literal like #(< % 42). Note that it is not\n  generally necessary to wrap predicates in spec when using the rest\n  of the spec macros, only to attach a unique generator\n\n  Can also be passed the result of one of the regex ops -\n  cat, alt, *, +, ?, in which case it will return a regex-conforming\n  spec, useful when nesting an independent regex.\n  ---\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\n\n  Returns a spec.", :row 87} {:fixed-arities #{2}, :end-row 133, :ns "cljs.spec.alpha", :name "multi-spec", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[mm retag]"], :doc "Takes the name of a spec/predicate-returning multimethod and a\n  tag-restoring keyword or fn (retag).  Returns a spec that when\n  conforming or explaining data will pass it to the multimethod to get\n  an appropriate spec. You can e.g. use multi-spec to dynamically and\n  extensibly associate specs with 'tagged' data (i.e. data where one\n  of the fields indicates the shape of the rest of the structure).\n\n  (defmulti mspec :tag)\n\n  The methods should ignore their argument and return a predicate/spec:\n  (defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\n  retag is used during generation to retag generated values with\n  matching tags. retag can either be a keyword, at which key the\n  dispatch-tag will be assoc'ed, or a fn of generated value and\n  dispatch-tag that should return an appropriately retagged value.\n\n  Note that because the tags themselves comprise an open set,\n  the tag key spec cannot enumerate the values, but can e.g.\n  test for keyword?.\n\n  Note also that the dispatch values of the multimethod will be\n  included in the path, i.e. in reporting and gen overrides, even\n  though those values are not evident in the spec.\n", :row 106} {:end-row 195, :ns "cljs.spec.alpha", :name "keys", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [req req-un opt opt-un gen]}]"], :doc "Creates and returns a map validating spec. :req and :opt are both\n  vectors of namespaced-qualified keywords. The validator will ensure\n  the :req keys are present. The :opt keys serve as documentation and\n  may be used by the generator.\n\n  The :req key vector supports 'and' and 'or' for key groups:\n\n  (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\n  There are also -un versions of :req and :opt. These allow\n  you to connect unqualified keys to specs.  In each case, fully\n  qualfied keywords are passed, which name the specs, but unqualified\n  keys (with the same name component) are expected and checked at\n  conform-time, and generated during gen:\n\n  (s/keys :req-un [:my.ns/x :my.ns/y])\n\n  The above says keys :x and :y are required, and will be validated\n  and generated by specs (if they exist) named :my.ns/x :my.ns/y\n  respectively.\n\n  In addition, the values of *all* namespace-qualified keys will be validated\n  (and possibly destructured) by any registered specs. Note: there is\n  no support for inline value specification, by design.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.", :row 135} {:end-row 212, :ns "cljs.spec.alpha", :name "or", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/or :even even? :small #(< % 42))\n\n  Returns a destructuring spec that returns a map entry containing the\n  key of the first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :row 197} {:end-row 222, :ns "cljs.spec.alpha", :name "and", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& pred-forms]"], :doc "Takes predicate/spec-forms, e.g.\n\n  (s/and even? #(< % 42))\n\n  Returns a spec that returns the conformed value. Successive\n  conformed values propagate through rest of predicates.", :row 214} {:fixed-arities #{2}, :end-row 231, :private true, :ns "cljs.spec.alpha", :name "res-kind", :lang :clj, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env opts]"], :row 224} {:end-row 279, :ns "cljs.spec.alpha", :name "every", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred & {:keys [into kind count max-count min-count distinct gen-max gen-into gen] :as opts}]"], :doc "takes a pred and validates collection elements against that pred.\n\n  Note that 'every' does not do exhaustive checking, rather it samples\n  *coll-check-limit* elements. Nor (as a result) does it do any\n  conforming of elements. 'explain' will report at most *coll-error-limit*\n  problems.  Thus 'every' should be suitable for potentially large\n  collections.\n\n  Takes several kwargs options that further constrain the collection:\n\n  :kind - a pred that the collection type must satisfy, e.g. vector?\n          (default nil) Note that if :kind is specified and :into is\n          not, this pred must generate in order for every to generate.\n  :count - specifies coll has exactly this count (default nil)\n  :min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n  :distinct - all the elements are distinct (default nil)\n\n  And additional args that control gen\n\n  :gen-max - the maximum coll size to generate (default 20)\n  :into - one of [], (), {}, #{} - the default collection to generate into\n      (default same as :kind if supplied, else []\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator\n\n  See also - coll-of, every-kv\n", :row 233} {:end-row 290, :ns "cljs.spec.alpha", :name "every-kv", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[kpred vpred & opts]"], :doc "like 'every' but takes separate key and val preds and works on associative collections.\n\n  Same options as 'every', :into defaults to {}\n\n  See also - map-of", :row 281} {:end-row 305, :ns "cljs.spec.alpha", :name "coll-of", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred & opts]"], :doc "Returns a spec for a collection of items satisfying pred. Unlike\n  generator will fill an empty init-coll.\n\n  Same options as 'every'. conform will produce a collection\n  corresponding to :into if supplied, else will match the input collection,\n  avoiding rebuilding when possible.\n\n  Same options as 'every'.\n\n  See also - every, map-of", :row 292} {:end-row 319, :ns "cljs.spec.alpha", :name "map-of", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[kpred vpred & opts]"], :doc "Returns a spec for a map whose keys satisfy kpred and vals satisfy\n  vpred. Unlike 'every-kv', map-of will exhaustively conform every\n  value.\n\n  Same options as 'every', :kind defaults to map?, with the addition of:\n\n  :conform-keys - conform keys as well as values (default false)\n\n  See also - every-kv", :row 307} {:fixed-arities #{1}, :end-row 325, :ns "cljs.spec.alpha", :name "*", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches zero or more values matching\n  pred. Produces a vector of matches iff there is at least one match", :row 321} {:fixed-arities #{1}, :end-row 331, :ns "cljs.spec.alpha", :name "+", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches one or more values matching\n  pred. Produces a vector of matches", :row 327} {:fixed-arities #{1}, :end-row 337, :ns "cljs.spec.alpha", :name "?", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches zero or one value matching\n  pred. Produces a single value (not a collection) if matched.", :row 333} {:end-row 354, :ns "cljs.spec.alpha", :name "alt", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/alt :even even? :small #(< % 42))\n\n  Returns a regex op that returns a map entry containing the key of the\n  first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :row 339} {:end-row 370, :ns "cljs.spec.alpha", :name "cat", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/cat :e even? :o odd?)\n\n  Returns a regex op that matches (all) values in sequence, returning a map\n  containing the keys of each pred and the corresponding value.", :row 356} {:end-row 378, :ns "cljs.spec.alpha", :name "&", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[re & preds]"], :doc "takes a regex op re, and predicates. Returns a regex-op that consumes\n  input as per re but subjects the resulting value to the\n  conjunction of the predicates, and any conforming they might perform.", :row 372} {:fixed-arities #{1 2}, :end-row 386, :ns "cljs.spec.alpha", :name "conformer", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[f]" "[f unf]"], :doc "takes a predicate function with the semantics of conform i.e. it should return either a\n  (possibly converted) value or :cljs.spec.alpha/invalid, and returns a\n  spec that uses it as a predicate/conformer. Optionally takes a\n  second fn that does unform of result of first", :row 380} {:end-row 406, :ns "cljs.spec.alpha", :name "fspec", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [args ret fn gen] :or {ret `cljs.core/any?}}]"], :doc "takes :args :ret and (optional) :fn kwargs whose values are preds\n  and returns a spec whose conform/explain take a fn and validates it\n  using generative testing. The conformed value is always the fn itself.\n\n  See 'fdef' for a single operation that creates an fspec and\n  registers it, as well as a full description of :args, :ret and :fn\n\n  fspecs can generate functions that validate the arguments and\n  fabricate a return value compliant with the :ret spec, ignoring\n  the :fn spec if present.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args\n  that returns a test.check generator.", :row 388} {:end-row 414, :ns "cljs.spec.alpha", :name "tuple", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& preds]"], :doc "takes one or more preds and returns a spec for a tuple, a vector\n  where each element conforms to the corresponding pred. Each element\n  will be referred to in paths using its ordinal.", :row 408} {:end-row 449, :ns "cljs.spec.alpha", :name "fdef", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[fn-sym & specs]"], :doc "Takes a symbol naming a function, and one or more of the following:\n\n  :args A regex spec for the function arguments as they were a list to be\n    passed to apply - in this way, a single spec can handle functions with\n    multiple arities\n  :ret A spec for the function's return value\n  :fn A spec of the relationship between args and ret - the\n    value passed is {:args conformed-args :ret conformed-ret} and is\n    expected to contain predicates that relate those values\n\n  Qualifies fn-sym with resolve, or using *ns* if no resolution found.\n  Registers an fspec in the global registry, where it can be retrieved\n  by calling get-spec with the var or fully-qualified symbol.\n\n  Once registered, function specs are included in doc, checked by\n  instrument, tested by the runner cljs.spec.test.alpha/check, and (if\n  a macro) used to explain errors during macroexpansion.\n\n  Note that :fn specs require the presence of :args and :ret specs to\n  conform values, and so :fn specs will be ignored if :args or :ret\n  are missing.\n\n  Returns the qualified fn-sym.\n\n  For example, to register function specs for the symbol function:\n\n  (s/fdef cljs.core/symbol\n    :args (s/alt :separate (s/cat :ns string? :n string?)\n                 :str string?\n                 :sym symbol?)\n    :ret symbol?)", :row 416} {:end-row 468, :ns "cljs.spec.alpha", :name "keys*", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& kspecs]"], :doc "takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\n  converts them into a map, and conforms that map with a corresponding\n  spec/keys call:\n\n  user=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n  {:a 1, :c 2}\n  user=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n  {:a 1, :c 2}\n\n  the resulting regex op can be composed into a larger regex:\n\n  user=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n  {:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}", :row 451} {:fixed-arities #{1}, :end-row 474, :ns "cljs.spec.alpha", :name "nilable", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred]"], :doc "returns a spec that accepts nil and values satisfiying pred", :row 470} {:fixed-arities #{2}, :end-row 486, :ns "cljs.spec.alpha", :name "inst-in", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[start end]"], :doc "Returns a spec that validates insts in the range from start\n  (inclusive) to end (exclusive).", :row 476} {:fixed-arities #{2}, :end-row 493, :ns "cljs.spec.alpha", :name "int-in", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[start end]"], :doc "Returns a spec that validates fixed precision integers in the\n  range from start (inclusive) to end (exclusive).", :row 488} {:end-row 510, :ns "cljs.spec.alpha", :name "double-in", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [infinite? NaN? min max] :or {infinite? true NaN? true} :as m}]"], :doc "Specs a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity allowed (default true)\n    :NaN?      - whether NaN allowed (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)", :row 495} {:end-row 519, :ns "cljs.spec.alpha", :name "merge", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& pred-forms]"], :doc "Takes map-validating specs (e.g. 'keys' specs) and\n  returns a spec that returns a conformed map satisfying all of the\n  specs.  Successive conformed values propagate through rest of\n  predicates. Unlike 'and', merge can generate maps satisfying the\n  union of the predicates.", :row 512} {:fixed-arities #{1 3 2}, :end-row 542, :ns "cljs.spec.alpha", :name "exercise-fn", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[sym]" "[sym n]" "[sym n fspec]"], :doc "exercises the fn named by sym (a symbol) by applying it to\n  n (default 10) generated samples of its args spec. When fspec is\n  supplied its arg spec is used, and sym-or-f can be a fn.  Returns a\n  sequence of tuples of [args ret]. ", :row 521} {:fixed-arities #{0}, :end-row 546, :private true, :ns "cljs.spec.alpha", :name "init-compile-asserts", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[]"], :row 544} {:fixed-arities #{2}, :end-row 564, :ns "cljs.spec.alpha", :name "assert", :lang :clj, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[spec x]"], :doc "spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an error with explain-data plus ::failure of\n:assertion-failed.\nCan be disabled at either compile time or runtime:\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto the negation value of the ':elide-asserts' compiler option, or true if\nnot set.\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'cljs.spec.alpha/*runtime-asserts*', or false if not set. You can\ntoggle check-asserts? with (check-asserts bool).", :row 548} {:end-row 19, :filename "cljs/spec/alpha.cljc", :lang :cljs, :name "registry-ref", :ns "cljs.spec.alpha", :row 19} {:fixed-arities #{1}, :end-row 26, :private true, :ns "cljs.spec.alpha", :name "->sym", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[x]"], :doc "Returns a symbol from a symbol or var", :row 21} {:fixed-arities #{1}, :end-row 34, :private true, :ns "cljs.spec.alpha", :name "unfn", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[expr]"], :row 28} {:fixed-arities #{2}, :end-row 48, :private true, :ns "cljs.spec.alpha", :name "res", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env form]"], :row 36} {:fixed-arities #{1}, :end-row 53, :private true, :ns "cljs.spec.alpha", :name "mres", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[form]"], :doc "a compile time res, for use in cljs/spec/alpha.cljs", :row 50} {:fixed-arities #{2}, :end-row 61, :private true, :ns "cljs.spec.alpha", :name "ns-qualify", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env s]"], :doc "Qualify symbol s by resolving it or using the current *ns*.", :row 55} {:end-row 63, :filename "cljs/spec/alpha.cljc", :lang :cljs, :name "_speced_vars", :ns "cljs.spec.alpha", :private true, :row 63} {:arglist-strs ["[]"], :end-row 66, :filename "cljs/spec/alpha.cljc", :fixed-arities #{0}, :lang :cljs, :name "speced-vars", :ns "cljs.spec.alpha", :row 65} {:fixed-arities #{2}, :end-row 85, :ns "cljs.spec.alpha", :name "def", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[k spec-form]"], :doc "Given a namespace-qualified keyword or resolveable symbol k, and a\n  spec, spec-name, predicate or regex-op makes an entry in the\n  registry mapping k to the spec. Use nil to remove an entry in\n  the registry for k.", :row 68} {:end-row 104, :ns "cljs.spec.alpha", :name "spec", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[form & {:keys [gen]}]"], :doc "Takes a single predicate form, e.g. can be the name of a predicate,\n  like even?, or a fn literal like #(< % 42). Note that it is not\n  generally necessary to wrap predicates in spec when using the rest\n  of the spec macros, only to attach a unique generator\n\n  Can also be passed the result of one of the regex ops -\n  cat, alt, *, +, ?, in which case it will return a regex-conforming\n  spec, useful when nesting an independent regex.\n  ---\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.\n\n  Returns a spec.", :row 87} {:fixed-arities #{2}, :end-row 133, :ns "cljs.spec.alpha", :name "multi-spec", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[mm retag]"], :doc "Takes the name of a spec/predicate-returning multimethod and a\n  tag-restoring keyword or fn (retag).  Returns a spec that when\n  conforming or explaining data will pass it to the multimethod to get\n  an appropriate spec. You can e.g. use multi-spec to dynamically and\n  extensibly associate specs with 'tagged' data (i.e. data where one\n  of the fields indicates the shape of the rest of the structure).\n\n  (defmulti mspec :tag)\n\n  The methods should ignore their argument and return a predicate/spec:\n  (defmethod mspec :int [_] (s/keys :req-un [::tag ::i]))\n\n  retag is used during generation to retag generated values with\n  matching tags. retag can either be a keyword, at which key the\n  dispatch-tag will be assoc'ed, or a fn of generated value and\n  dispatch-tag that should return an appropriately retagged value.\n\n  Note that because the tags themselves comprise an open set,\n  the tag key spec cannot enumerate the values, but can e.g.\n  test for keyword?.\n\n  Note also that the dispatch values of the multimethod will be\n  included in the path, i.e. in reporting and gen overrides, even\n  though those values are not evident in the spec.\n", :row 106} {:end-row 195, :ns "cljs.spec.alpha", :name "keys", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [req req-un opt opt-un gen]}]"], :doc "Creates and returns a map validating spec. :req and :opt are both\n  vectors of namespaced-qualified keywords. The validator will ensure\n  the :req keys are present. The :opt keys serve as documentation and\n  may be used by the generator.\n\n  The :req key vector supports 'and' and 'or' for key groups:\n\n  (s/keys :req [::x ::y (or ::secret (and ::user ::pwd))] :opt [::z])\n\n  There are also -un versions of :req and :opt. These allow\n  you to connect unqualified keys to specs.  In each case, fully\n  qualfied keywords are passed, which name the specs, but unqualified\n  keys (with the same name component) are expected and checked at\n  conform-time, and generated during gen:\n\n  (s/keys :req-un [:my.ns/x :my.ns/y])\n\n  The above says keys :x and :y are required, and will be validated\n  and generated by specs (if they exist) named :my.ns/x :my.ns/y\n  respectively.\n\n  In addition, the values of *all* namespace-qualified keys will be validated\n  (and possibly destructured) by any registered specs. Note: there is\n  no support for inline value specification, by design.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator.", :row 135} {:end-row 212, :ns "cljs.spec.alpha", :name "or", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/or :even even? :small #(< % 42))\n\n  Returns a destructuring spec that returns a map entry containing the\n  key of the first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :row 197} {:end-row 222, :ns "cljs.spec.alpha", :name "and", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& pred-forms]"], :doc "Takes predicate/spec-forms, e.g.\n\n  (s/and even? #(< % 42))\n\n  Returns a spec that returns the conformed value. Successive\n  conformed values propagate through rest of predicates.", :row 214} {:fixed-arities #{2}, :end-row 231, :private true, :ns "cljs.spec.alpha", :name "res-kind", :lang :cljs, :filename "cljs/spec/alpha.cljc", :arglist-strs ["[env opts]"], :row 224} {:end-row 279, :ns "cljs.spec.alpha", :name "every", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred & {:keys [into kind count max-count min-count distinct gen-max gen-into gen] :as opts}]"], :doc "takes a pred and validates collection elements against that pred.\n\n  Note that 'every' does not do exhaustive checking, rather it samples\n  *coll-check-limit* elements. Nor (as a result) does it do any\n  conforming of elements. 'explain' will report at most *coll-error-limit*\n  problems.  Thus 'every' should be suitable for potentially large\n  collections.\n\n  Takes several kwargs options that further constrain the collection:\n\n  :kind - a pred that the collection type must satisfy, e.g. vector?\n          (default nil) Note that if :kind is specified and :into is\n          not, this pred must generate in order for every to generate.\n  :count - specifies coll has exactly this count (default nil)\n  :min-count, :max-count - coll has count (<= min-count count max-count) (defaults nil)\n  :distinct - all the elements are distinct (default nil)\n\n  And additional args that control gen\n\n  :gen-max - the maximum coll size to generate (default 20)\n  :into - one of [], (), {}, #{} - the default collection to generate into\n      (default same as :kind if supplied, else []\n\n  Optionally takes :gen generator-fn, which must be a fn of no args that\n  returns a test.check generator\n\n  See also - coll-of, every-kv\n", :row 233} {:end-row 290, :ns "cljs.spec.alpha", :name "every-kv", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[kpred vpred & opts]"], :doc "like 'every' but takes separate key and val preds and works on associative collections.\n\n  Same options as 'every', :into defaults to {}\n\n  See also - map-of", :row 281} {:end-row 305, :ns "cljs.spec.alpha", :name "coll-of", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred & opts]"], :doc "Returns a spec for a collection of items satisfying pred. Unlike\n  generator will fill an empty init-coll.\n\n  Same options as 'every'. conform will produce a collection\n  corresponding to :into if supplied, else will match the input collection,\n  avoiding rebuilding when possible.\n\n  Same options as 'every'.\n\n  See also - every, map-of", :row 292} {:end-row 319, :ns "cljs.spec.alpha", :name "map-of", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[kpred vpred & opts]"], :doc "Returns a spec for a map whose keys satisfy kpred and vals satisfy\n  vpred. Unlike 'every-kv', map-of will exhaustively conform every\n  value.\n\n  Same options as 'every', :kind defaults to map?, with the addition of:\n\n  :conform-keys - conform keys as well as values (default false)\n\n  See also - every-kv", :row 307} {:fixed-arities #{1}, :end-row 325, :ns "cljs.spec.alpha", :name "*", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches zero or more values matching\n  pred. Produces a vector of matches iff there is at least one match", :row 321} {:fixed-arities #{1}, :end-row 331, :ns "cljs.spec.alpha", :name "+", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches one or more values matching\n  pred. Produces a vector of matches", :row 327} {:fixed-arities #{1}, :end-row 337, :ns "cljs.spec.alpha", :name "?", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred-form]"], :doc "Returns a regex op that matches zero or one value matching\n  pred. Produces a single value (not a collection) if matched.", :row 333} {:end-row 354, :ns "cljs.spec.alpha", :name "alt", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/alt :even even? :small #(< % 42))\n\n  Returns a regex op that returns a map entry containing the key of the\n  first matching pred and the corresponding value. Thus the\n  'key' and 'val' functions can be used to refer generically to the\n  components of the tagged return.", :row 339} {:end-row 370, :ns "cljs.spec.alpha", :name "cat", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& key-pred-forms]"], :doc "Takes key+pred pairs, e.g.\n\n  (s/cat :e even? :o odd?)\n\n  Returns a regex op that matches (all) values in sequence, returning a map\n  containing the keys of each pred and the corresponding value.", :row 356} {:end-row 378, :ns "cljs.spec.alpha", :name "&", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[re & preds]"], :doc "takes a regex op re, and predicates. Returns a regex-op that consumes\n  input as per re but subjects the resulting value to the\n  conjunction of the predicates, and any conforming they might perform.", :row 372} {:fixed-arities #{1 2}, :end-row 386, :ns "cljs.spec.alpha", :name "conformer", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[f]" "[f unf]"], :doc "takes a predicate function with the semantics of conform i.e. it should return either a\n  (possibly converted) value or :cljs.spec.alpha/invalid, and returns a\n  spec that uses it as a predicate/conformer. Optionally takes a\n  second fn that does unform of result of first", :row 380} {:end-row 406, :ns "cljs.spec.alpha", :name "fspec", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [args ret fn gen] :or {ret `cljs.core/any?}}]"], :doc "takes :args :ret and (optional) :fn kwargs whose values are preds\n  and returns a spec whose conform/explain take a fn and validates it\n  using generative testing. The conformed value is always the fn itself.\n\n  See 'fdef' for a single operation that creates an fspec and\n  registers it, as well as a full description of :args, :ret and :fn\n\n  fspecs can generate functions that validate the arguments and\n  fabricate a return value compliant with the :ret spec, ignoring\n  the :fn spec if present.\n\n  Optionally takes :gen generator-fn, which must be a fn of no args\n  that returns a test.check generator.", :row 388} {:end-row 414, :ns "cljs.spec.alpha", :name "tuple", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& preds]"], :doc "takes one or more preds and returns a spec for a tuple, a vector\n  where each element conforms to the corresponding pred. Each element\n  will be referred to in paths using its ordinal.", :row 408} {:end-row 449, :ns "cljs.spec.alpha", :name "fdef", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[fn-sym & specs]"], :doc "Takes a symbol naming a function, and one or more of the following:\n\n  :args A regex spec for the function arguments as they were a list to be\n    passed to apply - in this way, a single spec can handle functions with\n    multiple arities\n  :ret A spec for the function's return value\n  :fn A spec of the relationship between args and ret - the\n    value passed is {:args conformed-args :ret conformed-ret} and is\n    expected to contain predicates that relate those values\n\n  Qualifies fn-sym with resolve, or using *ns* if no resolution found.\n  Registers an fspec in the global registry, where it can be retrieved\n  by calling get-spec with the var or fully-qualified symbol.\n\n  Once registered, function specs are included in doc, checked by\n  instrument, tested by the runner cljs.spec.test.alpha/check, and (if\n  a macro) used to explain errors during macroexpansion.\n\n  Note that :fn specs require the presence of :args and :ret specs to\n  conform values, and so :fn specs will be ignored if :args or :ret\n  are missing.\n\n  Returns the qualified fn-sym.\n\n  For example, to register function specs for the symbol function:\n\n  (s/fdef cljs.core/symbol\n    :args (s/alt :separate (s/cat :ns string? :n string?)\n                 :str string?\n                 :sym symbol?)\n    :ret symbol?)", :row 416} {:end-row 468, :ns "cljs.spec.alpha", :name "keys*", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& kspecs]"], :doc "takes the same arguments as spec/keys and returns a regex op that matches sequences of key/values,\n  converts them into a map, and conforms that map with a corresponding\n  spec/keys call:\n\n  user=> (s/conform (s/keys :req-un [::a ::c]) {:a 1 :c 2})\n  {:a 1, :c 2}\n  user=> (s/conform (s/keys* :req-un [::a ::c]) [:a 1 :c 2])\n  {:a 1, :c 2}\n\n  the resulting regex op can be composed into a larger regex:\n\n  user=> (s/conform (s/cat :i1 integer? :m (s/keys* :req-un [::a ::c]) :i2 integer?) [42 :a 1 :c 2 :d 4 99])\n  {:i1 42, :m {:a 1, :c 2, :d 4}, :i2 99}", :row 451} {:fixed-arities #{1}, :end-row 474, :ns "cljs.spec.alpha", :name "nilable", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[pred]"], :doc "returns a spec that accepts nil and values satisfiying pred", :row 470} {:fixed-arities #{2}, :end-row 486, :ns "cljs.spec.alpha", :name "inst-in", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[start end]"], :doc "Returns a spec that validates insts in the range from start\n  (inclusive) to end (exclusive).", :row 476} {:fixed-arities #{2}, :end-row 493, :ns "cljs.spec.alpha", :name "int-in", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[start end]"], :doc "Returns a spec that validates fixed precision integers in the\n  range from start (inclusive) to end (exclusive).", :row 488} {:end-row 510, :ns "cljs.spec.alpha", :name "double-in", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& {:keys [infinite? NaN? min max] :or {infinite? true NaN? true} :as m}]"], :doc "Specs a 64-bit floating point number. Options:\n\n    :infinite? - whether +/- infinity allowed (default true)\n    :NaN?      - whether NaN allowed (default true)\n    :min       - minimum value (inclusive, default none)\n    :max       - maximum value (inclusive, default none)", :row 495} {:end-row 519, :ns "cljs.spec.alpha", :name "merge", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[& pred-forms]"], :doc "Takes map-validating specs (e.g. 'keys' specs) and\n  returns a spec that returns a conformed map satisfying all of the\n  specs.  Successive conformed values propagate through rest of\n  predicates. Unlike 'and', merge can generate maps satisfying the\n  union of the predicates.", :row 512} {:fixed-arities #{1 3 2}, :end-row 542, :ns "cljs.spec.alpha", :name "exercise-fn", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[sym]" "[sym n]" "[sym n fspec]"], :doc "exercises the fn named by sym (a symbol) by applying it to\n  n (default 10) generated samples of its args spec. When fspec is\n  supplied its arg spec is used, and sym-or-f can be a fn.  Returns a\n  sequence of tuples of [args ret]. ", :row 521} {:fixed-arities #{0}, :end-row 546, :private true, :ns "cljs.spec.alpha", :name "init-compile-asserts", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[]"], :row 544} {:fixed-arities #{2}, :end-row 564, :ns "cljs.spec.alpha", :name "assert", :lang :cljs, :filename "cljs/spec/alpha.cljc", :macro true, :arglist-strs ["[spec x]"], :doc "spec-checking assert expression. Returns x if x is valid? according\nto spec, else throws an error with explain-data plus ::failure of\n:assertion-failed.\nCan be disabled at either compile time or runtime:\nIf *compile-asserts* is false at compile time, compiles to x. Defaults\nto the negation value of the ':elide-asserts' compiler option, or true if\nnot set.\nIf (check-asserts?) is false at runtime, always returns x. Defaults to\nvalue of 'cljs.spec.alpha/*runtime-asserts*', or false if not set. You can\ntoggle check-asserts? with (check-asserts bool).", :row 548} {:end-row 19, :filename "cljs/spec/alpha.cljs", :name "MAX_INT", :ns "cljs.spec.alpha", :row 19} {:doc "A soft limit on how many times a branching spec (or/alt/*/opt-keys/multi-spec)\n  can be recursed through during generation. After this a\n  non-recursive branch will be chosen.", :end-row 25, :filename "cljs/spec/alpha.cljs", :name "*recursion-limit*", :ns "cljs.spec.alpha", :row 21} {:doc "The number of times an anonymous fn specified by fspec will be (generatively) tested during conform", :end-row 29, :filename "cljs/spec/alpha.cljs", :name "*fspec-iterations*", :ns "cljs.spec.alpha", :row 27} {:doc "The number of items validated in a collection spec'ed with 'every'", :end-row 33, :filename "cljs/spec/alpha.cljs", :name "*coll-check-limit*", :ns "cljs.spec.alpha", :row 31} {:doc "The number of errors reported by explain in a collection spec'ed with 'every'", :end-row 37, :filename "cljs/spec/alpha.cljs", :name "*coll-error-limit*", :ns "cljs.spec.alpha", :row 35} {:end-row 45, :filename "cljs/spec/alpha.cljs", :name "Spec", :ns "cljs.spec.alpha", :row 39} {:arglist-strs ["[spec x]"], :end-row 40, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "conform*", :ns "cljs.spec.alpha", :row 40} {:arglist-strs ["[spec y]"], :end-row 41, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "unform*", :ns "cljs.spec.alpha", :row 41} {:arglist-strs ["[spec path via in x]"], :end-row 42, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "explain*", :ns "cljs.spec.alpha", :row 42} {:arglist-strs ["[spec overrides path rmap]"], :end-row 43, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "gen*", :ns "cljs.spec.alpha", :row 43} {:arglist-strs ["[spec gfn]"], :end-row 44, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "with-gen*", :ns "cljs.spec.alpha", :row 44} {:arglist-strs ["[spec]"], :end-row 45, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "describe*", :ns "cljs.spec.alpha", :row 45} {:end-row 47, :filename "cljs/spec/alpha.cljs", :name "registry-ref", :ns "cljs.spec.alpha", :private true, :row 47} {:arglist-strs ["[reg k]"], :end-row 53, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "deep-resolve", :ns "cljs.spec.alpha", :private true, :row 49} {:fixed-arities #{1}, :end-row 64, :private true, :ns "cljs.spec.alpha", :name "reg-resolve", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[k]"], :doc "returns the spec/regex at end of alias chain starting with k, nil if not found, k if k not ident", :row 55} {:fixed-arities #{1}, :end-row 72, :private true, :ns "cljs.spec.alpha", :name "reg-resolve!", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[k]"], :doc "returns the spec/regex at end of alias chain starting with k, throws if not found, k if k not ident", :row 66} {:arglist-strs ["[x]"], :doc "returns x if x is a spec object, else logical false", :end-row 78, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "spec?", :ns "cljs.spec.alpha", :row 74} {:arglist-strs ["[x]"], :doc "returns x if x is a (cljs.spec.alpha) regex op, else logical false", :end-row 83, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "regex?", :ns "cljs.spec.alpha", :row 80} {:arglist-strs ["[spec name]"], :end-row 91, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "with-name", :ns "cljs.spec.alpha", :private true, :row 85} {:arglist-strs ["[spec]"], :end-row 100, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "spec-name", :ns "cljs.spec.alpha", :private true, :row 93} {:end-row 102, :filename "cljs/spec/alpha.cljs", :name "spec-impl", :ns "cljs.spec.alpha", :row 102} {:end-row 103, :filename "cljs/spec/alpha.cljs", :name "regex-spec-impl", :ns "cljs.spec.alpha", :row 103} {:fixed-arities #{1}, :end-row 114, :private true, :ns "cljs.spec.alpha", :name "maybe-spec", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[spec-or-k]"], :doc "spec-or-k must be a spec, regex or resolvable kw/sym, else returns nil.", :row 105} {:fixed-arities #{1}, :end-row 121, :private true, :ns "cljs.spec.alpha", :name "the-spec", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[spec-or-k]"], :doc "spec-or-k must be a spec, regex or kw/sym, else returns nil. Throws if unresolvable kw/sym", :row 116} {:arglist-strs ["[f-n]"], :end-row 129, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "fn-sym", :ns "cljs.spec.alpha", :private true, :row 123} {:end-row 132, :filename "cljs/spec/alpha.cljs", :name "Specize", :ns "cljs.spec.alpha", :row 131} {:arglist-strs ["[_]" "[_ form]"], :end-row 132, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1 2}, :name "specize*", :ns "cljs.spec.alpha", :row 132} {:arglist-strs ["[s]" "[s form]"], :end-row 161, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1 2}, :name "specize", :ns "cljs.spec.alpha", :private true, :row 159} {:arglist-strs ["[ret]"], :doc "tests the validity of a conform return value", :end-row 166, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "invalid?", :ns "cljs.spec.alpha", :row 163} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value, returns :cljs.spec.alpha/invalid if value does\n  not match spec, else the (possibly destructured) value.", :end-row 172, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "conform", :ns "cljs.spec.alpha", :row 168} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value created by or compliant with a call to\n  'conform' with the same spec, returns a value with all conform\n   destructuring undone.", :end-row 179, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "unform", :ns "cljs.spec.alpha", :row 174} {:arglist-strs ["[spec]"], :doc "returns the spec as data", :end-row 185, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "form", :ns "cljs.spec.alpha", :row 181} {:arglist-strs ["[form]"], :end-row 204, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "abbrev", :ns "cljs.spec.alpha", :row 187} {:arglist-strs ["[spec]"], :doc "returns an abbreviated description of the spec as data", :end-row 209, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "describe", :ns "cljs.spec.alpha", :row 206} {:arglist-strs ["[spec gen-fn]"], :doc "Takes a spec and a no-arg, generator-returning fn and returns a version of that spec that uses that generator", :end-row 217, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "with-gen", :ns "cljs.spec.alpha", :row 211} {:arglist-strs ["[spec path via in x]"], :end-row 224, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "explain-data*", :ns "cljs.spec.alpha", :row 219} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value x which ought to conform, returns nil if x\n  conforms, else a map with at least the key ::problems whose value is\n  a collection of problem-maps, where problem-map has at least :path :pred and :val\n  keys describing the predicate and the value that failed at that\n  path.", :end-row 233, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "explain-data", :ns "cljs.spec.alpha", :row 226} {:arglist-strs ["[ed]"], :doc "Default printer for explain-data. nil indicates a successful validation.", :end-row 260, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "explain-printer", :ns "cljs.spec.alpha", :row 235} {:end-row 262, :filename "cljs/spec/alpha.cljs", :name "*explain-out*", :ns "cljs.spec.alpha", :row 262} {:arglist-strs ["[ed]"], :doc "Prints explanation data (per 'explain-data') to *out* using the printer in *explain-out*,\n    by default explain-printer.", :end-row 268, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "explain-out", :ns "cljs.spec.alpha", :row 264} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value that fails to conform, prints an explanation to *out*.", :end-row 273, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "explain", :ns "cljs.spec.alpha", :row 270} {:arglist-strs ["[spec x]"], :doc "Given a spec and a value that fails to conform, returns an explanation as a string.", :end-row 278, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "explain-str", :ns "cljs.spec.alpha", :row 275} {:end-row 280, :filename "cljs/spec/alpha.cljs", :name "valid?", :ns "cljs.spec.alpha", :row 280} {:arglist-strs ["[spec overrides path rmap form]"], :end-row 291, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "gensub", :ns "cljs.spec.alpha", :private true, :row 282} {:arglist-strs ["[spec]" "[spec overrides]"], :doc "Given a spec, returns the generator for it, or throws if none can\n  be constructed. Optionally an overrides map can be provided which\n  should map spec names or paths (vectors of keywords) to no-arg\n  generator-creating fns. These will be used instead of the generators at those\n  names/paths. Note that parent generator (in the spec or overrides\n  map) will supersede those of any subtrees. A generator for a regex\n  op must always return a sequential collection (i.e. a generator for\n  s/? should return either an empty sequence/vector or a\n  sequence/vector with one item in it)", :end-row 304, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1 2}, :name "gen", :ns "cljs.spec.alpha", :row 293} {:arglist-strs ["[k form spec]"], :doc "Do not call this directly, use 'def'", :end-row 316, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "def-impl", :ns "cljs.spec.alpha", :row 306} {:arglist-strs ["[]"], :doc "returns the registry map, prefer 'get-spec' to lookup a spec by name", :end-row 321, :filename "cljs/spec/alpha.cljs", :fixed-arities #{0}, :name "registry", :ns "cljs.spec.alpha", :row 318} {:fixed-arities #{1}, :end-row 328, :private true, :ns "cljs.spec.alpha", :name "->sym", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[x]"], :doc "Returns a symbol from a symbol or var", :row 323} {:arglist-strs ["[k]"], :doc "Returns spec registered for keyword/symbol/var k, or nil.", :end-row 333, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "get-spec", :ns "cljs.spec.alpha", :row 330} {:end-row 335, :filename "cljs/spec/alpha.cljs", :name "map-spec", :ns "cljs.spec.alpha", :row 335} {:arglist-strs ["[v args]"], :end-row 348, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "macroexpand-check", :ns "cljs.spec.alpha", :private true, :row 337} {:arglist-strs ["[rmap id path k]"], :end-row 353, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "recur-limit?", :ns "cljs.spec.alpha", :private true, :row 351} {:arglist-strs ["[m k]"], :end-row 356, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "inck", :ns "cljs.spec.alpha", :private true, :row 355} {:arglist-strs ["[pred x form]" "[pred x form cpred?]"], :end-row 369, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4 3}, :name "dt", :ns "cljs.spec.alpha", :private true, :row 358} {:arglist-strs ["[spec x]" "[spec x form]"], :doc "Helper function that returns true when x is valid for spec.", :end-row 378, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3 2}, :name "valid?", :ns "cljs.spec.alpha", :row 371} {:fixed-arities #{3 2}, :end-row 385, :private true, :ns "cljs.spec.alpha", :name "pvalid?", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[pred x]" "[pred x form]"], :doc "internal helper function that returns true when x is valid for spec.", :row 380} {:arglist-strs ["[form pred path via in v]"], :end-row 392, :filename "cljs/spec/alpha.cljs", :fixed-arities #{6}, :name "explain-1", :ns "cljs.spec.alpha", :private true, :row 387} {:end-row 395, :filename "cljs/spec/alpha.cljs", :name "or-k-gen", :ns "cljs.spec.alpha", :row 394} {:end-row 395, :filename "cljs/spec/alpha.cljs", :name "and-k-gen", :ns "cljs.spec.alpha", :row 394} {:fixed-arities #{1}, :end-row 404, :private true, :ns "cljs.spec.alpha", :name "k-gen", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[f]"], :doc "returns a generator for form f, which can be a keyword or a list\n  starting with 'or or 'and.", :row 397} {:fixed-arities #{1 2}, :end-row 415, :private true, :ns "cljs.spec.alpha", :name "or-k-gen", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[s]" "[min-count s]"], :doc "returns a tuple generator made up of generators for a random subset\n  of min-count (default 0) to all elements in s.", :row 406} {:fixed-arities #{1}, :end-row 421, :private true, :ns "cljs.spec.alpha", :name "and-k-gen", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[s]"], :doc "returns a tuple generator made up of generators for every element\n  in s.", :row 417} {:arglist-strs ["[{:keys [req-un opt-un keys-pred pred-exprs opt-keys req-specs req req-keys opt-specs pred-forms opt gfn] :as argm}]"], :doc "Do not call this directly, use 'spec' with a map argument", :end-row 509, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "map-spec-impl", :ns "cljs.spec.alpha", :row 423} {:arglist-strs ["[form pred gfn cpred?]" "[form pred gfn cpred? unc]"], :doc "Do not call this directly, use 'spec'", :end-row 542, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4 5}, :name "spec-impl", :ns "cljs.spec.alpha", :row 511} {:arglist-strs ["[form mmvar retag]" "[form mmvar retag gfn]"], :doc "Do not call this directly, use 'multi-spec'", :end-row 592, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4 3}, :name "multi-spec-impl", :ns "cljs.spec.alpha", :row 544} {:arglist-strs ["[forms preds]" "[forms preds gfn]"], :doc "Do not call this directly, use 'tuple'", :end-row 654, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3 2}, :name "tuple-impl", :ns "cljs.spec.alpha", :row 594} {:arglist-strs ["[tag ret]"], :end-row 657, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "tagged-ret", :ns "cljs.spec.alpha", :private true, :row 656} {:arglist-strs ["[keys forms preds gfn]"], :doc "Do not call this directly, use 'or'", :end-row 724, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "or-spec-impl", :ns "cljs.spec.alpha", :row 659} {:arglist-strs ["[x preds forms]"], :end-row 736, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "and-preds", :ns "cljs.spec.alpha", :private true, :row 726} {:arglist-strs ["[forms preds path via in x]"], :end-row 747, :filename "cljs/spec/alpha.cljs", :fixed-arities #{6}, :name "explain-pred-list", :ns "cljs.spec.alpha", :private true, :row 738} {:arglist-strs ["[forms preds gfn]"], :doc "Do not call this directly, use 'and'", :end-row 791, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "and-spec-impl", :ns "cljs.spec.alpha", :row 749} {:arglist-strs ["[x kfn kform distinct count min-count max-count path via in]"], :end-row 811, :filename "cljs/spec/alpha.cljs", :fixed-arities #{10}, :name "coll-prob", :ns "cljs.spec.alpha", :private true, :row 793} {:arglist-strs ["[forms preds gfn]"], :doc "Do not call this directly, use 'merge'", :end-row 839, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "merge-spec-impl", :ns "cljs.spec.alpha", :row 813} {:end-row 841, :filename "cljs/spec/alpha.cljs", :name "empty-coll", :ns "cljs.spec.alpha", :private true, :row 841} {:arglist-strs ["[form pred opts]" "[form pred {conform-into :into describe-form ::describe :keys [kind ::kind-form count max-count min-count distinct gen-max ::kfn ::cpred conform-keys ::conform-all] :or {gen-max 20} :as opts} gfn]"], :doc "Do not call this directly, use 'every', 'every-kv', 'coll-of' or 'map-of'", :end-row 969, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4 3}, :name "every-impl", :ns "cljs.spec.alpha", :row 843} {:arglist-strs ["[x]"], :end-row 977, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "accept", :ns "cljs.spec.alpha", :private true, :row 977} {:arglist-strs ["[{:keys [::op]}]"], :end-row 980, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "accept?", :ns "cljs.spec.alpha", :private true, :row 979} {:arglist-strs ["[{[p1 & pr :as ps] :ps [k1 & kr :as ks] :ks [f1 & fr :as forms] :forms ret :ret rep+ :rep+}]"], :end-row 990, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "pcat*", :ns "cljs.spec.alpha", :private true, :row 982} {:arglist-strs ["[& ps]"], :end-row 992, :filename "cljs/spec/alpha.cljs", :name "pcat", :ns "cljs.spec.alpha", :private true, :row 992} {:arglist-strs ["[ks ps forms]"], :doc "Do not call this directly, use 'cat'", :end-row 997, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "cat-impl", :ns "cljs.spec.alpha", :row 994} {:arglist-strs ["[p1 p2 ret splice form]"], :end-row 1004, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "rep*", :ns "cljs.spec.alpha", :private true, :row 999} {:arglist-strs ["[form p]"], :doc "Do not call this directly, use '*'", :end-row 1008, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "rep-impl", :ns "cljs.spec.alpha", :row 1006} {:arglist-strs ["[form p]"], :doc "Do not call this directly, use '+'", :end-row 1013, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "rep+impl", :ns "cljs.spec.alpha", :row 1010} {:arglist-strs ["[re re-form preds pred-forms]"], :doc "Do not call this directly, use '&'", :end-row 1018, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "amp-impl", :ns "cljs.spec.alpha", :row 1015} {:arglist-strs ["[ps ks forms f]"], :end-row 1027, :filename "cljs/spec/alpha.cljs", :fixed-arities #{4}, :name "filter-alt", :ns "cljs.spec.alpha", :private true, :row 1020} {:arglist-strs ["[ps ks forms]"], :end-row 1039, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "alt*", :ns "cljs.spec.alpha", :private true, :row 1029} {:arglist-strs ["[& ps]"], :end-row 1041, :filename "cljs/spec/alpha.cljs", :name "alts", :ns "cljs.spec.alpha", :private true, :row 1041} {:arglist-strs ["[p1 p2]"], :end-row 1042, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "alt2", :ns "cljs.spec.alpha", :private true, :row 1042} {:arglist-strs ["[ks ps forms]"], :doc "Do not call this directly, use 'alt'", :end-row 1046, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "alt-impl", :ns "cljs.spec.alpha", :row 1044} {:arglist-strs ["[p form]"], :doc "Do not call this directly, use '?'", :end-row 1050, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "maybe-impl", :ns "cljs.spec.alpha", :row 1048} {:arglist-strs ["[p1 pret]"], :end-row 1056, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "noret?", :ns "cljs.spec.alpha", :private true, :row 1052} {:end-row 1058, :filename "cljs/spec/alpha.cljs", :name "preturn", :ns "cljs.spec.alpha", :row 1058} {:arglist-strs ["[p]"], :end-row 1070, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "accept-nil?", :ns "cljs.spec.alpha", :private true, :row 1060} {:end-row 1072, :filename "cljs/spec/alpha.cljs", :name "add-ret", :ns "cljs.spec.alpha", :row 1072} {:arglist-strs ["[p]"], :end-row 1087, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "preturn", :ns "cljs.spec.alpha", :private true, :row 1074} {:arglist-strs ["[p x]"], :end-row 1108, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "op-unform", :ns "cljs.spec.alpha", :private true, :row 1089} {:arglist-strs ["[p r k]"], :end-row 1121, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "add-ret", :ns "cljs.spec.alpha", :private true, :row 1110} {:arglist-strs ["[p x]"], :end-row 1141, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "deriv", :ns "cljs.spec.alpha", :private true, :row 1123} {:arglist-strs ["[p]"], :end-row 1157, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "op-describe", :ns "cljs.spec.alpha", :private true, :row 1143} {:arglist-strs ["[form p path via in input]"], :end-row 1212, :filename "cljs/spec/alpha.cljs", :fixed-arities #{6}, :name "op-explain", :ns "cljs.spec.alpha", :private true, :row 1159} {:arglist-strs ["[p overrides path rmap f]"], :end-row 1253, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "re-gen", :ns "cljs.spec.alpha", :private true, :row 1214} {:arglist-strs ["[p [x & xs :as data]]"], :end-row 1266, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "re-conform", :ns "cljs.spec.alpha", :private true, :row 1255} {:arglist-strs ["[path via in re input]"], :end-row 1292, :filename "cljs/spec/alpha.cljs", :fixed-arities #{5}, :name "re-explain", :ns "cljs.spec.alpha", :private true, :row 1268} {:arglist-strs ["[re gfn]"], :doc "Do not call this directly, use 'spec' with a regex op argument", :end-row 1317, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "regex-spec-impl", :ns "cljs.spec.alpha", :row 1294} {:arglist-strs ["[f specs args]"], :end-row 1330, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "call-valid?", :ns "cljs.spec.alpha", :private true, :row 1321} {:fixed-arities #{3}, :end-row 1340, :private true, :ns "cljs.spec.alpha", :name "validate-fn", :filename "cljs/spec/alpha.cljs", :arglist-strs ["[f specs iters]"], :doc "returns f if valid, else smallest", :row 1332} {:arglist-strs ["[argspec aform retspec rform fnspec fform gfn]"], :doc "Do not call this directly, use 'fspec'", :end-row 1384, :filename "cljs/spec/alpha.cljs", :fixed-arities #{7}, :name "fspec-impl", :ns "cljs.spec.alpha", :row 1342} {:arglist-strs ["[spec]"], :doc "takes a spec and returns a spec that has the same properties except\n  'conform' returns the original (not the conformed) value. Note, will specize regex ops.", :end-row 1408, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "nonconforming", :ns "cljs.spec.alpha", :row 1389} {:arglist-strs ["[form pred gfn]"], :doc "Do not call this directly, use 'nilable'", :end-row 1434, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "nilable-impl", :ns "cljs.spec.alpha", :row 1410} {:arglist-strs ["[spec]" "[spec n]" "[spec n overrides]"], :doc "generates a number (default 10) of values compatible with spec and maps conform over them,\n  returning a sequence of [val conformed-val] tuples. Optionally takes\n  a generator overrides map as per gen", :end-row 1443, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1 3 2}, :name "exercise", :ns "cljs.spec.alpha", :row 1436} {:arglist-strs ["[start end inst]"], :doc "Return true if inst at or after start and before end", :end-row 1450, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "inst-in-range?", :ns "cljs.spec.alpha", :row 1445} {:arglist-strs ["[start end val]"], :doc "Return true if start <= val, val < end and val is a fixed\n  precision integer.", :end-row 1467, :filename "cljs/spec/alpha.cljs", :fixed-arities #{3}, :name "int-in-range?", :ns "cljs.spec.alpha", :row 1452} {:doc "If true, compiler will enable spec asserts, which are then\nsubject to runtime control via check-asserts? If false, compiler\nwill eliminate all spec assert overhead. See 'assert'.\nInitially set to the negation of the ':elide-asserts' compiler option.\nDefaults to true.", :end-row 1478, :filename "cljs/spec/alpha.cljs", :name "*compile-asserts*", :ns "cljs.spec.alpha", :row 1470} {:end-row 1483, :filename "cljs/spec/alpha.cljs", :name "*runtime-asserts*", :ns "cljs.spec.alpha", :private true, :row 1480} {:arglist-strs ["[]"], :doc "Returns the value set by check-asserts.", :end-row 1488, :filename "cljs/spec/alpha.cljs", :fixed-arities #{0}, :name "check-asserts?", :ns "cljs.spec.alpha", :row 1485} {:arglist-strs ["[flag]"], :doc "Enable or disable spec asserts that have been compiled\nwith '*compile-asserts*' true.  See 'assert'.\nInitially set to boolean value of cljs.spec.alpha/*runtime-asserts*.\nDefaults to false.", :end-row 1496, :filename "cljs/spec/alpha.cljs", :fixed-arities #{1}, :name "check-asserts", :ns "cljs.spec.alpha", :row 1490} {:arglist-strs ["[spec x]"], :doc "Do not call this directly, use 'assert'.", :end-row 1506, :filename "cljs/spec/alpha.cljs", :fixed-arities #{2}, :name "assert*", :ns "cljs.spec.alpha", :row 1498}]} {:doc "edn reading.\n\n  This namespace provides alias for cljs.reader/read and cljs.reader/read-string.\n  Thus Clojure and ClojureScript source can reference these functions in the same way.\n  In Clojure, read and read-string may cause evaluation,\n  but clojure.edn/read and clojure.edn/read-string will not.\n  In ClojureScript cljs.reader/read and cljs.reader/read-string will not cause evaluation,\n  they only read edn.", :end-row 18, :filename "clojure/edn.cljs", :name "clojure.edn", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[reader]" "[opts reader]" "[reader eof-error? eof opts]"], :doc "Reads the first object from an cljs.tools.reader.reader-types/IPushbackReader.\n   Returns the object read. If EOF, throws if eof-error? is true otherwise returns eof.\n   If no reader is provided, *in* will be used.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   cljs.tools.reader.edn/read doesn't depend on dynamic Vars, all configuration\n   is done by passing an opt map.\n\n   opts is a map that can include the following keys:\n   :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n   :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n   :default - A function of two args, that will, if present and no reader is found for a tag,\n              be called with the tag and the value.", :end-row 42, :filename "clojure/edn.cljs", :fixed-arities #{1 4 2}, :name "read", :ns "clojure.edn", :row 20} {:arglist-strs ["[s]" "[opts s]"], :doc "Reads one object from the string s.\n   Returns nil when s is nil or empty.\n\n   Reads data in the edn format (subset of Clojure data):\n   http://edn-format.org\n\n   opts is a map as per cljs.tools.reader.edn/read", :end-row 55, :filename "clojure/edn.cljs", :fixed-arities #{1 2}, :name "read-string", :ns "clojure.edn", :row 44}]} {:author "Stuart Sierra", :doc "This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.", :end-row 35, :filename "clojure/walk.cljs", :name "clojure.walk", :row 23, :ns nil, :var-definitions [{:arglist-strs ["[inner outer form]"], :doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :end-row 52, :filename "clojure/walk.cljs", :fixed-arities #{3}, :name "walk", :ns "clojure.walk", :row 37} {:arglist-strs ["[f form]"], :doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :end-row 60, :filename "clojure/walk.cljs", :fixed-arities #{2}, :name "postwalk", :ns "clojure.walk", :row 54} {:arglist-strs ["[f form]"], :doc "Like postwalk, but does pre-order traversal.", :end-row 66, :filename "clojure/walk.cljs", :fixed-arities #{2}, :name "prewalk", :ns "clojure.walk", :row 62} {:arglist-strs ["[m]"], :doc "Recursively transforms all map keys from strings to keywords.", :end-row 74, :filename "clojure/walk.cljs", :fixed-arities #{1}, :name "keywordize-keys", :ns "clojure.walk", :row 68} {:arglist-strs ["[m]"], :doc "Recursively transforms all map keys from keywords to strings.", :end-row 82, :filename "clojure/walk.cljs", :fixed-arities #{1}, :name "stringify-keys", :ns "clojure.walk", :row 76} {:arglist-strs ["[smap form]"], :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", :end-row 90, :filename "clojure/walk.cljs", :fixed-arities #{2}, :name "prewalk-replace", :ns "clojure.walk", :row 84} {:arglist-strs ["[smap form]"], :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", :end-row 98, :filename "clojure/walk.cljs", :fixed-arities #{2}, :name "postwalk-replace", :ns "clojure.walk", :row 92}]} {:end-row 13, :filename "clojure/reflect.cljs", :name "clojure.reflect", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[block]"], :end-row 19, :filename "clojure/reflect.cljs", :fixed-arities #{1}, :name "evaluate-javascript", :ns "clojure.reflect", :private true, :row 15} {:fixed-arities #{2}, :end-row 31, :private true, :ns "clojure.reflect", :name "query-reflection", :filename "clojure/reflect.cljs", :arglist-strs ["[query-param cb]"], :doc "Issues a GET to /reflect with a single query-parameter string.\n  Calls cb with the result.", :row 21} {:arglist-strs ["[sym cb]"], :doc "Queries the reflection api with a fully qualified symbol, then calls\n  callback fn cb with the evaluated cljs map containing that symbol's\n  meta information.", :end-row 39, :filename "clojure/reflect.cljs", :fixed-arities #{2}, :name "meta", :ns "clojure.reflect", :row 33} {:arglist-strs ["[form]"], :doc "Queries the reflection api with a quoted macro form, then calls the\n  callback function with the macroexpanded form, as a string.", :end-row 45, :filename "clojure/reflect.cljs", :fixed-arities #{1}, :name "macroexpand", :ns "clojure.reflect", :row 41} {:arglist-strs ["[{:keys [name method-params doc]}]"], :end-row 51, :filename "clojure/reflect.cljs", :fixed-arities #{1}, :name "print-doc", :ns "clojure.reflect", :row 47} {:arglist-strs ["[sym]"], :doc "Queries the reflection api with a fully qualified symbol, then prints\n  documentation information at the repl.", :end-row 57, :filename "clojure/reflect.cljs", :fixed-arities #{1}, :name "doc", :ns "clojure.reflect", :row 53}]} {:end-row 12, :filename "clojure/string.cljs", :name "clojure.string", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[coll]"], :end-row 16, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "seq-reverse", :ns "clojure.string", :private true, :row 14} {:end-row 19, :filename "clojure/string.cljs", :name "re-surrogate-pair", :ns "clojure.string", :private true, :row 18} {:arglist-strs ["[s]"], :doc "Returns s with its characters reversed.", :end-row 25, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "reverse", :ns "clojure.string", :row 21} {:arglist-strs ["[s re replacement]"], :end-row 34, :filename "clojure/string.cljs", :fixed-arities #{3}, :name "replace-all", :ns "clojure.string", :private true, :row 27} {:arglist-strs ["[f]"], :end-row 42, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "replace-with", :ns "clojure.string", :private true, :row 36} {:arglist-strs ["[s match replacement]"], :doc "Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.\n\n   Example:\n   (clojure.string/replace \"Almost Pig Latin\" #\"\\b(\\w)(\\w+)\\b\" \"$2$1ay\")\n   -> \"lmostAay igPay atinLay\"", :end-row 74, :filename "clojure/string.cljs", :fixed-arities #{3}, :name "replace", :ns "clojure.string", :row 44} {:arglist-strs ["[s match replacement]"], :doc "Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.\n\n   Example:\n   (clojure.string/replace-first \"swap first two words\"\n                                 #\"(\\w+)(\\s+)(\\w+)\" \"$3$2$1\")\n   -> \"first swap two words\"", :end-row 98, :filename "clojure/string.cljs", :fixed-arities #{3}, :name "replace-first", :ns "clojure.string", :row 76} {:arglist-strs ["[coll]" "[separator coll]"], :doc "Returns a string of all elements in coll, as returned by (seq coll),\n  separated by an optional separator.", :end-row 117, :filename "clojure/string.cljs", :fixed-arities #{1 2}, :name "join", :ns "clojure.string", :row 100} {:arglist-strs ["[s]"], :doc "Converts string to all upper-case.", :end-row 122, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "upper-case", :ns "clojure.string", :row 119} {:arglist-strs ["[s]"], :doc "Converts string to all lower-case.", :end-row 127, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "lower-case", :ns "clojure.string", :row 124} {:arglist-strs ["[s]"], :doc "Converts first character of the string to upper-case, all other\n  characters to lower-case.", :end-row 133, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "capitalize", :ns "clojure.string", :row 129} {:arglist-strs ["[v]"], :end-row 149, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "pop-last-while-empty", :ns "clojure.string", :private true, :row 144} {:arglist-strs ["[limit v]"], :end-row 155, :filename "clojure/string.cljs", :fixed-arities #{2}, :name "discard-trailing-if-needed", :ns "clojure.string", :private true, :row 151} {:arglist-strs ["[s limit]"], :end-row 165, :filename "clojure/string.cljs", :fixed-arities #{2}, :name "split-with-empty-regex", :ns "clojure.string", :private true, :row 157} {:arglist-strs ["[s re]" "[s re limit]"], :doc "Splits string on a regular expression. Optional argument limit is\n  the maximum number of parts. Not lazy. Returns vector of the parts.\n  Trailing empty strings are not returned - pass limit of -1 to return all.", :end-row 190, :filename "clojure/string.cljs", :fixed-arities #{3 2}, :name "split", :ns "clojure.string", :row 167} {:arglist-strs ["[s]"], :doc "Splits s on \\n or \\r\\n. Trailing empty lines are not returned.", :end-row 195, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "split-lines", :ns "clojure.string", :row 192} {:arglist-strs ["[s]"], :doc "Removes whitespace from both ends of string.", :end-row 200, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "trim", :ns "clojure.string", :row 197} {:arglist-strs ["[s]"], :doc "Removes whitespace from the left side of string.", :end-row 205, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "triml", :ns "clojure.string", :row 202} {:arglist-strs ["[s]"], :doc "Removes whitespace from the right side of string.", :end-row 210, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "trimr", :ns "clojure.string", :row 207} {:arglist-strs ["[s]"], :doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", :end-row 223, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "trim-newline", :ns "clojure.string", :row 212} {:arglist-strs ["[s]"], :doc "True is s is nil, empty, or contains only whitespace.", :end-row 228, :filename "clojure/string.cljs", :fixed-arities #{1}, :name "blank?", :ns "clojure.string", :row 225} {:arglist-strs ["[s cmap]"], :doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n\n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", :end-row 247, :filename "clojure/string.cljs", :fixed-arities #{2}, :name "escape", :ns "clojure.string", :row 230} {:arglist-strs ["[s value]" "[s value from-index]"], :doc "Return index of value (string or char) in s, optionally searching\n  forward from from-index or nil if not found.", :end-row 261, :filename "clojure/string.cljs", :fixed-arities #{3 2}, :name "index-of", :ns "clojure.string", :row 249} {:arglist-strs ["[s value]" "[s value from-index]"], :doc "Return last index of value (string or char) in s, optionally\n  searching backward from from-index or nil if not found.", :end-row 275, :filename "clojure/string.cljs", :fixed-arities #{3 2}, :name "last-index-of", :ns "clojure.string", :row 263} {:arglist-strs ["[s substr]"], :doc "True if s starts with substr.", :end-row 280, :filename "clojure/string.cljs", :fixed-arities #{2}, :name "starts-with?", :ns "clojure.string", :row 277} {:arglist-strs ["[s substr]"], :doc "True if s ends with substr.", :end-row 285, :filename "clojure/string.cljs", :fixed-arities #{2}, :name "ends-with?", :ns "clojure.string", :row 282} {:arglist-strs ["[s substr]"], :doc "True if s includes substr.", :end-row 290, :filename "clojure/string.cljs", :fixed-arities #{2}, :name "includes?", :ns "clojure.string", :row 287}]} {:author "Rich Hickey", :doc "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet", :end-row 16, :filename "clojure/zip.cljs", :name "clojure.zip", :row 12, :ns nil, :var-definitions [{:arglist-strs ["[branch? children make-node root]"], :doc "Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node.", :end-row 32, :filename "clojure/zip.cljs", :fixed-arities #{4}, :name "zipper", :ns "clojure.zip", :row 18} {:arglist-strs ["[root]"], :doc "Returns a zipper for nested sequences, given a root sequence", :end-row 40, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "seq-zip", :ns "clojure.zip", :row 34} {:arglist-strs ["[root]"], :doc "Returns a zipper for nested vectors, given a root vector", :end-row 48, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "vector-zip", :ns "clojure.zip", :row 42} {:arglist-strs ["[root]"], :doc "Returns a zipper for xml elements (as from xml/parse),\n  given a root element", :end-row 58, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "xml-zip", :ns "clojure.zip", :row 50} {:arglist-strs ["[loc]"], :doc "Returns the node at loc", :end-row 62, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "node", :ns "clojure.zip", :row 60} {:arglist-strs ["[loc]"], :doc "Returns true if the node at loc is a branch", :end-row 67, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "branch?", :ns "clojure.zip", :row 64} {:arglist-strs ["[loc]"], :doc "Returns a seq of the children of node at loc, which must be a branch", :end-row 74, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "children", :ns "clojure.zip", :row 69} {:arglist-strs ["[loc node children]"], :doc "Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor.", :end-row 80, :filename "clojure/zip.cljs", :fixed-arities #{3}, :name "make-node", :ns "clojure.zip", :row 76} {:arglist-strs ["[loc]"], :doc "Returns a seq of nodes leading to this loc", :end-row 85, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "path", :ns "clojure.zip", :row 82} {:arglist-strs ["[loc]"], :doc "Returns a seq of the left siblings of this loc", :end-row 90, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "lefts", :ns "clojure.zip", :row 87} {:arglist-strs ["[loc]"], :doc "Returns a seq of the right siblings of this loc", :end-row 95, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "rights", :ns "clojure.zip", :row 92} {:arglist-strs ["[loc]"], :doc "Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children", :end-row 109, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "down", :ns "clojure.zip", :row 98} {:arglist-strs ["[loc]"], :doc "Returns the loc of the parent of the node at this loc, or nil if at\n  the top", :end-row 122, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "up", :ns "clojure.zip", :row 111} {:arglist-strs ["[loc]"], :doc "zips all the way up and returns the root node, reflecting any\n changes.", :end-row 133, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "root", :ns "clojure.zip", :row 124} {:arglist-strs ["[loc]"], :doc "Returns the loc of the right sibling of the node at this loc, or nil", :end-row 140, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "right", :ns "clojure.zip", :row 135} {:arglist-strs ["[loc]"], :doc "Returns the loc of the rightmost sibling of the node at this loc, or self", :end-row 148, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "rightmost", :ns "clojure.zip", :row 142} {:arglist-strs ["[loc]"], :doc "Returns the loc of the left sibling of the node at this loc, or nil", :end-row 155, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "left", :ns "clojure.zip", :row 150} {:arglist-strs ["[loc]"], :doc "Returns the loc of the leftmost sibling of the node at this loc, or self", :end-row 163, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "leftmost", :ns "clojure.zip", :row 157} {:arglist-strs ["[loc item]"], :doc "Inserts the item as the left sibling of the node at this loc,\n without moving", :end-row 172, :filename "clojure/zip.cljs", :fixed-arities #{2}, :name "insert-left", :ns "clojure.zip", :row 165} {:arglist-strs ["[loc item]"], :doc "Inserts the item as the right sibling of the node at this loc,\n  without moving", :end-row 181, :filename "clojure/zip.cljs", :fixed-arities #{2}, :name "insert-right", :ns "clojure.zip", :row 174} {:arglist-strs ["[loc node]"], :doc "Replaces the node at this loc, without moving", :end-row 187, :filename "clojure/zip.cljs", :fixed-arities #{2}, :name "replace", :ns "clojure.zip", :row 183} {:arglist-strs ["[loc f & args]"], :doc "Replaces the node at this loc with the value of (f node args)", :end-row 192, :filename "clojure/zip.cljs", :name "edit", :ns "clojure.zip", :row 189} {:arglist-strs ["[loc item]"], :doc "Inserts the item as the leftmost child of the node at this loc,\n  without moving", :end-row 198, :filename "clojure/zip.cljs", :fixed-arities #{2}, :name "insert-child", :ns "clojure.zip", :row 194} {:arglist-strs ["[loc item]"], :doc "Inserts the item as the rightmost child of the node at this loc,\n  without moving", :end-row 204, :filename "clojure/zip.cljs", :fixed-arities #{2}, :name "append-child", :ns "clojure.zip", :row 200} {:arglist-strs ["[loc]"], :doc "Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there.", :end-row 219, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "next", :ns "clojure.zip", :row 206} {:arglist-strs ["[loc]"], :doc "Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil.", :end-row 230, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "prev", :ns "clojure.zip", :row 221} {:arglist-strs ["[loc]"], :doc "Returns true if loc represents the end of a depth-first walk", :end-row 235, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "end?", :ns "clojure.zip", :row 232} {:arglist-strs ["[loc]"], :doc "Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk.", :end-row 251, :filename "clojure/zip.cljs", :fixed-arities #{1}, :name "remove", :ns "clojure.zip", :row 237} {:end-row 257, :filename "clojure/zip.cljs", :name "data", :ns "clojure.zip", :row 257} {:end-row 258, :filename "clojure/zip.cljs", :name "dz", :ns "clojure.zip", :row 258}]} {:end-row 10, :filename "clojure/browser/repl/preload.cljs", :name "clojure.browser.repl.preload", :row 9, :ns nil, :var-definitions [{:end-row 13, :filename "clojure/browser/repl/preload.cljs", :name "conn", :ns "clojure.browser.repl.preload", :row 12}]} {:end-row 11, :filename "clojure/browser/dom.cljs", :name "clojure.browser.dom", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[parent & children]"], :end-row 15, :filename "clojure/browser/dom.cljs", :name "append", :ns "clojure.browser.dom", :row 13} {:end-row 18, :filename "clojure/browser/dom.cljs", :name "DOMBuilder", :ns "clojure.browser.dom", :row 17} {:arglist-strs ["[this]" "[this attrs-or-children]" "[this attrs children]"], :end-row 18, :filename "clojure/browser/dom.cljs", :fixed-arities #{1 3 2}, :name "-element", :ns "clojure.browser.dom", :row 18} {:arglist-strs ["[& args]"], :end-row 21, :filename "clojure/browser/dom.cljs", :name "log", :ns "clojure.browser.dom", :row 20} {:arglist-strs ["[obj]"], :end-row 24, :filename "clojure/browser/dom.cljs", :fixed-arities #{1}, :name "log-obj", :ns "clojure.browser.dom", :row 23} {:arglist-strs ["[tag-or-text]" "[tag & children]"], :end-row 90, :filename "clojure/browser/dom.cljs", :fixed-arities #{1}, :name "element", :ns "clojure.browser.dom", :row 81} {:arglist-strs ["[id]"], :doc "Remove all children from the element with the passed id.", :end-row 96, :filename "clojure/browser/dom.cljs", :fixed-arities #{1}, :name "remove-children", :ns "clojure.browser.dom", :row 92} {:arglist-strs ["[id]"], :end-row 99, :filename "clojure/browser/dom.cljs", :fixed-arities #{1}, :name "get-element", :ns "clojure.browser.dom", :row 98} {:arglist-strs ["[s]"], :end-row 102, :filename "clojure/browser/dom.cljs", :fixed-arities #{1}, :name "html->dom", :ns "clojure.browser.dom", :row 101} {:arglist-strs ["[parent child index]"], :end-row 105, :filename "clojure/browser/dom.cljs", :fixed-arities #{3}, :name "insert-at", :ns "clojure.browser.dom", :row 104} {:arglist-strs ["[e]"], :doc "Coerce the argument to a dom element if possible.", :end-row 112, :filename "clojure/browser/dom.cljs", :fixed-arities #{1}, :name "ensure-element", :ns "clojure.browser.dom", :row 107} {:arglist-strs ["[old-node new-node]"], :doc "Replace old-node with new-node. old-node can be an element or a\n   keyword which is the id of the node to replace.  new-node can be an\n   element or an html string.", :end-row 122, :filename "clojure/browser/dom.cljs", :fixed-arities #{2}, :name "replace-node", :ns "clojure.browser.dom", :row 114} {:arglist-strs ["[e s]"], :doc "Set the text content for the passed element returning the\n  element. If a keyword is passed in the place of e, the element with\n  that id will be used and returned.", :end-row 129, :filename "clojure/browser/dom.cljs", :fixed-arities #{2}, :name "set-text", :ns "clojure.browser.dom", :row 124} {:arglist-strs ["[e]"], :doc "Get the value of an element.", :end-row 134, :filename "clojure/browser/dom.cljs", :fixed-arities #{1}, :name "get-value", :ns "clojure.browser.dom", :row 131} {:arglist-strs ["[e m]"], :doc "Set properties on an element", :end-row 140, :filename "clojure/browser/dom.cljs", :fixed-arities #{2}, :name "set-properties", :ns "clojure.browser.dom", :row 136} {:arglist-strs ["[e v]"], :doc "Set the value property for an element.", :end-row 145, :filename "clojure/browser/dom.cljs", :fixed-arities #{2}, :name "set-value", :ns "clojure.browser.dom", :row 142} {:arglist-strs ["[e]"], :end-row 149, :filename "clojure/browser/dom.cljs", :fixed-arities #{1}, :name "click-element", :ns "clojure.browser.dom", :row 147}]} {:author "Bobby Calderwood and Alex Redington", :doc "Network communication library, wrapping goog.net.\nIncludes a common API over XhrIo, CrossPageChannel, and Websockets.", :end-row 18, :filename "clojure/browser/net.cljs", :name "clojure.browser.net", :row 9, :ns nil, :var-definitions [{:end-row 20, :filename "clojure/browser/net.cljs", :name "*timeout*", :ns "clojure.browser.net", :row 20} {:end-row 29, :filename "clojure/browser/net.cljs", :name "event-types", :ns "clojure.browser.net", :row 22} {:end-row 43, :filename "clojure/browser/net.cljs", :name "IConnection", :ns "clojure.browser.net", :row 31} {:arglist-strs ["[this]" "[this opt1]" "[this opt1 opt2]" "[this opt1 opt2 opt3]"], :end-row 36, :filename "clojure/browser/net.cljs", :fixed-arities #{1 4 3 2}, :name "connect", :ns "clojure.browser.net", :row 32} {:arglist-strs ["[this opt]" "[this opt opt2]" "[this opt opt2 opt3]" "[this opt opt2 opt3 opt4]" "[this opt opt2 opt3 opt4 opt5]"], :end-row 42, :filename "clojure/browser/net.cljs", :fixed-arities #{4 6 3 2 5}, :name "transmit", :ns "clojure.browser.net", :row 37} {:arglist-strs ["[this]"], :end-row 43, :filename "clojure/browser/net.cljs", :fixed-arities #{1}, :name "close", :ns "clojure.browser.net", :row 43} {:end-row 80, :filename "clojure/browser/net.cljs", :name "xpc-config-fields", :ns "clojure.browser.net", :row 74} {:arglist-strs ["[]"], :doc "Returns an XhrIo connection", :end-row 85, :filename "clojure/browser/net.cljs", :fixed-arities #{0}, :name "xhr-connection", :ns "clojure.browser.net", :row 82} {:end-row 88, :filename "clojure/browser/net.cljs", :name "ICrossPageChannel", :ns "clojure.browser.net", :row 87} {:arglist-strs ["[this service-name fn]" "[this service-name fn encode-json?]"], :end-row 88, :filename "clojure/browser/net.cljs", :fixed-arities #{4 3}, :name "register-service", :ns "clojure.browser.net", :row 88} {:arglist-strs ["[]" "[config]"], :doc "When passed with a config hash-map, returns a parent\n  CrossPageChannel object. Keys in the config hash map are downcased\n  versions of the goog.net.xpc.CfgFields enum keys,\n  e.g. goog.net.xpc.CfgFields.PEER_URI becomes :peer_uri in the config\n  hash.\n\n  When passed with no args, creates a child CrossPageChannel object,\n  and the config is automatically taken from the URL param 'xpc', as\n  per the CrossPageChannel API.", :end-row 139, :filename "clojure/browser/net.cljs", :fixed-arities #{0 1}, :name "xpc-connection", :ns "clojure.browser.net", :row 117} {:end-row 145, :filename "clojure/browser/net.cljs", :name "IWebSocket", :ns "clojure.browser.net", :row 144} {:arglist-strs ["[this]"], :end-row 145, :filename "clojure/browser/net.cljs", :fixed-arities #{1}, :name "open?", :ns "clojure.browser.net", :row 145} {:arglist-strs ["[]" "[auto-reconnect?]" "[auto-reconnect? next-reconnect-fn]"], :end-row 181, :filename "clojure/browser/net.cljs", :fixed-arities #{0 1 2}, :name "websocket-connection", :ns "clojure.browser.net", :row 175}]} {:author "Bobby Calderwood", :doc "This namespace contains functions to work with browser\nevents.  It is based on the Google Closure Library event system.", :end-row 14, :filename "clojure/browser/event.cljs", :name "clojure.browser.event", :row 9, :ns nil, :var-definitions [{:end-row 17, :filename "clojure/browser/event.cljs", :name "IEventType", :ns "clojure.browser.event", :row 16} {:arglist-strs ["[this]"], :end-row 17, :filename "clojure/browser/event.cljs", :fixed-arities #{1}, :name "event-types", :ns "clojure.browser.event", :row 17} {:arglist-strs ["[src type fn]" "[src type fn capture?]"], :end-row 53, :filename "clojure/browser/event.cljs", :fixed-arities #{4 3}, :name "listen", :ns "clojure.browser.event", :row 46} {:arglist-strs ["[src type fn]" "[src type fn capture?]"], :end-row 62, :filename "clojure/browser/event.cljs", :fixed-arities #{4 3}, :name "listen-once", :ns "clojure.browser.event", :row 55} {:arglist-strs ["[src type fn]" "[src type fn capture?]"], :end-row 71, :filename "clojure/browser/event.cljs", :fixed-arities #{4 3}, :name "unlisten", :ns "clojure.browser.event", :row 64} {:arglist-strs ["[key]"], :end-row 75, :filename "clojure/browser/event.cljs", :fixed-arities #{1}, :name "unlisten-by-key", :ns "clojure.browser.event", :row 73} {:arglist-strs ["[src event]"], :end-row 79, :filename "clojure/browser/event.cljs", :fixed-arities #{2}, :name "dispatch-event", :ns "clojure.browser.event", :row 77} {:arglist-strs ["[e]"], :end-row 82, :filename "clojure/browser/event.cljs", :fixed-arities #{1}, :name "expose", :ns "clojure.browser.event", :row 81} {:arglist-strs ["[obj type capture event]"], :end-row 85, :filename "clojure/browser/event.cljs", :fixed-arities #{4}, :name "fire-listeners", :ns "clojure.browser.event", :row 84} {:arglist-strs ["[]"], :end-row 88, :filename "clojure/browser/event.cljs", :fixed-arities #{0}, :name "total-listener-count", :ns "clojure.browser.event", :row 87} {:arglist-strs ["[src type listener opt_capt opt_handler]"], :end-row 91, :filename "clojure/browser/event.cljs", :fixed-arities #{5}, :name "get-listener", :ns "clojure.browser.event", :row 91} {:arglist-strs ["[obj type capture]"], :end-row 92, :filename "clojure/browser/event.cljs", :fixed-arities #{3}, :name "all-listeners", :ns "clojure.browser.event", :row 92} {:arglist-strs ["[event-type]"], :end-row 94, :filename "clojure/browser/event.cljs", :fixed-arities #{1}, :name "unique-event-id", :ns "clojure.browser.event", :row 94} {:arglist-strs ["[obj opt_type opt_capture]"], :end-row 96, :filename "clojure/browser/event.cljs", :fixed-arities #{3}, :name "has-listener", :ns "clojure.browser.event", :row 96} {:arglist-strs ["[opt_obj opt_type opt_capt]"], :end-row 100, :filename "clojure/browser/event.cljs", :fixed-arities #{3}, :name "remove-all", :ns "clojure.browser.event", :row 100}]} {:author "Bobby Calderwood and Alex Redington", :doc "Receive - Eval - Print - Loop\n\n  Receive a block of JS (presumably generated by a ClojureScript compiler)\n  Evaluate it naively\n  Print the result of evaluation to a string\n  Send the resulting string back to the server Loop!", :end-row 29, :filename "clojure/browser/repl.cljs", :name "clojure.browser.repl", :row 9, :ns nil, :var-definitions [{:end-row 31, :filename "clojure/browser/repl.cljs", :name "HOST", :ns "clojure.browser.repl", :row 31} {:end-row 32, :filename "clojure/browser/repl.cljs", :name "PORT", :ns "clojure.browser.repl", :row 32} {:end-row 34, :filename "clojure/browser/repl.cljs", :name "*repl*", :ns "clojure.browser.repl", :row 34} {:end-row 37, :filename "clojure/browser/repl.cljs", :name "xpc-connection", :ns "clojure.browser.repl", :row 37} {:end-row 38, :filename "clojure/browser/repl.cljs", :name "parent-connected?", :ns "clojure.browser.repl", :row 38} {:end-row 41, :filename "clojure/browser/repl.cljs", :name "print-queue", :ns "clojure.browser.repl", :row 41} {:arglist-strs ["[conn]"], :end-row 49, :filename "clojure/browser/repl.cljs", :fixed-arities #{1}, :name "flush-print-queue!", :ns "clojure.browser.repl", :row 43} {:arglist-strs ["[data]"], :end-row 54, :filename "clojure/browser/repl.cljs", :fixed-arities #{1}, :name "repl-print", :ns "clojure.browser.repl", :row 51} {:arglist-strs ["[]"], :end-row 65, :filename "clojure/browser/repl.cljs", :fixed-arities #{0}, :name "get-ua-product", :ns "clojure.browser.repl", :row 60} {:arglist-strs ["[conn block]"], :doc "Process a single block of JavaScript received from the server", :end-row 77, :filename "clojure/browser/repl.cljs", :fixed-arities #{2}, :name "evaluate-javascript", :ns "clojure.browser.repl", :row 67} {:arglist-strs ["[connection url data]"], :end-row 80, :filename "clojure/browser/repl.cljs", :fixed-arities #{3}, :name "send-result", :ns "clojure.browser.repl", :row 79} {:arglist-strs ["[url data]" "[url data n]"], :doc "Send data to be printed in the REPL. If there is an error, try again\n  up to 10 times.", :end-row 94, :filename "clojure/browser/repl.cljs", :fixed-arities #{3 2}, :name "send-print", :ns "clojure.browser.repl", :row 82} {:end-row 96, :filename "clojure/browser/repl.cljs", :name "order", :ns "clojure.browser.repl", :row 96} {:arglist-strs ["[repl t data]"], :end-row 103, :filename "clojure/browser/repl.cljs", :fixed-arities #{3}, :name "wrap-message", :ns "clojure.browser.repl", :row 98} {:arglist-strs ["[url]"], :doc "Start the REPL server connection process. This process runs inside the\n  embedded iframe.", :end-row 158, :filename "clojure/browser/repl.cljs", :fixed-arities #{1}, :name "start-evaluator", :ns "clojure.browser.repl", :row 105} {:end-row 160, :filename "clojure/browser/repl.cljs", :name "load-queue", :ns "clojure.browser.repl", :row 160} {:arglist-strs ["[]"], :doc "Reusable browser REPL bootstrapping. Patches the essential functions\n  in goog.base to support re-loading of namespaces after page load.", :end-row 233, :filename "clojure/browser/repl.cljs", :fixed-arities #{0}, :name "bootstrap", :ns "clojure.browser.repl", :row 162} {:arglist-strs ["[repl-server-url]"], :doc "Connects to a REPL server from an HTML document. After the\n  connection is made, the REPL will evaluate forms in the context of\n  the document that called this function.", :end-row 278, :filename "clojure/browser/repl.cljs", :fixed-arities #{1}, :name "connect", :ns "clojure.browser.repl", :row 235}]} {:author "Stuart Halloway", :doc "Non-core data functions.", :end-row 13, :filename "clojure/data.cljs", :name "clojure.data", :row 9, :ns nil, :var-definitions [{:end-row 15, :filename "clojure/data.cljs", :name "diff", :ns "clojure.data", :row 15} {:fixed-arities #{2}, :end-row 20, :private true, :ns "clojure.data", :name "atom-diff", :filename "clojure/data.cljs", :arglist-strs ["[a b]"], :doc "Internal helper for diff.", :row 17} {:fixed-arities #{1}, :end-row 31, :private true, :ns "clojure.data", :name "vectorize", :filename "clojure/data.cljs", :arglist-strs ["[m]"], :doc "Convert an associative-by-numeric-index collection into\n   an equivalent vector, with nil for any missing keys", :row 23} {:fixed-arities #{3}, :end-row 47, :private true, :ns "clojure.data", :name "diff-associative-key", :filename "clojure/data.cljs", :arglist-strs ["[a b k]"], :doc "Diff associative things a and b, comparing only the key k.", :row 33} {:fixed-arities #{3 2}, :end-row 60, :private true, :ns "clojure.data", :name "diff-associative", :filename "clojure/data.cljs", :arglist-strs ["[a b]" "[a b ks]"], :doc "Diff associative things a and b, comparing only keys in ks (if supplied).", :row 49} {:arglist-strs ["[a b]"], :end-row 67, :filename "clojure/data.cljs", :fixed-arities #{2}, :name "diff-sequential", :ns "clojure.data", :private true, :row 62} {:arglist-strs ["[a b]"], :end-row 73, :filename "clojure/data.cljs", :fixed-arities #{2}, :name "diff-set", :ns "clojure.data", :private true, :row 69} {:doc "Implementation detail. Subject to change.", :end-row 77, :filename "clojure/data.cljs", :name "EqualityPartition", :ns "clojure.data", :row 75} {:arglist-strs ["[x]"], :doc "Implementation detail. Subject to change.", :end-row 77, :filename "clojure/data.cljs", :fixed-arities #{1}, :name "equality-partition", :ns "clojure.data", :row 77} {:doc "Implementation detail. Subject to change.", :end-row 81, :filename "clojure/data.cljs", :name "Diff", :ns "clojure.data", :row 79} {:arglist-strs ["[a b]"], :doc "Implementation detail. Subject to change.", :end-row 81, :filename "clojure/data.cljs", :fixed-arities #{2}, :name "diff-similar", :ns "clojure.data", :row 81} {:arglist-strs ["[a b]"], :doc "Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.", :end-row 161, :filename "clojure/data.cljs", :fixed-arities #{2}, :name "diff", :ns "clojure.data", :row 144}]} {:doc "Functions to turn objects into data. Alpha, subject to change", :end-row 12, :filename "clojure/datafy.cljs", :name "clojure.datafy", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[x]"], :doc "Attempts to return x as data.\n  datafy will return the value of clojure.protocols/datafy. If\n  the value has been transformed and the result supports\n  metadata, :clojure.datafy/obj will be set on the metadata to the\n  original value of x.", :end-row 29, :filename "clojure/datafy.cljs", :fixed-arities #{1}, :name "datafy", :ns "clojure.datafy", :row 14} {:arglist-strs ["[coll k v]"], :doc "Returns (possibly transformed) v in the context of coll and k (a\n  key/index or nil). Callers should attempt to provide the key/index\n  context k for Indexed/Associative/ILookup colls if possible, but not\n  to fabricate one e.g. for sequences (pass nil). nav will return the\n  value of clojure.core.protocols/nav.", :end-row 38, :filename "clojure/datafy.cljs", :fixed-arities #{3}, :name "nav", :ns "clojure.datafy", :row 31} {:arglist-strs ["[r]"], :end-row 41, :filename "clojure/datafy.cljs", :fixed-arities #{1}, :name "datify-ref", :ns "clojure.datafy", :private true, :row 40}]} {:author "Rich Hickey", :doc "Set operations such as union/intersection.", :end-row 11, :filename "clojure/set.cljs", :name "clojure.set", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[k coll]"], :end-row 17, :filename "clojure/set.cljs", :fixed-arities #{2}, :name "bubble-max-key", :ns "clojure.set", :private true, :row 13} {:arglist-strs ["[]" "[s1]" "[s1 s2]" "[s1 s2 & sets]"], :doc "Return a set that is the union of the input sets", :end-row 29, :filename "clojure/set.cljs", :fixed-arities #{0 1 2}, :name "union", :ns "clojure.set", :row 19} {:arglist-strs ["[s1]" "[s1 s2]" "[s1 s2 & sets]"], :doc "Return a set that is the intersection of the input sets", :end-row 44, :filename "clojure/set.cljs", :fixed-arities #{1 2}, :name "intersection", :ns "clojure.set", :row 31} {:arglist-strs ["[s1]" "[s1 s2]" "[s1 s2 & sets]"], :doc "Return a set that is the first set without elements of the remaining sets", :end-row 58, :filename "clojure/set.cljs", :fixed-arities #{1 2}, :name "difference", :ns "clojure.set", :row 46} {:arglist-strs ["[pred xset]"], :doc "Returns a set of the elements for which pred is true", :end-row 65, :filename "clojure/set.cljs", :fixed-arities #{2}, :name "select", :ns "clojure.set", :row 61} {:arglist-strs ["[xrel ks]"], :doc "Returns a rel of the elements of xrel with only the keys in ks", :end-row 70, :filename "clojure/set.cljs", :fixed-arities #{2}, :name "project", :ns "clojure.set", :row 67} {:arglist-strs ["[map kmap]"], :doc "Returns the map with the keys in kmap renamed to the vals in kmap", :end-row 80, :filename "clojure/set.cljs", :fixed-arities #{2}, :name "rename-keys", :ns "clojure.set", :row 72} {:arglist-strs ["[xrel kmap]"], :doc "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap", :end-row 85, :filename "clojure/set.cljs", :fixed-arities #{2}, :name "rename", :ns "clojure.set", :row 82} {:arglist-strs ["[xrel ks]"], :doc "Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.", :end-row 95, :filename "clojure/set.cljs", :fixed-arities #{2}, :name "index", :ns "clojure.set", :row 87} {:arglist-strs ["[m]"], :doc "Returns the map with the vals mapped to the keys.", :end-row 103, :filename "clojure/set.cljs", :fixed-arities #{1}, :name "map-invert", :ns "clojure.set", :row 97} {:arglist-strs ["[xrel yrel]" "[xrel yrel km]"], :doc "When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.", :end-row 133, :filename "clojure/set.cljs", :fixed-arities #{3 2}, :name "join", :ns "clojure.set", :row 105} {:arglist-strs ["[set1 set2]"], :doc "Is set1 a subset of set2?", :end-row 139, :filename "clojure/set.cljs", :fixed-arities #{2}, :name "subset?", :ns "clojure.set", :row 135} {:arglist-strs ["[set1 set2]"], :doc "Is set1 a superset of set2?", :end-row 145, :filename "clojure/set.cljs", :fixed-arities #{2}, :name "superset?", :ns "clojure.set", :row 141} {:end-row 151, :filename "clojure/set.cljs", :name "xs", :ns "clojure.set", :row 149} {:end-row 155, :filename "clojure/set.cljs", :name "ys", :ns "clojure.set", :row 153}]} {:end-row 9, :filename "clojure/core/protocols.cljs", :name "clojure.core.protocols", :row 9, :ns nil, :var-definitions [{:end-row 13, :filename "clojure/core/protocols.cljs", :name "Datafiable", :ns "clojure.core.protocols", :row 11} {:arglist-strs ["[o]"], :doc "return a representation of o as data (default identity)", :end-row 13, :filename "clojure/core/protocols.cljs", :fixed-arities #{1}, :name "datafy", :ns "clojure.core.protocols", :row 13} {:end-row 25, :filename "clojure/core/protocols.cljs", :name "Navigable", :ns "clojure.core.protocols", :row 22} {:arglist-strs ["[coll k v]"], :doc "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v.", :end-row 25, :filename "clojure/core/protocols.cljs", :fixed-arities #{3}, :name "nav", :ns "clojure.core.protocols", :row 24}]} {:author "Rich Hickey", :doc "A library for reduction and parallel folding. Alpha and subject\n      to change.  Note that fold and its derivatives require\n      jsr166y.jar for fork/join support. See Clojure's pom.xml for the\n      dependency info.", :end-row 17, :filename "clojure/core/reducers.cljs", :name "clojure.core.reducers", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[f]"], :end-row 21, :filename "clojure/core/reducers.cljs", :fixed-arities #{1}, :name "fjtask", :ns "clojure.core.reducers", :private true, :row 20} {:arglist-strs ["[f]"], :end-row 24, :filename "clojure/core/reducers.cljs", :fixed-arities #{1}, :name "fjinvoke", :ns "clojure.core.reducers", :private true, :row 23} {:arglist-strs ["[task]"], :end-row 27, :filename "clojure/core/reducers.cljs", :fixed-arities #{1}, :name "fjfork", :ns "clojure.core.reducers", :private true, :row 26} {:arglist-strs ["[task]"], :end-row 30, :filename "clojure/core/reducers.cljs", :fixed-arities #{1}, :name "fjjoin", :ns "clojure.core.reducers", :private true, :row 29} {:arglist-strs ["[f coll]" "[f init coll]"], :doc "Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv", :end-row 44, :filename "clojure/core/reducers.cljs", :fixed-arities #{3 2}, :name "reduce", :ns "clojure.core.reducers", :row 33} {:end-row 47, :filename "clojure/core/reducers.cljs", :name "CollFold", :ns "clojure.core.reducers", :row 46} {:arglist-strs ["[coll n combinef reducef]"], :end-row 47, :filename "clojure/core/reducers.cljs", :fixed-arities #{4}, :name "coll-fold", :ns "clojure.core.reducers", :row 47} {:arglist-strs ["[reducef coll]" "[combinef reducef coll]" "[n combinef reducef coll]"], :doc "Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.\n\n  Note: Performing operations in parallel is currently not implemented.", :end-row 64, :filename "clojure/core/reducers.cljs", :fixed-arities #{4 3 2}, :name "fold", :ns "clojure.core.reducers", :row 49} {:arglist-strs ["[coll xf]"], :doc "Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.", :end-row 77, :filename "clojure/core/reducers.cljs", :fixed-arities #{2}, :name "reducer", :ns "clojure.core.reducers", :row 66} {:arglist-strs ["[coll xf]"], :doc "Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.", :end-row 94, :filename "clojure/core/reducers.cljs", :fixed-arities #{2}, :name "folder", :ns "clojure.core.reducers", :row 79} {:end-row 211, :filename "clojure/core/reducers.cljs", :name "Cat", :ns "clojure.core.reducers", :row 193} {:arglist-strs ["[cnt left right]"], :end-row 211, :filename "clojure/core/reducers.cljs", :fixed-arities #{3}, :name "->Cat", :ns "clojure.core.reducers", :row 193} {:arglist-strs ["[]" "[ctor]" "[left right]"], :doc "A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.", :end-row 230, :filename "clojure/core/reducers.cljs", :fixed-arities #{0 1 2}, :name "cat", :ns "clojure.core.reducers", :row 213} {:arglist-strs ["[acc x]"], :doc ".adds x to acc and returns acc", :end-row 235, :filename "clojure/core/reducers.cljs", :fixed-arities #{2}, :name "append!", :ns "clojure.core.reducers", :row 232} {:arglist-strs ["[coll]"], :doc "Equivalent to (fold cat append! coll)", :end-row 240, :filename "clojure/core/reducers.cljs", :fixed-arities #{1}, :name "foldcat", :ns "clojure.core.reducers", :row 237} {:arglist-strs ["[op ctor]"], :doc "Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it.", :end-row 249, :filename "clojure/core/reducers.cljs", :fixed-arities #{2}, :name "monoid", :ns "clojure.core.reducers", :row 242} {:end-row 254, :filename "clojure/core/reducers.cljs", :name "v", :ns "clojure.core.reducers", :row 254} {:arglist-strs ["[v n combinef reducef]"], :end-row 287, :filename "clojure/core/reducers.cljs", :fixed-arities #{4}, :name "foldvec", :ns "clojure.core.reducers", :private true, :row 273}]}]