[{:author "Stuart Sierra, Stuart Halloway, David Liebke", :doc "Clojure String utilities\n\nIt is poor form to (:use clojure.string). Instead, use require\nwith :as to specify a prefix, e.g.\n\n(ns your.namespace.here\n  (:require [clojure.string :as str]))\n\nDesign notes for clojure.string:\n\n1. Strings are objects (as opposed to sequences). As such, the\n   string being manipulated is the first argument to a function;\n   passing nil will result in a NullPointerException unless\n   documented otherwise. If you want sequence-y behavior instead,\n   use a sequence.\n\n2. Functions are generally not lazy, and call straight to host\n   methods where those are available and efficient.\n\n3. Functions take advantage of String implementation details to\n   write high-performing loop/recurs instead of using higher-order\n   functions. (This is not idiomatic in general-purpose application\n   code.)\n\n4. When a function is documented to accept a string argument, it\n   will take any implementation of the correct *interface* on the\n   host platform. In Java, this is CharSequence, which is more\n   general than String. In ordinary usage you will almost always\n   pass concrete strings. If you are doing something unusual,\n   e.g. passing a mutable implementation of CharSequence, then\n   thread-safety is your responsibility.", :end-row 44, :filename "clojure/string.clj", :name "clojure.string", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[s]"], :doc "Returns s with its characters reversed.", :end-row 52, :filename "clojure/string.clj", :fixed-arities #{1}, :name "reverse", :ns "clojure.string", :row 48} {:arglist-strs ["[replacement]"], :doc "Given a replacement string that you wish to be a literal\n   replacement for a pattern match in replace or replace-first, do the\n   necessary escaping of special characters in the replacement.", :end-row 60, :filename "clojure/string.clj", :fixed-arities #{1}, :name "re-quote-replacement", :ns "clojure.string", :row 54} {:arglist-strs ["[s re f]"], :end-row 73, :filename "clojure/string.clj", :fixed-arities #{3}, :name "replace-by", :ns "clojure.string", :private true, :row 62} {:arglist-strs ["[s match replacement]"], :doc "Replaces all instance of match with replacement in s.\n\n   match/replacement can be:\n\n   string / string\n   char / char\n   pattern / (string or function of match).\n\n   See also replace-first.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace \"Almost Pig Latin\" #\"\\b(\\w)(\\w+)\\b\" \"$2$1ay\")\n   -> \"lmostAay igPay atinLay\"", :end-row 109, :filename "clojure/string.clj", :fixed-arities #{3}, :name "replace", :ns "clojure.string", :row 75} {:arglist-strs ["[s re f]"], :end-row 120, :filename "clojure/string.clj", :fixed-arities #{3}, :name "replace-first-by", :ns "clojure.string", :private true, :row 111} {:arglist-strs ["[s match replace]"], :end-row 128, :filename "clojure/string.clj", :fixed-arities #{3}, :name "replace-first-char", :ns "clojure.string", :private true, :row 122} {:arglist-strs ["[s match replace]"], :end-row 136, :filename "clojure/string.clj", :fixed-arities #{3}, :name "replace-first-str", :ns "clojure.string", :private true, :row 130} {:arglist-strs ["[s match replacement]"], :doc "Replaces the first instance of match with replacement in s.\n\n   match/replacement can be:\n\n   char / char\n   string / string\n   pattern / (string or function of match).\n\n   See also replace.\n\n   The replacement is literal (i.e. none of its characters are treated\n   specially) for all cases above except pattern / string.\n\n   For pattern / string, $1, $2, etc. in the replacement string are\n   substituted with the string that matched the corresponding\n   parenthesized group in the pattern.  If you wish your replacement\n   string r to be used literally, use (re-quote-replacement r) as the\n   replacement argument.  See also documentation for\n   java.util.regex.Matcher's appendReplacement method.\n\n   Example:\n   (clojure.string/replace-first \"swap first two words\"\n                                 #\"(\\w+)(\\s+)(\\w+)\" \"$3$2$1\")\n   -> \"first swap two words\"", :end-row 177, :filename "clojure/string.clj", :fixed-arities #{3}, :name "replace-first", :ns "clojure.string", :row 138} {:arglist-strs ["[coll]" "[separator coll]"], :doc "Returns a string of all elements in coll, as returned by (seq coll),\n   separated by an optional separator.", :end-row 194, :filename "clojure/string.clj", :fixed-arities #{1 2}, :name "join", :ns "clojure.string", :row 180} {:arglist-strs ["[s]"], :doc "Converts first character of the string to upper-case, all other\n  characters to lower-case.", :end-row 205, :filename "clojure/string.clj", :fixed-arities #{1}, :name "capitalize", :ns "clojure.string", :row 196} {:arglist-strs ["[s]"], :doc "Converts string to all upper-case.", :end-row 211, :filename "clojure/string.clj", :fixed-arities #{1}, :name "upper-case", :ns "clojure.string", :row 207} {:arglist-strs ["[s]"], :doc "Converts string to all lower-case.", :end-row 217, :filename "clojure/string.clj", :fixed-arities #{1}, :name "lower-case", :ns "clojure.string", :row 213} {:arglist-strs ["[s re]" "[s re limit]"], :doc "Splits string on a regular expression.  Optional argument limit is\n  the maximum number of parts. Not lazy. Returns vector of the parts.\n  Trailing empty strings are not returned - pass limit of -1 to return all.", :end-row 227, :filename "clojure/string.clj", :fixed-arities #{3 2}, :name "split", :ns "clojure.string", :row 219} {:arglist-strs ["[s]"], :doc "Splits s on \\n or \\r\\n. Trailing empty lines are not returned.", :end-row 233, :filename "clojure/string.clj", :fixed-arities #{1}, :name "split-lines", :ns "clojure.string", :row 229} {:arglist-strs ["[s]"], :doc "Removes whitespace from both ends of string.", :end-row 250, :filename "clojure/string.clj", :fixed-arities #{1}, :name "trim", :ns "clojure.string", :row 235} {:arglist-strs ["[s]"], :doc "Removes whitespace from the left side of string.", :end-row 262, :filename "clojure/string.clj", :fixed-arities #{1}, :name "triml", :ns "clojure.string", :row 252} {:arglist-strs ["[s]"], :doc "Removes whitespace from the right side of string.", :end-row 273, :filename "clojure/string.clj", :fixed-arities #{1}, :name "trimr", :ns "clojure.string", :row 264} {:arglist-strs ["[s]"], :doc "Removes all trailing newline \\n or return \\r characters from\n  string.  Similar to Perl's chomp.", :end-row 286, :filename "clojure/string.clj", :fixed-arities #{1}, :name "trim-newline", :ns "clojure.string", :row 275} {:arglist-strs ["[s]"], :doc "True if s is nil, empty, or contains only whitespace.", :end-row 299, :filename "clojure/string.clj", :fixed-arities #{1}, :name "blank?", :ns "clojure.string", :row 288} {:arglist-strs ["[s cmap]"], :doc "Return a new string, using cmap to escape each character ch\n   from s as follows:\n   \n   If (cmap ch) is nil, append ch to the new string.\n   If (cmap ch) is non-nil, append (str (cmap ch)) instead.", :end-row 317, :filename "clojure/string.clj", :fixed-arities #{2}, :name "escape", :ns "clojure.string", :row 301} {:arglist-strs ["[s value]" "[s value from-index]"], :doc "Return index of value (string or char) in s, optionally searching\n  forward from from-index. Return nil if value not found.", :end-row 338, :filename "clojure/string.clj", :fixed-arities #{3 2}, :name "index-of", :ns "clojure.string", :row 319} {:arglist-strs ["[s value]" "[s value from-index]"], :doc "Return last index of value (string or char) in s, optionally\n  searching backward from from-index. Return nil if value not found.", :end-row 359, :filename "clojure/string.clj", :fixed-arities #{3 2}, :name "last-index-of", :ns "clojure.string", :row 340} {:arglist-strs ["[s substr]"], :doc "True if s starts with substr.", :end-row 365, :filename "clojure/string.clj", :fixed-arities #{2}, :name "starts-with?", :ns "clojure.string", :row 361} {:arglist-strs ["[s substr]"], :doc "True if s ends with substr.", :end-row 371, :filename "clojure/string.clj", :fixed-arities #{2}, :name "ends-with?", :ns "clojure.string", :row 367} {:arglist-strs ["[s substr]"], :doc "True if s includes substr.", :end-row 377, :filename "clojure/string.clj", :fixed-arities #{2}, :name "includes?", :ns "clojure.string", :row 373}]} {:author "Rich Hickey", :doc "Set operations such as union/intersection.", :end-row 11, :filename "clojure/set.clj", :name "clojure.set", :row 9, :ns nil, :var-definitions [{:fixed-arities #{2}, :end-row 18, :private true, :ns "clojure.set", :name "bubble-max-key", :filename "clojure/set.clj", :arglist-strs ["[k coll]"], :doc "Move a maximal element of coll according to fn k (which returns a\n  number) to the front of coll.", :row 13} {:arglist-strs ["[]" "[s1]" "[s1 s2]" "[s1 s2 & sets]"], :doc "Return a set that is the union of the input sets", :end-row 31, :filename "clojure/set.clj", :fixed-arities #{0 1 2}, :name "union", :ns "clojure.set", :row 20} {:arglist-strs ["[s1]" "[s1 s2]" "[s1 s2 & sets]"], :doc "Return a set that is the intersection of the input sets", :end-row 47, :filename "clojure/set.clj", :fixed-arities #{1 2}, :name "intersection", :ns "clojure.set", :row 33} {:arglist-strs ["[s1]" "[s1 s2]" "[s1 s2 & sets]"], :doc "Return a set that is the first set without elements of the remaining sets", :end-row 62, :filename "clojure/set.clj", :fixed-arities #{1 2}, :name "difference", :ns "clojure.set", :row 49} {:arglist-strs ["[pred xset]"], :doc "Returns a set of the elements for which pred is true", :end-row 70, :filename "clojure/set.clj", :fixed-arities #{2}, :name "select", :ns "clojure.set", :row 65} {:arglist-strs ["[xrel ks]"], :doc "Returns a rel of the elements of xrel with only the keys in ks", :end-row 76, :filename "clojure/set.clj", :fixed-arities #{2}, :name "project", :ns "clojure.set", :row 72} {:arglist-strs ["[map kmap]"], :doc "Returns the map with the keys in kmap renamed to the vals in kmap", :end-row 87, :filename "clojure/set.clj", :fixed-arities #{2}, :name "rename-keys", :ns "clojure.set", :row 78} {:arglist-strs ["[xrel kmap]"], :doc "Returns a rel of the maps in xrel with the keys in kmap renamed to the vals in kmap", :end-row 93, :filename "clojure/set.clj", :fixed-arities #{2}, :name "rename", :ns "clojure.set", :row 89} {:arglist-strs ["[xrel ks]"], :doc "Returns a map of the distinct values of ks in the xrel mapped to a\n  set of the maps in xrel with the corresponding values of ks.", :end-row 104, :filename "clojure/set.clj", :fixed-arities #{2}, :name "index", :ns "clojure.set", :row 95} {:arglist-strs ["[m]"], :doc "Returns the map with the vals mapped to the keys.", :end-row 113, :filename "clojure/set.clj", :fixed-arities #{1}, :name "map-invert", :ns "clojure.set", :row 106} {:arglist-strs ["[xrel yrel]" "[xrel yrel km]"], :doc "When passed 2 rels, returns the rel corresponding to the natural\n  join. When passed an additional keymap, joins on the corresponding\n  keys.", :end-row 144, :filename "clojure/set.clj", :fixed-arities #{3 2}, :name "join", :ns "clojure.set", :row 115} {:arglist-strs ["[set1 set2]"], :doc "Is set1 a subset of set2?", :end-row 152, :filename "clojure/set.clj", :fixed-arities #{2}, :name "subset?", :ns "clojure.set", :row 146} {:arglist-strs ["[set1 set2]"], :doc "Is set1 a superset of set2?", :end-row 160, :filename "clojure/set.clj", :fixed-arities #{2}, :name "superset?", :ns "clojure.set", :row 154} {:end-row 166, :filename "clojure/set.clj", :name "xs", :ns "clojure.set", :row 164} {:end-row 170, :filename "clojure/set.clj", :name "ys", :ns "clojure.set", :row 168}]} {:author "Jason Sankey", :doc "clojure.test extension for JUnit-compatible XML output.\n\n  JUnit (http://junit.org/) is the most popular unit-testing library\n  for Java.  As such, tool support for JUnit output formats is\n  common.  By producing compatible output from tests, this tool\n  support can be exploited.\n\n  To use, wrap any calls to clojure.test/run-tests in the\n  with-junit-output macro, like this:\n\n    (use 'clojure.test)\n    (use 'clojure.test.junit)\n\n    (with-junit-output\n      (run-tests 'my.cool.library))\n\n  To write the output to a file, rebind clojure.test/*test-out* to\n  your own PrintWriter (perhaps opened using\n  clojure.java.io/writer).", :end-row 39, :filename "clojure/test/junit.clj", :name "clojure.test.junit", :row 17, :ns nil, :var-definitions [{:end-row 44, :filename "clojure/test/junit.clj", :name "escape-xml-map", :ns "clojure.test.junit", :private true, :row 42} {:arglist-strs ["[text]"], :end-row 46, :filename "clojure/test/junit.clj", :fixed-arities #{1}, :name "escape-xml", :ns "clojure.test.junit", :private true, :row 45} {:end-row 48, :filename "clojure/test/junit.clj", :name "*var-context*", :ns "clojure.test.junit", :row 48} {:end-row 49, :filename "clojure/test/junit.clj", :name "*depth*", :ns "clojure.test.junit", :row 49} {:arglist-strs ["[]"], :end-row 53, :filename "clojure/test/junit.clj", :fixed-arities #{0}, :name "indent", :ns "clojure.test.junit", :row 51} {:arglist-strs ["[tag pretty & [attrs]]"], :end-row 64, :filename "clojure/test/junit.clj", :name "start-element", :ns "clojure.test.junit", :row 55} {:arglist-strs ["[content]"], :end-row 68, :filename "clojure/test/junit.clj", :fixed-arities #{1}, :name "element-content", :ns "clojure.test.junit", :row 66} {:arglist-strs ["[tag pretty]"], :end-row 75, :filename "clojure/test/junit.clj", :fixed-arities #{2}, :name "finish-element", :ns "clojure.test.junit", :row 70} {:arglist-strs ["[vars]"], :end-row 80, :filename "clojure/test/junit.clj", :fixed-arities #{1}, :name "test-name", :ns "clojure.test.junit", :row 77} {:arglist-strs ["[name]"], :end-row 87, :filename "clojure/test/junit.clj", :fixed-arities #{1}, :name "package-class", :ns "clojure.test.junit", :row 82} {:arglist-strs ["[name classname]"], :end-row 91, :filename "clojure/test/junit.clj", :fixed-arities #{2}, :name "start-case", :ns "clojure.test.junit", :row 89} {:arglist-strs ["[]"], :end-row 95, :filename "clojure/test/junit.clj", :fixed-arities #{0}, :name "finish-case", :ns "clojure.test.junit", :row 93} {:arglist-strs ["[package classname]"], :end-row 102, :filename "clojure/test/junit.clj", :fixed-arities #{2}, :name "suite-attrs", :ns "clojure.test.junit", :row 97} {:arglist-strs ["[name]"], :end-row 107, :filename "clojure/test/junit.clj", :fixed-arities #{1}, :name "start-suite", :ns "clojure.test.junit", :row 104} {:arglist-strs ["[]"], :end-row 111, :filename "clojure/test/junit.clj", :fixed-arities #{0}, :name "finish-suite", :ns "clojure.test.junit", :row 109} {:arglist-strs ["[tag message expected-str actual-str]"], :end-row 126, :filename "clojure/test/junit.clj", :fixed-arities #{4}, :name "message-el", :ns "clojure.test.junit", :row 113} {:arglist-strs ["[message expected actual]"], :end-row 130, :filename "clojure/test/junit.clj", :fixed-arities #{3}, :name "failure-el", :ns "clojure.test.junit", :row 128} {:arglist-strs ["[message expected actual]"], :end-row 139, :filename "clojure/test/junit.clj", :fixed-arities #{3}, :name "error-el", :ns "clojure.test.junit", :row 132} {:end-row 142, :filename "clojure/test/junit.clj", :name "junit-report", :ns "clojure.test.junit", :row 142} {:arglist-strs ["[& body]"], :doc "Execute body with modified test-is reporting functions that write\n  JUnit-compatible XML output.", :end-row 195, :filename "clojure/test/junit.clj", :macro true, :name "with-junit-output", :ns "clojure.test.junit", :row 182}]} {:author "Stuart Sierra", :doc "clojure.test extensions for the Test Anything Protocol (TAP)\n\n  TAP is a simple text-based syntax for reporting test results.  TAP\n  was originally developed for Perl, and now has implementations in\n  several languages.  For more information on TAP, see\n  http://testanything.org/ and\n  http://search.cpan.org/~petdance/TAP-1.0.0/TAP.pm\n\n  To use this library, wrap any calls to\n  clojure.test/run-tests in the with-tap-output macro,\n  like this:\n\n    (use 'clojure.test)\n    (use 'clojure.test.tap)\n\n    (with-tap-output\n     (run-tests 'my.cool.library))", :end-row 43, :filename "clojure/test/tap.clj", :name "clojure.test.tap", :row 23, :ns nil, :var-definitions [{:arglist-strs ["[n]"], :doc "Prints a TAP plan line like '1..n'.  n is the number of tests", :end-row 49, :filename "clojure/test/tap.clj", :fixed-arities #{1}, :name "print-tap-plan", :ns "clojure.test.tap", :row 45} {:arglist-strs ["[data]"], :doc "Prints a TAP diagnostic line.  data is a (possibly multi-line)\n  string.", :end-row 57, :filename "clojure/test/tap.clj", :fixed-arities #{1}, :name "print-tap-diagnostic", :ns "clojure.test.tap", :row 51} {:arglist-strs ["[msg]"], :doc "Prints a TAP 'ok' line.  msg is a string, with no line breaks", :end-row 63, :filename "clojure/test/tap.clj", :fixed-arities #{1}, :name "print-tap-pass", :ns "clojure.test.tap", :row 59} {:arglist-strs ["[msg]"], :doc "Prints a TAP 'not ok' line.  msg is a string, with no line breaks", :end-row 69, :filename "clojure/test/tap.clj", :fixed-arities #{1}, :name "print-tap-fail", :ns "clojure.test.tap", :row 65} {:end-row 72, :filename "clojure/test/tap.clj", :name "tap-report", :ns "clojure.test.tap", :row 72} {:arglist-strs ["[data]"], :end-row 92, :filename "clojure/test/tap.clj", :fixed-arities #{1}, :name "print-diagnostics", :ns "clojure.test.tap", :row 78} {:arglist-strs ["[& body]"], :doc "Execute body with modified test reporting functions that produce\n  TAP output", :end-row 123, :filename "clojure/test/tap.clj", :macro true, :name "with-tap-output", :ns "clojure.test.tap", :row 117}]} {:author "Rich Hickey", :doc "Functional hierarchical zipper, with navigation, editing,\n  and enumeration.  See Huet", :end-row 16, :filename "clojure/zip.clj", :name "clojure.zip", :row 12, :ns nil, :var-definitions [{:arglist-strs ["[branch? children make-node root]"], :doc "Creates a new zipper structure. \n\n  branch? is a fn that, given a node, returns true if can have\n  children, even if it currently doesn't.\n\n  children is a fn that, given a branch node, returns a seq of its\n  children.\n\n  make-node is a fn that, given an existing node and a seq of\n  children, returns a new branch node with the supplied children.\n  root is the root node.", :end-row 33, :filename "clojure/zip.clj", :fixed-arities #{4}, :name "zipper", :ns "clojure.zip", :row 18} {:arglist-strs ["[root]"], :doc "Returns a zipper for nested sequences, given a root sequence", :end-row 42, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "seq-zip", :ns "clojure.zip", :row 35} {:arglist-strs ["[root]"], :doc "Returns a zipper for nested vectors, given a root vector", :end-row 51, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "vector-zip", :ns "clojure.zip", :row 44} {:arglist-strs ["[root]"], :doc "Returns a zipper for xml elements (as from xml/parse),\n  given a root element", :end-row 62, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "xml-zip", :ns "clojure.zip", :row 53} {:arglist-strs ["[loc]"], :doc "Returns the node at loc", :end-row 67, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "node", :ns "clojure.zip", :row 64} {:arglist-strs ["[loc]"], :doc "Returns true if the node at loc is a branch", :end-row 73, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "branch?", :ns "clojure.zip", :row 69} {:arglist-strs ["[loc]"], :doc "Returns a seq of the children of node at loc, which must be a branch", :end-row 81, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "children", :ns "clojure.zip", :row 75} {:arglist-strs ["[loc node children]"], :doc "Returns a new branch node, given an existing node and new\n  children. The loc is only used to supply the constructor.", :end-row 88, :filename "clojure/zip.clj", :fixed-arities #{3}, :name "make-node", :ns "clojure.zip", :row 83} {:arglist-strs ["[loc]"], :doc "Returns a seq of nodes leading to this loc", :end-row 94, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "path", :ns "clojure.zip", :row 90} {:arglist-strs ["[loc]"], :doc "Returns a seq of the left siblings of this loc", :end-row 100, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "lefts", :ns "clojure.zip", :row 96} {:arglist-strs ["[loc]"], :doc "Returns a seq of the right siblings of this loc", :end-row 106, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "rights", :ns "clojure.zip", :row 102} {:arglist-strs ["[loc]"], :doc "Returns the loc of the leftmost child of the node at this loc, or\n  nil if no children", :end-row 121, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "down", :ns "clojure.zip", :row 109} {:arglist-strs ["[loc]"], :doc "Returns the loc of the parent of the node at this loc, or nil if at\n  the top", :end-row 135, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "up", :ns "clojure.zip", :row 123} {:arglist-strs ["[loc]"], :doc "zips all the way up and returns the root node, reflecting any\n changes.", :end-row 147, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "root", :ns "clojure.zip", :row 137} {:arglist-strs ["[loc]"], :doc "Returns the loc of the right sibling of the node at this loc, or nil", :end-row 155, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "right", :ns "clojure.zip", :row 149} {:arglist-strs ["[loc]"], :doc "Returns the loc of the rightmost sibling of the node at this loc, or self", :end-row 164, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "rightmost", :ns "clojure.zip", :row 157} {:arglist-strs ["[loc]"], :doc "Returns the loc of the left sibling of the node at this loc, or nil", :end-row 172, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "left", :ns "clojure.zip", :row 166} {:arglist-strs ["[loc]"], :doc "Returns the loc of the leftmost sibling of the node at this loc, or self", :end-row 181, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "leftmost", :ns "clojure.zip", :row 174} {:arglist-strs ["[loc item]"], :doc "Inserts the item as the left sibling of the node at this loc,\n without moving", :end-row 191, :filename "clojure/zip.clj", :fixed-arities #{2}, :name "insert-left", :ns "clojure.zip", :row 183} {:arglist-strs ["[loc item]"], :doc "Inserts the item as the right sibling of the node at this loc,\n  without moving", :end-row 201, :filename "clojure/zip.clj", :fixed-arities #{2}, :name "insert-right", :ns "clojure.zip", :row 193} {:arglist-strs ["[loc node]"], :doc "Replaces the node at this loc, without moving", :end-row 208, :filename "clojure/zip.clj", :fixed-arities #{2}, :name "replace", :ns "clojure.zip", :row 203} {:arglist-strs ["[loc f & args]"], :doc "Replaces the node at this loc with the value of (f node args)", :end-row 214, :filename "clojure/zip.clj", :name "edit", :ns "clojure.zip", :row 210} {:arglist-strs ["[loc item]"], :doc "Inserts the item as the leftmost child of the node at this loc,\n  without moving", :end-row 221, :filename "clojure/zip.clj", :fixed-arities #{2}, :name "insert-child", :ns "clojure.zip", :row 216} {:arglist-strs ["[loc item]"], :doc "Inserts the item as the rightmost child of the node at this loc,\n  without moving", :end-row 228, :filename "clojure/zip.clj", :fixed-arities #{2}, :name "append-child", :ns "clojure.zip", :row 223} {:arglist-strs ["[loc]"], :doc "Moves to the next loc in the hierarchy, depth-first. When reaching\n  the end, returns a distinguished loc detectable via end?. If already\n  at the end, stays there.", :end-row 244, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "next", :ns "clojure.zip", :row 230} {:arglist-strs ["[loc]"], :doc "Moves to the previous loc in the hierarchy, depth-first. If already\n  at the root, returns nil.", :end-row 256, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "prev", :ns "clojure.zip", :row 246} {:arglist-strs ["[loc]"], :doc "Returns true if loc represents the end of a depth-first walk", :end-row 262, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "end?", :ns "clojure.zip", :row 258} {:arglist-strs ["[loc]"], :doc "Removes the node at loc, returning the loc that would have preceded\n  it in a depth-first walk.", :end-row 279, :filename "clojure/zip.clj", :fixed-arities #{1}, :name "remove", :ns "clojure.zip", :row 264} {:end-row 285, :filename "clojure/zip.clj", :name "data", :ns "clojure.zip", :row 285} {:end-row 286, :filename "clojure/zip.clj", :name "dz", :ns "clojure.zip", :row 286}]} {:author "Rich Hickey", :doc "Graphical object inspector for Clojure data structures.", :end-row 17, :filename "clojure/inspector.clj", :name "clojure.inspector", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[x]"], :end-row 20, :filename "clojure/inspector.clj", :fixed-arities #{1}, :name "atom?", :ns "clojure.inspector", :row 19} {:arglist-strs ["[x]"], :end-row 29, :filename "clojure/inspector.clj", :fixed-arities #{1}, :name "collection-tag", :ns "clojure.inspector", :row 22} {:end-row 31, :filename "clojure/inspector.clj", :name "is-leaf", :ns "clojure.inspector", :row 31} {:end-row 32, :filename "clojure/inspector.clj", :name "get-child", :ns "clojure.inspector", :row 32} {:end-row 33, :filename "clojure/inspector.clj", :name "get-child-count", :ns "clojure.inspector", :row 33} {:arglist-strs ["[data]"], :end-row 69, :filename "clojure/inspector.clj", :fixed-arities #{1}, :name "tree-model", :ns "clojure.inspector", :row 56} {:arglist-strs ["[data]"], :end-row 89, :filename "clojure/inspector.clj", :fixed-arities #{1}, :name "old-table-model", :ns "clojure.inspector", :row 72} {:arglist-strs ["[data]"], :doc "creates a graphical (Swing) inspector on the supplied hierarchical data", :end-row 98, :filename "clojure/inspector.clj", :fixed-arities #{1}, :name "inspect-tree", :ns "clojure.inspector", :row 91} {:arglist-strs ["[data]"], :doc "creates a graphical (Swing) inspector on the supplied regular\n  data, which must be a sequential data structure of data structures\n  of equal length", :end-row 109, :filename "clojure/inspector.clj", :fixed-arities #{1}, :name "inspect-table", :ns "clojure.inspector", :row 100} {:end-row 112, :filename "clojure/inspector.clj", :name "list-provider", :ns "clojure.inspector", :row 112} {:arglist-strs ["[provider]"], :end-row 137, :filename "clojure/inspector.clj", :fixed-arities #{1}, :name "list-model", :ns "clojure.inspector", :row 129} {:end-row 139, :filename "clojure/inspector.clj", :name "table-model", :ns "clojure.inspector", :row 139} {:arglist-strs ["[x]"], :doc "creates a graphical (Swing) inspector on the supplied object", :end-row 179, :filename "clojure/inspector.clj", :fixed-arities #{1}, :name "inspect", :ns "clojure.inspector", :row 154}]} {:author "Rich Hickey", :doc "XML reading/writing.", :end-row 13, :filename "clojure/xml.clj", :name "clojure.xml", :row 9, :ns nil, :var-definitions [{:end-row 15, :filename "clojure/xml.clj", :name "*stack*", :ns "clojure.xml", :row 15} {:end-row 16, :filename "clojure/xml.clj", :name "*current*", :ns "clojure.xml", :row 16} {:end-row 17, :filename "clojure/xml.clj", :name "*state*", :ns "clojure.xml", :row 17} {:end-row 18, :filename "clojure/xml.clj", :name "*sb*", :ns "clojure.xml", :row 18} {:end-row 22, :filename "clojure/xml.clj", :name "tag", :ns "clojure.xml", :row 22} {:end-row 23, :filename "clojure/xml.clj", :name "attrs", :ns "clojure.xml", :row 23} {:end-row 24, :filename "clojure/xml.clj", :name "content", :ns "clojure.xml", :row 24} {:end-row 73, :filename "clojure/xml.clj", :name "content-handler", :ns "clojure.xml", :row 26} {:arglist-strs ["[]"], :doc "Create a new SAXParser", :end-row 79, :filename "clojure/xml.clj", :fixed-arities #{0}, :name "sax-parser", :ns "clojure.xml", :row 75} {:arglist-strs ["[parser]"], :doc "Modifies a SAXParser to disable external entity resolution to prevent XXE attacks", :end-row 90, :filename "clojure/xml.clj", :fixed-arities #{1}, :name "disable-external-entities", :ns "clojure.xml", :row 81} {:arglist-strs ["[s ch]"], :doc "A startparse function suitable for use with clojure.xml/parse.\n  Note that this function is open to XXE entity attacks, see startparse-sax-safe.", :end-row 97, :filename "clojure/xml.clj", :fixed-arities #{2}, :name "startparse-sax", :ns "clojure.xml", :row 92} {:arglist-strs ["[s ch]"], :doc "A startparse function suitable for use with clojure.xml/parse.\n  External entity resolution is disabled to prevent XXE entity attacks.", :end-row 104, :filename "clojure/xml.clj", :fixed-arities #{2}, :name "startparse-sax-safe", :ns "clojure.xml", :row 99} {:arglist-strs ["[s]" "[s startparse]"], :doc "Parses and loads the source s, which can be a File, InputStream or\n  String naming a URI. Returns a tree of the xml/element struct-map,\n  which has the keys :tag, :attrs, and :content. and accessor fns tag,\n  attrs, and content. Other parsers can be supplied by passing\n  startparse, a fn taking a source and a ContentHandler and returning\n  a parser.\n\n  Prior to 1.11, used startparse-sax by default. As of 1.11, uses\n  startparse-sax-safe, which disables XXE (XML External Entity)\n  processing. Pass startparse-sax to revert to prior behavior.", :end-row 125, :filename "clojure/xml.clj", :fixed-arities #{1 2}, :name "parse", :ns "clojure.xml", :row 106} {:arglist-strs ["[e]"], :end-row 141, :filename "clojure/xml.clj", :fixed-arities #{1}, :name "emit-element", :ns "clojure.xml", :row 127} {:arglist-strs ["[x]"], :end-row 145, :filename "clojure/xml.clj", :fixed-arities #{1}, :name "emit", :ns "clojure.xml", :row 143}]} {:author "Stuart Halloway", :doc "Reflection on Host Types\nAlpha - subject to change.\n\nTwo main entry points: \n\n* type-reflect reflects on something that implements TypeReference.\n* reflect (for REPL use) reflects on the class of an instance, or\n  on a class if passed a class\n\nKey features:\n\n* Exposes the read side of reflection as pure data. Reflecting\n  on a type returns a map with keys :bases, :flags, and :members.\n\n* Canonicalizes class names as Clojure symbols. Types can extend\n  to the TypeReference protocol to indicate that they can be\n  unambiguously resolved as a type name. The canonical format\n  requires one non-Java-ish convention: array brackets are <>\n  instead of [] so they can be part of a Clojure symbol.\n\n* Pluggable Reflectors for different implementations. The default\n  JavaReflector is good when you have a class in hand, or use\n  the AsmReflector for \"hands off\" reflection without forcing\n  classes to load.\n\nPlatform implementers must:\n\n* Create an implementation of Reflector.\n* Create one or more implementations of TypeReference.\n* def default-reflector to be an instance that satisfies Reflector.", :end-row 42, :filename "clojure/reflect.clj", :name "clojure.reflect", :row 9, :ns nil, :var-definitions [{:doc "Protocol for reflection implementers.", :end-row 46, :filename "clojure/reflect.clj", :name "Reflector", :ns "clojure.reflect", :row 44} {:arglist-strs ["[reflector typeref]"], :end-row 46, :filename "clojure/reflect.clj", :fixed-arities #{2}, :name "do-reflect", :ns "clojure.reflect", :row 46} {:doc "A TypeReference can be unambiguously converted to a type name on\n   the host platform.\n\n   All typerefs are normalized into symbols. If you need to\n   normalize a typeref yourself, call typesym.", :end-row 54, :filename "clojure/reflect.clj", :name "TypeReference", :ns "clojure.reflect", :row 48} {:arglist-strs ["[o]"], :doc "Returns Java name as returned by ASM getClassName, e.g. byte[], java.lang.String[]", :end-row 54, :filename "clojure/reflect.clj", :fixed-arities #{1}, :name "typename", :ns "clojure.reflect", :row 54} {:end-row 56, :filename "clojure/reflect.clj", :name "default-reflector", :ns "clojure.reflect", :row 56} {:arglist-strs ["[typeref & options]"], :doc "Alpha - subject to change.\n   Reflect on a typeref, returning a map with :bases, :flags, and\n  :members. In the discussion below, names are always Clojure symbols.\n\n   :bases            a set of names of the type's bases\n   :flags            a set of keywords naming the boolean attributes\n                     of the type.\n   :members          a set of the type's members. Each member is a map\n                     and can be a constructor, method, or field.\n\n   Keys common to all members:\n   :name             name of the type \n   :declaring-class  name of the declarer\n   :flags            keyword naming boolean attributes of the member\n\n   Keys specific to constructors:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n\n   Key specific to methods:\n   :parameter-types  vector of parameter type names\n   :exception-types  vector of exception type names\n   :return-type      return type name\n\n   Keys specific to fields:\n   :type             type name\n\n   Options:\n\n     :ancestors     in addition to the keys described above, also\n                    include an :ancestors key with the entire set of\n                    ancestors, and add all ancestor members to\n                    :members.\n     :reflector     implementation to use. Defaults to JavaReflector,\n                    AsmReflector is also an option.", :end-row 113, :filename "clojure/reflect.clj", :name "type-reflect", :ns "clojure.reflect", :row 58} {:arglist-strs ["[obj & options]"], :doc "Alpha - subject to change.\n   Reflect on the type of obj (or obj itself if obj is a class).\n   Return value and options are the same as for type-reflect. ", :end-row 121, :filename "clojure/reflect.clj", :name "reflect", :ns "clojure.reflect", :row 115} {:fixed-arities #{1}, :end-row 45, :private true, :ns "clojure.reflect", :name "typesym", :filename "clojure/reflect/java.clj", :arglist-strs ["[t]"], :doc "Given a typeref, create a legal Clojure symbol version of the\n   type's name.", :row 36} {:fixed-arities #{1}, :end-row 53, :private true, :ns "clojure.reflect", :name "resource-name", :filename "clojure/reflect/java.clj", :arglist-strs ["[typeref]"], :doc "Given a typeref, return implied resource name. Used by Reflectors\n   such as ASM that need to find and read classbytes from files.", :row 47} {:arglist-strs ["[[name flag & contexts]]"], :end-row 57, :filename "clojure/reflect/java.clj", :fixed-arities #{1}, :name "access-flag", :ns "clojure.reflect", :private true, :row 55} {:fixed-arities #{1}, :end-row 65, :private true, :ns "clojure.reflect", :name "field-descriptor->class-symbol", :filename "clojure/reflect/java.clj", :arglist-strs ["[d]"], :doc "Convert a Java field descriptor to a Clojure class symbol. Field\n   descriptors are described in section 4.3.2 of the JVM spec, 2nd ed.:\n   http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#14152", :row 59} {:fixed-arities #{1}, :end-row 75, :private true, :ns "clojure.reflect", :name "internal-name->class-symbol", :filename "clojure/reflect/java.clj", :arglist-strs ["[d]"], :doc "Convert a Java internal name to a Clojure class symbol. Internal\n   names uses slashes instead of dots, e.g. java/lang/String. See\n   Section 4.2 of the JVM spec, 2nd ed.:\n\n   http://java.sun.com/docs/books/jvms/second_edition/html/ClassFile.doc.html#14757", :row 67} {:doc "The Java access bitflags, along with their friendly names and\nthe kinds of objects to which they can apply.", :end-row 101, :filename "clojure/reflect/java.clj", :name "flag-descriptors", :ns "clojure.reflect", :row 77} {:fixed-arities #{2}, :end-row 113, :private true, :ns "clojure.reflect", :name "parse-flags", :filename "clojure/reflect/java.clj", :arglist-strs ["[flags context]"], :doc "Convert reflection bitflags into a set of keywords.", :row 103} {:end-row 116, :filename "clojure/reflect/java.clj", :name "Constructor", :ns "clojure.reflect", :row 115} {:arglist-strs ["[name declaring-class parameter-types exception-types flags]"], :end-row 116, :filename "clojure/reflect/java.clj", :fixed-arities #{5}, :name "->Constructor", :ns "clojure.reflect", :row 115} {:arglist-strs ["[m]"], :end-row 116, :filename "clojure/reflect/java.clj", :fixed-arities #{1}, :name "map->Constructor", :ns "clojure.reflect", :row 115} {:arglist-strs ["[constructor]"], :end-row 125, :filename "clojure/reflect/java.clj", :fixed-arities #{1}, :name "constructor->map", :ns "clojure.reflect", :private true, :row 118} {:fixed-arities #{1}, :end-row 132, :private true, :ns "clojure.reflect", :name "declared-constructors", :filename "clojure/reflect/java.clj", :arglist-strs ["[cls]"], :doc "Return a set of the declared constructors of class as a Clojure map.", :row 127} {:end-row 135, :filename "clojure/reflect/java.clj", :name "Method", :ns "clojure.reflect", :row 134} {:arglist-strs ["[name return-type declaring-class parameter-types exception-types flags]"], :end-row 135, :filename "clojure/reflect/java.clj", :fixed-arities #{6}, :name "->Method", :ns "clojure.reflect", :row 134} {:arglist-strs ["[m]"], :end-row 135, :filename "clojure/reflect/java.clj", :fixed-arities #{1}, :name "map->Method", :ns "clojure.reflect", :row 134} {:arglist-strs ["[method]"], :end-row 145, :filename "clojure/reflect/java.clj", :fixed-arities #{1}, :name "method->map", :ns "clojure.reflect", :private true, :row 137} {:fixed-arities #{1}, :end-row 152, :private true, :ns "clojure.reflect", :name "declared-methods", :filename "clojure/reflect/java.clj", :arglist-strs ["[cls]"], :doc "Return a set of the declared constructors of class as a Clojure map.", :row 147} {:end-row 155, :filename "clojure/reflect/java.clj", :name "Field", :ns "clojure.reflect", :row 154} {:arglist-strs ["[name type declaring-class flags]"], :end-row 155, :filename "clojure/reflect/java.clj", :fixed-arities #{4}, :name "->Field", :ns "clojure.reflect", :row 154} {:arglist-strs ["[m]"], :end-row 155, :filename "clojure/reflect/java.clj", :fixed-arities #{1}, :name "map->Field", :ns "clojure.reflect", :row 154} {:arglist-strs ["[field]"], :end-row 163, :filename "clojure/reflect/java.clj", :fixed-arities #{1}, :name "field->map", :ns "clojure.reflect", :private true, :row 157} {:fixed-arities #{1}, :end-row 170, :private true, :ns "clojure.reflect", :name "declared-fields", :filename "clojure/reflect/java.clj", :arglist-strs ["[cls]"], :doc "Return a set of the declared fields of class as a Clojure map.", :row 165} {:arglist-strs ["[typeref classloader]"], :end-row 176, :filename "clojure/reflect/java.clj", :fixed-arities #{2}, :name "typeref->class", :ns "clojure.reflect", :private true, :row 172} {:end-row 186, :filename "clojure/reflect/java.clj", :name "JavaReflector", :ns "clojure.reflect", :row 178} {:arglist-strs ["[classloader]"], :end-row 186, :filename "clojure/reflect/java.clj", :fixed-arities #{1}, :name "->JavaReflector", :ns "clojure.reflect", :row 178} {:end-row 189, :filename "clojure/reflect/java.clj", :name "default-reflector", :ns "clojure.reflect", :private true, :row 188} {:arglist-strs ["[md]"], :end-row 194, :filename "clojure/reflect/java.clj", :fixed-arities #{1}, :name "parse-method-descriptor", :ns "clojure.reflect", :private true, :row 191} {:end-row 198, :filename "clojure/reflect/java.clj", :name "ClassResolver", :ns "clojure.reflect", :row 196} {:arglist-strs ["[this name]"], :doc "Given a class name, return that typeref's class bytes as an InputStream.", :end-row 198, :filename "clojure/reflect/java.clj", :fixed-arities #{2}, :name "resolve-class", :ns "clojure.reflect", :row 197} {:end-row 266, :filename "clojure/reflect/java.clj", :name "AsmReflector", :ns "clojure.reflect", :row 208} {:arglist-strs ["[class-resolver]"], :end-row 266, :filename "clojure/reflect/java.clj", :fixed-arities #{1}, :name "->AsmReflector", :ns "clojure.reflect", :row 208}]} {:author "Stuart Halloway", :doc "Non-core data functions.", :end-row 13, :filename "clojure/data.clj", :name "clojure.data", :row 9, :ns nil, :var-definitions [{:end-row 17, :filename "clojure/data.clj", :name "diff", :ns "clojure.data", :row 17} {:fixed-arities #{2}, :end-row 22, :private true, :ns "clojure.data", :name "atom-diff", :filename "clojure/data.clj", :arglist-strs ["[a b]"], :doc "Internal helper for diff.", :row 19} {:fixed-arities #{1}, :end-row 33, :private true, :ns "clojure.data", :name "vectorize", :filename "clojure/data.clj", :arglist-strs ["[m]"], :doc "Convert an associative-by-numeric-index collection into\n   an equivalent vector, with nil for any missing keys", :row 25} {:fixed-arities #{3}, :end-row 49, :private true, :ns "clojure.data", :name "diff-associative-key", :filename "clojure/data.clj", :arglist-strs ["[a b k]"], :doc "Diff associative things a and b, comparing only the key k.", :row 35} {:fixed-arities #{3}, :end-row 60, :private true, :ns "clojure.data", :name "diff-associative", :filename "clojure/data.clj", :arglist-strs ["[a b ks]"], :doc "Diff associative things a and b, comparing only keys in ks.", :row 51} {:arglist-strs ["[a b]"], :end-row 67, :filename "clojure/data.clj", :fixed-arities #{2}, :name "diff-sequential", :ns "clojure.data", :private true, :row 62} {:doc "Implementation detail. Subject to change.", :end-row 71, :filename "clojure/data.clj", :name "EqualityPartition", :ns "clojure.data", :row 69} {:arglist-strs ["[x]"], :doc "Implementation detail. Subject to change.", :end-row 71, :filename "clojure/data.clj", :fixed-arities #{1}, :name "equality-partition", :ns "clojure.data", :row 71} {:doc "Implementation detail. Subject to change.", :end-row 75, :filename "clojure/data.clj", :name "Diff", :ns "clojure.data", :row 73} {:arglist-strs ["[a b]"], :doc "Implementation detail. Subject to change.", :end-row 75, :filename "clojure/data.clj", :fixed-arities #{2}, :name "diff-similar", :ns "clojure.data", :row 75} {:arglist-strs ["[s]"], :end-row 104, :filename "clojure/data.clj", :fixed-arities #{1}, :name "as-set-value", :ns "clojure.data", :private true, :row 102} {:arglist-strs ["[a b]"], :doc "Recursively compares a and b, returning a tuple of\n  [things-only-in-a things-only-in-b things-in-both].\n  Comparison rules:\n\n  * For equal a and b, return [nil nil a].\n  * Maps are subdiffed where keys match and values differ.\n  * Sets are never subdiffed.\n  * All sequential things are treated as associative collections\n    by their indexes, with results returned as vectors.\n  * Everything else (including strings!) is treated as\n    an atom and compared for equality.", :end-row 142, :filename "clojure/data.clj", :fixed-arities #{2}, :name "diff", :ns "clojure.data", :row 124}]} {:doc "Functions to turn objects into data. Alpha, subject to change", :end-row 11, :filename "clojure/datafy.clj", :name "clojure.datafy", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[x]"], :doc "Attempts to return x as data.\n  datafy will return the value of clojure.core.protocols/datafy. If\n  the value has been transformed and the result supports\n  metadata, :clojure.datafy/obj will be set on the metadata to the\n  original value of x, and :clojure.datafy/class to the name of the\n  class of x, as a symbol.", :end-row 28, :filename "clojure/datafy.clj", :fixed-arities #{1}, :name "datafy", :ns "clojure.datafy", :row 15} {:arglist-strs ["[coll k v]"], :doc "Returns (possibly transformed) v in the context of coll and k (a\n  key/index or nil). Callers should attempt to provide the key/index\n  context k for Indexed/Associative/ILookup colls if possible, but not\n  to fabricate one e.g. for sequences (pass nil). nav returns the\n  value of clojure.core.protocols/nav.", :end-row 37, :filename "clojure/datafy.clj", :fixed-arities #{3}, :name "nav", :ns "clojure.datafy", :row 30} {:arglist-strs ["[m]"], :end-row 40, :filename "clojure/datafy.clj", :fixed-arities #{1}, :name "sortmap", :ns "clojure.datafy", :private true, :row 39}]} {:author "Stuart Sierra", :doc "Print stack traces oriented towards Clojure, not Java.", :end-row 16, :filename "clojure/stacktrace.clj", :name "clojure.stacktrace", :row 14, :ns nil, :var-definitions [{:arglist-strs ["[tr]"], :doc "Returns the last 'cause' Throwable in a chain of Throwables.", :end-row 26, :filename "clojure/stacktrace.clj", :fixed-arities #{1}, :name "root-cause", :ns "clojure.stacktrace", :row 20} {:arglist-strs ["[e]"], :doc "Prints a Clojure-oriented view of one element in a stack trace.", :end-row 38, :filename "clojure/stacktrace.clj", :fixed-arities #{1}, :name "print-trace-element", :ns "clojure.stacktrace", :row 28} {:arglist-strs ["[tr]"], :doc "Prints the class and message of a Throwable. Prints the ex-data map\n  if present.", :end-row 48, :filename "clojure/stacktrace.clj", :fixed-arities #{1}, :name "print-throwable", :ns "clojure.stacktrace", :row 40} {:arglist-strs ["[tr]" "[tr n]"], :doc "Prints a Clojure-oriented stack trace of tr, a Throwable.\n  Prints a maximum of n stack frames (default: unlimited).\n  Does not print chained exceptions (causes).", :end-row 70, :filename "clojure/stacktrace.clj", :fixed-arities #{1 2}, :name "print-stack-trace", :ns "clojure.stacktrace", :row 50} {:arglist-strs ["[tr]" "[tr n]"], :doc "Like print-stack-trace but prints chained exceptions (causes).", :end-row 80, :filename "clojure/stacktrace.clj", :fixed-arities #{1 2}, :name "print-cause-trace", :ns "clojure.stacktrace", :row 72} {:arglist-strs ["[]"], :doc "REPL utility.  Prints a brief stack trace for the root cause of the\n  most recent exception.", :end-row 87, :filename "clojure/stacktrace.clj", :fixed-arities #{0}, :name "e", :ns "clojure.stacktrace", :row 82}]} {:author "Rich Hickey", :doc "DEPRECATED Wrapper of the ForkJoin library (JSR-166).", :end-row 11, :filename "clojure/parallel.clj", :name "clojure.parallel", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[f]"], :end-row 47, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "op", :ns "clojure.parallel", :private true, :row 45} {:arglist-strs ["[f]"], :end-row 51, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "binary-op", :ns "clojure.parallel", :private true, :row 49} {:arglist-strs ["[f]"], :end-row 55, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "int-and-object-to-object", :ns "clojure.parallel", :private true, :row 53} {:arglist-strs ["[f]"], :end-row 59, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "reducer", :ns "clojure.parallel", :private true, :row 57} {:arglist-strs ["[f]"], :end-row 63, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "predicate", :ns "clojure.parallel", :private true, :row 61} {:arglist-strs ["[f]"], :end-row 67, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "binary-predicate", :ns "clojure.parallel", :private true, :row 65} {:arglist-strs ["[f]"], :end-row 71, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "int-and-object-predicate", :ns "clojure.parallel", :private true, :row 69} {:arglist-strs ["[coll]" "[coll & ops]"], :doc "Creates a parallel array from coll. ops, if supplied, perform\n  on-the-fly filtering or transformations during parallel realization\n  or calculation. ops form a chain, and bounds must precede filters,\n  must precede maps. ops must be a set of keyword value pairs of the\n  following forms:\n\n     :bound [start end] \n\n  Only elements from start (inclusive) to end (exclusive) will be\n  processed when the array is realized.\n\n     :filter pred \n\n  Filter preds remove elements from processing when the array is realized. pred\n  must be a function of one argument whose return will be processed\n  via boolean.\n\n     :filter-index pred2 \n\n  pred2 must be a function of two arguments, which will be an element\n  of the collection and the corresponding index, whose return will be\n  processed via boolean.\n\n     :filter-with [pred2 coll2] \n\n  pred2 must be a function of two arguments, which will be\n  corresponding elements of the 2 collections.\n\n     :map f \n\n  Map fns will be used to transform elements when the array is\n  realized. f must be a function of one argument.\n\n     :map-index f2 \n\n  f2 must be a function of two arguments, which will be an element of\n  the collection and the corresponding index.\n\n     :map-with [f2 coll2]\n\n  f2 must be a function of two arguments, which will be corresponding\n  elements of the 2 collections.", :end-row 135, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "par", :ns "clojure.parallel", :row 73} {:arglist-strs ["[coll]"], :doc "Returns some (random) element of the coll if it satisfies the bound/filter/map", :end-row 141, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "pany", :ns "clojure.parallel", :row 138} {:arglist-strs ["[coll]" "[coll comp]"], :doc "Returns the maximum element, presuming Comparable elements, unless\n  a Comparator comp is supplied", :end-row 147, :filename "clojure/parallel.clj", :fixed-arities #{1 2}, :name "pmax", :ns "clojure.parallel", :row 143} {:arglist-strs ["[coll]" "[coll comp]"], :doc "Returns the minimum element, presuming Comparable elements, unless\n  a Comparator comp is supplied", :end-row 153, :filename "clojure/parallel.clj", :fixed-arities #{1 2}, :name "pmin", :ns "clojure.parallel", :row 149} {:arglist-strs ["[s]"], :end-row 156, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "summary-map", :ns "clojure.parallel", :private true, :row 155} {:arglist-strs ["[coll]" "[coll comp]"], :doc "Returns a map of summary statistics (min. max, size, min-index, max-index, \n  presuming Comparable elements, unless a Comparator comp is supplied", :end-row 162, :filename "clojure/parallel.clj", :fixed-arities #{1 2}, :name "psummary", :ns "clojure.parallel", :row 158} {:arglist-strs ["[f base coll]"], :doc "Returns the reduction of the realized elements of coll\n  using function f. Note f will not necessarily be called\n  consecutively, and so must be commutative. Also note that \n  (f base an-element) might be performed many times, i.e. base is not\n  an initial value as with sequential reduce.", :end-row 171, :filename "clojure/parallel.clj", :fixed-arities #{3}, :name "preduce", :ns "clojure.parallel", :row 164} {:arglist-strs ["[pa]"], :end-row 176, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "pa-to-vec", :ns "clojure.parallel", :private true, :row 175} {:fixed-arities #{1}, :end-row 183, :private true, :ns "clojure.parallel", :name "pall", :filename "clojure/parallel.clj", :arglist-strs ["[coll]"], :doc "Realizes a copy of the coll as a parallel array, with any bounds/filters/maps applied", :row 178} {:arglist-strs ["[pa]"], :doc "Returns the realized contents of the parallel array pa as a Clojure vector", :end-row 187, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "pvec", :ns "clojure.parallel", :row 185} {:arglist-strs ["[coll]"], :doc "Returns a parallel array of the distinct elements of coll", :end-row 192, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "pdistinct", :ns "clojure.parallel", :row 189} {:arglist-strs ["[coll f init]"], :end-row 196, :filename "clojure/parallel.clj", :fixed-arities #{3}, :name "pcumulate", :ns "clojure.parallel", :private true, :row 195} {:arglist-strs ["[coll]" "[coll comp]"], :doc "Returns a new vector consisting of the realized items in coll, sorted, \n  presuming Comparable elements, unless a Comparator comp is supplied", :end-row 202, :filename "clojure/parallel.clj", :fixed-arities #{1 2}, :name "psort", :ns "clojure.parallel", :row 198} {:arglist-strs ["[coll]"], :doc "Returns a vector containing the non-nil (realized) elements of coll", :end-row 207, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "pfilter-nils", :ns "clojure.parallel", :row 204} {:arglist-strs ["[coll]"], :doc "Returns a vector containing the (realized) elements of coll, \n  without any consecutive duplicates", :end-row 213, :filename "clojure/parallel.clj", :fixed-arities #{1}, :name "pfilter-dupes", :ns "clojure.parallel", :row 209} {:end-row 221, :filename "clojure/parallel.clj", :name "a", :ns "clojure.parallel", :row 221} {:end-row 246, :filename "clojure/parallel.clj", :name "v", :ns "clojure.parallel", :row 246}]} {:author "Rich Hickey", :doc "edn reading.", :end-row 12, :filename "clojure/edn.clj", :name "clojure.edn", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[]" "[stream]" "[opts stream]"], :doc "Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Reads data in the edn format (subset of Clojure data):\n  http://edn-format.org\n\n  opts is a map that can include the following keys:\n  :eof - value to return on end-of-file. When not supplied, eof throws an exception.\n  :readers  - a map of tag symbols to data-reader functions to be considered before default-data-readers.\n              When not supplied, only the default-data-readers will be used.\n  :default - A function of two args, that will, if present and no reader is found for a tag,\n             be called with the tag and the value.", :end-row 35, :filename "clojure/edn.clj", :fixed-arities #{0 1 2}, :name "read", :ns "clojure.edn", :row 14} {:arglist-strs ["[s]" "[opts s]"], :doc "Reads one object from the string s. Returns nil when s is nil or empty.\n\n  Reads data in the edn format (subset of Clojure data):\n  http://edn-format.org\n\n  opts is a map as per clojure.edn/read", :end-row 46, :filename "clojure/edn.clj", :fixed-arities #{1 2}, :name "read-string", :ns "clojure.edn", :row 37}]} {:author "Stuart Sierra, with contributions and suggestions by \n  Chas Emerick, Allen Rohner, and Stuart Halloway", :doc "A unit testing framework.\n\n   ASSERTIONS\n\n   The core of the library is the \"is\" macro, which lets you make\n   assertions of any arbitrary expression:\n\n   (is (= 4 (+ 2 2)))\n   (is (instance? Integer 256))\n   (is (.startsWith \"abcde\" \"ab\"))\n\n   You can type an \"is\" expression directly at the REPL, which will\n   print a message if it fails.\n\n       user> (is (= 5 (+ 2 2)))\n\n       FAIL in  (:1)\n       expected: (= 5 (+ 2 2))\n         actual: (not (= 5 4))\n       false\n\n   The \"expected:\" line shows you the original expression, and the\n   \"actual:\" shows you what actually happened.  In this case, it\n   shows that (+ 2 2) returned 4, which is not = to 5.  Finally, the\n   \"false\" on the last line is the value returned from the\n   expression.  The \"is\" macro always returns the result of the\n   inner expression.\n\n   There are two special assertions for testing exceptions.  The\n   \"(is (thrown? c ...))\" form tests if an exception of class c is\n   thrown:\n\n   (is (thrown? ArithmeticException (/ 1 0))) \n\n   \"(is (thrown-with-msg? c re ...))\" does the same thing and also\n   tests that the message on the exception matches the regular\n   expression re:\n\n   (is (thrown-with-msg? ArithmeticException #\"Divide by zero\"\n                         (/ 1 0)))\n\n   DOCUMENTING TESTS\n\n   \"is\" takes an optional second argument, a string describing the\n   assertion.  This message will be included in the error report.\n\n   (is (= 5 (+ 2 2)) \"Crazy arithmetic\")\n\n   In addition, you can document groups of assertions with the\n   \"testing\" macro, which takes a string followed by any number of\n   assertions.  The string will be included in failure reports.\n   Calls to \"testing\" may be nested, and all of the strings will be\n   joined together with spaces in the final report, in a style\n   similar to RSpec <http://rspec.info/>\n\n   (testing \"Arithmetic\"\n     (testing \"with positive integers\"\n       (is (= 4 (+ 2 2)))\n       (is (= 7 (+ 3 4))))\n     (testing \"with negative integers\"\n       (is (= -4 (+ -2 -2)))\n       (is (= -1 (+ 3 -4)))))\n\n   Note that, unlike RSpec, the \"testing\" macro may only be used\n   INSIDE a \"deftest\" or \"with-test\" form (see below).\n\n\n   DEFINING TESTS\n\n   There are two ways to define tests.  The \"with-test\" macro takes\n   a defn or def form as its first argument, followed by any number\n   of assertions.  The tests will be stored as metadata on the\n   definition.\n\n   (with-test\n       (defn my-function [x y]\n         (+ x y))\n     (is (= 4 (my-function 2 2)))\n     (is (= 7 (my-function 3 4))))\n\n   As of Clojure SVN rev. 1221, this does not work with defmacro.\n   See http://code.google.com/p/clojure/issues/detail?id=51\n\n   The other way lets you define tests separately from the rest of\n   your code, even in a different namespace:\n\n   (deftest addition\n     (is (= 4 (+ 2 2)))\n     (is (= 7 (+ 3 4))))\n\n   (deftest subtraction\n     (is (= 1 (- 4 3)))\n     (is (= 3 (- 7 4))))\n\n   This creates functions named \"addition\" and \"subtraction\", which\n   can be called like any other function.  Therefore, tests can be\n   grouped and composed, in a style similar to the test framework in\n   Peter Seibel's \"Practical Common Lisp\"\n   <http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html>\n\n   (deftest arithmetic\n     (addition)\n     (subtraction))\n\n   The names of the nested tests will be joined in a list, like\n   \"(arithmetic addition)\", in failure reports.  You can use nested\n   tests to set up a context shared by several tests.\n\n\n   RUNNING TESTS\n\n   Run tests with the function \"(run-tests namespaces...)\":\n\n   (run-tests 'your.namespace 'some.other.namespace)\n\n   If you don't specify any namespaces, the current namespace is\n   used.  To run all tests in all namespaces, use \"(run-all-tests)\".\n\n   By default, these functions will search for all tests defined in\n   a namespace and run them in an undefined order.  However, if you\n   are composing tests, as in the \"arithmetic\" example above, you\n   probably do not want the \"addition\" and \"subtraction\" tests run\n   separately.  In that case, you must define a special function\n   named \"test-ns-hook\" that runs your tests in the correct order:\n\n   (defn test-ns-hook []\n     (arithmetic))\n\n   Note: test-ns-hook prevents execution of fixtures (see below).\n\n\n   OMITTING TESTS FROM PRODUCTION CODE\n\n   You can bind the variable \"*load-tests*\" to false when loading or\n   compiling code in production.  This will prevent any tests from\n   being created by \"with-test\" or \"deftest\".\n\n\n   FIXTURES\n\n   Fixtures allow you to run code before and after tests, to set up\n   the context in which tests should be run.\n\n   A fixture is just a function that calls another function passed as\n   an argument.  It looks like this:\n\n   (defn my-fixture [f]\n      Perform setup, establish bindings, whatever.\n     (f)  Then call the function we were passed.\n      Tear-down / clean-up code here.\n    )\n\n   Fixtures are attached to namespaces in one of two ways.  \"each\"\n   fixtures are run repeatedly, once for each test function created\n   with \"deftest\" or \"with-test\".  \"each\" fixtures are useful for\n   establishing a consistent before/after state for each test, like\n   clearing out database tables.\n\n   \"each\" fixtures can be attached to the current namespace like this:\n   (use-fixtures :each fixture1 fixture2 ...)\n   The fixture1, fixture2 are just functions like the example above.\n   They can also be anonymous functions, like this:\n   (use-fixtures :each (fn [f] setup... (f) cleanup...))\n\n   The other kind of fixture, a \"once\" fixture, is only run once,\n   around ALL the tests in the namespace.  \"once\" fixtures are useful\n   for tasks that only need to be performed once, like establishing\n   database connections, or for time-consuming tasks.\n\n   Attach \"once\" fixtures to the current namespace like this:\n   (use-fixtures :once fixture1 fixture2 ...)\n\n   Note: Fixtures and test-ns-hook are mutually incompatible.  If you\n   are using test-ns-hook, fixture functions will *never* be run.\n\n\n   SAVING TEST OUTPUT TO A FILE\n\n   All the test reporting functions write to the var *test-out*.  By\n   default, this is the same as *out*, but you can rebind it to any\n   PrintWriter.  For example, it could be a file opened with\n   clojure.java.io/writer.\n\n\n   EXTENDING TEST-IS (ADVANCED)\n\n   You can extend the behavior of the \"is\" macro by defining new\n   methods for the \"assert-expr\" multimethod.  These methods are\n   called during expansion of the \"is\" macro, so they should return\n   quoted forms to be evaluated.\n\n   You can plug in your own test-reporting framework by rebinding\n   the \"report\" function: (report event)\n\n   The 'event' argument is a map.  It will always have a :type key,\n   whose value will be a keyword signaling the type of event being\n   reported.  Standard events with :type value of :pass, :fail, and\n   :error are called when an assertion passes, fails, and throws an\n   exception, respectively.  In that case, the event will also have\n   the following keys:\n\n     :expected   The form that was expected to be true\n     :actual     A form representing what actually occurred\n     :message    The string message given as an argument to 'is'\n\n   The \"testing\" strings will be a list in \"*testing-contexts*\", and\n   the vars being tested will be a list in \"*testing-vars*\".\n\n   Your \"report\" function should wrap any printing calls in the\n   \"with-test-out\" macro, which rebinds *out* to the current value\n   of *test-out*.\n\n   For additional event types, see the examples in the code.\n", :end-row 237, :filename "clojure/test.clj", :name "clojure.test", :row 17, :ns nil, :var-definitions [{:doc "True by default.  If set to false, no test functions will\n   be created by deftest, set-test, or with-test.  Use this to omit\n   tests when compiling or loading production code.", :end-row 250, :filename "clojure/test.clj", :name "*load-tests*", :ns "clojure.test", :row 245} {:doc "The maximum depth of stack traces to print when an Exception\n  is thrown during a test.  Defaults to nil, which means print the \n  complete stack trace.", :end-row 257, :filename "clojure/test.clj", :name "*stack-trace-depth*", :ns "clojure.test", :row 252} {:end-row 262, :filename "clojure/test.clj", :name "*report-counters*", :ns "clojure.test", :row 262} {:end-row 265, :filename "clojure/test.clj", :name "*initial-report-counters*", :ns "clojure.test", :row 264} {:end-row 267, :filename "clojure/test.clj", :name "*testing-vars*", :ns "clojure.test", :row 267} {:end-row 269, :filename "clojure/test.clj", :name "*testing-contexts*", :ns "clojure.test", :row 269} {:end-row 271, :filename "clojure/test.clj", :name "*test-out*", :ns "clojure.test", :row 271} {:arglist-strs ["[& body]"], :doc "Runs body with *out* bound to the value of *test-out*.", :end-row 278, :filename "clojure/test.clj", :macro true, :name "with-test-out", :ns "clojure.test", :row 273} {:fixed-arities #{1}, :end-row 292, :ns "clojure.test", :name "file-position", :filename "clojure/test.clj", :deprecated "1.2", :arglist-strs ["[n]"], :doc "Returns a vector [filename line-number] for the nth call up the\n  stack.\n\n  Deprecated in 1.2: The information needed for test reporting is\n  now on :file and :line keys in the result map.", :row 282} {:arglist-strs ["[m]"], :doc "Returns a string representation of the current test.  Renders names\n  in *testing-vars* as a list, then the source file and line of\n  current assertion.", :end-row 305, :filename "clojure/test.clj", :fixed-arities #{1}, :name "testing-vars-str", :ns "clojure.test", :row 294} {:arglist-strs ["[]"], :doc "Returns a string representation of the current test context. Joins\n  strings in *testing-contexts* with spaces.", :end-row 312, :filename "clojure/test.clj", :fixed-arities #{0}, :name "testing-contexts-str", :ns "clojure.test", :row 307} {:arglist-strs ["[name]"], :doc "Increments the named counter in *report-counters*, a ref to a map.\n  Does nothing if *report-counters* is nil.", :end-row 320, :filename "clojure/test.clj", :fixed-arities #{1}, :name "inc-report-counter", :ns "clojure.test", :row 314} {:doc "Generic reporting function, may be overridden to plug in\n   different report formats (e.g., TAP, JUnit).  Assertions such as\n   'is' call 'report' to indicate results.  The argument given to\n   'report' will be a map with a :type key.  See the documentation at\n   the top of test_is.clj for more information on the types of\n   arguments for 'report'.", :end-row 333, :filename "clojure/test.clj", :name "report", :ns "clojure.test", :row 324} {:fixed-arities #{2}, :end-row 342, :private true, :ns "clojure.test", :name "file-and-line", :filename "clojure/test.clj", :deprecated "1.8", :arglist-strs ["[exception depth]"], :row 335} {:arglist-strs ["[stacktrace]"], :end-row 349, :filename "clojure/test.clj", :fixed-arities #{1}, :name "stacktrace-file-and-line", :ns "clojure.test", :private true, :row 344} {:arglist-strs ["[m]"], :doc "Add file and line information to a test result and call report.\n   If you are writing a custom assert-expr method, call this function\n   to pass test results to report.", :end-row 367, :filename "clojure/test.clj", :fixed-arities #{1}, :name "do-report", :ns "clojure.test", :row 351} {:arglist-strs ["[v]"], :doc "Like var-get but returns nil if the var is unbound.", :end-row 422, :filename "clojure/test.clj", :fixed-arities #{1}, :name "get-possibly-unbound-var", :ns "clojure.test", :row 416} {:arglist-strs ["[x]"], :doc "Returns true if argument is a function or a symbol that resolves to\n  a function (not a macro).", :end-row 434, :filename "clojure/test.clj", :fixed-arities #{1}, :name "function?", :ns "clojure.test", :row 424} {:arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any functional predicate.  The\n  'expected' argument to 'report' will contains the original form, the\n  'actual' argument will contain the form with all its sub-forms\n  evaluated.  If the predicate returns false, the 'actual' form will\n  be wrapped in (not...).", :end-row 453, :filename "clojure/test.clj", :fixed-arities #{2}, :name "assert-predicate", :ns "clojure.test", :row 436} {:arglist-strs ["[msg form]"], :doc "Returns generic assertion code for any test, including macros, Java\n  method calls, or isolated symbols.", :end-row 466, :filename "clojure/test.clj", :fixed-arities #{2}, :name "assert-any", :ns "clojure.test", :row 455} {:end-row 481, :filename "clojure/test.clj", :name "assert-expr", :ns "clojure.test", :row 476} {:fixed-arities #{2}, :end-row 546, :ns "clojure.test", :name "try-expr", :filename "clojure/test.clj", :macro true, :arglist-strs ["[msg form]"], :doc "Used by the 'is' macro to catch unexpected exceptions.\n  You don't call this.", :row 538} {:fixed-arities #{1 2}, :end-row 570, :ns "clojure.test", :name "is", :filename "clojure/test.clj", :macro true, :arglist-strs ["[form]" "[form msg]"], :doc "Generic assertion macro.  'form' is any predicate test.\n  'msg' is an optional message to attach to the assertion.\n  \n  Example: (is (= 4 (+ 2 2)) \"Two plus two should be 4\")\n\n  Special forms:\n\n  (is (thrown? c body)) checks that an instance of c is thrown from\n  body, fails if not; then returns the thing thrown.\n\n  (is (thrown-with-msg? c re body)) checks that an instance of c is\n  thrown AND that the message on the exception matches (with\n  re-find) the regular expression re.", :row 554} {:arglist-strs ["[argv expr & args]"], :doc "Checks multiple assertions with a template expression.\n  See clojure.template/do-template for an explanation of\n  templates.\n\n  Example: (are [x y] (= x y)  \n                2 (+ 1 1)\n                4 (* 2 2))\n  Expands to: \n           (do (is (= 2 (+ 1 1)))\n               (is (= 4 (* 2 2))))\n\n  Note: This breaks some reporting features, such as line numbers.", :end-row 595, :filename "clojure/test.clj", :macro true, :name "are", :ns "clojure.test", :row 572} {:arglist-strs ["[string & body]"], :doc "Adds a new string to the list of testing contexts.  May be nested,\n  but must occur inside a test function (deftest).", :end-row 603, :filename "clojure/test.clj", :macro true, :name "testing", :ns "clojure.test", :row 597} {:arglist-strs ["[definition & body]"], :doc "Takes any definition form (that returns a Var) as the first argument.\n  Remaining body goes in the :test metadata function for that Var.\n\n  When *load-tests* is false, only evaluates the definition, ignoring\n  the tests.", :end-row 619, :filename "clojure/test.clj", :macro true, :name "with-test", :ns "clojure.test", :row 609} {:arglist-strs ["[name & body]"], :doc "Defines a test function with no arguments.  Test functions may call\n  other tests, so tests may be composed.  If you compose tests, you\n  should also define a function named test-ns-hook; run-tests will\n  call test-ns-hook instead of testing all vars.\n\n  Note: Actually, the test body goes in the :test metadata on the var,\n  and the real function (the value of the var) calls test-var on\n  itself.\n\n  When *load-tests* is false, deftest is ignored.", :end-row 637, :filename "clojure/test.clj", :macro true, :name "deftest", :ns "clojure.test", :row 622} {:arglist-strs ["[name & body]"], :doc "Like deftest but creates a private var.", :end-row 645, :filename "clojure/test.clj", :macro true, :name "deftest-", :ns "clojure.test", :row 639} {:arglist-strs ["[name & body]"], :doc "Experimental.\n  Sets :test metadata of the named var to a fn with the given body.\n  The var must already exist.  Does not modify the value of the var.\n\n  When *load-tests* is false, set-test is ignored.", :end-row 657, :filename "clojure/test.clj", :macro true, :name "set-test", :ns "clojure.test", :row 648} {:fixed-arities #{2}, :end-row 668, :private true, :ns "clojure.test", :name "add-ns-meta", :filename "clojure/test.clj", :arglist-strs ["[key coll]"], :doc "Adds elements in coll to the current namespace metadata as the\n  value of key.", :row 663} {:doc "Wrap test runs in a fixture function to perform setup and\n  teardown. Using a fixture-type of :each wraps every test\n  individually, while :once wraps the whole run in a single function.", :end-row 675, :filename "clojure/test.clj", :name "use-fixtures", :ns "clojure.test", :row 670} {:fixed-arities #{1}, :end-row 687, :private true, :ns "clojure.test", :name "default-fixture", :filename "clojure/test.clj", :arglist-strs ["[f]"], :doc "The default, empty, fixture function.  Just calls its argument.", :row 683} {:arglist-strs ["[f1 f2]"], :doc "Composes two fixture functions, creating a new fixture function\n  that combines their behavior.", :end-row 694, :filename "clojure/test.clj", :fixed-arities #{2}, :name "compose-fixtures", :ns "clojure.test", :row 689} {:arglist-strs ["[fixtures]"], :doc "Composes a collection of fixtures, in order.  Always returns a valid\n  fixture function, even if the collection is empty.", :end-row 701, :filename "clojure/test.clj", :fixed-arities #{1}, :name "join-fixtures", :ns "clojure.test", :row 696} {:arglist-strs ["[v]"], :doc "If v has a function in its :test metadata, calls that function,\n  with *testing-vars* bound to (conj *testing-vars* v).", :end-row 721, :filename "clojure/test.clj", :fixed-arities #{1}, :name "test-var", :ns "clojure.test", :row 708} {:arglist-strs ["[vars]"], :doc "Groups vars by their namespace and runs test-var on them with\n  appropriate fixtures applied.", :end-row 735, :filename "clojure/test.clj", :fixed-arities #{1}, :name "test-vars", :ns "clojure.test", :row 723} {:arglist-strs ["[ns]"], :doc "Calls test-vars on every var interned in the namespace, with fixtures.", :end-row 741, :filename "clojure/test.clj", :fixed-arities #{1}, :name "test-all-vars", :ns "clojure.test", :row 737} {:arglist-strs ["[ns]"], :doc "If the namespace defines a function named test-ns-hook, calls that.\n  Otherwise, calls test-all-vars on the namespace.  'ns' is a\n  namespace object or a symbol.\n\n  Internally binds *report-counters* to a ref initialized to\n  *initial-report-counters*.  Returns the final, dereferenced state of\n  *report-counters*.", :end-row 762, :filename "clojure/test.clj", :fixed-arities #{1}, :name "test-ns", :ns "clojure.test", :row 743} {:arglist-strs ["[]" "[& namespaces]"], :doc "Runs all tests in the given namespaces; prints results.\n  Defaults to current namespace if none given.  Returns a map\n  summarizing test results.", :end-row 778, :filename "clojure/test.clj", :fixed-arities #{0}, :name "run-tests", :ns "clojure.test", :row 768} {:arglist-strs ["[]" "[re]"], :doc "Runs all tests in all namespaces; prints results.\n  Optional argument is a regular expression; only namespaces with\n  names matching the regular expression (with re-matches) will be\n  tested.", :end-row 787, :filename "clojure/test.clj", :fixed-arities #{0 1}, :name "run-all-tests", :ns "clojure.test", :row 780} {:arglist-strs ["[summary]"], :doc "Returns true if the given test summary indicates all tests\n  were successful, false otherwise.", :end-row 795, :filename "clojure/test.clj", :fixed-arities #{1}, :name "successful?", :ns "clojure.test", :row 789} {:arglist-strs ["[v]"], :doc "Runs the tests for a single Var, with fixtures executed around the test, and summary output after.", :end-row 811, :filename "clojure/test.clj", :fixed-arities #{1}, :name "run-test-var", :ns "clojure.test", :row 797} {:fixed-arities #{1}, :end-row 830, :ns "clojure.test", :name "run-test", :filename "clojure/test.clj", :macro true, :arglist-strs ["[test-symbol]"], :doc "Runs a single test.\n\n  Because the intent is to run a single test, there is no check for the namespace test-ns-hook.", :row 813}]} {:author "Rich Hickey", :doc "The core Clojure language.", :end-row 11, :filename "clojure/core.clj", :name "clojure.core", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[c invalid-method?]"], :end-row 40, :filename "clojure/genclass.clj", :fixed-arities #{2}, :name "filter-methods", :ns "clojure.core", :private true, :row 19} {:arglist-strs ["[c]"], :end-row 49, :filename "clojure/genclass.clj", :fixed-arities #{1}, :name "non-private-methods", :ns "clojure.core", :private true, :row 42} {:arglist-strs ["[c]"], :end-row 57, :filename "clojure/genclass.clj", :fixed-arities #{1}, :name "protected-final-methods", :ns "clojure.core", :private true, :row 51} {:arglist-strs ["[super]"], :end-row 62, :filename "clojure/genclass.clj", :fixed-arities #{1}, :name "ctor-sigs", :ns "clojure.core", :private true, :row 59} {:arglist-strs ["[c]"], :end-row 66, :filename "clojure/genclass.clj", :fixed-arities #{1}, :name "escape-class-name", :ns "clojure.core", :private true, :row 64} {:arglist-strs ["[mname pclasses]"], :end-row 72, :filename "clojure/genclass.clj", :fixed-arities #{2}, :name "overload-name", :ns "clojure.core", :private true, :row 68} {:arglist-strs ["[c f]"], :end-row 81, :filename "clojure/genclass.clj", :fixed-arities #{2}, :name "find-field", :ns "clojure.core", :private true, :row 74} {:end-row 102, :filename "clojure/genclass.clj", :name "prim->class", :ns "clojure.core", :private true, :row 85} {:arglist-strs ["[x]"], :end-row 112, :filename "clojure/genclass.clj", :fixed-arities #{1}, :name "the-class", :ns "clojure.core", :private true, :row 104} {:arglist-strs ["[s]"], :end-row 117, :filename "clojure/genclass.clj", :fixed-arities #{1}, :name "valid-java-method-name", :ns "clojure.core", :private true, :row 115} {:arglist-strs ["[{:keys [methods]}]"], :end-row 122, :filename "clojure/genclass.clj", :fixed-arities #{1}, :name "validate-generate-class-options", :ns "clojure.core", :private true, :row 119} {:arglist-strs ["[options-map]"], :end-row 505, :filename "clojure/genclass.clj", :fixed-arities #{1}, :name "generate-class", :ns "clojure.core", :private true, :row 124} {:arglist-strs ["[& options]"], :doc "When compiling, generates compiled bytecode for a class with the\n  given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does\n  nothing. The gen-class construct contains no implementation, as the\n  implementation will be dynamically sought by the generated class in\n  functions in an implementing Clojure namespace. Given a generated\n  class org.mydomain.MyClass with a method named mymethod, gen-class\n  will generate an implementation that looks for a function named by \n  (str prefix mymethod) (default prefix: \"-\") in a\n  Clojure namespace specified by :impl-ns\n  (defaults to the current namespace). All inherited methods,\n  generated methods, and init and main functions (see :methods, :init,\n  and :main below) will be found similarly prefixed. By default, the\n  static initializer for the generated class will attempt to load the\n  Clojure support code for the class as a resource from the classpath,\n  e.g. in the example case, ``org/mydomain/MyClass__init.class``. This\n  behavior can be controlled by :load-impl-ns\n\n  Note that methods with a maximum of 18 parameters are supported.\n\n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n\n  Options should be a set of key/value pairs, all except for :name are optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends aclass\n\n  Specifies the superclass, the non-private methods of which will be\n  overridden by the class. If not provided, defaults to Object.\n\n  :implements [interface ...]\n\n  One or more interfaces, the methods of which will be implemented by the class.\n\n  :init name\n\n  If supplied, names a function that will be called with the arguments\n  to the constructor. Must return [ [superclass-constructor-args] state] \n  If not supplied, the constructor args are passed directly to\n  the superclass constructor and the state will be nil\n\n  :constructors {[param-types] [super-param-types], ...}\n\n  By default, constructors are created for the generated class which\n  match the signature(s) of the constructors for the superclass. This\n  parameter may be used to explicitly specify constructors, each entry\n  providing a mapping from a constructor signature to a superclass\n  constructor signature. When you supply this, you must supply an :init\n  specifier. \n\n  :post-init name\n\n  If supplied, names a function that will be called with the object as\n  the first argument, followed by the arguments to the constructor.\n  It will be called every time an object of this class is created,\n  immediately after all the inherited constructors have completed.\n  Its return value is ignored.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  The generated class automatically defines all of the non-private\n  methods of its superclasses/interfaces. This parameter can be used\n  to specify the signatures of additional methods of the generated\n  class. Static methods can be specified with ^{:static true} in the\n  signature's metadata. Do not repeat superclass/interface signatures\n  here.\n\n  :main boolean\n\n  If supplied and true, a static public main function will be generated. It will\n  pass each string of the String[] argument as a separate argument to\n  a function called (str prefix main).\n\n  :factory name\n\n  If supplied, a (set of) public static factory function(s) will be\n  created with the given name, and the same signature(s) as the\n  constructor(s).\n  \n  :state name\n\n  If supplied, a public final instance field with the given name will be\n  created. You must supply an :init function in order to provide a\n  value for the state. Note that, though final, the state can be a ref\n  or agent, supporting the creation of Java objects with transactional\n  or asynchronous mutation semantics.\n\n  :exposes {protected-field-name {:get name :set name}, ...}\n\n  Since the implementations of the methods of the generated class\n  occur in Clojure functions, they have no access to the inherited\n  protected fields of the superclass. This parameter can be used to\n  generate public getter/setter methods exposing the protected field(s)\n  for use in the implementation.\n\n  :exposes-methods {super-method-name exposed-name, ...}\n\n  It is sometimes necessary to call the superclass' implementation of an\n  overridden method.  Those methods may be exposed and referred in \n  the new method implementation by a local name.\n\n  :prefix string\n\n  Default: \"-\" Methods called e.g. Foo will be looked up in vars called\n  prefixFoo in the implementing ns.\n\n  :impl-ns name\n\n  Default: the name of the current ns. Implementations of methods will be \n  looked up in this namespace.\n\n  :load-impl-ns boolean\n\n  Default: true. Causes the static initializer for the generated class\n  to reference the load code for the implementing namespace. Should be\n  true when implementing-ns is the default, false if you intend to\n  load the code via some other method.", :end-row 638, :filename "clojure/genclass.clj", :macro true, :name "gen-class", :ns "clojure.core", :row 507} {:fixed-arities #{1}, :end-row 656, :private true, :ns "clojure.core", :name "asm-type", :filename "clojure/genclass.clj", :arglist-strs ["[c]"], :doc "Returns an asm Type object for c, which may be a primitive class\n  (such as Integer/TYPE), any other class (such as Double), or a\n  fully-qualified class name given as a string or symbol\n  (such as 'java.lang.String)", :row 643} {:arglist-strs ["[{:keys [name extends methods]}]"], :end-row 686, :filename "clojure/genclass.clj", :fixed-arities #{1}, :name "generate-interface", :ns "clojure.core", :private true, :row 658} {:arglist-strs ["[& options]"], :doc "When compiling, generates compiled bytecode for an interface with\n  the given package-qualified :name (which, as all names in these\n  parameters, can be a string or symbol), and writes the .class file\n  to the *compile-path* directory.  When not compiling, does nothing.\n \n  In all subsequent sections taking types, the primitive types can be\n  referred to by their Java names (int, float etc), and classes in the\n  java.lang package can be used without a package qualifier. All other\n  classes must be fully qualified.\n \n  Options should be a set of key/value pairs, all except for :name are\n  optional:\n\n  :name aname\n\n  The package-qualified name of the class to be generated\n\n  :extends [interface ...]\n\n  One or more interfaces, which will be extended by this interface.\n\n  :methods [ [name [param-types] return-type], ...]\n\n  This parameter is used to specify the signatures of the methods of\n  the generated interface.  Do not repeat superinterface signatures\n  here.", :end-row 723, :filename "clojure/genclass.clj", :macro true, :name "gen-interface", :ns "clojure.core", :row 688} {:arglist-strs ["[& options]"], :doc "Generates and immediately loads the bytecode for the specified\n  class. Note that a class generated this way can be loaded only once\n  - the JVM supports only one class with a given name per\n  classloader. Subsequent to generation you can import it into any\n  desired namespaces just like any other class. See gen-class for a\n  description of the options.", :end-row 739, :filename "clojure/genclass.clj", :name "gen-and-load-class", :ns "clojure.core", :row 727} {:end-row 13, :filename "clojure/core.clj", :name "unquote", :ns "clojure.core", :row 13} {:end-row 14, :filename "clojure/core.clj", :name "unquote-splicing", :ns "clojure.core", :row 14} {:doc "Creates a new list containing the items.", :end-row 20, :filename "clojure/core.clj", :name "list", :ns "clojure.core", :row 16} {:arglist-strs ["[x seq]"], :doc "Returns a new seq where x is the first element and seq is\n    the rest.", :end-row 29, :filename "clojure/core.clj", :fixed-arities #{2}, :name "cons", :ns "clojure.core", :row 22} {:end-row 35, :filename "clojure/core.clj", :macro true, :name "let", :ns "clojure.core", :row 32} {:end-row 40, :filename "clojure/core.clj", :macro true, :name "loop", :ns "clojure.core", :row 37} {:end-row 47, :filename "clojure/core.clj", :macro true, :name "fn", :ns "clojure.core", :row 42} {:arglist-strs ["[coll]"], :doc "Returns the first item in the collection. Calls seq on its\n    argument. If coll is nil, returns nil.", :end-row 55, :filename "clojure/core.clj", :fixed-arities #{1}, :name "first", :ns "clojure.core", :row 49} {:arglist-strs ["[x]"], :doc "Returns a seq of the items after the first. Calls seq on its\n  argument.  If there are no more items, returns nil.", :end-row 64, :filename "clojure/core.clj", :fixed-arities #{1}, :name "next", :ns "clojure.core", :row 57} {:arglist-strs ["[x]"], :doc "Returns a possibly empty seq of the items after the first. Calls seq on its\n  argument.", :end-row 73, :filename "clojure/core.clj", :fixed-arities #{1}, :name "rest", :ns "clojure.core", :row 66} {:arglist-strs ["[]" "[coll]" "[coll x]" "[coll x & xs]"], :doc "conj[oin]. Returns a new collection with the xs\n    'added'. (conj nil item) returns (item).\n    (conj coll) returns coll. (conj) returns [].\n    The 'addition' may happen at different 'places' depending\n    on the concrete type.", :end-row 91, :filename "clojure/core.clj", :fixed-arities #{0 1 2}, :name "conj", :ns "clojure.core", :row 75} {:arglist-strs ["[x]"], :doc "Same as (first (next x))", :end-row 98, :filename "clojure/core.clj", :fixed-arities #{1}, :name "second", :ns "clojure.core", :row 93} {:arglist-strs ["[x]"], :doc "Same as (first (first x))", :end-row 105, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ffirst", :ns "clojure.core", :row 100} {:arglist-strs ["[x]"], :doc "Same as (next (first x))", :end-row 112, :filename "clojure/core.clj", :fixed-arities #{1}, :name "nfirst", :ns "clojure.core", :row 107} {:arglist-strs ["[x]"], :doc "Same as (first (next x))", :end-row 119, :filename "clojure/core.clj", :fixed-arities #{1}, :name "fnext", :ns "clojure.core", :row 114} {:arglist-strs ["[x]"], :doc "Same as (next (next x))", :end-row 126, :filename "clojure/core.clj", :fixed-arities #{1}, :name "nnext", :ns "clojure.core", :row 121} {:arglist-strs ["[coll]"], :doc "Returns a seq on the collection. If the collection is\n    empty, returns nil.  (seq nil) returns nil. seq also works on\n    Strings, native Java arrays (of reference types) and any objects\n    that implement Iterable. Note that seqs cache values, thus seq\n    should not be used on any Iterable whose iterator repeatedly\n    returns the same mutable object.", :end-row 139, :filename "clojure/core.clj", :fixed-arities #{1}, :name "seq", :ns "clojure.core", :row 128} {:arglist-strs ["[c x]"], :doc "Evaluates x and tests if it is an instance of the class\n    c. Returns true or false", :end-row 146, :filename "clojure/core.clj", :fixed-arities #{2}, :name "instance?", :ns "clojure.core", :row 141} {:arglist-strs ["[x]"], :doc "Return true if x implements ISeq", :end-row 153, :filename "clojure/core.clj", :fixed-arities #{1}, :name "seq?", :ns "clojure.core", :row 148} {:arglist-strs ["[x]"], :doc "Return true if x is a Character", :end-row 160, :filename "clojure/core.clj", :fixed-arities #{1}, :name "char?", :ns "clojure.core", :row 155} {:arglist-strs ["[x]"], :doc "Return true if x is a String", :end-row 167, :filename "clojure/core.clj", :fixed-arities #{1}, :name "string?", :ns "clojure.core", :row 162} {:arglist-strs ["[x]"], :doc "Return true if x implements IPersistentMap", :end-row 174, :filename "clojure/core.clj", :fixed-arities #{1}, :name "map?", :ns "clojure.core", :row 169} {:arglist-strs ["[x]"], :doc "Return true if x implements IPersistentVector", :end-row 181, :filename "clojure/core.clj", :fixed-arities #{1}, :name "vector?", :ns "clojure.core", :row 176} {:arglist-strs ["[map key val]" "[map key val & kvs]"], :doc "assoc[iate]. When applied to a map, returns a new map of the\n    same (hashed/sorted) type, that contains the mapping of key(s) to\n    val(s). When applied to a vector, returns a new vector that\n    contains val at index. Note - index must be <= (count vector).", :end-row 201, :filename "clojure/core.clj", :fixed-arities #{3}, :name "assoc", :ns "clojure.core", :row 183} {:arglist-strs ["[x]"], :doc "Returns the metadata of obj, returns nil if there is no metadata.", :end-row 211, :filename "clojure/core.clj", :fixed-arities #{1}, :name "meta", :ns "clojure.core", :row 204} {:arglist-strs ["[x m]"], :doc "Returns an object of the same type and value as obj, with\n    map m as its metadata.", :end-row 220, :filename "clojure/core.clj", :fixed-arities #{2}, :name "with-meta", :ns "clojure.core", :row 213} {:arglist-strs ["[fdecl]"], :end-row 223, :filename "clojure/core.clj", :fixed-arities #{1}, :name "assert-valid-fdecl", :ns "clojure.core", :private true, :row 222} {:arglist-strs ["[fdecl]"], :end-row 261, :filename "clojure/core.clj", :fixed-arities #{1}, :name "sigs", :ns "clojure.core", :private true, :row 225} {:arglist-strs ["[s]"], :doc "Return the last item in coll, in linear time", :end-row 272, :filename "clojure/core.clj", :fixed-arities #{1}, :name "last", :ns "clojure.core", :row 264} {:arglist-strs ["[s]"], :doc "Return a seq of all but the last item in coll, in linear time", :end-row 283, :filename "clojure/core.clj", :fixed-arities #{1}, :name "butlast", :ns "clojure.core", :row 274} {:fixed-arities #{}, :end-row 336, :ns "clojure.core", :name "defn", :filename "clojure/core.clj", :macro true, :arglist-strs ["[&form &env name & fdecl]"], :doc "Same as (def name (fn [params* ] exprs*)) or (def\n    name (fn ([params* ] exprs*)+)) with any doc-string or attrs added\n    to the var metadata. prepost-map defines a map with optional keys\n    :pre and :post that contain collections of pre or post conditions.", :row 285} {:arglist-strs ["[coll]"], :doc "Returns an array of Objects containing the contents of coll, which\n  can be any Collection.  Maps to java.util.Collection.toArray().", :end-row 346, :filename "clojure/core.clj", :fixed-arities #{1}, :name "to-array", :ns "clojure.core", :row 340} {:arglist-strs ["[c x]"], :doc "Throws a ClassCastException if x is not a c, else returns x.", :end-row 353, :filename "clojure/core.clj", :fixed-arities #{2}, :name "cast", :ns "clojure.core", :row 348} {:arglist-strs ["[]" "[a]" "[a b]" "[a b c]" "[a b c d]" "[a b c d e]" "[a b c d e f]" "[a b c d e f & args]"], :doc "Creates a new vector containing the args.", :end-row 367, :filename "clojure/core.clj", :fixed-arities #{0 1 4 6 3 2 5}, :name "vector", :ns "clojure.core", :row 355} {:arglist-strs ["[coll]"], :doc "Creates a new vector containing the contents of coll. Java arrays\n  will be aliased and should not be modified.", :end-row 379, :filename "clojure/core.clj", :fixed-arities #{1}, :name "vec", :ns "clojure.core", :row 369} {:arglist-strs ["[]" "[& keyvals]"], :doc "keyval => key val\n  Returns a new hash map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", :end-row 389, :filename "clojure/core.clj", :fixed-arities #{0}, :name "hash-map", :ns "clojure.core", :row 381} {:arglist-strs ["[]" "[& keys]"], :doc "Returns a new hash set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :end-row 398, :filename "clojure/core.clj", :fixed-arities #{0}, :name "hash-set", :ns "clojure.core", :row 391} {:arglist-strs ["[& keyvals]"], :doc "keyval => key val\n  Returns a new sorted map with supplied mappings.  If any keys are\n  equal, they are handled as if by repeated uses of assoc.", :end-row 407, :filename "clojure/core.clj", :name "sorted-map", :ns "clojure.core", :row 400} {:arglist-strs ["[comparator & keyvals]"], :doc "keyval => key val\n  Returns a new sorted map with supplied mappings, using the supplied\n  comparator.  If any keys are equal, they are handled as if by\n  repeated uses of assoc.", :end-row 417, :filename "clojure/core.clj", :name "sorted-map-by", :ns "clojure.core", :row 409} {:arglist-strs ["[& keys]"], :doc "Returns a new sorted set with supplied keys.  Any equal keys are\n  handled as if by repeated uses of conj.", :end-row 425, :filename "clojure/core.clj", :name "sorted-set", :ns "clojure.core", :row 419} {:arglist-strs ["[comparator & keys]"], :doc "Returns a new sorted set with supplied keys, using the supplied\n  comparator.  Any equal keys are handled as if by repeated uses of\n  conj.", :end-row 434, :filename "clojure/core.clj", :name "sorted-set-by", :ns "clojure.core", :row 427} {:arglist-strs ["[x]"], :doc "Returns true if x is nil, false otherwise.", :end-row 444, :filename "clojure/core.clj", :fixed-arities #{1}, :name "nil?", :ns "clojure.core", :row 438} {:fixed-arities #{}, :end-row 490, :ns "clojure.core", :name "defmacro", :filename "clojure/core.clj", :macro true, :arglist-strs ["[&form &env name & args]"], :doc "Like defn, but the resulting function name is declared as a\n  macro and will be used as a macro by the compiler when it is\n  called.", :row 446} {:arglist-strs ["[test & body]"], :doc "Evaluates test. If logical true, evaluates body in an implicit do.", :end-row 499, :filename "clojure/core.clj", :macro true, :name "when", :ns "clojure.core", :row 495} {:arglist-strs ["[test & body]"], :doc "Evaluates test. If logical false, evaluates body in an implicit do.", :end-row 505, :filename "clojure/core.clj", :macro true, :name "when-not", :ns "clojure.core", :row 501} {:arglist-strs ["[x]"], :doc "Returns true if x is the value false, false otherwise.", :end-row 512, :filename "clojure/core.clj", :fixed-arities #{1}, :name "false?", :ns "clojure.core", :row 507} {:arglist-strs ["[x]"], :doc "Returns true if x is the value true, false otherwise.", :end-row 519, :filename "clojure/core.clj", :fixed-arities #{1}, :name "true?", :ns "clojure.core", :row 514} {:arglist-strs ["[x]"], :doc "Return true if x is a Boolean", :end-row 524, :filename "clojure/core.clj", :fixed-arities #{1}, :name "boolean?", :ns "clojure.core", :row 521} {:arglist-strs ["[x]"], :doc "Returns true if x is logical false, false otherwise.", :end-row 531, :filename "clojure/core.clj", :fixed-arities #{1}, :name "not", :ns "clojure.core", :row 526} {:arglist-strs ["[x]"], :doc "Returns true if x is not nil, false otherwise.", :end-row 538, :filename "clojure/core.clj", :fixed-arities #{1}, :name "some?", :ns "clojure.core", :row 533} {:arglist-strs ["[x]"], :doc "Returns true given any argument.", :end-row 544, :filename "clojure/core.clj", :fixed-arities #{1}, :name "any?", :ns "clojure.core", :row 540} {:arglist-strs ["[]" "[x]" "[x & ys]"], :doc "With no args, returns the empty string. With one arg x, returns\n  x.toString().  (str nil) returns the empty string. With more than\n  one arg, returns the concatenation of the str values of the args.", :end-row 561, :filename "clojure/core.clj", :fixed-arities #{0 1}, :name "str", :ns "clojure.core", :row 546} {:arglist-strs ["[x]"], :doc "Return true if x is a Symbol", :end-row 568, :filename "clojure/core.clj", :fixed-arities #{1}, :name "symbol?", :ns "clojure.core", :row 564} {:arglist-strs ["[x]"], :doc "Return true if x is a Keyword", :end-row 574, :filename "clojure/core.clj", :fixed-arities #{1}, :name "keyword?", :ns "clojure.core", :row 570} {:arglist-strs ["[& clauses]"], :doc "Takes a set of test/expr pairs. It evaluates each test one at a\n  time.  If a test returns logical true, cond evaluates and returns\n  the value of the corresponding expr and doesn't evaluate any of the\n  other tests or exprs. (cond) returns nil.", :end-row 589, :filename "clojure/core.clj", :macro true, :name "cond", :ns "clojure.core", :row 576} {:arglist-strs ["[name]" "[ns name]"], :doc "Returns a Symbol with the given namespace and name. Arity-1 works\n  on strings, keywords, and vars.", :end-row 604, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "symbol", :ns "clojure.core", :row 591} {:arglist-strs ["[]" "[prefix-string]"], :doc "Returns a new symbol with a unique name. If a prefix string is\n  supplied, the name is prefix# where # is some unique number. If\n  prefix is not supplied, the prefix is 'G__'.", :end-row 613, :filename "clojure/core.clj", :fixed-arities #{0 1}, :name "gensym", :ns "clojure.core", :row 606} {:arglist-strs ["[name]" "[ns name]"], :doc "Returns a Keyword with the given namespace and name.  Do not use :\n  in the keyword strings, it will be added automatically.", :end-row 625, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "keyword", :ns "clojure.core", :row 616} {:arglist-strs ["[name]" "[ns name]"], :doc "Returns a Keyword with the given namespace and name if one already\n  exists.  This function will not intern a new keyword. If the keyword\n  has not already been interned, it will return nil.  Do not use :\n  in the keyword strings, it will be added automatically.", :end-row 638, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "find-keyword", :ns "clojure.core", :row 627} {:arglist-strs ["[arglist]"], :end-row 648, :filename "clojure/core.clj", :fixed-arities #{1}, :name "spread", :ns "clojure.core", :private true, :row 641} {:arglist-strs ["[args]" "[a args]" "[a b args]" "[a b c args]" "[a b c d & more]"], :doc "Creates a new seq containing the items prepended to the rest, the\n  last of which will be treated as a sequence.", :end-row 660, :filename "clojure/core.clj", :fixed-arities #{1 4 3 2}, :name "list*", :ns "clojure.core", :row 650} {:arglist-strs ["[f args]" "[f x args]" "[f x y args]" "[f x y z args]" "[f a b c d & args]"], :doc "Applies fn f to the argument list formed by prepending intervening arguments to args.", :end-row 675, :filename "clojure/core.clj", :fixed-arities #{4 3 2 5}, :name "apply", :ns "clojure.core", :row 662} {:arglist-strs ["[obj f & args]"], :doc "Returns an object of the same type and value as obj, with\n  (apply f (meta obj) args) as its metadata.", :end-row 683, :filename "clojure/core.clj", :name "vary-meta", :ns "clojure.core", :row 677} {:arglist-strs ["[& body]"], :doc "Takes a body of expressions that returns an ISeq or nil, and yields\n  a Seqable object that will invoke the body only the first time seq\n  is called, and will cache the result and return it on all subsequent\n  seq calls. See also - realized?", :end-row 692, :filename "clojure/core.clj", :macro true, :name "lazy-seq", :ns "clojure.core", :row 685} {:arglist-strs ["[capacity]"], :end-row 695, :filename "clojure/core.clj", :fixed-arities #{1}, :name "chunk-buffer", :ns "clojure.core", :row 694} {:arglist-strs ["[b x]"], :end-row 698, :filename "clojure/core.clj", :fixed-arities #{2}, :name "chunk-append", :ns "clojure.core", :row 697} {:arglist-strs ["[b]"], :end-row 701, :filename "clojure/core.clj", :fixed-arities #{1}, :name "chunk", :ns "clojure.core", :row 700} {:arglist-strs ["[s]"], :end-row 704, :filename "clojure/core.clj", :fixed-arities #{1}, :name "chunk-first", :ns "clojure.core", :row 703} {:arglist-strs ["[s]"], :end-row 707, :filename "clojure/core.clj", :fixed-arities #{1}, :name "chunk-rest", :ns "clojure.core", :row 706} {:arglist-strs ["[s]"], :end-row 710, :filename "clojure/core.clj", :fixed-arities #{1}, :name "chunk-next", :ns "clojure.core", :row 709} {:arglist-strs ["[chunk rest]"], :end-row 715, :filename "clojure/core.clj", :fixed-arities #{2}, :name "chunk-cons", :ns "clojure.core", :row 712} {:arglist-strs ["[s]"], :end-row 718, :filename "clojure/core.clj", :fixed-arities #{1}, :name "chunked-seq?", :ns "clojure.core", :row 717} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & zs]"], :doc "Returns a lazy seq representing the concatenation of the elements in the supplied colls.", :end-row 745, :filename "clojure/core.clj", :fixed-arities #{0 1 2}, :name "concat", :ns "clojure.core", :row 720} {:arglist-strs ["[& body]"], :doc "Takes a body of expressions and yields a Delay object that will\n  invoke the body only the first time it is forced (with force or deref/@), and\n  will cache the result and return it on all subsequent force\n  calls. See also - realized?", :end-row 755, :filename "clojure/core.clj", :macro true, :name "delay", :ns "clojure.core", :row 748} {:arglist-strs ["[x]"], :doc "returns true if x is a Delay created with delay", :end-row 761, :filename "clojure/core.clj", :fixed-arities #{1}, :name "delay?", :ns "clojure.core", :row 757} {:arglist-strs ["[x]"], :doc "If x is a Delay, returns the (possibly cached) value of its expression, else returns x", :end-row 767, :filename "clojure/core.clj", :fixed-arities #{1}, :name "force", :ns "clojure.core", :row 763} {:fixed-arities #{3 2}, :end-row 775, :ns "clojure.core", :name "if-not", :filename "clojure/core.clj", :macro true, :arglist-strs ["[test then]" "[test then else]"], :doc "Evaluates test. If logical false, evaluates and returns then expr, \n  otherwise else expr, if supplied, else nil.", :row 769} {:arglist-strs ["[x y]"], :doc "Tests if 2 arguments are the same object", :end-row 782, :filename "clojure/core.clj", :fixed-arities #{2}, :name "identical?", :ns "clojure.core", :row 777} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Equality. Returns true if x equals y, false if not. Same as\n  Java x.equals(y) except it also works for nil, and compares\n  numbers and collections in a type-independent manner.  Clojure's immutable data\n  structures define equals() (and thus =) as a value, not an identity,\n  comparison.", :end-row 801, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "=", :ns "clojure.core", :row 785} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Same as (not (= obj1 obj2))", :end-row 829, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "not=", :ns "clojure.core", :row 821} {:arglist-strs ["[x y]"], :doc "Comparator. Returns a negative number, zero, or a positive number\n  when x is logically 'less than', 'equal to', or 'greater than'\n  y. Same as Java x.compareTo(y) except it also works for nil, and\n  compares numbers and collections in a type-independent manner. x\n  must implement Comparable", :end-row 842, :filename "clojure/core.clj", :fixed-arities #{2}, :name "compare", :ns "clojure.core", :row 833} {:fixed-arities #{0 1}, :end-row 854, :ns "clojure.core", :name "and", :filename "clojure/core.clj", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns logical false (nil or false), and returns that value and\n  doesn't evaluate any of the other expressions, otherwise it returns\n  the value of the last expr. (and) returns true.", :row 844} {:fixed-arities #{0 1}, :end-row 866, :ns "clojure.core", :name "or", :filename "clojure/core.clj", :macro true, :arglist-strs ["[]" "[x]" "[x & next]"], :doc "Evaluates exprs one at a time, from left to right. If a form\n  returns a logical true value, or returns that value and doesn't\n  evaluate any of the other expressions, otherwise it returns the\n  value of the last expression. (or) returns nil.", :row 856} {:arglist-strs ["[num]"], :doc "Returns true if num is zero, else false", :end-row 874, :filename "clojure/core.clj", :fixed-arities #{1}, :name "zero?", :ns "clojure.core", :row 869} {:arglist-strs ["[coll]"], :doc "Returns the number of items in the collection. (count nil) returns\n  0.  Also works on strings, arrays, and Java Collections and Maps", :end-row 882, :filename "clojure/core.clj", :fixed-arities #{1}, :name "count", :ns "clojure.core", :row 876} {:arglist-strs ["[x]"], :doc "Coerce to int", :end-row 889, :filename "clojure/core.clj", :fixed-arities #{1}, :name "int", :ns "clojure.core", :row 884} {:arglist-strs ["[coll index]" "[coll index not-found]"], :doc "Returns the value at the index. get returns nil if index out of\n  bounds, nth throws an exception unless not-found is supplied.  nth\n  also works for strings, Java arrays, regex Matchers and Lists, and,\n  in O(n) time, for sequences.", :end-row 900, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "nth", :ns "clojure.core", :row 891} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically increasing order,\n  otherwise false.", :end-row 915, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "<", :ns "clojure.core", :row 902} {:arglist-strs ["[x]"], :doc "Returns a number one greater than num. Supports arbitrary precision.\n  See also: inc", :end-row 922, :filename "clojure/core.clj", :fixed-arities #{1}, :name "inc'", :ns "clojure.core", :row 917} {:arglist-strs ["[x]"], :doc "Returns a number one greater than num. Does not auto-promote\n  longs, will throw on overflow. See also: inc'", :end-row 929, :filename "clojure/core.clj", :fixed-arities #{1}, :name "inc", :ns "clojure.core", :row 924} {:arglist-strs ["[f coll]" "[f val coll]"], :end-row 947, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "reduce1", :ns "clojure.core", :private true, :row 932} {:arglist-strs ["[coll]"], :doc "Returns a seq of the items in coll in reverse order. Not lazy.", :end-row 954, :filename "clojure/core.clj", :fixed-arities #{1}, :name "reverse", :ns "clojure.core", :row 949} {:arglist-strs ["[op]" "[op unchecked-op]"], :end-row 969, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "nary-inline", :ns "clojure.core", :private true, :row 957} {:arglist-strs ["[n]"], :end-row 971, :filename "clojure/core.clj", :fixed-arities #{1}, :name ">1?", :ns "clojure.core", :private true, :row 971} {:arglist-strs ["[n]"], :end-row 972, :filename "clojure/core.clj", :fixed-arities #{1}, :name ">0?", :ns "clojure.core", :private true, :row 972} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the sum of nums. (+') returns 0. Supports arbitrary precision.\n  See also: +", :end-row 984, :filename "clojure/core.clj", :fixed-arities #{0 1 2}, :name "+'", :ns "clojure.core", :row 974} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the sum of nums. (+) returns 0. Does not auto-promote\n  longs, will throw on overflow. See also: +'", :end-row 996, :filename "clojure/core.clj", :fixed-arities #{0 1 2}, :name "+", :ns "clojure.core", :row 986} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the product of nums. (*') returns 1. Supports arbitrary precision.\n  See also: *", :end-row 1008, :filename "clojure/core.clj", :fixed-arities #{0 1 2}, :name "*'", :ns "clojure.core", :row 998} {:arglist-strs ["[]" "[x]" "[x y]" "[x y & more]"], :doc "Returns the product of nums. (*) returns 1. Does not auto-promote\n  longs, will throw on overflow. See also: *'", :end-row 1020, :filename "clojure/core.clj", :fixed-arities #{0 1 2}, :name "*", :ns "clojure.core", :row 1010} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no denominators are supplied, returns 1/numerator,\n  else returns numerator divided by all of the denominators.", :end-row 1031, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "/", :ns "clojure.core", :row 1022} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Supports arbitrary precision.\n  See also: -", :end-row 1043, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "-'", :ns "clojure.core", :row 1033} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "If no ys are supplied, returns the negation of x, else subtracts\n  the ys from x and returns the result. Does not auto-promote\n  longs, will throw on overflow. See also: -'", :end-row 1055, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "-", :ns "clojure.core", :row 1045} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically non-decreasing order,\n  otherwise false.", :end-row 1070, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "<=", :ns "clojure.core", :row 1057} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically decreasing order,\n  otherwise false.", :end-row 1085, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name ">", :ns "clojure.core", :row 1072} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums are in monotonically non-increasing order,\n  otherwise false.", :end-row 1100, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name ">=", :ns "clojure.core", :row 1087} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns non-nil if nums all have the equivalent\n  value (type-independent), otherwise false", :end-row 1115, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "==", :ns "clojure.core", :row 1102} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns the greatest of the nums.", :end-row 1125, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "max", :ns "clojure.core", :row 1117} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns the least of the nums.", :end-row 1135, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "min", :ns "clojure.core", :row 1127} {:arglist-strs ["[a]"], :doc "Returns the absolute value of a.\n  If a is Long/MIN_VALUE => Long/MIN_VALUE\n  If a is a double and zero => +0.0\n  If a is a double and ##Inf or ##-Inf => ##Inf\n  If a is a double and ##NaN => ##NaN", :end-row 1147, :filename "clojure/core.clj", :fixed-arities #{1}, :name "abs", :ns "clojure.core", :row 1137} {:arglist-strs ["[x]"], :doc "Returns a number one less than num. Supports arbitrary precision.\n  See also: dec", :end-row 1154, :filename "clojure/core.clj", :fixed-arities #{1}, :name "dec'", :ns "clojure.core", :row 1149} {:arglist-strs ["[x]"], :doc "Returns a number one less than num. Does not auto-promote\n  longs, will throw on overflow. See also: dec'", :end-row 1161, :filename "clojure/core.clj", :fixed-arities #{1}, :name "dec", :ns "clojure.core", :row 1156} {:arglist-strs ["[x]"], :doc "Returns a number one greater than x, an int.\n  Note - uses a primitive operator subject to overflow.", :end-row 1168, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-inc-int", :ns "clojure.core", :row 1163} {:arglist-strs ["[x]"], :doc "Returns a number one greater than x, a long.\n  Note - uses a primitive operator subject to overflow.", :end-row 1175, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-inc", :ns "clojure.core", :row 1170} {:arglist-strs ["[x]"], :doc "Returns a number one less than x, an int.\n  Note - uses a primitive operator subject to overflow.", :end-row 1182, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-dec-int", :ns "clojure.core", :row 1177} {:arglist-strs ["[x]"], :doc "Returns a number one less than x, a long.\n  Note - uses a primitive operator subject to overflow.", :end-row 1189, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-dec", :ns "clojure.core", :row 1184} {:arglist-strs ["[x]"], :doc "Returns the negation of x, an int.\n  Note - uses a primitive operator subject to overflow.", :end-row 1196, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-negate-int", :ns "clojure.core", :row 1191} {:arglist-strs ["[x]"], :doc "Returns the negation of x, a long.\n  Note - uses a primitive operator subject to overflow.", :end-row 1203, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-negate", :ns "clojure.core", :row 1198} {:arglist-strs ["[x y]"], :doc "Returns the sum of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", :end-row 1210, :filename "clojure/core.clj", :fixed-arities #{2}, :name "unchecked-add-int", :ns "clojure.core", :row 1205} {:arglist-strs ["[x y]"], :doc "Returns the sum of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", :end-row 1217, :filename "clojure/core.clj", :fixed-arities #{2}, :name "unchecked-add", :ns "clojure.core", :row 1212} {:arglist-strs ["[x y]"], :doc "Returns the difference of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", :end-row 1224, :filename "clojure/core.clj", :fixed-arities #{2}, :name "unchecked-subtract-int", :ns "clojure.core", :row 1219} {:arglist-strs ["[x y]"], :doc "Returns the difference of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", :end-row 1231, :filename "clojure/core.clj", :fixed-arities #{2}, :name "unchecked-subtract", :ns "clojure.core", :row 1226} {:arglist-strs ["[x y]"], :doc "Returns the product of x and y, both int.\n  Note - uses a primitive operator subject to overflow.", :end-row 1238, :filename "clojure/core.clj", :fixed-arities #{2}, :name "unchecked-multiply-int", :ns "clojure.core", :row 1233} {:arglist-strs ["[x y]"], :doc "Returns the product of x and y, both long.\n  Note - uses a primitive operator subject to overflow.", :end-row 1245, :filename "clojure/core.clj", :fixed-arities #{2}, :name "unchecked-multiply", :ns "clojure.core", :row 1240} {:arglist-strs ["[x y]"], :doc "Returns the division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", :end-row 1252, :filename "clojure/core.clj", :fixed-arities #{2}, :name "unchecked-divide-int", :ns "clojure.core", :row 1247} {:arglist-strs ["[x y]"], :doc "Returns the remainder of division of x by y, both int.\n  Note - uses a primitive operator subject to truncation.", :end-row 1259, :filename "clojure/core.clj", :fixed-arities #{2}, :name "unchecked-remainder-int", :ns "clojure.core", :row 1254} {:arglist-strs ["[num]"], :doc "Returns true if num is greater than zero, else false", :end-row 1266, :filename "clojure/core.clj", :fixed-arities #{1}, :name "pos?", :ns "clojure.core", :row 1261} {:arglist-strs ["[num]"], :doc "Returns true if num is less than zero, else false", :end-row 1273, :filename "clojure/core.clj", :fixed-arities #{1}, :name "neg?", :ns "clojure.core", :row 1268} {:arglist-strs ["[num div]"], :doc "quot[ient] of dividing numerator by denominator.", :end-row 1281, :filename "clojure/core.clj", :fixed-arities #{2}, :name "quot", :ns "clojure.core", :row 1275} {:arglist-strs ["[num div]"], :doc "remainder of dividing numerator by denominator.", :end-row 1289, :filename "clojure/core.clj", :fixed-arities #{2}, :name "rem", :ns "clojure.core", :row 1283} {:arglist-strs ["[num]"], :doc "returns the rational value of num", :end-row 1296, :filename "clojure/core.clj", :fixed-arities #{1}, :name "rationalize", :ns "clojure.core", :row 1291} {:arglist-strs ["[x]"], :doc "Bitwise complement", :end-row 1304, :filename "clojure/core.clj", :fixed-arities #{1}, :name "bit-not", :ns "clojure.core", :row 1300} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise and", :end-row 1314, :filename "clojure/core.clj", :fixed-arities #{2}, :name "bit-and", :ns "clojure.core", :row 1307} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise or", :end-row 1323, :filename "clojure/core.clj", :fixed-arities #{2}, :name "bit-or", :ns "clojure.core", :row 1316} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise exclusive or", :end-row 1332, :filename "clojure/core.clj", :fixed-arities #{2}, :name "bit-xor", :ns "clojure.core", :row 1325} {:arglist-strs ["[x y]" "[x y & more]"], :doc "Bitwise and with complement", :end-row 1342, :filename "clojure/core.clj", :fixed-arities #{2}, :name "bit-and-not", :ns "clojure.core", :row 1334} {:arglist-strs ["[x n]"], :doc "Clear bit at index n", :end-row 1349, :filename "clojure/core.clj", :fixed-arities #{2}, :name "bit-clear", :ns "clojure.core", :row 1345} {:arglist-strs ["[x n]"], :doc "Set bit at index n", :end-row 1355, :filename "clojure/core.clj", :fixed-arities #{2}, :name "bit-set", :ns "clojure.core", :row 1351} {:arglist-strs ["[x n]"], :doc "Flip bit at index n", :end-row 1361, :filename "clojure/core.clj", :fixed-arities #{2}, :name "bit-flip", :ns "clojure.core", :row 1357} {:arglist-strs ["[x n]"], :doc "Test bit at index n", :end-row 1367, :filename "clojure/core.clj", :fixed-arities #{2}, :name "bit-test", :ns "clojure.core", :row 1363} {:arglist-strs ["[x n]"], :doc "Bitwise shift left", :end-row 1374, :filename "clojure/core.clj", :fixed-arities #{2}, :name "bit-shift-left", :ns "clojure.core", :row 1370} {:arglist-strs ["[x n]"], :doc "Bitwise shift right", :end-row 1380, :filename "clojure/core.clj", :fixed-arities #{2}, :name "bit-shift-right", :ns "clojure.core", :row 1376} {:arglist-strs ["[x n]"], :doc "Bitwise shift right, without sign-extension.", :end-row 1386, :filename "clojure/core.clj", :fixed-arities #{2}, :name "unsigned-bit-shift-right", :ns "clojure.core", :row 1382} {:arglist-strs ["[n]"], :doc "Returns true if n is an integer", :end-row 1398, :filename "clojure/core.clj", :fixed-arities #{1}, :name "integer?", :ns "clojure.core", :row 1388} {:arglist-strs ["[n]"], :doc "Returns true if n is even, throws an exception if n is not an integer", :end-row 1406, :filename "clojure/core.clj", :fixed-arities #{1}, :name "even?", :ns "clojure.core", :row 1400} {:arglist-strs ["[n]"], :doc "Returns true if n is odd, throws an exception if n is not an integer", :end-row 1412, :filename "clojure/core.clj", :fixed-arities #{1}, :name "odd?", :ns "clojure.core", :row 1408} {:arglist-strs ["[x]"], :doc "Return true if x is a fixed precision integer", :end-row 1420, :filename "clojure/core.clj", :fixed-arities #{1}, :name "int?", :ns "clojure.core", :row 1414} {:arglist-strs ["[x]"], :doc "Return true if x is a positive fixed precision integer", :end-row 1426, :filename "clojure/core.clj", :fixed-arities #{1}, :name "pos-int?", :ns "clojure.core", :row 1422} {:arglist-strs ["[x]"], :doc "Return true if x is a negative fixed precision integer", :end-row 1432, :filename "clojure/core.clj", :fixed-arities #{1}, :name "neg-int?", :ns "clojure.core", :row 1428} {:arglist-strs ["[x]"], :doc "Return true if x is a non-negative fixed precision integer", :end-row 1438, :filename "clojure/core.clj", :fixed-arities #{1}, :name "nat-int?", :ns "clojure.core", :row 1434} {:arglist-strs ["[x]"], :doc "Return true if x is a Double", :end-row 1443, :filename "clojure/core.clj", :fixed-arities #{1}, :name "double?", :ns "clojure.core", :row 1440} {:arglist-strs ["[f]"], :doc "Takes a fn f and returns a fn that takes the same arguments as f,\n  has the same effects, if any, and returns the opposite truth value.", :end-row 1457, :filename "clojure/core.clj", :fixed-arities #{1}, :name "complement", :ns "clojure.core", :row 1447} {:arglist-strs ["[x]"], :doc "Returns a function that takes any number of arguments and returns x.", :end-row 1463, :filename "clojure/core.clj", :fixed-arities #{1}, :name "constantly", :ns "clojure.core", :row 1459} {:arglist-strs ["[x]"], :doc "Returns its argument.", :end-row 1469, :filename "clojure/core.clj", :fixed-arities #{1}, :name "identity", :ns "clojure.core", :row 1465} {:arglist-strs ["[coll]"], :doc "For a list or queue, same as first, for a vector, same as, but much\n  more efficient than, last. If the collection is empty, returns nil.", :end-row 1479, :filename "clojure/core.clj", :fixed-arities #{1}, :name "peek", :ns "clojure.core", :row 1474} {:arglist-strs ["[coll]"], :doc "For a list or queue, returns a new list/queue without the first\n  item, for a vector, returns a new vector without the last item. If\n  the collection is empty, throws an exception.  Note - not the same\n  as next/butlast.", :end-row 1488, :filename "clojure/core.clj", :fixed-arities #{1}, :name "pop", :ns "clojure.core", :row 1481} {:arglist-strs ["[x]"], :doc "Return true if x is a map entry", :end-row 1496, :filename "clojure/core.clj", :fixed-arities #{1}, :name "map-entry?", :ns "clojure.core", :row 1492} {:arglist-strs ["[coll key]"], :doc "Returns true if key is present in the given collection, otherwise\n  returns false.  Note that for numerically indexed collections like\n  vectors and Java arrays, this tests if the numeric key is within the\n  range of indexes. 'contains?' operates constant or logarithmic time;\n  it will not perform a linear search for a value.  See also 'some'.", :end-row 1506, :filename "clojure/core.clj", :fixed-arities #{2}, :name "contains?", :ns "clojure.core", :row 1498} {:arglist-strs ["[map key]" "[map key not-found]"], :doc "Returns the value mapped to key, not-found or nil if key not present\n  in associative collection, set, string, array, or ILookup instance.", :end-row 1517, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "get", :ns "clojure.core", :row 1508} {:arglist-strs ["[map]" "[map key]" "[map key & ks]"], :doc "dissoc[iate]. Returns a new map of the same (hashed/sorted) type,\n  that does not contain a mapping for key(s).", :end-row 1531, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "dissoc", :ns "clojure.core", :row 1519} {:arglist-strs ["[set]" "[set key]" "[set key & ks]"], :doc "disj[oin]. Returns a new set of the same (hashed/sorted) type, that\n  does not contain key(s).", :end-row 1547, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "disj", :ns "clojure.core", :row 1533} {:arglist-strs ["[map key]"], :doc "Returns the map entry for key, or nil if key not present.", :end-row 1553, :filename "clojure/core.clj", :fixed-arities #{2}, :name "find", :ns "clojure.core", :row 1549} {:arglist-strs ["[map keyseq]"], :doc "Returns a map containing only those entries in map whose key is in keys", :end-row 1568, :filename "clojure/core.clj", :fixed-arities #{2}, :name "select-keys", :ns "clojure.core", :row 1555} {:arglist-strs ["[map]"], :doc "Returns a sequence of the map's keys, in the same order as (seq map).", :end-row 1574, :filename "clojure/core.clj", :fixed-arities #{1}, :name "keys", :ns "clojure.core", :row 1570} {:arglist-strs ["[map]"], :doc "Returns a sequence of the map's values, in the same order as (seq map).", :end-row 1580, :filename "clojure/core.clj", :fixed-arities #{1}, :name "vals", :ns "clojure.core", :row 1576} {:arglist-strs ["[e]"], :doc "Returns the key of the map entry.", :end-row 1587, :filename "clojure/core.clj", :fixed-arities #{1}, :name "key", :ns "clojure.core", :row 1582} {:arglist-strs ["[e]"], :doc "Returns the value in the map entry.", :end-row 1594, :filename "clojure/core.clj", :fixed-arities #{1}, :name "val", :ns "clojure.core", :row 1589} {:arglist-strs ["[rev]"], :doc "Returns, in constant time, a seq of the items in rev (which\n  can be a vector or sorted-map), in reverse order. If rev is empty returns nil", :end-row 1602, :filename "clojure/core.clj", :fixed-arities #{1}, :name "rseq", :ns "clojure.core", :row 1596} {:arglist-strs ["[x]"], :doc "Returns the name String of a string, symbol or keyword.", :end-row 1610, :filename "clojure/core.clj", :fixed-arities #{1}, :name "name", :ns "clojure.core", :row 1604} {:arglist-strs ["[x]"], :doc "Returns the namespace String of a symbol or keyword, or nil if not present.", :end-row 1618, :filename "clojure/core.clj", :fixed-arities #{1}, :name "namespace", :ns "clojure.core", :row 1612} {:arglist-strs ["[x]"], :doc "Coerce to boolean", :end-row 1625, :filename "clojure/core.clj", :fixed-arities #{1}, :name "boolean", :ns "clojure.core", :row 1620} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol or keyword", :end-row 1630, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ident?", :ns "clojure.core", :row 1627} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol or keyword without a namespace", :end-row 1635, :filename "clojure/core.clj", :fixed-arities #{1}, :name "simple-ident?", :ns "clojure.core", :row 1632} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol or keyword with a namespace", :end-row 1640, :filename "clojure/core.clj", :fixed-arities #{1}, :name "qualified-ident?", :ns "clojure.core", :row 1637} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol without a namespace", :end-row 1645, :filename "clojure/core.clj", :fixed-arities #{1}, :name "simple-symbol?", :ns "clojure.core", :row 1642} {:arglist-strs ["[x]"], :doc "Return true if x is a symbol with a namespace", :end-row 1650, :filename "clojure/core.clj", :fixed-arities #{1}, :name "qualified-symbol?", :ns "clojure.core", :row 1647} {:arglist-strs ["[x]"], :doc "Return true if x is a keyword without a namespace", :end-row 1655, :filename "clojure/core.clj", :fixed-arities #{1}, :name "simple-keyword?", :ns "clojure.core", :row 1652} {:arglist-strs ["[x]"], :doc "Return true if x is a keyword with a namespace", :end-row 1660, :filename "clojure/core.clj", :fixed-arities #{1}, :name "qualified-keyword?", :ns "clojure.core", :row 1657} {:arglist-strs ["[x & body]"], :doc "Executes exprs in an implicit do, while holding the monitor of x.\n  Will release the monitor of x in all circumstances.", :end-row 1674, :filename "clojure/core.clj", :macro true, :name "locking", :ns "clojure.core", :row 1662} {:fixed-arities #{2}, :end-row 1692, :ns "clojure.core", :name "..", :filename "clojure/core.clj", :macro true, :arglist-strs ["[x form]" "[x form & more]"], :doc "form => fieldName-symbol or (instanceMethodName-symbol args*)\n\n  Expands into a member access (.) of the first member on the first\n  argument, followed by the next member on the result, etc. For\n  instance:\n\n  (.. System (getProperties) (get \"os.name\"))\n\n  expands to:\n\n  (. (. System (getProperties)) (get \"os.name\"))\n\n  but is easier to write, read, and understand.", :row 1676} {:arglist-strs ["[x & forms]"], :doc "Threads the expr through the forms. Inserts x as the\n  second item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  second item in second form, etc.", :end-row 1708, :filename "clojure/core.clj", :macro true, :name "->", :ns "clojure.core", :row 1694} {:arglist-strs ["[x & forms]"], :doc "Threads the expr through the forms. Inserts x as the\n  last item in the first form, making a list of it if it is not a\n  list already. If there are more forms, inserts the first form as the\n  last item in second form, etc.", :end-row 1724, :filename "clojure/core.clj", :macro true, :name "->>", :ns "clojure.core", :row 1710} {:end-row 1726, :filename "clojure/core.clj", :name "map", :ns "clojure.core", :row 1726} {:arglist-strs ["[options & valid-keys]"], :doc "Throws an exception if the given option map contains keys not listed\n  as valid, else returns nil.", :end-row 1737, :filename "clojure/core.clj", :name "check-valid-options", :ns "clojure.core", :private true, :row 1728} {:end-row 1740, :filename "clojure/core.clj", :name "global-hierarchy", :ns "clojure.core", :row 1740} {:arglist-strs ["[mm-name & options]"], :doc "Creates a new multimethod with the associated dispatch function.\n  The docstring and attr-map are optional.\n\n  Options are key-value pairs and may be one of:\n\n  :default\n\n  The default dispatch value, defaults to :default\n\n  :hierarchy\n\n  The value used for hierarchical dispatch (e.g. ::square is-a ::shape)\n\n  Hierarchies are type-like relationships that do not depend upon type\n  inheritance. By default Clojure's multimethods dispatch off of a\n  global hierarchy map.  However, a hierarchy relationship can be\n  created with the derive function used to augment the root ancestor\n  created with make-hierarchy.\n\n  Multimethods expect the value of the hierarchy option to be supplied as\n  a reference type e.g. a var (i.e. via the Var-quote dispatch macro #'\n  or the var special form).", :end-row 1798, :filename "clojure/core.clj", :macro true, :name "defmulti", :ns "clojure.core", :row 1742} {:arglist-strs ["[multifn dispatch-val & fn-tail]"], :doc "Creates and installs a new method of multimethod associated with dispatch-value. ", :end-row 1804, :filename "clojure/core.clj", :macro true, :name "defmethod", :ns "clojure.core", :row 1800} {:arglist-strs ["[multifn]"], :doc "Removes all of the methods of multimethod.", :end-row 1811, :filename "clojure/core.clj", :fixed-arities #{1}, :name "remove-all-methods", :ns "clojure.core", :row 1806} {:arglist-strs ["[multifn dispatch-val]"], :doc "Removes the method of multimethod associated with dispatch-value.", :end-row 1818, :filename "clojure/core.clj", :fixed-arities #{2}, :name "remove-method", :ns "clojure.core", :row 1813} {:arglist-strs ["[multifn dispatch-val-x dispatch-val-y]"], :doc "Causes the multimethod to prefer matches of dispatch-val-x over dispatch-val-y \n   when there is a conflict", :end-row 1826, :filename "clojure/core.clj", :fixed-arities #{3}, :name "prefer-method", :ns "clojure.core", :row 1820} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, returns a map of dispatch values -> dispatch fns", :end-row 1832, :filename "clojure/core.clj", :fixed-arities #{1}, :name "methods", :ns "clojure.core", :row 1828} {:arglist-strs ["[multifn dispatch-val]"], :doc "Given a multimethod and a dispatch value, returns the dispatch fn\n  that would apply to that value, or nil if none apply and no default", :end-row 1839, :filename "clojure/core.clj", :fixed-arities #{2}, :name "get-method", :ns "clojure.core", :row 1834} {:arglist-strs ["[multifn]"], :doc "Given a multimethod, returns a map of preferred value -> set of other values", :end-row 1845, :filename "clojure/core.clj", :fixed-arities #{1}, :name "prefers", :ns "clojure.core", :row 1841} {:arglist-strs ["[& pairs]"], :end-row 1856, :filename "clojure/core.clj", :macro true, :name "assert-args", :ns "clojure.core", :private true, :row 1849} {:fixed-arities #{3 2}, :end-row 1876, :ns "clojure.core", :name "if-let", :filename "clojure/core.clj", :macro true, :arglist-strs ["[bindings then]" "[bindings then else & oldform]"], :doc "bindings => binding-form test\n\n  If test is true, evaluates then with binding-form bound to the value of \n  test, if not, yields else", :row 1858} {:arglist-strs ["[bindings & body]"], :doc "bindings => binding-form test\n\n  When test is true, evaluates body with binding-form bound to the value of test", :end-row 1891, :filename "clojure/core.clj", :macro true, :name "when-let", :ns "clojure.core", :row 1878} {:fixed-arities #{3 2}, :end-row 1911, :ns "clojure.core", :name "if-some", :filename "clojure/core.clj", :macro true, :arglist-strs ["[bindings then]" "[bindings then else & oldform]"], :doc "bindings => binding-form test\n\n   If test is not nil, evaluates then with binding-form bound to the\n   value of test, if not, yields else", :row 1893} {:arglist-strs ["[bindings & body]"], :doc "bindings => binding-form test\n\n   When test is not nil, evaluates body with binding-form bound to the\n   value of test", :end-row 1928, :filename "clojure/core.clj", :macro true, :name "when-some", :ns "clojure.core", :row 1913} {:arglist-strs ["[bindings]"], :doc "WARNING: This is a low-level function. Prefer high-level macros like\n  binding where ever possible.\n\n  Takes a map of Var/value pairs. Binds each Var to the associated value for\n  the current thread. Each call *MUST* be accompanied by a matching call to\n  pop-thread-bindings wrapped in a try-finally!\n  \n      (push-thread-bindings bindings)\n      (try\n        ...\n        (finally\n          (pop-thread-bindings)))", :end-row 1946, :filename "clojure/core.clj", :fixed-arities #{1}, :name "push-thread-bindings", :ns "clojure.core", :row 1930} {:arglist-strs ["[]"], :doc "Pop one set of bindings pushed with push-binding before. It is an error to\n  pop bindings without pushing before.", :end-row 1954, :filename "clojure/core.clj", :fixed-arities #{0}, :name "pop-thread-bindings", :ns "clojure.core", :row 1948} {:arglist-strs ["[]"], :doc "Get a map with the Var/value pairs which is currently in effect for the\n  current thread.", :end-row 1962, :filename "clojure/core.clj", :fixed-arities #{0}, :name "get-thread-bindings", :ns "clojure.core", :row 1956} {:arglist-strs ["[bindings & body]"], :doc "binding => var-symbol init-expr\n\n  Creates new bindings for the (already-existing) vars, with the\n  supplied initial values, executes the exprs in an implicit do, then\n  re-establishes the bindings that existed before.  The new bindings\n  are made in parallel (unlike let); all init-exprs are evaluated\n  before the vars are bound to their new values.", :end-row 1988, :filename "clojure/core.clj", :macro true, :name "binding", :ns "clojure.core", :row 1964} {:arglist-strs ["[binding-map f & args]"], :doc "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then calls f with the supplied arguments.\n  Pops the installed bindings after f returned. Returns whatever f returns.", :end-row 2001, :filename "clojure/core.clj", :name "with-bindings*", :ns "clojure.core", :row 1990} {:arglist-strs ["[binding-map & body]"], :doc "Takes a map of Var/value pairs. Installs for the given Vars the associated\n  values as thread-local bindings. Then executes body. Pops the installed\n  bindings after body was evaluated. Returns the value of body.", :end-row 2009, :filename "clojure/core.clj", :macro true, :name "with-bindings", :ns "clojure.core", :row 2003} {:arglist-strs ["[f]"], :doc "Returns a function, which will install the same bindings in effect as in\n  the thread at the time bound-fn* was called and then call f with any given\n  arguments. This may be used to define a helper function which runs on a\n  different thread, but needs the same bindings in place.", :end-row 2021, :filename "clojure/core.clj", :fixed-arities #{1}, :name "bound-fn*", :ns "clojure.core", :row 2011} {:arglist-strs ["[& fntail]"], :doc "Returns a function defined by the given fntail, which will install the\n  same bindings in effect as in the thread at the time bound-fn was called.\n  This may be used to define a helper function which runs on a different\n  thread, but needs the same bindings in place.", :end-row 2030, :filename "clojure/core.clj", :macro true, :name "bound-fn", :ns "clojure.core", :row 2023} {:arglist-strs ["[sym]"], :doc "Returns the global var named by the namespace-qualified symbol, or\n  nil if no var with that name.", :end-row 2037, :filename "clojure/core.clj", :fixed-arities #{1}, :name "find-var", :ns "clojure.core", :row 2032} {:arglist-strs ["[f]"], :end-row 2059, :filename "clojure/core.clj", :fixed-arities #{1}, :name "binding-conveyor-fn", :ns "clojure.core", :private true, :row 2039} {:arglist-strs ["[r options]"], :end-row 2069, :filename "clojure/core.clj", :fixed-arities #{2}, :name "setup-reference", :ns "clojure.core", :private true, :row 2062} {:arglist-strs ["[state & options]"], :doc "Creates and returns an agent with an initial value of state and\n  zero or more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :error-handler handler-fn\n\n  :error-mode mode-keyword\n\n  If metadata-map is supplied, it will become the metadata on the\n  agent. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.  handler-fn is called if an\n  action throws an exception or if validate-fn rejects a new state --\n  see set-error-handler! for details.  The mode-keyword may be either\n  :continue (the default if an error-handler is given) or :fail (the\n  default if no error-handler is given) -- see set-error-mode! for\n  details.", :end-row 2104, :filename "clojure/core.clj", :name "agent", :ns "clojure.core", :row 2071} {:arglist-strs ["[executor]"], :doc "Sets the ExecutorService to be used by send", :end-row 2110, :filename "clojure/core.clj", :fixed-arities #{1}, :name "set-agent-send-executor!", :ns "clojure.core", :row 2106} {:arglist-strs ["[executor]"], :doc "Sets the ExecutorService to be used by send-off", :end-row 2116, :filename "clojure/core.clj", :fixed-arities #{1}, :name "set-agent-send-off-executor!", :ns "clojure.core", :row 2112} {:arglist-strs ["[executor a f & args]"], :doc "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread supplied by executor, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", :end-row 2126, :filename "clojure/core.clj", :name "send-via", :ns "clojure.core", :row 2118} {:arglist-strs ["[a f & args]"], :doc "Dispatch an action to an agent. Returns the agent immediately.\n  Subsequently, in a thread from a thread pool, the state of the agent\n  will be set to the value of:\n\n  (apply action-fn state-of-agent args)", :end-row 2137, :filename "clojure/core.clj", :name "send", :ns "clojure.core", :row 2128} {:arglist-strs ["[a f & args]"], :doc "Dispatch a potentially blocking action to an agent. Returns the\n  agent immediately. Subsequently, in a separate thread, the state of\n  the agent will be set to the value of:\n\n  (apply action-fn state-of-agent args)", :end-row 2148, :filename "clojure/core.clj", :name "send-off", :ns "clojure.core", :row 2139} {:arglist-strs ["[]"], :doc "Normally, actions sent directly or indirectly during another action\n  are held until the action completes (changes the agent's\n  state). This function can be used to dispatch any pending sent\n  actions immediately. This has no impact on actions sent during a\n  transaction, which are still held until commit. If no action is\n  occurring, does nothing. Returns the number of actions dispatched.", :end-row 2159, :filename "clojure/core.clj", :fixed-arities #{0}, :name "release-pending-sends", :ns "clojure.core", :row 2150} {:arglist-strs ["[reference key fn]"], :doc "Adds a watch function to an agent/atom/var/ref reference. The watch\n  fn must be a fn of 4 args: a key, the reference, its old-state, its\n  new-state. Whenever the reference's state might have been changed,\n  any registered watches will have their functions called. The watch fn\n  will be called synchronously, on the agent's thread if an agent,\n  before any pending sends if agent or ref. Note that an atom's or\n  ref's state may have changed again prior to the fn call, so use\n  old/new-state rather than derefing the reference. Note also that watch\n  fns may be called from multiple threads simultaneously. Var watchers\n  are triggered only by root binding changes, not thread-local\n  set!s. Keys must be unique per reference, and can be used to remove\n  the watch with remove-watch, but are otherwise considered opaque by\n  the watch mechanism.", :end-row 2177, :filename "clojure/core.clj", :fixed-arities #{3}, :name "add-watch", :ns "clojure.core", :row 2161} {:arglist-strs ["[reference key]"], :doc "Removes a watch (set by add-watch) from a reference", :end-row 2184, :filename "clojure/core.clj", :fixed-arities #{2}, :name "remove-watch", :ns "clojure.core", :row 2179} {:arglist-strs ["[a]"], :doc "Returns the exception thrown during an asynchronous action of the\n  agent if the agent is failed.  Returns nil if the agent is not\n  failed.", :end-row 2192, :filename "clojure/core.clj", :fixed-arities #{1}, :name "agent-error", :ns "clojure.core", :row 2186} {:arglist-strs ["[a new-state & options]"], :doc "When an agent is failed, changes the agent state to new-state and\n  then un-fails the agent so that sends are allowed again.  If\n  a :clear-actions true option is given, any actions queued on the\n  agent that were being held while it was failed will be discarded,\n  otherwise those held actions will proceed.  The new-state must pass\n  the validator if any, or restart will throw an exception and the\n  agent will remain failed with its old state and error.  Watchers, if\n  any, will NOT be notified of the new state.  Throws an exception if\n  the agent is not failed.", :end-row 2209, :filename "clojure/core.clj", :name "restart-agent", :ns "clojure.core", :row 2194} {:arglist-strs ["[a handler-fn]"], :doc "Sets the error-handler of agent a to handler-fn.  If an action\n  being run by the agent throws an exception or doesn't pass the\n  validator fn, handler-fn will be called with two arguments: the\n  agent and the exception.", :end-row 2219, :filename "clojure/core.clj", :fixed-arities #{2}, :name "set-error-handler!", :ns "clojure.core", :row 2211} {:arglist-strs ["[a]"], :doc "Returns the error-handler of agent a, or nil if there is none.\n  See set-error-handler!", :end-row 2227, :filename "clojure/core.clj", :fixed-arities #{1}, :name "error-handler", :ns "clojure.core", :row 2221} {:arglist-strs ["[a mode-keyword]"], :doc "Sets the error-mode of agent a to mode-keyword, which must be\n  either :fail or :continue.  If an action being run by the agent\n  throws an exception or doesn't pass the validator fn, an\n  error-handler may be called (see set-error-handler!), after which,\n  if the mode is :continue, the agent will continue as if neither the\n  action that caused the error nor the error itself ever happened.\n  \n  If the mode is :fail, the agent will become failed and will stop\n  accepting new 'send' and 'send-off' actions, and any previously\n  queued actions will be held until a 'restart-agent'.  Deref will\n  still work, returning the state of the agent before the error.", :end-row 2244, :filename "clojure/core.clj", :fixed-arities #{2}, :name "set-error-mode!", :ns "clojure.core", :row 2229} {:arglist-strs ["[a]"], :doc "Returns the error-mode of agent a.  See set-error-mode!", :end-row 2251, :filename "clojure/core.clj", :fixed-arities #{1}, :name "error-mode", :ns "clojure.core", :row 2246} {:fixed-arities #{1}, :end-row 2261, :ns "clojure.core", :name "agent-errors", :filename "clojure/core.clj", :deprecated "1.2", :arglist-strs ["[a]"], :doc "DEPRECATED: Use 'agent-error' instead.\n  Returns a sequence of the exceptions thrown during asynchronous\n  actions of the agent.", :row 2253} {:fixed-arities #{1}, :end-row 2269, :ns "clojure.core", :name "clear-agent-errors", :filename "clojure/core.clj", :deprecated "1.2", :arglist-strs ["[a]"], :doc "DEPRECATED: Use 'restart-agent' instead.\n  Clears any exceptions thrown during asynchronous actions of the\n  agent, allowing subsequent actions to occur.", :row 2263} {:arglist-strs ["[]"], :doc "Initiates a shutdown of the thread pools that back the agent\n  system. Running actions will complete, but no new actions will be\n  accepted", :end-row 2277, :filename "clojure/core.clj", :fixed-arities #{0}, :name "shutdown-agents", :ns "clojure.core", :row 2271} {:arglist-strs ["[x]" "[x & options]"], :doc "Creates and returns a Ref with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  :min-history (default 0)\n  :max-history (default 10)\n\n  If metadata-map is supplied, it will become the metadata on the\n  ref. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception. validate-fn will be called on\n  transaction commit, when all refs have their final values.\n\n  Normally refs accumulate history dynamically as needed to deal with\n  read demands. If you know in advance you will need history you can\n  set :min-history to ensure it will be available when first needed (instead\n  of after a read fault). History is limited, and the limit can be set\n  with :max-history.", :end-row 2313, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ref", :ns "clojure.core", :row 2279} {:arglist-strs ["[fut]" "[fut timeout-ms timeout-val]"], :end-row 2321, :filename "clojure/core.clj", :fixed-arities #{1 3}, :name "deref-future", :ns "clojure.core", :private true, :row 2315} {:arglist-strs ["[ref]" "[ref timeout-ms timeout-val]"], :doc "Also reader macro: @ref/@agent/@var/@atom/@delay/@future/@promise. Within a transaction,\n  returns the in-transaction-value of ref, else returns the\n  most-recently-committed value of ref. When applied to a var, agent\n  or atom, returns its current state. When applied to a delay, forces\n  it if not already forced. When applied to a future, will block if\n  computation not complete. When applied to a promise, will block\n  until a value is delivered.  The variant taking a timeout can be\n  used for blocking references (futures and promises), and will return\n  timeout-val if the timeout (in milliseconds) is reached before a\n  value is available. See also - realized?.", :end-row 2342, :filename "clojure/core.clj", :fixed-arities #{1 3}, :name "deref", :ns "clojure.core", :row 2323} {:arglist-strs ["[x]" "[x & options]"], :doc "Creates and returns an Atom with an initial value of x and zero or\n  more options (in any order):\n\n  :meta metadata-map\n\n  :validator validate-fn\n\n  If metadata-map is supplied, it will become the metadata on the\n  atom. validate-fn must be nil or a side-effect-free fn of one\n  argument, which will be passed the intended new state on any state\n  change. If the new state is unacceptable, the validate-fn should\n  return false or throw an exception.", :end-row 2360, :filename "clojure/core.clj", :fixed-arities #{1}, :name "atom", :ns "clojure.core", :row 2344} {:arglist-strs ["[atom f]" "[atom f x]" "[atom f x y]" "[atom f x y & args]"], :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.  Returns\n  the value that was swapped in.", :end-row 2372, :filename "clojure/core.clj", :fixed-arities #{4 3 2}, :name "swap!", :ns "clojure.core", :row 2362} {:arglist-strs ["[atom f]" "[atom f x]" "[atom f x y]" "[atom f x y & args]"], :doc "Atomically swaps the value of atom to be:\n  (apply f current-value-of-atom args). Note that f may be called\n  multiple times, and thus should be free of side effects.\n  Returns [old new], the value of the atom before and after the swap.", :end-row 2383, :filename "clojure/core.clj", :fixed-arities #{4 3 2}, :name "swap-vals!", :ns "clojure.core", :row 2374} {:arglist-strs ["[atom oldval newval]"], :doc "Atomically sets the value of atom to newval if and only if the\n  current value of the atom is identical to oldval. Returns true if\n  set happened, else false", :end-row 2391, :filename "clojure/core.clj", :fixed-arities #{3}, :name "compare-and-set!", :ns "clojure.core", :row 2385} {:arglist-strs ["[atom newval]"], :doc "Sets the value of atom to newval without regard for the\n  current value. Returns newval.", :end-row 2398, :filename "clojure/core.clj", :fixed-arities #{2}, :name "reset!", :ns "clojure.core", :row 2393} {:arglist-strs ["[atom newval]"], :doc "Sets the value of atom to newval. Returns [old new], the value of the\n   atom before and after the reset.", :end-row 2404, :filename "clojure/core.clj", :fixed-arities #{2}, :name "reset-vals!", :ns "clojure.core", :row 2400} {:arglist-strs ["[iref validator-fn]"], :doc "Sets the validator-fn for a var/ref/agent/atom. validator-fn must be nil or a\n  side-effect-free fn of one argument, which will be passed the intended\n  new state on any state change. If the new state is unacceptable, the\n  validator-fn should return false or throw an exception. If the current state (root\n  value if var) is not acceptable to the new validator, an exception\n  will be thrown and the validator will not be changed.", :end-row 2415, :filename "clojure/core.clj", :fixed-arities #{2}, :name "set-validator!", :ns "clojure.core", :row 2406} {:arglist-strs ["[iref]"], :doc "Gets the validator-fn for a var/ref/agent/atom.", :end-row 2421, :filename "clojure/core.clj", :fixed-arities #{1}, :name "get-validator", :ns "clojure.core", :row 2417} {:arglist-strs ["[iref f & args]"], :doc "Atomically sets the metadata for a namespace/var/ref/agent/atom to be:\n\n  (apply f its-current-meta args)\n\n  f must be free of side-effects", :end-row 2431, :filename "clojure/core.clj", :name "alter-meta!", :ns "clojure.core", :row 2423} {:arglist-strs ["[iref metadata-map]"], :doc "Atomically resets the metadata for a namespace/var/ref/agent/atom", :end-row 2437, :filename "clojure/core.clj", :fixed-arities #{2}, :name "reset-meta!", :ns "clojure.core", :row 2433} {:arglist-strs ["[ref fun & args]"], :doc "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.\n\n  At the commit point of the transaction, sets the value of ref to be:\n\n  (apply fun most-recently-committed-value-of-ref args)\n\n  Thus fun should be commutative, or, failing that, you must accept\n  last-one-in-wins behavior.  commute allows for more concurrency than\n  ref-set.", :end-row 2458, :filename "clojure/core.clj", :name "commute", :ns "clojure.core", :row 2439} {:arglist-strs ["[ref fun & args]"], :doc "Must be called in a transaction. Sets the in-transaction-value of\n  ref to:\n\n  (apply fun in-transaction-value-of-ref args)\n\n  and returns the in-transaction-value of ref.", :end-row 2470, :filename "clojure/core.clj", :name "alter", :ns "clojure.core", :row 2460} {:arglist-strs ["[ref val]"], :doc "Must be called in a transaction. Sets the value of ref.\n  Returns val.", :end-row 2478, :filename "clojure/core.clj", :fixed-arities #{2}, :name "ref-set", :ns "clojure.core", :row 2472} {:arglist-strs ["[ref]"], :doc "Returns the history count of a ref", :end-row 2485, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ref-history-count", :ns "clojure.core", :row 2480} {:arglist-strs ["[ref]" "[ref n]"], :doc "Gets the min-history of a ref, or sets it and returns the ref", :end-row 2494, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "ref-min-history", :ns "clojure.core", :row 2487} {:arglist-strs ["[ref]" "[ref n]"], :doc "Gets the max-history of a ref, or sets it and returns the ref", :end-row 2503, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "ref-max-history", :ns "clojure.core", :row 2496} {:arglist-strs ["[ref]"], :doc "Must be called in a transaction. Protects the ref from modification\n  by other transactions.  Returns the in-transaction-value of\n  ref. Allows for more concurrency than (ref-set ref @ref)", :end-row 2513, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ensure", :ns "clojure.core", :row 2505} {:arglist-strs ["[flags-ignored-for-now & body]"], :doc "transaction-flags => TBD, pass nil for now\n\n  Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of sync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", :end-row 2526, :filename "clojure/core.clj", :macro true, :name "sync", :ns "clojure.core", :row 2515} {:arglist-strs ["[& body]"], :doc "If an io! block occurs in a transaction, throws an\n  IllegalStateException, else runs body in an implicit do. If the\n  first expression in body is a literal string, will use that as the\n  exception message.", :end-row 2540, :filename "clojure/core.clj", :macro true, :name "io!", :ns "clojure.core", :row 2529} {:arglist-strs ["[val]"], :doc "Creates and returns a Volatile with an initial value of val.", :end-row 2547, :filename "clojure/core.clj", :fixed-arities #{1}, :name "volatile!", :ns "clojure.core", :row 2542} {:arglist-strs ["[vol newval]"], :doc "Sets the value of volatile to newval without regard for the\n   current value. Returns newval.", :end-row 2554, :filename "clojure/core.clj", :fixed-arities #{2}, :name "vreset!", :ns "clojure.core", :row 2549} {:arglist-strs ["[vol f & args]"], :doc "Non-atomically swaps the value of the volatile as if:\n   (apply f current-value-of-vol args). Returns the value that\n   was swapped in.", :end-row 2563, :filename "clojure/core.clj", :macro true, :name "vswap!", :ns "clojure.core", :row 2556} {:arglist-strs ["[x]"], :doc "Returns true if x is a volatile.", :end-row 2569, :filename "clojure/core.clj", :fixed-arities #{1}, :name "volatile?", :ns "clojure.core", :row 2565} {:arglist-strs ["[]" "[f]" "[f g]" "[f g & fs]"], :doc "Takes a set of functions and returns a fn that is the composition\n  of those fns.  The returned fn takes a variable number of args,\n  applies the rightmost of fns to the args, the next\n  fn (right-to-left) to the result, etc.", :end-row 2591, :filename "clojure/core.clj", :fixed-arities #{0 1 2}, :name "comp", :ns "clojure.core", :row 2574} {:arglist-strs ["[f]" "[f g]" "[f g h]" "[f g h & fs]"], :doc "Takes a set of functions and returns a fn that is the juxtaposition\n  of those fns.  The returned fn takes a variable number of args, and\n  returns a vector containing the result of applying each fn to the\n  args (left-to-right).\n  ((juxt a b c) x) => [(a x) (b x) (c x)]", :end-row 2629, :filename "clojure/core.clj", :fixed-arities #{1 3 2}, :name "juxt", :ns "clojure.core", :row 2593} {:arglist-strs ["[f]" "[f arg1]" "[f arg1 arg2]" "[f arg1 arg2 arg3]" "[f arg1 arg2 arg3 & more]"], :doc "Takes a function f and fewer than the normal arguments to f, and\n  returns a fn that takes a variable number of additional args. When\n  called, the returned function calls f with args + additional args.", :end-row 2660, :filename "clojure/core.clj", :fixed-arities #{1 4 3 2}, :name "partial", :ns "clojure.core", :row 2631} {:arglist-strs ["[coll]" "[xform coll]" "[xform coll & colls]"], :doc "Coerces coll to a (possibly empty) sequence, if it is not already\n  one. Will not force a lazy seq. (sequence nil) yields (), When a\n  transducer is supplied, returns a lazy sequence of applications of\n  the transform to the items in coll(s), i.e. to the set of first\n  items of each coll, followed by the set of second\n  items in each coll, until any one of the colls is exhausted.  Any\n  remaining items in other colls are ignored. The transform should accept\n  number-of-colls arguments", :end-row 2687, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "sequence", :ns "clojure.core", :row 2664} {:arglist-strs ["[pred coll]"], :doc "Returns true if (pred x) is logical true for every x in coll, else\n  false.", :end-row 2699, :filename "clojure/core.clj", :fixed-arities #{2}, :name "every?", :ns "clojure.core", :row 2689} {:doc "Returns false if (pred x) is logical true for every x in\n  coll, else true.", :end-row 2707, :filename "clojure/core.clj", :name "not-every?", :ns "clojure.core", :row 2701} {:arglist-strs ["[pred coll]"], :doc "Returns the first logical true value of (pred x) for any x in coll,\n  else nil.  One common idiom is to use a set as pred, for example\n  this will return :fred if :fred is in the sequence, otherwise nil:\n  (some #{:fred} coll)", :end-row 2718, :filename "clojure/core.clj", :fixed-arities #{2}, :name "some", :ns "clojure.core", :row 2709} {:doc "Returns false if (pred x) is logical true for any x in coll,\n  else true.", :end-row 2726, :filename "clojure/core.clj", :name "not-any?", :ns "clojure.core", :row 2720} {:arglist-strs ["[bindings & body]"], :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", :end-row 2742, :filename "clojure/core.clj", :macro true, :name "dotimes", :ns "clojure.core", :row 2729} {:arglist-strs ["[f]" "[f coll]" "[f c1 c2]" "[f c1 c2 c3]" "[f c1 c2 c3 & colls]"], :doc "Returns a lazy sequence consisting of the result of applying f to\n  the set of first items of each coll, followed by applying f to the\n  set of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments. Returns a transducer when\n  no collection is provided.", :end-row 2791, :filename "clojure/core.clj", :fixed-arities #{1 4 3 2}, :name "map", :ns "clojure.core", :row 2744} {:arglist-strs ["[& names]"], :doc "defs the supplied var names with no bindings, useful for making forward declarations.", :end-row 2796, :filename "clojure/core.clj", :macro true, :name "declare", :ns "clojure.core", :row 2793} {:end-row 2798, :filename "clojure/core.clj", :name "cat", :ns "clojure.core", :row 2798} {:arglist-strs ["[f]" "[f & colls]"], :doc "Returns the result of applying concat to the result of applying map\n  to f and colls.  Thus function f should return a collection. Returns\n  a transducer when no collections are provided", :end-row 2808, :filename "clojure/core.clj", :fixed-arities #{1}, :name "mapcat", :ns "clojure.core", :row 2800} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-row 2840, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "filter", :ns "clojure.core", :row 2810} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of the items in coll for which\n  (pred item) returns logical false. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-row 2851, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "remove", :ns "clojure.core", :row 2843} {:arglist-strs ["[x]"], :doc "Wraps x in a way such that a reduce will terminate with the value x", :end-row 2857, :filename "clojure/core.clj", :fixed-arities #{1}, :name "reduced", :ns "clojure.core", :row 2853} {:arglist-strs ["[x]"], :doc "Returns true if x is the result of a call to reduced", :end-row 2864, :filename "clojure/core.clj", :fixed-arities #{1}, :name "reduced?", :ns "clojure.core", :row 2859} {:arglist-strs ["[x]"], :doc "If x is already reduced?, returns it, else returns (reduced x)", :end-row 2870, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ensure-reduced", :ns "clojure.core", :row 2866} {:arglist-strs ["[x]"], :doc "If x is reduced?, returns (deref x), else returns x", :end-row 2876, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unreduced", :ns "clojure.core", :row 2872} {:arglist-strs ["[n]" "[n coll]"], :doc "Returns a lazy sequence of the first n items in coll, or all items if\n  there are fewer than n.  Returns a stateful transducer when\n  no collection is provided.", :end-row 2903, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "take", :ns "clojure.core", :row 2878} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of successive items from coll while\n  (pred item) returns logical true. pred must be free of side-effects.\n  Returns a transducer when no collection is provided.", :end-row 2924, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "take-while", :ns "clojure.core", :row 2905} {:arglist-strs ["[n]" "[n coll]"], :doc "Returns a lazy sequence of all but the first n items in coll.\n  Returns a stateful transducer when no collection is provided.", :end-row 2949, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "drop", :ns "clojure.core", :row 2926} {:arglist-strs ["[coll]" "[n coll]"], :doc "Return a lazy sequence of all but the last n (default 1) items in coll", :end-row 2956, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "drop-last", :ns "clojure.core", :row 2951} {:arglist-strs ["[n coll]"], :doc "Returns a seq of the last n items in coll.  Depending on the type\n  of coll may be no better than linear time.  For vectors, see also subvec.", :end-row 2967, :filename "clojure/core.clj", :fixed-arities #{2}, :name "take-last", :ns "clojure.core", :row 2958} {:arglist-strs ["[pred]" "[pred coll]"], :doc "Returns a lazy sequence of the items in coll starting from the\n  first item for which (pred item) returns logical false.  Returns a\n  stateful transducer when no collection is provided.", :end-row 2994, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "drop-while", :ns "clojure.core", :row 2969} {:arglist-strs ["[coll]"], :doc "Returns a lazy (infinite!) sequence of repetitions of the items in coll.", :end-row 3000, :filename "clojure/core.clj", :fixed-arities #{1}, :name "cycle", :ns "clojure.core", :row 2996} {:arglist-strs ["[n coll]"], :doc "Returns a vector of [(take n coll) (drop n coll)]", :end-row 3007, :filename "clojure/core.clj", :fixed-arities #{2}, :name "split-at", :ns "clojure.core", :row 3002} {:arglist-strs ["[pred coll]"], :doc "Returns a vector of [(take-while pred coll) (drop-while pred coll)]", :end-row 3014, :filename "clojure/core.clj", :fixed-arities #{2}, :name "split-with", :ns "clojure.core", :row 3009} {:arglist-strs ["[x]" "[n x]"], :doc "Returns a lazy (infinite!, or length n if supplied) sequence of xs.", :end-row 3021, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "repeat", :ns "clojure.core", :row 3016} {:fixed-arities #{2}, :end-row 3028, :ns "clojure.core", :name "replicate", :filename "clojure/core.clj", :deprecated "1.3", :arglist-strs ["[n x]"], :doc "DEPRECATED: Use 'repeat' instead.\n   Returns a lazy seq of n xs.", :row 3023} {:arglist-strs ["[f x]"], :doc "Returns a lazy sequence of x, (f x), (f (f x)) etc. f must be free of side-effects", :end-row 3034, :filename "clojure/core.clj", :fixed-arities #{2}, :name "iterate", :ns "clojure.core", :row 3030} {:arglist-strs ["[]" "[end]" "[start end]" "[start end step]"], :doc "Returns a lazy seq of nums from start (inclusive) to end\n  (exclusive), by step, where start defaults to 0, step to 1, and end to\n  infinity. When step is equal to 0, returns an infinite sequence of\n  start. When start is equal to end, returns empty list.", :end-row 3056, :filename "clojure/core.clj", :fixed-arities #{0 1 3 2}, :name "range", :ns "clojure.core", :row 3036} {:arglist-strs ["[& maps]"], :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping from\n  the latter (left-to-right) will be the mapping in the result.", :end-row 3066, :filename "clojure/core.clj", :name "merge", :ns "clojure.core", :row 3058} {:arglist-strs ["[f & maps]"], :doc "Returns a map that consists of the rest of the maps conj-ed onto\n  the first.  If a key occurs in more than one map, the mapping(s)\n  from the latter (left-to-right) will be combined with the mapping in\n  the result by calling (f val-in-result val-in-latter).", :end-row 3084, :filename "clojure/core.clj", :name "merge-with", :ns "clojure.core", :row 3068} {:arglist-strs ["[rdr]"], :doc "Returns the lines of text from rdr as a lazy sequence of strings.\n  rdr must implement java.io.BufferedReader.", :end-row 3093, :filename "clojure/core.clj", :fixed-arities #{1}, :name "line-seq", :ns "clojure.core", :row 3086} {:arglist-strs ["[pred]"], :doc "Returns an implementation of java.util.Comparator based upon pred.", :end-row 3101, :filename "clojure/core.clj", :fixed-arities #{1}, :name "comparator", :ns "clojure.core", :row 3095} {:arglist-strs ["[coll]" "[comp coll]"], :doc "Returns a sorted sequence of the items in coll. If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", :end-row 3118, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "sort", :ns "clojure.core", :row 3103} {:arglist-strs ["[keyfn coll]" "[keyfn comp coll]"], :doc "Returns a sorted sequence of the items in coll, where the sort\n  order is determined by comparing (keyfn item).  If no comparator is\n  supplied, uses compare.  comparator must implement\n  java.util.Comparator.  Guaranteed to be stable: equal elements will\n  not be reordered.  If coll is a Java array, it will be modified.  To\n  avoid this, sort a copy of the array.", :end-row 3132, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "sort-by", :ns "clojure.core", :row 3120} {:arglist-strs ["[coll]" "[n coll]"], :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. dorun can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, does not retain the head and returns nil.", :end-row 3147, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "dorun", :ns "clojure.core", :row 3134} {:arglist-strs ["[coll]" "[n coll]"], :doc "When lazy sequences are produced via functions that have side\n  effects, any effects other than those needed to produce the first\n  element in the seq do not occur until the seq is consumed. doall can\n  be used to force any effects. Walks through the successive nexts of\n  the seq, retains the head and returns it, thus causing the entire\n  seq to reside in memory at one time.", :end-row 3163, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "doall", :ns "clojure.core", :row 3149} {:arglist-strs ["[coll n]"], :doc "Returns the nth next of coll, (seq coll) when n is 0.", :end-row 3173, :filename "clojure/core.clj", :fixed-arities #{2}, :name "nthnext", :ns "clojure.core", :row 3165} {:arglist-strs ["[coll n]"], :doc "Returns the nth rest of coll, coll when n is 0.", :end-row 3183, :filename "clojure/core.clj", :fixed-arities #{2}, :name "nthrest", :ns "clojure.core", :row 3175} {:arglist-strs ["[n coll]" "[n step coll]" "[n step pad coll]"], :doc "Returns a lazy sequence of lists of n items each, at offsets step\n  apart. If step is not supplied, defaults to n, i.e. the partitions\n  do not overlap. If a pad collection is supplied, use its elements as\n  necessary to complete last partition upto n items. In case there are\n  not enough padding elements, return a partition with less than n items.", :end-row 3207, :filename "clojure/core.clj", :fixed-arities #{4 3 2}, :name "partition", :ns "clojure.core", :row 3185} {:arglist-strs ["[form]"], :doc "Evaluates the form data structure (not text!) and returns the result.", :end-row 3215, :filename "clojure/core.clj", :fixed-arities #{1}, :name "eval", :ns "clojure.core", :row 3211} {:arglist-strs ["[seq-exprs & body]"], :doc "Repeatedly executes body (presumably for side-effects) with\n  bindings and filtering as provided by \"for\".  Does not retain\n  the head of the sequence. Returns nil.", :end-row 3273, :filename "clojure/core.clj", :macro true, :name "doseq", :ns "clojure.core", :row 3217} {:arglist-strs ["[& agents]"], :doc "Blocks the current thread (indefinitely!) until all actions\n  dispatched thus far, from this thread or agent, to the agent(s) have\n  occurred.  Will block on failed agents.  Will never return if\n  a failed agent is restarted with :clear-actions true or shutdown-agents was called.", :end-row 3290, :filename "clojure/core.clj", :name "await", :ns "clojure.core", :row 3275} {:arglist-strs ["[a]"], :end-row 3295, :filename "clojure/core.clj", :fixed-arities #{1}, :name "await1", :ns "clojure.core", :row 3292} {:arglist-strs ["[timeout-ms & agents]"], :doc "Blocks the current thread until all actions dispatched thus\n  far (from this thread or agent) to the agents have occurred, or the\n  timeout (in milliseconds) has elapsed. Returns logical false if\n  returning due to timeout, logical true otherwise.", :end-row 3312, :filename "clojure/core.clj", :name "await-for", :ns "clojure.core", :row 3297} {:arglist-strs ["[bindings & body]"], :doc "bindings => name n\n\n  Repeatedly executes body (presumably for side-effects) with name\n  bound to integers from 0 through n-1.", :end-row 3330, :filename "clojure/core.clj", :macro true, :name "dotimes", :ns "clojure.core", :row 3314} {:arglist-strs ["[coll]"], :doc "Returns a new, transient version of the collection, in constant time.", :end-row 3348, :filename "clojure/core.clj", :fixed-arities #{1}, :name "transient", :ns "clojure.core", :row 3343} {:arglist-strs ["[coll]"], :doc "Returns a new, persistent version of the transient collection, in\n  constant time. The transient collection cannot be used after this\n  call, any such use will throw an exception.", :end-row 3357, :filename "clojure/core.clj", :fixed-arities #{1}, :name "persistent!", :ns "clojure.core", :row 3350} {:arglist-strs ["[]" "[coll]" "[coll x]"], :doc "Adds x to the transient collection, and return coll. The 'addition'\n  may happen at different 'places' depending on the concrete type.", :end-row 3367, :filename "clojure/core.clj", :fixed-arities #{0 1 2}, :name "conj!", :ns "clojure.core", :row 3359} {:arglist-strs ["[coll key val]" "[coll key val & kvs]"], :doc "When applied to a transient map, adds mapping of key(s) to\n  val(s). When applied to a transient vector, sets the val at index.\n  Note - index must be <= (count vector). Returns coll.", :end-row 3380, :filename "clojure/core.clj", :fixed-arities #{3}, :name "assoc!", :ns "clojure.core", :row 3369} {:arglist-strs ["[map key]" "[map key & ks]"], :doc "Returns a transient map that doesn't contain a mapping for key(s).", :end-row 3391, :filename "clojure/core.clj", :fixed-arities #{2}, :name "dissoc!", :ns "clojure.core", :row 3382} {:arglist-strs ["[coll]"], :doc "Removes the last item from a transient vector. If\n  the collection is empty, throws an exception. Returns coll", :end-row 3399, :filename "clojure/core.clj", :fixed-arities #{1}, :name "pop!", :ns "clojure.core", :row 3393} {:arglist-strs ["[set]" "[set key]" "[set key & ks]"], :doc "disj[oin]. Returns a transient set of the same (hashed/sorted) type, that\n  does not contain key(s).", :end-row 3413, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "disj!", :ns "clojure.core", :row 3401} {:fixed-arities #{2}, :end-row 3424, :private true, :ns "clojure.core", :name "into1", :filename "clojure/core.clj", :arglist-strs ["[to from]"], :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined.", :row 3416} {:arglist-strs ["[& import-symbols-or-lists]"], :doc "import-list => (package-symbol class-name-symbols*)\n\n  For each name in class-name-symbols, adds a mapping from name to the\n  class named by package.name to the current namespace. Use :import in the ns\n  macro in preference to calling this directly.", :end-row 3442, :filename "clojure/core.clj", :macro true, :name "import", :ns "clojure.core", :row 3426} {:arglist-strs ["[aseq]" "[type aseq]"], :doc "Returns an array with components set to the values in aseq. The array's\n  component type is type if provided, or the type of the first value in\n  aseq if present, or Object. All values in aseq must be compatible with\n  the component type. Class objects for the primitive types can be obtained\n  using, e.g., Integer/TYPE.", :end-row 3455, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "into-array", :ns "clojure.core", :row 3444} {:arglist-strs ["[& items]"], :end-row 3459, :filename "clojure/core.clj", :name "array", :ns "clojure.core", :private true, :row 3457} {:arglist-strs ["[x]"], :doc "Returns the Class of x", :end-row 3465, :filename "clojure/core.clj", :fixed-arities #{1}, :name "class", :ns "clojure.core", :row 3461} {:arglist-strs ["[x]"], :doc "Returns the :type metadata of x, or its Class if none", :end-row 3472, :filename "clojure/core.clj", :fixed-arities #{1}, :name "type", :ns "clojure.core", :row 3467} {:arglist-strs ["[x]"], :doc "Coerce to Number", :end-row 3479, :filename "clojure/core.clj", :fixed-arities #{1}, :name "num", :ns "clojure.core", :row 3474} {:arglist-strs ["[x]"], :doc "Coerce to long", :end-row 3485, :filename "clojure/core.clj", :fixed-arities #{1}, :name "long", :ns "clojure.core", :row 3481} {:arglist-strs ["[x]"], :doc "Coerce to float", :end-row 3491, :filename "clojure/core.clj", :fixed-arities #{1}, :name "float", :ns "clojure.core", :row 3487} {:arglist-strs ["[x]"], :doc "Coerce to double", :end-row 3497, :filename "clojure/core.clj", :fixed-arities #{1}, :name "double", :ns "clojure.core", :row 3493} {:arglist-strs ["[x]"], :doc "Coerce to short", :end-row 3503, :filename "clojure/core.clj", :fixed-arities #{1}, :name "short", :ns "clojure.core", :row 3499} {:arglist-strs ["[x]"], :doc "Coerce to byte", :end-row 3509, :filename "clojure/core.clj", :fixed-arities #{1}, :name "byte", :ns "clojure.core", :row 3505} {:arglist-strs ["[x]"], :doc "Coerce to char", :end-row 3515, :filename "clojure/core.clj", :fixed-arities #{1}, :name "char", :ns "clojure.core", :row 3511} {:arglist-strs ["[x]"], :doc "Coerce to byte. Subject to rounding or truncation.", :end-row 3521, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-byte", :ns "clojure.core", :row 3517} {:arglist-strs ["[x]"], :doc "Coerce to short. Subject to rounding or truncation.", :end-row 3527, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-short", :ns "clojure.core", :row 3523} {:arglist-strs ["[x]"], :doc "Coerce to char. Subject to rounding or truncation.", :end-row 3533, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-char", :ns "clojure.core", :row 3529} {:arglist-strs ["[x]"], :doc "Coerce to int. Subject to rounding or truncation.", :end-row 3539, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-int", :ns "clojure.core", :row 3535} {:arglist-strs ["[x]"], :doc "Coerce to long. Subject to rounding or truncation.", :end-row 3545, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-long", :ns "clojure.core", :row 3541} {:arglist-strs ["[x]"], :doc "Coerce to float. Subject to rounding.", :end-row 3551, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-float", :ns "clojure.core", :row 3547} {:arglist-strs ["[x]"], :doc "Coerce to double. Subject to rounding.", :end-row 3557, :filename "clojure/core.clj", :fixed-arities #{1}, :name "unchecked-double", :ns "clojure.core", :row 3553} {:arglist-strs ["[x]"], :doc "Returns true if x is a Number", :end-row 3565, :filename "clojure/core.clj", :fixed-arities #{1}, :name "number?", :ns "clojure.core", :row 3560} {:arglist-strs ["[num div]"], :doc "Modulus of num and div. Truncates toward negative infinity.", :end-row 3575, :filename "clojure/core.clj", :fixed-arities #{2}, :name "mod", :ns "clojure.core", :row 3567} {:arglist-strs ["[n]"], :doc "Returns true if n is a Ratio", :end-row 3581, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ratio?", :ns "clojure.core", :row 3577} {:arglist-strs ["[r]"], :doc "Returns the numerator part of a Ratio.", :end-row 3589, :filename "clojure/core.clj", :fixed-arities #{1}, :name "numerator", :ns "clojure.core", :row 3583} {:arglist-strs ["[r]"], :doc "Returns the denominator part of a Ratio.", :end-row 3597, :filename "clojure/core.clj", :fixed-arities #{1}, :name "denominator", :ns "clojure.core", :row 3591} {:arglist-strs ["[n]"], :doc "Returns true if n is a BigDecimal", :end-row 3603, :filename "clojure/core.clj", :fixed-arities #{1}, :name "decimal?", :ns "clojure.core", :row 3599} {:arglist-strs ["[n]"], :doc "Returns true if n is a floating point number", :end-row 3611, :filename "clojure/core.clj", :fixed-arities #{1}, :name "float?", :ns "clojure.core", :row 3605} {:arglist-strs ["[n]"], :doc "Returns true if n is a rational number", :end-row 3618, :filename "clojure/core.clj", :fixed-arities #{1}, :name "rational?", :ns "clojure.core", :row 3613} {:arglist-strs ["[x]"], :doc "Coerce to BigInt", :end-row 3632, :filename "clojure/core.clj", :fixed-arities #{1}, :name "bigint", :ns "clojure.core", :row 3620} {:arglist-strs ["[x]"], :doc "Coerce to BigInteger", :end-row 3646, :filename "clojure/core.clj", :fixed-arities #{1}, :name "biginteger", :ns "clojure.core", :row 3634} {:arglist-strs ["[x]"], :doc "Coerce to BigDecimal", :end-row 3660, :filename "clojure/core.clj", :fixed-arities #{1}, :name "bigdec", :ns "clojure.core", :row 3648} {:end-row 3662, :filename "clojure/core.clj", :name "print-initialized", :ns "clojure.core", :private true, :row 3662} {:end-row 3666, :filename "clojure/core.clj", :name "print-method", :ns "clojure.core", :row 3664} {:end-row 3667, :filename "clojure/core.clj", :name "print-dup", :ns "clojure.core", :row 3667} {:arglist-strs ["[x w]"], :end-row 3676, :filename "clojure/core.clj", :fixed-arities #{2}, :name "pr-on", :ns "clojure.core", :private true, :row 3669} {:arglist-strs ["[]" "[x]" "[x & more]"], :doc "Prints the object(s) to the output stream that is the current value\n  of *out*.  Prints the object(s), separated by spaces if there is\n  more than one.  By default, pr and prn print in a way that objects\n  can be read by the reader", :end-row 3693, :filename "clojure/core.clj", :fixed-arities #{0 1}, :name "pr", :ns "clojure.core", :row 3678} {:end-row 3696, :filename "clojure/core.clj", :name "system-newline", :ns "clojure.core", :private true, :row 3695} {:arglist-strs ["[]"], :doc "Writes a platform-specific newline to *out*", :end-row 3704, :filename "clojure/core.clj", :fixed-arities #{0}, :name "newline", :ns "clojure.core", :row 3698} {:arglist-strs ["[]"], :doc "Flushes the output stream that is the current value of\n  *out*", :end-row 3713, :filename "clojure/core.clj", :fixed-arities #{0}, :name "flush", :ns "clojure.core", :row 3706} {:arglist-strs ["[& more]"], :doc "Same as pr followed by (newline). Observes *flush-on-newline*", :end-row 3723, :filename "clojure/core.clj", :name "prn", :ns "clojure.core", :row 3715} {:arglist-strs ["[& more]"], :doc "Prints the object(s) to the output stream that is the current value\n  of *out*.  print and println produce output for human consumption.", :end-row 3732, :filename "clojure/core.clj", :name "print", :ns "clojure.core", :row 3725} {:arglist-strs ["[& more]"], :doc "Same as print followed by (newline)", :end-row 3740, :filename "clojure/core.clj", :name "println", :ns "clojure.core", :row 3734} {:arglist-strs ["[]" "[stream]" "[stream eof-error? eof-value]" "[stream eof-error? eof-value recursive?]" "[opts stream]"], :doc "Reads the next object from stream, which must be an instance of\n  java.io.PushbackReader or some derivee.  stream defaults to the\n  current value of *in*.\n\n  Opts is a persistent map with valid keys:\n    :read-cond - :allow to process reader conditionals, or\n                 :preserve to keep all branches\n    :features - persistent set of feature keywords for reader conditionals\n    :eof - on eof, return value unless :eofthrow, then throw.\n           if not specified, will throw\n\n  Note that read can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read", :end-row 3769, :filename "clojure/core.clj", :fixed-arities #{0 1 4 3 2}, :name "read", :ns "clojure.core", :row 3742} {:arglist-strs ["[]" "[stream]" "[stream eof-error? eof-value]" "[stream eof-error? eof-value recursive?]" "[opts stream]"], :doc "Like read, and taking the same args. stream must be a LineNumberingPushbackReader.\n  Returns a vector containing the object read and the (whitespace-trimmed) string read.", :end-row 3795, :filename "clojure/core.clj", :fixed-arities #{0 1 4 3 2}, :name "read+string", :ns "clojure.core", :row 3771} {:arglist-strs ["[]"], :doc "Reads the next line from stream that is the current value of *in* .", :end-row 3804, :filename "clojure/core.clj", :fixed-arities #{0}, :name "read-line", :ns "clojure.core", :row 3797} {:arglist-strs ["[s]" "[opts s]"], :doc "Reads one object from the string s. Optionally include reader\n  options, as specified in read.\n\n  Note that read-string can execute code (controlled by *read-eval*),\n  and as such should be used only with trusted sources.\n\n  For data structure interop use clojure.edn/read-string", :end-row 3817, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "read-string", :ns "clojure.core", :row 3806} {:arglist-strs ["[v start]" "[v start end]"], :doc "Returns a persistent vector of the items in vector from\n  start (inclusive) to end (exclusive).  If end is not supplied,\n  defaults to (count vector). This operation is O(1) and very fast, as\n  the resulting vector shares structure with the original and no\n  trimming is done.", :end-row 3830, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "subvec", :ns "clojure.core", :row 3819} {:arglist-strs ["[bindings & body]"], :doc "bindings => [name init ...]\n\n  Evaluates body in a try expression with names bound to the values\n  of the inits, and a finally clause that calls (.close name) on each\n  name in reverse order.", :end-row 3851, :filename "clojure/core.clj", :macro true, :name "with-open", :ns "clojure.core", :row 3832} {:arglist-strs ["[x & forms]"], :doc "Evaluates x then calls all of the methods and functions with the\n  value of x supplied at the front of the given arguments.  The forms\n  are evaluated in order.  Returns x.\n\n  (doto (new java.util.HashMap) (.put \"a\" 1) (.put \"b\" 2))", :end-row 3870, :filename "clojure/core.clj", :macro true, :name "doto", :ns "clojure.core", :row 3853} {:arglist-strs ["[name & args]"], :doc "Expands into code that creates a fn that expects to be passed an\n  object and any args and calls the named instance method on the\n  object passing the args. Use when you want to treat a Java method as\n  a first-class fn. name may be type-hinted with the method receiver's\n  type in order to avoid reflective calls.", :end-row 3883, :filename "clojure/core.clj", :macro true, :name "memfn", :ns "clojure.core", :row 3872} {:fixed-arities #{1}, :end-row 3893, :ns "clojure.core", :name "time", :filename "clojure/core.clj", :macro true, :arglist-strs ["[expr]"], :doc "Evaluates expr and prints the time it took.  Returns the value of\n expr.", :row 3885} {:arglist-strs ["[array]"], :doc "Returns the length of the Java array. Works on arrays of all\n  types.", :end-row 3904, :filename "clojure/core.clj", :fixed-arities #{1}, :name "alength", :ns "clojure.core", :row 3899} {:arglist-strs ["[array]"], :doc "Returns a clone of the Java array. Works on arrays of known\n  types.", :end-row 3911, :filename "clojure/core.clj", :fixed-arities #{1}, :name "aclone", :ns "clojure.core", :row 3906} {:arglist-strs ["[array idx]" "[array idx & idxs]"], :doc "Returns the value at the index/indices. Works on Java arrays of all\n  types.", :end-row 3922, :filename "clojure/core.clj", :fixed-arities #{2}, :name "aget", :ns "clojure.core", :row 3913} {:arglist-strs ["[array idx val]" "[array idx idx2 & idxv]"], :doc "Sets the value at the index/indices. Works on Java arrays of\n  reference types. Returns val.", :end-row 3934, :filename "clojure/core.clj", :fixed-arities #{3}, :name "aset", :ns "clojure.core", :row 3924} {:fixed-arities #{3}, :end-row 3945, :private true, :ns "clojure.core", :name "def-aset", :filename "clojure/core.clj", :macro true, :arglist-strs ["[name method coerce]"], :row 3936} {:arglist-strs ["[type len]" "[type dim & more-dims]"], :doc "Creates and returns an array of instances of the specified class of\n  the specified dimension(s).  Note that a class object is required.\n  Class objects can be obtained by using their imported or\n  fully-qualified name.  Class objects for the primitive types can be\n  obtained using, e.g., Integer/TYPE.", :end-row 4002, :filename "clojure/core.clj", :fixed-arities #{2}, :name "make-array", :ns "clojure.core", :row 3987} {:arglist-strs ["[coll]"], :doc "Returns a (potentially-ragged) 2-dimensional array of Objects\n  containing the contents of coll, which can be any Collection of any\n  Collection.", :end-row 4017, :filename "clojure/core.clj", :fixed-arities #{1}, :name "to-array-2d", :ns "clojure.core", :row 4004} {:arglist-strs ["[form]"], :doc "If form represents a macro form, returns its expansion,\n  else returns form.", :end-row 4025, :filename "clojure/core.clj", :fixed-arities #{1}, :name "macroexpand-1", :ns "clojure.core", :row 4019} {:arglist-strs ["[form]"], :doc "Repeatedly calls macroexpand-1 on form until it no longer\n  represents a macro form, then returns it.  Note neither\n  macroexpand-1 nor macroexpand expand macros in subforms.", :end-row 4037, :filename "clojure/core.clj", :fixed-arities #{1}, :name "macroexpand", :ns "clojure.core", :row 4027} {:arglist-strs ["[& keys]"], :doc "Returns a structure basis object.", :end-row 4044, :filename "clojure/core.clj", :name "create-struct", :ns "clojure.core", :row 4039} {:arglist-strs ["[name & keys]"], :doc "Same as (def name (create-struct keys...))", :end-row 4051, :filename "clojure/core.clj", :macro true, :name "defstruct", :ns "clojure.core", :row 4046} {:arglist-strs ["[s & inits]"], :doc "Returns a new structmap instance with the keys of the\n  structure-basis. keyvals may contain all, some or none of the basis\n  keys - where values are not supplied they will default to nil.\n  keyvals can also contain keys not in the basis.", :end-row 4061, :filename "clojure/core.clj", :name "struct-map", :ns "clojure.core", :row 4053} {:arglist-strs ["[s & vals]"], :doc "Returns a new structmap instance with the keys of the\n  structure-basis. vals must be supplied for basis keys in order -\n  where values are not supplied they will default to nil.", :end-row 4070, :filename "clojure/core.clj", :name "struct", :ns "clojure.core", :row 4063} {:arglist-strs ["[s key]"], :doc "Returns a fn that, given an instance of a structmap with the basis,\n  returns the value at the key.  The key must be in the basis. The\n  returned function should be (slightly) more efficient than using\n  get, but such use of accessors should be limited to known\n  performance-critical areas.", :end-row 4081, :filename "clojure/core.clj", :fixed-arities #{2}, :name "accessor", :ns "clojure.core", :row 4072} {:arglist-strs ["[rdr]"], :doc "Sequentially read and evaluate the set of forms contained in the\n  stream/file", :end-row 4088, :filename "clojure/core.clj", :fixed-arities #{1}, :name "load-reader", :ns "clojure.core", :row 4083} {:arglist-strs ["[s]"], :doc "Sequentially read and evaluate the set of forms contained in the\n  string", :end-row 4098, :filename "clojure/core.clj", :fixed-arities #{1}, :name "load-string", :ns "clojure.core", :row 4090} {:arglist-strs ["[x]"], :doc "Returns true if x implements IPersistentSet", :end-row 4104, :filename "clojure/core.clj", :fixed-arities #{1}, :name "set?", :ns "clojure.core", :row 4100} {:arglist-strs ["[coll]"], :doc "Returns a set of the distinct elements of coll.", :end-row 4115, :filename "clojure/core.clj", :fixed-arities #{1}, :name "set", :ns "clojure.core", :row 4106} {:arglist-strs ["[keyfn pred amap]"], :end-row 4125, :filename "clojure/core.clj", :fixed-arities #{3}, :name "filter-key", :ns "clojure.core", :private true, :row 4117} {:arglist-strs ["[sym]"], :doc "Returns the namespace named by the symbol or nil if it doesn't exist.", :end-row 4131, :filename "clojure/core.clj", :fixed-arities #{1}, :name "find-ns", :ns "clojure.core", :row 4127} {:arglist-strs ["[sym]"], :doc "Create a new namespace named by the symbol if one doesn't already\n  exist, returns it or the already-existing namespace of the same\n  name.", :end-row 4139, :filename "clojure/core.clj", :fixed-arities #{1}, :name "create-ns", :ns "clojure.core", :row 4133} {:arglist-strs ["[sym]"], :doc "Removes the namespace named by the symbol. Use with caution.\n  Cannot be used to remove the clojure namespace.", :end-row 4146, :filename "clojure/core.clj", :fixed-arities #{1}, :name "remove-ns", :ns "clojure.core", :row 4141} {:arglist-strs ["[]"], :doc "Returns a sequence of all namespaces.", :end-row 4152, :filename "clojure/core.clj", :fixed-arities #{0}, :name "all-ns", :ns "clojure.core", :row 4148} {:arglist-strs ["[x]"], :doc "If passed a namespace, returns it. Else, when passed a symbol,\n  returns the namespace named by it, throwing an exception if not\n  found.", :end-row 4163, :filename "clojure/core.clj", :fixed-arities #{1}, :name "the-ns", :ns "clojure.core", :row 4154} {:arglist-strs ["[ns]"], :doc "Returns the name of the namespace, a symbol.", :end-row 4170, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ns-name", :ns "clojure.core", :row 4165} {:arglist-strs ["[ns]"], :doc "Returns a map of all the mappings for the namespace.", :end-row 4177, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ns-map", :ns "clojure.core", :row 4172} {:arglist-strs ["[ns sym]"], :doc "Removes the mappings for the symbol from the namespace.", :end-row 4184, :filename "clojure/core.clj", :fixed-arities #{2}, :name "ns-unmap", :ns "clojure.core", :row 4179} {:arglist-strs ["[ns]"], :doc "Returns a map of the public intern mappings for the namespace.", :end-row 4199, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ns-publics", :ns "clojure.core", :row 4190} {:arglist-strs ["[ns]"], :doc "Returns a map of the import mappings for the namespace.", :end-row 4206, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ns-imports", :ns "clojure.core", :row 4201} {:arglist-strs ["[ns]"], :doc "Returns a map of the intern mappings for the namespace.", :end-row 4216, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ns-interns", :ns "clojure.core", :row 4208} {:arglist-strs ["[ns-sym & filters]"], :doc "refers to all public vars of ns, subject to filters.\n  filters can include at most one each of:\n\n  :exclude list-of-symbols\n  :only list-of-symbols\n  :rename map-of-fromsymbol-tosymbol\n\n  For each public interned var in the namespace named by the symbol,\n  adds a mapping from the name of the var to the var to the current\n  namespace.  Throws an exception if name is already mapped to\n  something else in the current namespace. Filters can be used to\n  select a subset, via inclusion or exclusion, or to provide a mapping\n  to a symbol different from the var's name, in order to prevent\n  clashes. Use :use in the ns macro in preference to calling this directly.", :end-row 4253, :filename "clojure/core.clj", :name "refer", :ns "clojure.core", :row 4218} {:arglist-strs ["[ns]"], :doc "Returns a map of the refer mappings for the namespace.", :end-row 4263, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ns-refers", :ns "clojure.core", :row 4255} {:arglist-strs ["[alias namespace-sym]"], :doc "Add an alias in the current namespace to another\n  namespace. Arguments are two symbols: the alias to be used, and\n  the symbolic name of the target namespace. Use :as in the ns macro in preference\n  to calling this directly.", :end-row 4273, :filename "clojure/core.clj", :fixed-arities #{2}, :name "alias", :ns "clojure.core", :row 4265} {:arglist-strs ["[ns]"], :doc "Returns a map of the aliases for the namespace.", :end-row 4280, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ns-aliases", :ns "clojure.core", :row 4275} {:arglist-strs ["[ns sym]"], :doc "Removes the alias for the symbol from the namespace.", :end-row 4287, :filename "clojure/core.clj", :fixed-arities #{2}, :name "ns-unalias", :ns "clojure.core", :row 4282} {:arglist-strs ["[n]" "[n coll]"], :doc "Returns a lazy seq of every nth item in coll.  Returns a stateful\n  transducer when no collection is provided.", :end-row 4308, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "take-nth", :ns "clojure.core", :row 4289} {:arglist-strs ["[]" "[c1]" "[c1 c2]" "[c1 c2 & colls]"], :doc "Returns a lazy seq of the first item in each coll, then the second etc.", :end-row 4326, :filename "clojure/core.clj", :fixed-arities #{0 1 2}, :name "interleave", :ns "clojure.core", :row 4310} {:arglist-strs ["[x]"], :doc "Gets the value in the var object", :end-row 4332, :filename "clojure/core.clj", :fixed-arities #{1}, :name "var-get", :ns "clojure.core", :row 4328} {:arglist-strs ["[x val]"], :doc "Sets the value in the var object to val. The var must be\n thread-locally bound.", :end-row 4339, :filename "clojure/core.clj", :fixed-arities #{2}, :name "var-set", :ns "clojure.core", :row 4334} {:arglist-strs ["[name-vals-vec & body]"], :doc "varbinding=> symbol init-expr\n\n  Executes the exprs in a context in which the symbols are bound to\n  vars with per-thread bindings to the init-exprs.  The symbols refer\n  to the var objects themselves, and must be accessed with var-get and\n  var-set", :end-row 4358, :filename "clojure/core.clj", :macro true, :name "with-local-vars", :ns "clojure.core", :row 4341} {:arglist-strs ["[ns sym]" "[ns env sym]"], :doc "Returns the var or Class to which a symbol will be resolved in the\n  namespace (unless found in the environment), else nil.  Note that\n  if the symbol is fully qualified, the var/Class to which it resolves\n  need not be present in the namespace.", :end-row 4371, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "ns-resolve", :ns "clojure.core", :row 4360} {:arglist-strs ["[sym]" "[env sym]"], :doc "same as (ns-resolve *ns* symbol) or (ns-resolve *ns* &env symbol)", :end-row 4378, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "resolve", :ns "clojure.core", :row 4373} {:arglist-strs ["[]" "[& keyvals]"], :doc "Constructs an array-map. If any keys are equal, they are handled as\n  if by repeated uses of assoc.", :end-row 4390, :filename "clojure/core.clj", :fixed-arities #{0}, :name "array-map", :ns "clojure.core", :row 4380} {:arglist-strs ["[s]"], :doc "Builds a map from a seq as described in\n  https://clojure.org/reference/special_forms#keyword-arguments", :end-row 4399, :filename "clojure/core.clj", :fixed-arities #{1}, :name "seq-to-map-for-destructuring", :ns "clojure.core", :row 4392} {:arglist-strs ["[bindings]"], :end-row 4496, :filename "clojure/core.clj", :fixed-arities #{1}, :name "destructure", :ns "clojure.core", :row 4402} {:arglist-strs ["[bindings & body]"], :doc "binding => binding-form init-expr\n  binding-form => name, or destructuring-form\n  destructuring-form => map-destructure-form, or seq-destructure-form\n\n  Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein.\n\n  See https://clojure.org/reference/special_forms#binding-forms for\n  more information about destructuring.", :end-row 4514, :filename "clojure/core.clj", :macro true, :name "let", :ns "clojure.core", :row 4498} {:arglist-strs ["[params body]"], :end-row 4532, :filename "clojure/core.clj", :fixed-arities #{2}, :name "maybe-destructured", :ns "clojure.core", :private true, :row 4516} {:arglist-strs ["[& sigs]"], :doc "params => positional-params*, or positional-params* & rest-param\n  positional-param => binding-form\n  rest-param => binding-form\n  binding-form => name, or destructuring-form\n\n  Defines a function.\n\n  See https://clojure.org/reference/special_forms#fn for more information", :end-row 4597, :filename "clojure/core.clj", :macro true, :name "fn", :ns "clojure.core", :row 4535} {:arglist-strs ["[bindings & body]"], :doc "Evaluates the exprs in a lexical context in which the symbols in\n  the binding-forms are bound to their respective init-exprs or parts\n  therein. Acts as a recur target.", :end-row 4622, :filename "clojure/core.clj", :macro true, :name "loop", :ns "clojure.core", :row 4599} {:arglist-strs ["[bindings & body]"], :doc "bindings => x xs\n\n  Roughly the same as (when (seq xs) (let [x (first xs)] body)) but xs is evaluated only once", :end-row 4636, :filename "clojure/core.clj", :macro true, :name "when-first", :ns "clojure.core", :row 4624} {:arglist-strs ["[& colls]"], :doc "Expands to code which yields a lazy sequence of the concatenation\n  of the supplied colls.  Each coll expr is not evaluated until it is\n  needed. \n\n  (lazy-cat xs ys zs) === (concat (lazy-seq xs) (lazy-seq ys) (lazy-seq zs))", :end-row 4646, :filename "clojure/core.clj", :macro true, :name "lazy-cat", :ns "clojure.core", :row 4638} {:fixed-arities #{2}, :end-row 4733, :ns "clojure.core", :name "for", :filename "clojure/core.clj", :macro true, :arglist-strs ["[seq-exprs body-expr]"], :doc "List comprehension. Takes a vector of one or more\n   binding-form/collection-expr pairs, each followed by zero or more\n   modifiers, and yields a lazy sequence of evaluations of expr.\n   Collections are iterated in a nested fashion, rightmost fastest,\n   and nested coll-exprs can refer to bindings created in prior\n   binding-forms.  Supported modifiers are: :let [binding-form expr ...],\n   :while test, :when test.\n\n  (take 100 (for [x (range 100000000) y (range 1000000) :while (< y x)] [x y]))", :row 4648} {:arglist-strs ["[& body]"], :doc "Ignores body, yields nil", :end-row 4738, :filename "clojure/core.clj", :macro true, :name "comment", :ns "clojure.core", :row 4735} {:arglist-strs ["[& body]"], :doc "Evaluates exprs in a context in which *out* is bound to a fresh\n  StringWriter.  Returns the string created by any nested printing\n  calls.", :end-row 4749, :filename "clojure/core.clj", :macro true, :name "with-out-str", :ns "clojure.core", :row 4740} {:arglist-strs ["[s & body]"], :doc "Evaluates body in a context in which *in* is bound to a fresh\n  StringReader initialized with the string s.", :end-row 4758, :filename "clojure/core.clj", :macro true, :name "with-in-str", :ns "clojure.core", :row 4751} {:arglist-strs ["[& xs]"], :doc "pr to a string, returning it", :end-row 4767, :filename "clojure/core.clj", :name "pr-str", :ns "clojure.core", :row 4760} {:arglist-strs ["[& xs]"], :doc "prn to a string, returning it", :end-row 4776, :filename "clojure/core.clj", :name "prn-str", :ns "clojure.core", :row 4769} {:arglist-strs ["[& xs]"], :doc "print to a string, returning it", :end-row 4785, :filename "clojure/core.clj", :name "print-str", :ns "clojure.core", :row 4778} {:arglist-strs ["[& xs]"], :doc "println to a string, returning it", :end-row 4794, :filename "clojure/core.clj", :name "println-str", :ns "clojure.core", :row 4787} {:arglist-strs ["[ex class-name]"], :end-row 4805, :filename "clojure/core.clj", :fixed-arities #{2}, :name "elide-top-frames", :ns "clojure.core", :private true, :row 4798} {:arglist-strs ["[msg map]" "[msg map cause]"], :doc "Create an instance of ExceptionInfo, a RuntimeException subclass\n   that carries a map of additional data.", :end-row 4814, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "ex-info", :ns "clojure.core", :row 4807} {:arglist-strs ["[ex]"], :doc "Returns exception data (a map) if ex is an IExceptionInfo.\n   Otherwise returns nil.", :end-row 4822, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ex-data", :ns "clojure.core", :row 4816} {:arglist-strs ["[ex]"], :doc "Returns the message attached to ex if ex is a Throwable.\n  Otherwise returns nil.", :end-row 4830, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ex-message", :ns "clojure.core", :row 4824} {:arglist-strs ["[ex]"], :doc "Returns the cause of ex if ex is a Throwable.\n  Otherwise returns nil.", :end-row 4839, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ex-cause", :ns "clojure.core", :row 4832} {:fixed-arities #{1 2}, :end-row 4852, :ns "clojure.core", :name "assert", :filename "clojure/core.clj", :macro true, :arglist-strs ["[x]" "[x message]"], :doc "Evaluates expr and throws an exception if it does not evaluate to\n  logical true.", :row 4841} {:arglist-strs ["[v]"], :doc "test [v] finds fn at key :test in var metadata and calls it,\n  presuming failure will throw exception", :end-row 4862, :filename "clojure/core.clj", :fixed-arities #{1}, :name "test", :ns "clojure.core", :row 4854} {:arglist-strs ["[s]"], :doc "Returns an instance of java.util.regex.Pattern, for use, e.g. in\n  re-matcher.", :end-row 4872, :filename "clojure/core.clj", :fixed-arities #{1}, :name "re-pattern", :ns "clojure.core", :row 4864} {:arglist-strs ["[re s]"], :doc "Returns an instance of java.util.regex.Matcher, for use, e.g. in\n  re-find.", :end-row 4881, :filename "clojure/core.clj", :fixed-arities #{2}, :name "re-matcher", :ns "clojure.core", :row 4874} {:arglist-strs ["[m]"], :doc "Returns the groups from the most recent match/find. If there are no\n  nested groups, returns a string of the entire match. If there are\n  nested groups, returns a vector of the groups, the first element\n  being the entire match.", :end-row 4897, :filename "clojure/core.clj", :fixed-arities #{1}, :name "re-groups", :ns "clojure.core", :row 4883} {:arglist-strs ["[re s]"], :doc "Returns a lazy sequence of successive matches of pattern in string,\n  using java.util.regex.Matcher.find(), each such match processed with\n  re-groups.", :end-row 4909, :filename "clojure/core.clj", :fixed-arities #{2}, :name "re-seq", :ns "clojure.core", :row 4899} {:arglist-strs ["[re s]"], :doc "Returns the match, if any, of string to pattern, using\n  java.util.regex.Matcher.matches().  Uses re-groups to return the\n  groups.", :end-row 4920, :filename "clojure/core.clj", :fixed-arities #{2}, :name "re-matches", :ns "clojure.core", :row 4911} {:arglist-strs ["[m]" "[re s]"], :doc "Returns the next regex match, if any, of string to pattern, using\n  java.util.regex.Matcher.find().  Uses re-groups to return the\n  groups.", :end-row 4934, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "re-find", :ns "clojure.core", :row 4923} {:arglist-strs ["[]" "[n]"], :doc "Returns a random floating point number between 0 (inclusive) and\n  n (default 1) (exclusive).", :end-row 4942, :filename "clojure/core.clj", :fixed-arities #{0 1}, :name "rand", :ns "clojure.core", :row 4936} {:arglist-strs ["[n]"], :doc "Returns a random integer between 0 (inclusive) and n (exclusive).", :end-row 4948, :filename "clojure/core.clj", :fixed-arities #{1}, :name "rand-int", :ns "clojure.core", :row 4944} {:arglist-strs ["[name & decls]"], :doc "same as defn, yielding non-public def", :end-row 4954, :filename "clojure/core.clj", :macro true, :name "defn-", :ns "clojure.core", :row 4950} {:arglist-strs ["[branch? children root]"], :doc "Returns a lazy sequence of the nodes in a tree, via a depth-first walk.\n   branch? must be a fn of one arg that returns true if passed a node\n   that can have children (but may not).  children must be a fn of one\n   arg that returns a sequence of the children. Will only be called on\n   nodes for which branch? returns true. Root is the root node of the\n  tree.", :end-row 4971, :filename "clojure/core.clj", :fixed-arities #{3}, :name "tree-seq", :ns "clojure.core", :row 4956} {:arglist-strs ["[dir]"], :doc "A tree seq on java.io.Files", :end-row 4981, :filename "clojure/core.clj", :fixed-arities #{1}, :name "file-seq", :ns "clojure.core", :row 4973} {:arglist-strs ["[root]"], :doc "A tree seq on the xml elements as per xml/parse", :end-row 4991, :filename "clojure/core.clj", :fixed-arities #{1}, :name "xml-seq", :ns "clojure.core", :row 4983} {:arglist-strs ["[s]"], :doc "Returns true if s names a special form", :end-row 4998, :filename "clojure/core.clj", :fixed-arities #{1}, :name "special-symbol?", :ns "clojure.core", :row 4993} {:arglist-strs ["[v]"], :doc "Returns true if v is of type clojure.lang.Var", :end-row 5004, :filename "clojure/core.clj", :fixed-arities #{1}, :name "var?", :ns "clojure.core", :row 5000} {:arglist-strs ["[s start]" "[s start end]"], :doc "Returns the substring of s beginning at start inclusive, and ending\n  at end (defaults to length of string), exclusive.", :end-row 5012, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "subs", :ns "clojure.core", :row 5006} {:arglist-strs ["[k x]" "[k x y]" "[k x y & more]"], :doc "Returns the x for which (k x), a number, is greatest.\n\n  If there are multiple such xs, the last one is returned.", :end-row 5032, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "max-key", :ns "clojure.core", :row 5014} {:arglist-strs ["[k x]" "[k x y]" "[k x y & more]"], :doc "Returns the x for which (k x), a number, is least.\n\n  If there are multiple such xs, the last one is returned.", :end-row 5052, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "min-key", :ns "clojure.core", :row 5034} {:arglist-strs ["[]" "[coll]"], :doc "Returns a lazy sequence of the elements of coll with duplicates removed.\n  Returns a stateful transducer when no collection is provided.", :end-row 5079, :filename "clojure/core.clj", :fixed-arities #{0 1}, :name "distinct", :ns "clojure.core", :row 5054} {:arglist-strs ["[smap]" "[smap coll]"], :doc "Given a map of replacement pairs and a vector/collection, returns a\n  vector/seq with any elements = a key in smap replaced with the\n  corresponding val in smap.  Returns a transducer when no collection\n  is provided.", :end-row 5099, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "replace", :ns "clojure.core", :row 5083} {:arglist-strs ["[& exprs]"], :doc "Runs the exprs (in an implicit do) in a transaction that encompasses\n  exprs and any nested calls.  Starts a transaction if none is already\n  running on this thread. Any uncaught exception will abort the\n  transaction and flow out of dosync. The exprs may be run more than\n  once, but any effects on Refs will be atomic.", :end-row 5109, :filename "clojure/core.clj", :macro true, :name "dosync", :ns "clojure.core", :row 5101} {:arglist-strs ["[precision & exprs]"], :doc "Sets the precision and rounding mode to be used for BigDecimal operations.\n\n  Usage: (with-precision 10 (/ 1M 3))\n  or:    (with-precision 10 :rounding HALF_DOWN (/ 1M 3))\n\n  The rounding mode is one of CEILING, FLOOR, HALF_UP, HALF_DOWN,\n  HALF_EVEN, UP, DOWN and UNNECESSARY; it defaults to HALF_UP.", :end-row 5126, :filename "clojure/core.clj", :macro true, :name "with-precision", :ns "clojure.core", :row 5111} {:arglist-strs ["[sc test key]"], :end-row 5132, :filename "clojure/core.clj", :fixed-arities #{3}, :name "mk-bound-fn", :ns "clojure.core", :private true, :row 5128} {:arglist-strs ["[sc test key]" "[sc start-test start-key end-test end-key]"], :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :end-row 5149, :filename "clojure/core.clj", :fixed-arities #{3 5}, :name "subseq", :ns "clojure.core", :row 5134} {:arglist-strs ["[sc test key]" "[sc start-test start-key end-test end-key]"], :doc "sc must be a sorted collection, test(s) one of <, <=, > or\n  >=. Returns a reverse seq of those entries with keys ek for\n  which (test (.. sc comparator (compare ek key)) 0) is true", :end-row 5166, :filename "clojure/core.clj", :fixed-arities #{3 5}, :name "rsubseq", :ns "clojure.core", :row 5151} {:arglist-strs ["[f]" "[n f]"], :doc "Takes a function of no args, presumably with side effects, and\n  returns an infinite (or length n if supplied) lazy sequence of calls\n  to it", :end-row 5175, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "repeatedly", :ns "clojure.core", :row 5168} {:fixed-arities #{1}, :end-row 5186, :ns "clojure.core", :name "add-classpath", :filename "clojure/core.clj", :deprecated "1.1", :arglist-strs ["[url]"], :doc "DEPRECATED \n\n  Adds the url (String or URL object) to the classpath per\n  URLClassLoader.addURL", :row 5177} {:arglist-strs ["[x]"], :doc "Returns the hash code of its argument. Note this is the hash code\n  consistent with =, and thus is different than .hashCode for Integer,\n  Short, Byte and Clojure collections.", :end-row 5197, :filename "clojure/core.clj", :fixed-arities #{1}, :name "hash", :ns "clojure.core", :row 5190} {:arglist-strs ["[hash-basis count]"], :doc "Mix final collection hash for ordered or unordered collections.\n   hash-basis is the combined collection hash, count is the number\n   of elements included in the basis. Note this is the hash code\n   consistent with =, different from .hashCode.\n   See http://clojure.org/data_structures#hash for full algorithms.", :end-row 5209, :filename "clojure/core.clj", :fixed-arities #{2}, :name "mix-collection-hash", :ns "clojure.core", :row 5200} {:arglist-strs ["[coll]"], :doc "Returns the hash code, consistent with =, for an external ordered\n   collection implementing Iterable.\n   See http://clojure.org/data_structures#hash for full algorithms.", :end-row 5218, :filename "clojure/core.clj", :fixed-arities #{1}, :name "hash-ordered-coll", :ns "clojure.core", :row 5211} {:arglist-strs ["[coll]"], :doc "Returns the hash code, consistent with =, for an external unordered\n   collection implementing Iterable. For maps, the iterator should\n   return map entries whose hash is computed as\n     (hash-ordered-coll [k v]).\n   See http://clojure.org/data_structures#hash for full algorithms.", :end-row 5229, :filename "clojure/core.clj", :fixed-arities #{1}, :name "hash-unordered-coll", :ns "clojure.core", :row 5220} {:arglist-strs ["[sep]" "[sep coll]"], :doc "Returns a lazy seq of the elements of coll separated by sep.\n  Returns a stateful transducer when no collection is provided.", :end-row 5252, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "interpose", :ns "clojure.core", :row 5231} {:arglist-strs ["[name & decl]"], :doc "Experimental - like defmacro, except defines a named function whose\n  body is the expansion, calls to which may be expanded inline as if\n  it were a macro. Cannot be used with variadic (&) args.", :end-row 5264, :filename "clojure/core.clj", :macro true, :name "definline", :ns "clojure.core", :row 5254} {:arglist-strs ["[coll]"], :doc "Returns an empty collection of the same category as coll, or nil", :end-row 5272, :filename "clojure/core.clj", :fixed-arities #{1}, :name "empty", :ns "clojure.core", :row 5266} {:fixed-arities #{4}, :end-row 5288, :ns "clojure.core", :name "amap", :filename "clojure/core.clj", :macro true, :arglist-strs ["[a idx ret expr]"], :doc "Maps an expression across an array a, using an index named idx, and\n  return value named ret, initialized to a clone of a, then setting \n  each element of ret to the evaluation of expr, returning the new \n  array ret.", :row 5274} {:fixed-arities #{5}, :end-row 5300, :ns "clojure.core", :name "areduce", :filename "clojure/core.clj", :macro true, :arglist-strs ["[a idx ret init expr]"], :doc "Reduces an expression across an array a, using an index named idx,\n  and return value named ret, initialized to init, setting ret to the \n  evaluation of expr at each step, returning ret.", :row 5290} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of floats", :end-row 5308, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "float-array", :ns "clojure.core", :row 5302} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of booleans", :end-row 5316, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "boolean-array", :ns "clojure.core", :row 5310} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of bytes", :end-row 5324, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "byte-array", :ns "clojure.core", :row 5318} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of chars", :end-row 5332, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "char-array", :ns "clojure.core", :row 5326} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of shorts", :end-row 5340, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "short-array", :ns "clojure.core", :row 5334} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of doubles", :end-row 5348, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "double-array", :ns "clojure.core", :row 5342} {:arglist-strs ["[size-or-seq]"], :doc "Creates an array of objects", :end-row 5355, :filename "clojure/core.clj", :fixed-arities #{1}, :name "object-array", :ns "clojure.core", :row 5350} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of ints", :end-row 5363, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "int-array", :ns "clojure.core", :row 5357} {:arglist-strs ["[size-or-seq]" "[size init-val-or-seq]"], :doc "Creates an array of longs", :end-row 5371, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "long-array", :ns "clojure.core", :row 5365} {:arglist-strs ["[xs]"], :doc "Casts to boolean[]", :end-row 5376, :filename "clojure/core.clj", :fixed-arities #{1}, :name "booleans", :ns "clojure.core", :row 5373} {:arglist-strs ["[xs]"], :doc "Casts to bytes[]", :end-row 5381, :filename "clojure/core.clj", :fixed-arities #{1}, :name "bytes", :ns "clojure.core", :row 5378} {:arglist-strs ["[xs]"], :doc "Casts to chars[]", :end-row 5386, :filename "clojure/core.clj", :fixed-arities #{1}, :name "chars", :ns "clojure.core", :row 5383} {:arglist-strs ["[xs]"], :doc "Casts to shorts[]", :end-row 5391, :filename "clojure/core.clj", :fixed-arities #{1}, :name "shorts", :ns "clojure.core", :row 5388} {:arglist-strs ["[xs]"], :doc "Casts to float[]", :end-row 5396, :filename "clojure/core.clj", :fixed-arities #{1}, :name "floats", :ns "clojure.core", :row 5393} {:arglist-strs ["[xs]"], :doc "Casts to int[]", :end-row 5401, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ints", :ns "clojure.core", :row 5398} {:arglist-strs ["[xs]"], :doc "Casts to double[]", :end-row 5406, :filename "clojure/core.clj", :fixed-arities #{1}, :name "doubles", :ns "clojure.core", :row 5403} {:arglist-strs ["[xs]"], :doc "Casts to long[]", :end-row 5411, :filename "clojure/core.clj", :fixed-arities #{1}, :name "longs", :ns "clojure.core", :row 5408} {:arglist-strs ["[x]"], :doc "Return true if x is a byte array", :end-row 5418, :filename "clojure/core.clj", :fixed-arities #{1}, :name "bytes?", :ns "clojure.core", :row 5413} {:arglist-strs ["[s]" "[n-or-q s]"], :doc "Creates a queued seq on another (presumably lazy) seq s. The queued\n  seq will produce a concrete seq in the background, and can get up to\n  n items ahead of the consumer. n-or-q can be an integer n buffer\n  size, or an instance of java.util.concurrent BlockingQueue. Note\n  that reading from a seque can block if the reader gets ahead of the\n  producer.", :end-row 5466, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "seque", :ns "clojure.core", :row 5422} {:arglist-strs ["[x]"], :doc "Returns true if x is an instance of Class", :end-row 5472, :filename "clojure/core.clj", :fixed-arities #{1}, :name "class?", :ns "clojure.core", :row 5468} {:arglist-strs ["[c]"], :end-row 5476, :filename "clojure/core.clj", :fixed-arities #{1}, :name "is-annotation?", :ns "clojure.core", :private true, :row 5474} {:arglist-strs ["[c]"], :end-row 5483, :filename "clojure/core.clj", :fixed-arities #{1}, :name "is-runtime-annotation?", :ns "clojure.core", :private true, :row 5478} {:arglist-strs ["[c]"], :end-row 5485, :filename "clojure/core.clj", :fixed-arities #{1}, :name "descriptor", :ns "clojure.core", :private true, :row 5485} {:end-row 5487, :filename "clojure/core.clj", :name "process-annotation", :ns "clojure.core", :row 5487} {:arglist-strs ["[av name v]"], :end-row 5506, :filename "clojure/core.clj", :fixed-arities #{3}, :name "add-annotation", :ns "clojure.core", :private true, :row 5488} {:arglist-strs ["[av v]"], :end-row 5512, :filename "clojure/core.clj", :fixed-arities #{2}, :name "process-annotation", :ns "clojure.core", :private true, :row 5508} {:arglist-strs ["[visitor m]" "[visitor m i]"], :end-row 5528, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "add-annotations", :ns "clojure.core", :private true, :row 5514} {:arglist-strs ["[v f & args]"], :doc "Atomically alters the root binding of var v by applying f to its\n  current value plus any args", :end-row 5535, :filename "clojure/core.clj", :name "alter-var-root", :ns "clojure.core", :row 5530} {:arglist-strs ["[& vars]"], :doc "Returns true if all of the vars provided as arguments have any bound value, root or thread-local.\n   Implies that deref'ing the provided vars will succeed. Returns true if no vars are provided.", :end-row 5543, :filename "clojure/core.clj", :name "bound?", :ns "clojure.core", :row 5537} {:arglist-strs ["[& vars]"], :doc "Returns true if all of the vars provided as arguments have thread-local bindings.\n   Implies that set!'ing the provided vars will succeed.  Returns true if no vars are provided.", :end-row 5551, :filename "clojure/core.clj", :name "thread-bound?", :ns "clojure.core", :row 5545} {:arglist-strs ["[]"], :doc "Creates a hierarchy object for use with derive, isa? etc.", :end-row 5557, :filename "clojure/core.clj", :fixed-arities #{0}, :name "make-hierarchy", :ns "clojure.core", :row 5553} {:end-row 5560, :filename "clojure/core.clj", :name "global-hierarchy", :ns "clojure.core", :private true, :row 5559} {:arglist-strs ["[coll]"], :doc "If coll is empty, returns nil, else coll", :end-row 5566, :filename "clojure/core.clj", :fixed-arities #{1}, :name "not-empty", :ns "clojure.core", :row 5562} {:arglist-strs ["[c]"], :doc "Returns the immediate superclass and direct interfaces of c, if any", :end-row 5576, :filename "clojure/core.clj", :fixed-arities #{1}, :name "bases", :ns "clojure.core", :row 5568} {:arglist-strs ["[class]"], :doc "Returns the immediate and indirect superclasses and interfaces of c, if any", :end-row 5587, :filename "clojure/core.clj", :fixed-arities #{1}, :name "supers", :ns "clojure.core", :row 5578} {:arglist-strs ["[child parent]" "[h child parent]"], :doc "Returns true if (= child parent), or child is directly or indirectly derived from\n  parent, either via a Java type inheritance relationship or a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy", :end-row 5608, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "isa?", :ns "clojure.core", :row 5589} {:arglist-strs ["[tag]" "[h tag]"], :doc "Returns the immediate parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :end-row 5621, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "parents", :ns "clojure.core", :row 5610} {:arglist-strs ["[tag]" "[h tag]"], :doc "Returns the immediate and indirect parents of tag, either via a Java type\n  inheritance relationship or a relationship established via derive. h\n  must be a hierarchy obtained from make-hierarchy, if not supplied\n  defaults to the global hierarchy", :end-row 5637, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "ancestors", :ns "clojure.core", :row 5623} {:arglist-strs ["[tag]" "[h tag]"], :doc "Returns the immediate and indirect children of tag, through a\n  relationship established via derive. h must be a hierarchy obtained\n  from make-hierarchy, if not supplied defaults to the global\n  hierarchy. Note: does not work on Java type inheritance\n  relationships.", :end-row 5649, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "descendants", :ns "clojure.core", :row 5639} {:arglist-strs ["[tag parent]" "[h tag parent]"], :doc "Establishes a parent/child relationship between parent and\n  tag. Parent must be a namespace-qualified symbol or keyword and\n  child can be either a namespace-qualified symbol or keyword or a\n  class. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :end-row 5685, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "derive", :ns "clojure.core", :row 5651} {:end-row 5687, :filename "clojure/core.clj", :name "flatten", :ns "clojure.core", :row 5687} {:arglist-strs ["[tag parent]" "[h tag parent]"], :doc "Removes a parent/child relationship between parent and\n  tag. h must be a hierarchy obtained from make-hierarchy, if not\n  supplied defaults to, and modifies, the global hierarchy.", :end-row 5707, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "underive", :ns "clojure.core", :row 5689} {:arglist-strs ["[x]" "[x y]" "[x y & more]"], :doc "Returns true if no two of the arguments are =", :end-row 5725, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "distinct?", :ns "clojure.core", :row 5710} {:arglist-strs ["[rs]"], :doc "Creates and returns a lazy sequence of structmaps corresponding to\n  the rows in the java.sql.ResultSet rs", :end-row 5744, :filename "clojure/core.clj", :fixed-arities #{1}, :name "resultset-seq", :ns "clojure.core", :row 5727} {:arglist-strs ["[iter]"], :doc "Returns a seq on a java.util.Iterator. Note that most collections\n  providing iterators implement Iterable and thus support seq directly.\n  Seqs cache values, thus iterator-seq should not be used on any\n  iterator that repeatedly returns the same mutable object.", :end-row 5754, :filename "clojure/core.clj", :fixed-arities #{1}, :name "iterator-seq", :ns "clojure.core", :row 5746} {:arglist-strs ["[e]"], :doc "Returns a seq on a java.util.Enumeration", :end-row 5761, :filename "clojure/core.clj", :fixed-arities #{1}, :name "enumeration-seq", :ns "clojure.core", :row 5756} {:arglist-strs ["[fmt & args]"], :doc "Formats a string using java.lang.String.format, see java.util.Formatter for format\n  string syntax", :end-row 5769, :filename "clojure/core.clj", :name "format", :ns "clojure.core", :row 5763} {:arglist-strs ["[fmt & args]"], :doc "Prints formatted output, as per format", :end-row 5776, :filename "clojure/core.clj", :name "printf", :ns "clojure.core", :row 5771} {:end-row 5778, :filename "clojure/core.clj", :name "gen-class", :ns "clojure.core", :row 5778} {:arglist-strs ["[& body]"], :end-row 5787, :filename "clojure/core.clj", :macro true, :name "with-loading-context", :ns "clojure.core", :row 5780} {:arglist-strs ["[name & references]"], :doc "Sets *ns* to the namespace named by name (unevaluated), creating it\n  if needed.  references can be zero or more of: (:refer-clojure ...)\n  (:require ...) (:use ...) (:import ...) (:load ...) (:gen-class)\n  with the syntax of refer-clojure/require/use/import/load/gen-class\n  respectively, except the arguments are unevaluated and need not be\n  quoted. (:gen-class ...), when supplied, defaults to :name\n  corresponding to the ns name, :main true, :impl-ns same as ns, and\n  :init-impl-ns true. All options of gen-class are\n  supported. The :gen-class directive is ignored when not\n  compiling. If :gen-class is not supplied, when compiled only an\n  nsname__init.class will be generated. If :refer-clojure is not used, a\n  default (refer 'clojure.core) is used.  Use of ns is preferred to\n  individual calls to in-ns/require/use/import:\n\n  (ns foo.bar\n    (:refer-clojure :exclude [ancestors printf])\n    (:require (clojure.contrib sql combinatorics))\n    (:use (my.lib this that))\n    (:import (java.util Date Timer Random)\n             (java.sql Connection Statement)))", :end-row 5845, :filename "clojure/core.clj", :macro true, :name "ns", :ns "clojure.core", :row 5789} {:arglist-strs ["[& filters]"], :doc "Same as (refer 'clojure.core <filters>)", :end-row 5851, :filename "clojure/core.clj", :macro true, :name "refer-clojure", :ns "clojure.core", :row 5847} {:fixed-arities #{2}, :end-row 5860, :ns "clojure.core", :name "defonce", :filename "clojure/core.clj", :macro true, :arglist-strs ["[name expr]"], :doc "defs name to have the root value of the expr iff the named var has no root value,\n  else expr is unevaluated", :row 5853} {:doc "A ref to a sorted set of symbols representing loaded libs", :end-row 5867, :filename "clojure/core.clj", :name "*loaded-libs*", :ns "clojure.core", :private true, :row 5864} {:doc "A stack of paths currently being loaded by this thread", :end-row 5872, :filename "clojure/core.clj", :name "*pending-paths*", :ns "clojure.core", :private true, :row 5869} {:doc "True while a verbose load is pending", :end-row 5877, :filename "clojure/core.clj", :name "*loading-verbosely*", :ns "clojure.core", :private true, :row 5874} {:arglist-strs ["[pred fmt & args]"], :doc "Throws a CompilerException with a message if pred is true", :end-row 5893, :filename "clojure/core.clj", :name "throw-if", :ns "clojure.core", :private true, :row 5879} {:fixed-arities #{1}, :end-row 5902, :private true, :ns "clojure.core", :name "libspec?", :filename "clojure/core.clj", :arglist-strs ["[x]"], :doc "Returns true if x is a libspec", :row 5895} {:fixed-arities #{2}, :end-row 5909, :private true, :ns "clojure.core", :name "prependss", :filename "clojure/core.clj", :arglist-strs ["[x coll]"], :doc "Prepends a symbol or a seq to coll", :row 5904} {:fixed-arities #{1}, :end-row 5918, :private true, :ns "clojure.core", :name "root-resource", :filename "clojure/core.clj", :arglist-strs ["[lib]"], :doc "Returns the root directory path for a lib", :row 5911} {:fixed-arities #{1}, :end-row 5924, :private true, :ns "clojure.core", :name "root-directory", :filename "clojure/core.clj", :arglist-strs ["[lib]"], :doc "Returns the root resource path for a lib", :row 5920} {:end-row 5926, :filename "clojure/core.clj", :name "load", :ns "clojure.core", :row 5926} {:fixed-arities #{3}, :end-row 5939, :private true, :ns "clojure.core", :name "load-one", :filename "clojure/core.clj", :arglist-strs ["[lib need-ns require]"], :doc "Loads a lib given its name. If need-ns, ensures that the associated\n  namespace exists after loading. If require, records the load so any\n  duplicate loads can be skipped.", :row 5928} {:fixed-arities #{3}, :end-row 5951, :private true, :ns "clojure.core", :name "load-all", :filename "clojure/core.clj", :arglist-strs ["[lib need-ns require]"], :doc "Loads a lib given its name and forces a load of any libs it directly or\n  indirectly loads. If need-ns, ensures that the associated namespace\n  exists after loading. If require, records the load so any duplicate loads\n  can be skipped.", :row 5941} {:arglist-strs ["[prefix lib & options]"], :doc "Loads a lib with options", :end-row 5998, :filename "clojure/core.clj", :name "load-lib", :ns "clojure.core", :private true, :row 5953} {:arglist-strs ["[& args]"], :doc "Loads libs, interpreting libspecs, prefix lists, and flags for\n  forwarding to load-lib", :end-row 6021, :filename "clojure/core.clj", :name "load-libs", :ns "clojure.core", :private true, :row 6000} {:fixed-arities #{1}, :end-row 6034, :private true, :ns "clojure.core", :name "check-cyclic-dependency", :filename "clojure/core.clj", :arglist-strs ["[path]"], :doc "Detects and rejects non-trivial cyclic load dependencies. The\n  exception message shows the dependency chain with the cycle\n  highlighted. Ignores the trivial case of a file attempting to load\n  itself because that can occur when a gen-class'd class loads its\n  implementation.", :row 6023} {:arglist-strs ["[& args]"], :doc "Loads libs, skipping any that are already loaded. Each argument is\n  either a libspec that identifies a lib, a prefix list that identifies\n  multiple libs whose names share a common prefix, or a flag that modifies\n  how all the identified libs are loaded. Use :require in the ns macro\n  in preference to calling this directly.\n\n  Libs\n\n  A 'lib' is a named set of resources in classpath whose contents define a\n  library of Clojure code. Lib names are symbols and each lib is associated\n  with a Clojure namespace and a Java package that share its name. A lib's\n  name also locates its root directory within classpath using Java's\n  package name to classpath-relative path mapping. All resources in a lib\n  should be contained in the directory structure under its root directory.\n  All definitions a lib makes should be in its associated namespace.\n\n  'require loads a lib by loading its root resource. The root resource path\n  is derived from the lib name in the following manner:\n  Consider a lib named by the symbol 'x.y.z; it has the root directory\n  <classpath>/x/y/, and its root resource is <classpath>/x/y/z.clj, or\n  <classpath>/x/y/z.cljc if <classpath>/x/y/z.clj does not exist. The\n  root resource should contain code to create the lib's\n  namespace (usually by using the ns macro) and load any additional\n  lib resources.\n\n  Libspecs\n\n  A libspec is a lib name or a vector containing a lib name followed by\n  options expressed as sequential keywords and arguments.\n\n  Recognized options:\n  :as takes a symbol as its argument and makes that symbol an alias to the\n    lib's namespace in the current namespace.\n  :as-alias takes a symbol as its argument and aliases like :as, however\n    the lib will not be loaded. If the lib has not been loaded, a new\n    empty namespace will be created (as with create-ns).\n  :refer takes a list of symbols to refer from the namespace or the :all\n    keyword to bring in all public vars.\n\n  Prefix Lists\n\n  It's common for Clojure code to depend on several libs whose names have\n  the same prefix. When specifying libs, prefix lists can be used to reduce\n  repetition. A prefix list contains the shared prefix followed by libspecs\n  with the shared prefix removed from the lib names. After removing the\n  prefix, the names that remain must not contain any periods.\n\n  Flags\n\n  A flag is a keyword.\n  Recognized flags: :reload, :reload-all, :verbose\n  :reload forces loading of all the identified libs even if they are\n    already loaded (has no effect on libspecs using :as-alias)\n  :reload-all implies :reload and also forces loading of all libs that the\n    identified libs directly or indirectly load via require or use\n    (has no effect on libspecs using :as-alias)\n  :verbose triggers printing information about each load, alias, and refer\n\n  Example:\n\n  The following would load the libraries clojure.zip and clojure.set\n  abbreviated as 's'.\n\n  (require '(clojure zip [set :as s]))", :end-row 6106, :filename "clojure/core.clj", :name "require", :ns "clojure.core", :row 6038} {:arglist-strs ["[& args]"], :doc "Like 'require', but serializes loading.\n  Interim function preferred over 'require' for known asynchronous loads.\n  Future changes may make these equivalent.", :end-row 6115, :filename "clojure/core.clj", :name "serialized-require", :ns "clojure.core", :private true, :row 6108} {:arglist-strs ["[sym]"], :doc "Resolves namespace-qualified sym per 'resolve'. If initial resolve\nfails, attempts to require sym's namespace and retries.", :end-row 6126, :filename "clojure/core.clj", :fixed-arities #{1}, :name "requiring-resolve", :ns "clojure.core", :row 6117} {:arglist-strs ["[& args]"], :doc "Like 'require, but also refers to each lib's namespace using\n  clojure.core/refer. Use :use in the ns macro in preference to calling\n  this directly.\n\n  'use accepts additional options in libspecs: :exclude, :only, :rename.\n  The arguments and semantics for :exclude, :only, and :rename are the same\n  as those documented for clojure.core/refer.", :end-row 6137, :filename "clojure/core.clj", :name "use", :ns "clojure.core", :row 6128} {:arglist-strs ["[]"], :doc "Returns a sorted set of symbols naming the currently loaded libs", :end-row 6142, :filename "clojure/core.clj", :fixed-arities #{0}, :name "loaded-libs", :ns "clojure.core", :row 6139} {:arglist-strs ["[& paths]"], :doc "Loads Clojure code from resources in classpath. A path is interpreted as\n  classpath-relative if it begins with a slash or relative to the root\n  directory for the current namespace otherwise.", :end-row 6161, :filename "clojure/core.clj", :name "load", :ns "clojure.core", :row 6144} {:arglist-strs ["[lib]"], :doc "Compiles the namespace named by the symbol lib into a set of\n  classfiles. The source for the lib must be in a proper\n  classpath-relative directory. The output files will go into the\n  directory specified by *compile-path*, and that directory too must\n  be in the classpath.", :end-row 6173, :filename "clojure/core.clj", :fixed-arities #{1}, :name "compile", :ns "clojure.core", :row 6163} {:arglist-strs ["[m ks]" "[m ks not-found]"], :doc "Returns the value in a nested associative structure,\n  where ks is a sequence of keys. Returns nil if the key\n  is not present, or the not-found value if supplied.", :end-row 6194, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "get-in", :ns "clojure.core", :row 6177} {:arglist-strs ["[m [k & ks] v]"], :doc "Associates a value in a nested associative structure, where ks is a\n  sequence of keys and v is the new value and returns a new nested structure.\n  If any levels do not exist, hash-maps will be created.", :end-row 6205, :filename "clojure/core.clj", :fixed-arities #{3}, :name "assoc-in", :ns "clojure.core", :row 6196} {:arglist-strs ["[m ks f & args]"], :doc "'Updates' a value in a nested associative structure, where ks is a\n  sequence of keys and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  nested structure.  If any levels do not exist, hash-maps will be\n  created.", :end-row 6221, :filename "clojure/core.clj", :name "update-in", :ns "clojure.core", :row 6207} {:arglist-strs ["[m k f]" "[m k f x]" "[m k f x y]" "[m k f x y z]" "[m k f x y z & more]"], :doc "'Updates' a value in an associative structure, where k is a\n  key and f is a function that will take the old value\n  and any supplied args and return the new value, and returns a new\n  structure.  If the key does not exist, nil is passed as the old value.", :end-row 6239, :filename "clojure/core.clj", :fixed-arities #{4 6 3 5}, :name "update", :ns "clojure.core", :row 6223} {:arglist-strs ["[coll]"], :doc "Returns true if coll has no items - same as (not (seq coll)).\n  Please use the idiom (seq x) rather than (not (empty? x))", :end-row 6246, :filename "clojure/core.clj", :fixed-arities #{1}, :name "empty?", :ns "clojure.core", :row 6241} {:arglist-strs ["[x]"], :doc "Returns true if x implements IPersistentCollection", :end-row 6252, :filename "clojure/core.clj", :fixed-arities #{1}, :name "coll?", :ns "clojure.core", :row 6248} {:arglist-strs ["[x]"], :doc "Returns true if x implements IPersistentList", :end-row 6258, :filename "clojure/core.clj", :fixed-arities #{1}, :name "list?", :ns "clojure.core", :row 6254} {:arglist-strs ["[x]"], :doc "Return true if the seq function is supported for x", :end-row 6263, :filename "clojure/core.clj", :fixed-arities #{1}, :name "seqable?", :ns "clojure.core", :row 6260} {:arglist-strs ["[x]"], :doc "Returns true if x implements IFn. Note that many data structures\n  (e.g. sets and maps) implement IFn", :end-row 6270, :filename "clojure/core.clj", :fixed-arities #{1}, :name "ifn?", :ns "clojure.core", :row 6265} {:arglist-strs ["[x]"], :doc "Returns true if x implements Fn, i.e. is an object created via fn.", :end-row 6276, :filename "clojure/core.clj", :fixed-arities #{1}, :name "fn?", :ns "clojure.core", :row 6272} {:arglist-strs ["[coll]"], :doc "Returns true if coll implements Associative", :end-row 6283, :filename "clojure/core.clj", :fixed-arities #{1}, :name "associative?", :ns "clojure.core", :row 6279} {:arglist-strs ["[coll]"], :doc "Returns true if coll implements Sequential", :end-row 6289, :filename "clojure/core.clj", :fixed-arities #{1}, :name "sequential?", :ns "clojure.core", :row 6285} {:arglist-strs ["[coll]"], :doc "Returns true if coll implements Sorted", :end-row 6295, :filename "clojure/core.clj", :fixed-arities #{1}, :name "sorted?", :ns "clojure.core", :row 6291} {:arglist-strs ["[coll]"], :doc "Returns true if coll implements count in constant time", :end-row 6301, :filename "clojure/core.clj", :fixed-arities #{1}, :name "counted?", :ns "clojure.core", :row 6297} {:arglist-strs ["[coll]"], :doc "Returns true if coll implements Reversible", :end-row 6307, :filename "clojure/core.clj", :fixed-arities #{1}, :name "reversible?", :ns "clojure.core", :row 6303} {:arglist-strs ["[coll]"], :doc "Return true if coll implements Indexed, indicating efficient lookup by index", :end-row 6312, :filename "clojure/core.clj", :fixed-arities #{1}, :name "indexed?", :ns "clojure.core", :row 6309} {:doc "bound in a repl thread to the most recent value printed", :end-row 6317, :filename "clojure/core.clj", :name "*1", :ns "clojure.core", :row 6314} {:doc "bound in a repl thread to the second most recent value printed", :end-row 6322, :filename "clojure/core.clj", :name "*2", :ns "clojure.core", :row 6319} {:doc "bound in a repl thread to the third most recent value printed", :end-row 6327, :filename "clojure/core.clj", :name "*3", :ns "clojure.core", :row 6324} {:doc "bound in a repl thread to the most recent exception caught by the repl", :end-row 6332, :filename "clojure/core.clj", :name "*e", :ns "clojure.core", :row 6329} {:arglist-strs ["[f]" "[f & args]"], :doc "trampoline can be used to convert algorithms requiring mutual\n  recursion without stack consumption. Calls f with supplied args, if\n  any. If f returns a fn, calls that fn with no arguments, and\n  continues to repeat, until the return value is not a fn, then\n  returns that non-fn value. Note that if you want to return a fn as a\n  final value, you must wrap it in some data structure and unpack it\n  after trampoline returns.", :end-row 6350, :filename "clojure/core.clj", :fixed-arities #{1}, :name "trampoline", :ns "clojure.core", :row 6334} {:arglist-strs ["[ns name]" "[ns name val]"], :doc "Finds or creates a var named by the symbol name in the namespace\n  ns (which can be a symbol or a namespace), setting its root binding\n  to val if supplied. The namespace must exist. The var will adopt any\n  metadata from the name symbol.  Returns the var.", :end-row 6366, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "intern", :ns "clojure.core", :row 6352} {:arglist-strs ["[test & body]"], :doc "Repeatedly executes body while test expression is true. Presumes\n  some side-effect will cause test to become false/nil. Returns nil", :end-row 6376, :filename "clojure/core.clj", :macro true, :name "while", :ns "clojure.core", :row 6368} {:arglist-strs ["[f]"], :doc "Returns a memoized version of a referentially transparent function. The\n  memoized version of the function keeps a cache of the mapping from arguments\n  to results and, when calls with the same arguments are repeated often, has\n  higher performance at the expense of higher memory use.", :end-row 6392, :filename "clojure/core.clj", :fixed-arities #{1}, :name "memoize", :ns "clojure.core", :row 6378} {:arglist-strs ["[pred expr & clauses]"], :doc "Takes a binary predicate, an expression, and a set of clauses.\n  Each clause can take the form of either:\n\n  test-expr result-expr\n\n  test-expr :>> result-fn\n\n  Note :>> is an ordinary keyword.\n\n  For each clause, (pred test-expr expr) is evaluated. If it returns\n  logical true, the clause is a match. If a binary clause matches, the\n  result-expr is returned, if a ternary clause matches, its result-fn,\n  which must be a unary function, is called with the result of the\n  predicate as its argument, the result of that call being the return\n  value of condp. A single default expression can follow the clauses,\n  and its value will be returned if no clause matches. If no default\n  expression is provided and no clause matches, an\n  IllegalArgumentException is thrown.", :end-row 6433, :filename "clojure/core.clj", :macro true, :name "condp", :ns "clojure.core", :row 6394} {:fixed-arities #{3}, :end-row 6442, :private true, :ns "clojure.core", :name "add-doc-and-meta", :filename "clojure/core.clj", :macro true, :arglist-strs ["[name docstring meta]"], :row 6441} {:arglist-strs ["[x]"], :doc "Returns true if x is a future", :end-row 6572, :filename "clojure/core.clj", :fixed-arities #{1}, :name "future?", :ns "clojure.core", :row 6568} {:arglist-strs ["[f]"], :doc "Returns true if future f is done", :end-row 6578, :filename "clojure/core.clj", :fixed-arities #{1}, :name "future-done?", :ns "clojure.core", :row 6574} {:arglist-strs ["[fnspecs & body]"], :doc "fnspec ==> (fname [params*] exprs) or (fname ([params*] exprs)+)\n\n  Takes a vector of function specs and a body, and generates a set of\n  bindings of functions to their names. All of the names are available\n  in all of the definitions of the functions, as well as the body.", :end-row 6592, :filename "clojure/core.clj", :macro true, :name "letfn", :ns "clojure.core", :row 6581} {:arglist-strs ["[f x]" "[f x y]" "[f x y z]"], :doc "Takes a function f, and returns a function that calls f, replacing\n  a nil first argument to f with the supplied value x. Higher arity\n  versions can replace arguments in the second and third\n  positions (y, z). Note that the function f can take any number of\n  arguments, not just the one(s) being nil-patched.", :end-row 6617, :filename "clojure/core.clj", :fixed-arities #{4 3 2}, :name "fnil", :ns "clojure.core", :row 6594} {:arglist-strs ["[keys vals]"], :doc "Returns a map with the keys mapped to the corresponding vals.", :end-row 6631, :filename "clojure/core.clj", :fixed-arities #{2}, :name "zipmap", :ns "clojure.core", :row 6619} {:arglist-strs ["[shift mask x]"], :end-row 6635, :filename "clojure/core.clj", :fixed-arities #{3}, :name "shift-mask", :ns "clojure.core", :private true, :row 6634} {:end-row 6637, :filename "clojure/core.clj", :name "max-mask-bits", :ns "clojure.core", :private true, :row 6637} {:end-row 6638, :filename "clojure/core.clj", :name "max-switch-table-size", :ns "clojure.core", :private true, :row 6638} {:fixed-arities #{1}, :end-row 6648, :private true, :ns "clojure.core", :name "maybe-min-hash", :filename "clojure/core.clj", :arglist-strs ["[hashes]"], :doc "takes a collection of hashes and returns [shift mask] or nil if none found", :row 6640} {:fixed-arities #{4}, :end-row 6659, :private true, :ns "clojure.core", :name "case-map", :filename "clojure/core.clj", :arglist-strs ["[case-f test-f tests thens]"], :doc "Transforms a sequence of test constants and a corresponding sequence of then\n  expressions into a sorted map to be consumed by case*. The form of the map\n  entries are {(case-f test) [(test-f test) then]}.", :row 6650} {:fixed-arities #{1}, :end-row 6665, :private true, :ns "clojure.core", :name "fits-table?", :filename "clojure/core.clj", :arglist-strs ["[ints]"], :doc "Returns true if the collection of ints can fit within the\n  max-table-switch-size, false otherwise.", :row 6661} {:fixed-arities #{2}, :end-row 6681, :private true, :ns "clojure.core", :name "prep-ints", :filename "clojure/core.clj", :arglist-strs ["[tests thens]"], :doc "Takes a sequence of int-sized test constants and a corresponding sequence of\n  then expressions. Returns a tuple of [shift mask case-map switch-type] where\n  case-map is a map of int case values to [test then] tuples, and switch-type\n  is either :sparse or :compact.", :row 6667} {:fixed-arities #{4}, :end-row 6717, :private true, :ns "clojure.core", :name "merge-hash-collisions", :filename "clojure/core.clj", :arglist-strs ["[expr-sym default tests thens]"], :doc "Takes a case expression, default expression, and a sequence of test constants\n  and a corresponding sequence of then expressions. Returns a tuple of\n  [tests thens skip-check-set] where no tests have the same hash. Each set of\n  input test constants with the same hash is replaced with a single test\n  constant (the case int), and their respective thens are combined into:\n  (condp = expr\n    test-1 then-1\n    ...\n    test-n then-n\n    default).\n  The skip-check is a set of case ints for which post-switch equivalence\n  checking must not be done (the cases holding the above condp thens).", :row 6683} {:fixed-arities #{4}, :end-row 6745, :private true, :ns "clojure.core", :name "prep-hashes", :filename "clojure/core.clj", :arglist-strs ["[expr-sym default tests thens]"], :doc "Takes a sequence of test constants and a corresponding sequence of then\n  expressions. Returns a tuple of [shift mask case-map switch-type skip-check]\n  where case-map is a map of int case values to [test then] tuples, switch-type\n  is either :sparse or :compact, and skip-check is a set of case ints for which\n  post-switch equivalence checking must not be done (occurs with hash\n  collisions).", :row 6719} {:arglist-strs ["[e & clauses]"], :doc "Takes an expression, and a set of clauses.\n\n  Each clause can take the form of either:\n\n  test-constant result-expr\n\n  (test-constant1 ... test-constantN)  result-expr\n\n  The test-constants are not evaluated. They must be compile-time\n  literals, and need not be quoted.  If the expression is equal to a\n  test-constant, the corresponding result-expr is returned. A single\n  default expression can follow the clauses, and its value will be\n  returned if no clause matches. If no default expression is provided\n  and no clause matches, an IllegalArgumentException is thrown.\n\n  Unlike cond and condp, case does a constant-time dispatch, the\n  clauses are not considered sequentially.  All manner of constant\n  expressions are acceptable in case, including numbers, strings,\n  symbols, keywords, and (Clojure) composites thereof. Note that since\n  lists are used to group multiple constants that map to the same\n  expression, a vector can be used to match a list if needed. The\n  test-constants need not be all of the same type.", :end-row 6808, :filename "clojure/core.clj", :macro true, :name "case", :ns "clojure.core", :row 6748} {:arglist-strs ["[class-name & body]"], :end-row 6826, :filename "clojure/core.clj", :macro true, :name "when-class", :ns "clojure.core", :private true, :row 6822} {:end-row 6832, :filename "clojure/core.clj", :name "Inst", :ns "clojure.core", :row 6831} {:arglist-strs ["[inst]"], :end-row 6832, :filename "clojure/core.clj", :fixed-arities #{1}, :name "inst-ms*", :ns "clojure.core", :row 6832} {:arglist-strs ["[inst]"], :doc "Return the number of milliseconds since January 1, 1970, 00:00:00 GMT", :end-row 6842, :filename "clojure/core.clj", :fixed-arities #{1}, :name "inst-ms", :ns "clojure.core", :row 6838} {:arglist-strs ["[x]"], :doc "Return true if x satisfies Inst", :end-row 6848, :filename "clojure/core.clj", :fixed-arities #{1}, :name "inst?", :ns "clojure.core", :row 6844} {:arglist-strs ["[x]"], :doc "Return true if x is a java.util.UUID", :end-row 6859, :filename "clojure/core.clj", :fixed-arities #{1}, :name "uuid?", :ns "clojure.core", :row 6856} {:arglist-strs ["[]"], :doc "Returns a pseudo-randomly generated java.util.UUID instance (i.e. type 4).\n\n  See: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#randomUUID--", :end-row 6866, :filename "clojure/core.clj", :fixed-arities #{0}, :name "random-uuid", :ns "clojure.core", :row 6861} {:arglist-strs ["[f coll]" "[f val coll]"], :doc "f should be a function of 2 arguments. If val is not supplied,\n  returns the result of applying f to the first 2 items in coll, then\n  applying f to that result and the 3rd item, etc. If coll contains no\n  items, f must accept no arguments as well, and reduce returns the\n  result of calling f with no arguments.  If coll has only 1 item, it\n  is returned and f is not called.  If val is supplied, returns the\n  result of applying f to val and the first item in coll, then\n  applying f to that result and the 2nd item, etc. If coll contains no\n  items, returns val and f is not called.", :end-row 6886, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "reduce", :ns "clojure.core", :row 6868} {:arglist-strs ["[f init coll]"], :doc "Reduces an associative collection. f should be a function of 3\n  arguments. Returns the result of applying f to init, the first key\n  and the first value in coll, then applying f to that result and the\n  2nd key and value, etc. If coll contains no entries, returns init\n  and f is not called. Note that reduce-kv is supported on vectors,\n  where the keys will be the ordinals.", :end-row 6919, :filename "clojure/core.clj", :fixed-arities #{3}, :name "reduce-kv", :ns "clojure.core", :row 6910} {:arglist-strs ["[f]" "[f cf]"], :doc "Takes a reducing function f of 2 args and returns a fn suitable for\n  transduce by adding an arity-1 signature that calls cf (default -\n  identity) on the result argument.", :end-row 6931, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "completing", :ns "clojure.core", :row 6921} {:arglist-strs ["[xform f coll]" "[xform f init coll]"], :doc "reduce with a transformation of f (xf). If init is not\n  supplied, (f) will be called to produce it. f should be a reducing\n  step function that accepts both 1 and 2 arguments, if it accepts\n  only 2 you can add the arity-1 with 'completing'. Returns the result\n  of applying (the transformed) xf to init and the first item in coll,\n  then applying xf to that result and the 2nd item, etc. If coll\n  contains no items, returns init and f is not called. Note that\n  certain transforms may inject or skip items.", :end-row 6948, :filename "clojure/core.clj", :fixed-arities #{4 3}, :name "transduce", :ns "clojure.core", :row 6933} {:arglist-strs ["[]" "[to]" "[to from]" "[to xform from]"], :doc "Returns a new coll consisting of to-coll with all of the items of\n  from-coll conjoined. A transducer may be supplied.", :end-row 6968, :filename "clojure/core.clj", :fixed-arities #{0 1 3 2}, :name "into", :ns "clojure.core", :row 6950} {:arglist-strs ["[f coll]" "[f c1 c2]" "[f c1 c2 c3]" "[f c1 c2 c3 & colls]"], :doc "Returns a vector consisting of the result of applying f to the\n  set of first items of each coll, followed by applying f to the set\n  of second items in each coll, until any one of the colls is\n  exhausted.  Any remaining items in other colls are ignored. Function\n  f should accept number-of-colls arguments.", :end-row 6986, :filename "clojure/core.clj", :fixed-arities #{4 3 2}, :name "mapv", :ns "clojure.core", :row 6970} {:arglist-strs ["[pred coll]"], :doc "Returns a vector of the items in coll for which\n  (pred item) returns logical true. pred must be free of side-effects.", :end-row 6997, :filename "clojure/core.clj", :fixed-arities #{2}, :name "filterv", :ns "clojure.core", :row 6988} {:arglist-strs ["[opts]"], :end-row 7007, :filename "clojure/core.clj", :fixed-arities #{1}, :name "normalize-slurp-opts", :ns "clojure.core", :private true, :row 7001} {:arglist-strs ["[f & opts]"], :doc "Opens a reader on f and reads all its contents, returning a string.\n  See clojure.java.io/reader for a complete list of supported arguments.", :end-row 7019, :filename "clojure/core.clj", :name "slurp", :ns "clojure.core", :row 7009} {:arglist-strs ["[f content & options]"], :doc "Opposite of slurp.  Opens f with writer, writes content, then\n  closes f. Options passed to clojure.java.io/writer.", :end-row 7027, :filename "clojure/core.clj", :name "spit", :ns "clojure.core", :row 7021} {:arglist-strs ["[f]"], :doc "Takes a function of no args and yields a future object that will\n  invoke the function in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant\n  of deref with timeout is used. See also - realized?.", :end-row 7055, :filename "clojure/core.clj", :fixed-arities #{1}, :name "future-call", :ns "clojure.core", :row 7030} {:arglist-strs ["[& body]"], :doc "Takes a body of expressions and yields a future object that will\n  invoke the body in another thread, and will cache the result and\n  return it on all subsequent calls to deref/@. If the computation has\n  not yet finished, calls to deref/@ will block, unless the variant of\n  deref with timeout is used. See also - realized?.", :end-row 7064, :filename "clojure/core.clj", :macro true, :name "future", :ns "clojure.core", :row 7057} {:arglist-strs ["[f]"], :doc "Cancels the future, if possible.", :end-row 7071, :filename "clojure/core.clj", :fixed-arities #{1}, :name "future-cancel", :ns "clojure.core", :row 7067} {:arglist-strs ["[f]"], :doc "Returns true if future f is cancelled", :end-row 7077, :filename "clojure/core.clj", :fixed-arities #{1}, :name "future-cancelled?", :ns "clojure.core", :row 7073} {:arglist-strs ["[f coll]" "[f coll & colls]"], :doc "Like map, except f is applied in parallel. Semi-lazy in that the\n  parallel computation stays ahead of the consumption, but doesn't\n  realize the entire result unless required. Only useful for\n  computationally intensive functions where the time of f dominates\n  the coordination overhead.", :end-row 7102, :filename "clojure/core.clj", :fixed-arities #{2}, :name "pmap", :ns "clojure.core", :row 7079} {:arglist-strs ["[& fns]"], :doc "Executes the no-arg fns in parallel, returning a lazy sequence of\n  their values", :end-row 7109, :filename "clojure/core.clj", :name "pcalls", :ns "clojure.core", :row 7104} {:arglist-strs ["[& exprs]"], :doc "Returns a lazy sequence of the values of the exprs, which are\n  evaluated in parallel", :end-row 7117, :filename "clojure/core.clj", :macro true, :name "pvalues", :ns "clojure.core", :row 7111} {:end-row 7140, :filename "clojure/core.clj", :name "*clojure-version*", :ns "clojure.core", :row 7137} {:arglist-strs ["[]"], :doc "Returns clojure version as a printable string.", :end-row 7162, :filename "clojure/core.clj", :fixed-arities #{0}, :name "clojure-version", :ns "clojure.core", :row 7149} {:arglist-strs ["[]"], :doc "Returns a promise object that can be read with deref/@, and set,\n  once only, with deliver. Calls to deref/@ prior to delivery will\n  block, unless the variant of deref with timeout is used. All\n  subsequent derefs will return the same delivered value without\n  blocking. See also - realized?.", :end-row 7193, :filename "clojure/core.clj", :fixed-arities #{0}, :name "promise", :ns "clojure.core", :row 7164} {:arglist-strs ["[promise val]"], :doc "Delivers the supplied value to the promise, releasing any pending\n  derefs. A subsequent call to deliver on a promise will have no effect.", :end-row 7200, :filename "clojure/core.clj", :fixed-arities #{2}, :name "deliver", :ns "clojure.core", :row 7195} {:arglist-strs ["[x]"], :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat lazy sequence.\n  (flatten nil) returns an empty sequence.", :end-row 7212, :filename "clojure/core.clj", :fixed-arities #{1}, :name "flatten", :ns "clojure.core", :row 7204} {:arglist-strs ["[f coll]"], :doc "Returns a map of the elements of coll keyed by the result of\n  f on each element. The value at each key will be a vector of the\n  corresponding elements, in the order they appeared in coll.", :end-row 7226, :filename "clojure/core.clj", :fixed-arities #{2}, :name "group-by", :ns "clojure.core", :row 7214} {:arglist-strs ["[f]" "[f coll]"], :doc "Applies f to each value in coll, splitting it each time f returns a\n   new value.  Returns a lazy seq of partitions.  Returns a stateful\n   transducer when no collection is provided.", :end-row 7269, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "partition-by", :ns "clojure.core", :row 7228} {:arglist-strs ["[coll]"], :doc "Returns a map from distinct items in coll to the number of times\n  they appear.", :end-row 7280, :filename "clojure/core.clj", :fixed-arities #{1}, :name "frequencies", :ns "clojure.core", :row 7271} {:arglist-strs ["[f coll]" "[f init coll]"], :doc "Returns a lazy seq of the intermediate values of the reduction (as\n  per reduce) of coll by f, starting with init.", :end-row 7297, :filename "clojure/core.clj", :fixed-arities #{3 2}, :name "reductions", :ns "clojure.core", :row 7282} {:arglist-strs ["[coll]"], :doc "Return a random element of the (sequential) collection. Will have\n  the same performance characteristics as nth for the given\n  collection.", :end-row 7306, :filename "clojure/core.clj", :fixed-arities #{1}, :name "rand-nth", :ns "clojure.core", :row 7299} {:arglist-strs ["[n]" "[n coll]" "[n step coll]"], :doc "Returns a lazy sequence of lists like partition, but may include\n  partitions with fewer than n items at the end.  Returns a stateful\n  transducer when no collection is provided.", :end-row 7340, :filename "clojure/core.clj", :fixed-arities #{1 3 2}, :name "partition-all", :ns "clojure.core", :row 7308} {:arglist-strs ["[coll]"], :doc "Return a random permutation of coll", :end-row 7349, :filename "clojure/core.clj", :fixed-arities #{1}, :name "shuffle", :ns "clojure.core", :row 7342} {:arglist-strs ["[f]" "[f coll]"], :doc "Returns a lazy sequence consisting of the result of applying f to 0\n  and the first item of coll, followed by applying f to 1 and the second\n  item in coll, etc, until coll is exhausted. Thus function f should\n  accept 2 arguments, index and item. Returns a stateful transducer when\n  no collection is provided.", :end-row 7379, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "map-indexed", :ns "clojure.core", :row 7351} {:arglist-strs ["[f]" "[f coll]"], :doc "Returns a lazy sequence of the non-nil results of (f item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a transducer when no collection is provided.", :end-row 7412, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "keep", :ns "clojure.core", :row 7381} {:arglist-strs ["[f]" "[f coll]"], :doc "Returns a lazy sequence of the non-nil results of (f index item). Note,\n  this means false return values will be included.  f must be free of\n  side-effects.  Returns a stateful transducer when no collection is\n  provided.", :end-row 7450, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "keep-indexed", :ns "clojure.core", :row 7414} {:arglist-strs ["[n coll]"], :doc "If coll is counted? returns its count, else will count at most the first n\n  elements of coll using its seq", :end-row 7462, :filename "clojure/core.clj", :fixed-arities #{2}, :name "bounded-count", :ns "clojure.core", :row 7452} {:arglist-strs ["[p]" "[p1 p2]" "[p1 p2 p3]" "[p1 p2 p3 & ps]"], :doc "Takes a set of predicates and returns a function f that returns true if all of its\n  composing predicates return a logical true value against all of its arguments, else it returns\n  false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical false result against the original predicates.", :end-row 7502, :filename "clojure/core.clj", :fixed-arities #{1 3 2}, :name "every-pred", :ns "clojure.core", :row 7464} {:arglist-strs ["[p]" "[p1 p2]" "[p1 p2 p3]" "[p1 p2 p3 & ps]"], :doc "Takes a set of predicates and returns a function f that returns the first logical true value\n  returned by one of its composing predicates against any of its arguments, else it returns\n  logical false. Note that f is short-circuiting in that it will stop execution on the first\n  argument that triggers a logical true result against the original predicates.", :end-row 7542, :filename "clojure/core.clj", :fixed-arities #{1 3 2}, :name "some-fn", :ns "clojure.core", :row 7504} {:fixed-arities #{1}, :end-row 7564, :private true, :ns "clojure.core", :name "assert-valid-fdecl", :filename "clojure/core.clj", :arglist-strs ["[fdecl]"], :doc "A good fdecl looks like (([a] ...) ([a b] ...)) near the end of defn.", :row 7544} {:arglist-strs ["[binding-map func]"], :doc "Temporarily redefines Vars during a call to func.  Each val of\n  binding-map will replace the root value of its key which must be\n  a Var.  After func is called with no args, the root values of all\n  the Vars will be set back to their old values.  These temporary\n  changes will be visible in all threads.  Useful for mocking out\n  functions during testing.", :end-row 7584, :filename "clojure/core.clj", :fixed-arities #{2}, :name "with-redefs-fn", :ns "clojure.core", :row 7566} {:arglist-strs ["[bindings & body]"], :doc "binding => var-symbol temp-value-expr\n\n  Temporarily redefines Vars while executing the body.  The\n  temp-value-exprs will be evaluated and each resulting value will\n  replace in parallel the root value of its Var.  After the body is\n  executed, the root values of all the Vars will be set back to their\n  old values.  These temporary changes will be visible in all threads.\n  Useful for mocking out functions during testing.", :end-row 7599, :filename "clojure/core.clj", :macro true, :name "with-redefs", :ns "clojure.core", :row 7586} {:arglist-strs ["[x]"], :doc "Returns true if a value has been produced for a promise, delay, future or lazy sequence.", :end-row 7604, :filename "clojure/core.clj", :fixed-arities #{1}, :name "realized?", :ns "clojure.core", :row 7601} {:arglist-strs ["[expr & clauses]"], :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->)\n  through each form for which the corresponding test\n  expression is true. Note that, unlike cond branching, cond-> threading does\n  not short circuit after the first true test expression.", :end-row 7621, :filename "clojure/core.clj", :macro true, :name "cond->", :ns "clojure.core", :row 7606} {:arglist-strs ["[expr & clauses]"], :doc "Takes an expression and a set of test/form pairs. Threads expr (via ->>)\n  through each form for which the corresponding test expression\n  is true.  Note that, unlike cond branching, cond->> threading does not short circuit\n  after the first true test expression.", :end-row 7638, :filename "clojure/core.clj", :macro true, :name "cond->>", :ns "clojure.core", :row 7623} {:arglist-strs ["[expr name & forms]"], :doc "Binds name to expr, evaluates the first form in the lexical context\n  of that binding, then binds name to that result, repeating for each\n  successive form, returning the result of the last form.", :end-row 7650, :filename "clojure/core.clj", :macro true, :name "as->", :ns "clojure.core", :row 7640} {:arglist-strs ["[expr & forms]"], :doc "When expr is not nil, threads it into the first form (via ->),\n  and when that result is not nil, through the next etc", :end-row 7664, :filename "clojure/core.clj", :macro true, :name "some->", :ns "clojure.core", :row 7652} {:arglist-strs ["[expr & forms]"], :doc "When expr is not nil, threads it into the first form (via ->>),\n  and when that result is not nil, through the next etc", :end-row 7678, :filename "clojure/core.clj", :macro true, :name "some->>", :ns "clojure.core", :row 7666} {:arglist-strs ["[rf]"], :end-row 7685, :filename "clojure/core.clj", :fixed-arities #{1}, :name "preserving-reduced", :ns "clojure.core", :private true, :row 7680} {:arglist-strs ["[rf]"], :doc "A transducer which concatenates the contents of each input, which must be a\n  collection, into the reduction.", :end-row 7697, :filename "clojure/core.clj", :fixed-arities #{1}, :name "cat", :ns "clojure.core", :row 7687} {:arglist-strs ["[pred]" "[pred retf]"], :doc "Returns a transducer that ends transduction when pred returns true\n  for an input. When retf is supplied it must be a fn of 2 arguments -\n  it will be passed the (completed) result so far and the input that\n  triggered the predicate, and its return value (if it does not throw\n  an exception) will be the return value of the transducer. If retf\n  is not supplied, the input that triggered the predicate will be\n  returned. If the predicate never returns true the transduction is\n  unaffected.", :end-row 7721, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "halt-when", :ns "clojure.core", :row 7699} {:arglist-strs ["[]" "[coll]"], :doc "Returns a lazy sequence removing consecutive duplicates in coll.\n  Returns a transducer when no collection is provided.", :end-row 7739, :filename "clojure/core.clj", :fixed-arities #{0 1}, :name "dedupe", :ns "clojure.core", :row 7723} {:arglist-strs ["[prob]" "[prob coll]"], :doc "Returns items from coll with random probability of prob (0.0 -\n  1.0).  Returns a transducer when no collection is provided.", :end-row 7748, :filename "clojure/core.clj", :fixed-arities #{1 2}, :name "random-sample", :ns "clojure.core", :row 7741} {:end-row 7760, :filename "clojure/core.clj", :name "Eduction", :ns "clojure.core", :row 7750} {:arglist-strs ["[xform coll]"], :end-row 7760, :filename "clojure/core.clj", :fixed-arities #{2}, :name "->Eduction", :ns "clojure.core", :row 7750} {:arglist-strs ["[& xforms]"], :doc "Returns a reducible/iterable application of the transducers\n  to the items in coll. Transducers are applied in order as if\n  combined with comp. Note that these applications will be\n  performed every time reduce/iterator is called.", :end-row 7770, :filename "clojure/core.clj", :name "eduction", :ns "clojure.core", :row 7762} {:arglist-strs ["[proc coll]"], :doc "Runs the supplied procedure (via reduce), for purposes of side\n  effects, on successive items in the collection. Returns nil", :end-row 7784, :filename "clojure/core.clj", :fixed-arities #{2}, :name "run!", :ns "clojure.core", :row 7778} {:arglist-strs ["[step & {:keys [somef vf kf initk] :or {vf identity kf identity somef some? initk nil}}]"], :doc "Creates a seqable/reducible via repeated calls to step,\n  a function of some (continuation token) 'k'. The first call to step\n  will be passed initk, returning 'ret'. Iff (somef ret) is true,\n  (vf ret) will be included in the iteration, else iteration will\n  terminate and vf/kf will not be called. If (kf ret) is non-nil it\n  will be passed to the next step call, else iteration will terminate.\n\n  This can be used e.g. to consume APIs that return paginated or batched data.\n\n   step - (possibly impure) fn of 'k' -> 'ret'\n\n   :somef - fn of 'ret' -> logical true/false, default 'some?'\n   :vf - fn of 'ret' -> 'v', a value produced by the iteration, default 'identity'\n   :kf - fn of 'ret' -> 'next-k' or nil (signaling 'do not continue'), default 'identity'\n   :initk - the first value passed to step, default 'nil'\n\n  It is presumed that step with non-initk is unreproducible/non-idempotent.\n  If step with initk is unreproducible it is on the consumer to not consume twice.", :end-row 7831, :filename "clojure/core.clj", :name "iteration", :ns "clojure.core", :row 7786} {:arglist-strs ["[value]"], :doc "Return true if the value is the data representation of a tagged literal", :end-row 7837, :filename "clojure/core.clj", :fixed-arities #{1}, :name "tagged-literal?", :ns "clojure.core", :row 7833} {:arglist-strs ["[tag form]"], :doc "Construct a data representation of a tagged literal from a\n  tag symbol and a form.", :end-row 7844, :filename "clojure/core.clj", :fixed-arities #{2}, :name "tagged-literal", :ns "clojure.core", :row 7839} {:arglist-strs ["[value]"], :doc "Return true if the value is the data representation of a reader conditional", :end-row 7850, :filename "clojure/core.clj", :fixed-arities #{1}, :name "reader-conditional?", :ns "clojure.core", :row 7846} {:arglist-strs ["[form splicing?]"], :doc "Construct a data representation of a reader conditional.\n  If true, splicing? indicates read-cond-splicing.", :end-row 7857, :filename "clojure/core.clj", :fixed-arities #{2}, :name "reader-conditional", :ns "clojure.core", :row 7852} {:doc "Default map of data reader functions provided by Clojure. May be\n  overridden by binding *data-readers*.", :end-row 7870, :filename "clojure/core.clj", :name "default-data-readers", :ns "clojure.core", :row 7864} {:doc "Map from reader tag symbols to data reader Vars.\n\n  When Clojure starts, it searches for files named 'data_readers.clj'\n  and 'data_readers.cljc' at the root of the classpath. Each such file\n  must contain a literal map of symbols, like this:\n\n      {foo/bar my.project.foo/bar\n       foo/baz my.project/baz}\n\n  The first symbol in each pair is a tag that will be recognized by\n  the Clojure reader. The second symbol in the pair is the\n  fully-qualified name of a Var which will be invoked by the reader to\n  parse the form following the tag. For example, given the\n  data_readers.clj file above, the Clojure reader would parse this\n  form:\n\n      #foo/bar [1 2 3]\n\n  by invoking the Var #'my.project.foo/bar on the vector [1 2 3]. The\n  data reader function is invoked on the form AFTER it has been read\n  as a normal Clojure data structure by the reader.\n\n  Reader tags without namespace qualifiers are reserved for\n  Clojure. Default reader tags are defined in\n  clojure.core/default-data-readers but may be overridden in\n  data_readers.clj, data_readers.cljc, or by rebinding this Var.", :end-row 7899, :filename "clojure/core.clj", :name "*data-readers*", :ns "clojure.core", :row 7872} {:doc "When no data reader is found for a tag and *default-data-reader-fn*\n  is non-nil, it will be called with two arguments,\n  the tag and the value.  If *default-data-reader-fn* is nil (the\n  default), an exception will be thrown for the unknown tag.", :end-row 7906, :filename "clojure/core.clj", :name "*default-data-reader-fn*", :ns "clojure.core", :row 7901} {:arglist-strs ["[]"], :end-row 7912, :filename "clojure/core.clj", :fixed-arities #{0}, :name "data-reader-urls", :ns "clojure.core", :private true, :row 7908} {:arglist-strs ["[sym]"], :end-row 7916, :filename "clojure/core.clj", :fixed-arities #{1}, :name "data-reader-var", :ns "clojure.core", :private true, :row 7914} {:arglist-strs ["[mappings url]"], :end-row 7945, :filename "clojure/core.clj", :fixed-arities #{2}, :name "load-data-reader-file", :ns "clojure.core", :private true, :row 7918} {:arglist-strs ["[]"], :end-row 7951, :filename "clojure/core.clj", :fixed-arities #{0}, :name "load-data-readers", :ns "clojure.core", :private true, :row 7947} {:arglist-strs ["[x]"], :doc "Return true if x is a java.net.URI", :end-row 7962, :filename "clojure/core.clj", :fixed-arities #{1}, :name "uri?", :ns "clojure.core", :row 7959} {:end-row 7964, :filename "clojure/core.clj", :name "tapset", :ns "clojure.core", :private true, :row 7964} {:end-row 7965, :filename "clojure/core.clj", :name "tapq", :ns "clojure.core", :private true, :row 7965} {:end-row 7980, :filename "clojure/core.clj", :name "tap-loop", :ns "clojure.core", :private true, :row 7967} {:arglist-strs ["[f]"], :doc "adds f, a fn of one argument, to the tap set. This function will be called with anything sent via tap>.\n  This function may (briefly) block (e.g. for streams), and will never impede calls to tap>,\n  but blocking indefinitely may cause tap values to be dropped.\n  Remember f in order to remove-tap", :end-row 7991, :filename "clojure/core.clj", :fixed-arities #{1}, :name "add-tap", :ns "clojure.core", :row 7982} {:arglist-strs ["[f]"], :doc "Remove f from the tap set.", :end-row 7998, :filename "clojure/core.clj", :fixed-arities #{1}, :name "remove-tap", :ns "clojure.core", :row 7993} {:arglist-strs ["[x]"], :doc "sends x to any taps. Will not block. Returns true if there was room in the queue,\n  false if not (dropped).", :end-row 8006, :filename "clojure/core.clj", :fixed-arities #{1}, :name "tap>", :ns "clojure.core", :row 8000} {:arglist-strs ["[m f]"], :doc "m f => {k (f v) ...}\n\n  Given a map m and a function f of 1-argument, returns a new map where the keys of m\n  are mapped to result of applying f to the corresponding values of m.", :end-row 8022, :filename "clojure/core.clj", :fixed-arities #{2}, :name "update-vals", :ns "clojure.core", :row 8008} {:arglist-strs ["[m f]"], :doc "m f => {(f k) v ...}\n\n  Given a map m and a function f of 1-argument, returns a new map whose\n  keys are the result of applying f to the keys of m, mapped to the\n  corresponding values of m.\n  f must return a unique key for each key of m, else the behavior is undefined.", :end-row 8037, :filename "clojure/core.clj", :fixed-arities #{2}, :name "update-keys", :ns "clojure.core", :row 8024} {:fixed-arities #{1}, :end-row 8042, :private true, :ns "clojure.core", :name "parsing-err", :filename "clojure/core.clj", :arglist-strs ["[val]"], :doc "Construct message for parsing for non-string parsing error", :row 8039} {:arglist-strs ["[s]"], :doc "Parse string of decimal digits with optional leading -/+ and return a\n  Long value, or nil if parse fails", :end-row 8053, :filename "clojure/core.clj", :fixed-arities #{1}, :name "parse-long", :ns "clojure.core", :row 8044} {:arglist-strs ["[s]"], :doc "Parse string with floating point components and return a Double value,\n  or nil if parse fails.\n\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#valueOf-java.lang.String-", :end-row 8066, :filename "clojure/core.clj", :fixed-arities #{1}, :name "parse-double", :ns "clojure.core", :row 8055} {:arglist-strs ["[s]"], :doc "Parse a string representing a UUID and return a java.util.UUID instance,\n  or nil if parse fails.\n\n  Grammar: https://docs.oracle.com/javase/8/docs/api/java/util/UUID.html#toString--", :end-row 8077, :filename "clojure/core.clj", :fixed-arities #{1}, :name "parse-uuid", :ns "clojure.core", :row 8068} {:arglist-strs ["[s]"], :doc "Parse strings \"true\" or \"false\" and return a boolean, or nil if invalid", :end-row 8088, :filename "clojure/core.clj", :fixed-arities #{1}, :name "parse-boolean", :ns "clojure.core", :row 8079} {:arglist-strs ["[num]"], :doc "Returns true if num is NaN, else false", :end-row 8097, :filename "clojure/core.clj", :fixed-arities #{1}, :name "NaN?", :ns "clojure.core", :row 8090} {:arglist-strs ["[num]"], :doc "Returns true if num is negative or positive infinity, else false", :end-row 8105, :filename "clojure/core.clj", :fixed-arities #{1}, :name "infinite?", :ns "clojure.core", :row 8099} {:arglist-strs ["[ns]"], :doc "Convert a Clojure namespace name to a legal Java package name.", :end-row 17, :filename "clojure/core_deftype.clj", :fixed-arities #{1}, :name "namespace-munge", :ns "clojure.core", :row 13} {:arglist-strs ["[name & sigs]"], :doc "Creates a new Java interface with the given name and method sigs.\n  The method return types and parameter types may be specified with type hints,\n  defaulting to Object if omitted.\n\n  (definterface MyInterface\n    (^int method1 [x])\n    (^Bar method2 [^Baz b ^Quux q]))", :end-row 36, :filename "clojure/core_deftype.clj", :macro true, :name "definterface", :ns "clojure.core", :row 20} {:arglist-strs ["[s]"], :end-row 44, :filename "clojure/core_deftype.clj", :fixed-arities #{1}, :name "parse-opts", :ns "clojure.core", :private true, :row 40} {:arglist-strs ["[specs]"], :end-row 51, :filename "clojure/core_deftype.clj", :fixed-arities #{1}, :name "parse-impls", :ns "clojure.core", :private true, :row 46} {:arglist-strs ["[opts+specs]"], :end-row 68, :filename "clojure/core_deftype.clj", :fixed-arities #{1}, :name "parse-opts+specs", :ns "clojure.core", :private true, :row 53} {:arglist-strs ["[& opts+specs]"], :doc "reify creates an object implementing a protocol or interface.\n  reify is a macro with the following structure:\n\n (reify options* specs*)\n  \n  Currently there are no options.\n\n  Each spec consists of the protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args+] body)*\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that the first parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations.  Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  The return type can be indicated by a type hint on the method name,\n  and arg types can be indicated by a type hint on arg names. If you\n  leave out all hints, reify will try to match on same name/arity\n  method in the protocol(s)/interface(s) - this is preferred. If you\n  supply any hints at all, no inference is done, so all hints (or\n  default of Object) must be correct, for both arguments and return\n  type. If a method is overloaded in a protocol/interface, multiple\n  independent method definitions must be supplied.  If overloaded with\n  same arity in an interface you must specify complete hints to\n  disambiguate - a missing hint implies Object.\n\n  recur works to method heads The method bodies of reify are lexical\n  closures, and can refer to the surrounding local scope:\n  \n  (str (let [f \"foo\"] \n       (reify Object \n         (toString [this] f))))\n  == \"foo\"\n\n  (seq (let [f \"foo\"] \n       (reify clojure.lang.Seqable \n         (seq [this] (seq f)))))\n  == (\\f \\o \\o))\n  \n  reify always implements clojure.lang.IObj and transfers meta\n  data of the form to the created object.\n  \n  (meta ^{:k :v} (reify Object (toString [this] \"foo\")))\n  == {:k :v}", :end-row 125, :filename "clojure/core_deftype.clj", :macro true, :name "reify", :ns "clojure.core", :row 70} {:arglist-strs ["[x y]"], :end-row 128, :filename "clojure/core_deftype.clj", :fixed-arities #{2}, :name "hash-combine", :ns "clojure.core", :row 127} {:arglist-strs ["[s]"], :end-row 131, :filename "clojure/core_deftype.clj", :fixed-arities #{1}, :name "munge", :ns "clojure.core", :row 130} {:arglist-strs ["[this o]"], :end-row 147, :filename "clojure/core_deftype.clj", :fixed-arities #{2}, :name "imap-cons", :ns "clojure.core", :private true, :row 133} {:fixed-arities #{6}, :end-row 265, :private true, :ns "clojure.core", :name "emit-defrecord", :filename "clojure/core_deftype.clj", :arglist-strs ["[tagname cname fields interfaces methods opts]"], :doc "Do not use this directly - use defrecord", :row 149} {:fixed-arities #{3}, :end-row 292, :private true, :ns "clojure.core", :name "build-positional-factory", :filename "clojure/core_deftype.clj", :arglist-strs ["[nom classname fields]"], :doc "Used to build a positional factory for a given type/record.  Because of the\n  limitation of 20 arguments to Clojure functions, this factory needs to be\n  constructed to deal with more arguments.  It does this by building a straight\n  forward type/record ctor call in the <=20 case, and a call to the same\n  ctor pulling the extra args out of the & overage parameter.  Finally, the\n  arity is constrained to the number of expected fields and an ArityException\n  will be thrown at runtime if the actual arg count does not match.", :row 267} {:fixed-arities #{2}, :end-row 311, :private true, :ns "clojure.core", :name "validate-fields", :filename "clojure/core_deftype.clj", :arglist-strs ["[fields name]"], :doc "", :row 294} {:arglist-strs ["[name fields & opts+specs]"], :doc "(defrecord name [fields*]  options* specs*)\n\n  Options are expressed as sequential keywords and arguments (in any order).\n\n  Supported options:\n  :load-ns - if true, importing the record class will cause the\n             namespace in which the record was defined to be loaded.\n             Defaults to false.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces.\n\n  The class will have the (immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  The class will have implementations of several (clojure.lang)\n  interfaces generated automatically: IObj (metadata support) and\n  IPersistentMap, and all of their superinterfaces.\n\n  In addition, defrecord will define type-and-value-based =,\n  and will defined Java .hashCode and .equals consistent with the\n  contract for java.util.Map.\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  Two constructors will be defined, one taking the designated fields\n  followed by a metadata map (nil for none) and an extension field\n  map (nil for none), and one taking only the fields (using nil for\n  meta and extension fields). Note that the field names __meta,\n  __extmap, __hash and __hasheq are currently reserved and should not\n  be used when defining your own records.\n\n  Given (defrecord TypeName ...), two factory functions will be\n  defined: ->TypeName, taking positional parameters for the fields,\n  and map->TypeName, taking a map of keywords to field values.", :end-row 404, :filename "clojure/core_deftype.clj", :macro true, :name "defrecord", :ns "clojure.core", :row 313} {:arglist-strs ["[x]"], :doc "Returns true if x is a record", :end-row 411, :filename "clojure/core_deftype.clj", :fixed-arities #{1}, :name "record?", :ns "clojure.core", :row 406} {:fixed-arities #{6}, :end-row 421, :private true, :ns "clojure.core", :name "emit-deftype*", :filename "clojure/core_deftype.clj", :arglist-strs ["[tagname cname fields interfaces methods opts]"], :doc "Do not use this directly - use deftype", :row 413} {:arglist-strs ["[name fields & opts+specs]"], :doc "(deftype name [fields*]  options* specs*)\n\n  Options are expressed as sequential keywords and arguments (in any order).\n\n  Supported options:\n  :load-ns - if true, importing the type class will cause the\n             namespace in which the type was defined to be loaded.\n             Defaults to false.\n\n  Each spec consists of a protocol or interface name followed by zero\n  or more method bodies:\n\n  protocol-or-interface-or-Object\n  (methodName [args*] body)*\n\n  Dynamically generates compiled bytecode for class with the given\n  name, in a package with the same name as the current namespace, the\n  given fields, and, optionally, methods for protocols and/or\n  interfaces. \n\n  The class will have the (by default, immutable) fields named by\n  fields, which can have type hints. Protocols/interfaces and methods\n  are optional. The only methods that can be supplied are those\n  declared in the protocols/interfaces.  Note that method bodies are\n  not closures, the local environment includes only the named fields,\n  and those fields can be accessed directly. Fields can be qualified\n  with the metadata :volatile-mutable true or :unsynchronized-mutable\n  true, at which point (set! afield aval) will be supported in method\n  bodies. Note well that mutable fields are extremely difficult to use\n  correctly, and are present only to facilitate the building of higher\n  level constructs, such as Clojure's reference types, in Clojure\n  itself. They are for experts only - if the semantics and\n  implications of :volatile-mutable or :unsynchronized-mutable are not\n  immediately apparent to you, you should not be using them.\n\n  Method definitions take the form:\n\n  (methodname [args*] body)\n\n  The argument and return types can be hinted on the arg and\n  methodname symbols. If not supplied, they will be inferred, so type\n  hints should be reserved for disambiguation.\n\n  Methods should be supplied for all methods of the desired\n  protocol(s) and interface(s). You can also define overrides for\n  methods of Object. Note that a parameter must be supplied to\n  correspond to the target object ('this' in Java parlance). Thus\n  methods for interfaces will take one more argument than do the\n  interface declarations. Note also that recur calls to the method\n  head should *not* pass the target object, it will be supplied\n  automatically and can not be substituted.\n\n  In the method bodies, the (unqualified) name can be used to name the\n  class (for calls to new, instance? etc).\n\n  When AOT compiling, generates compiled bytecode for a class with the\n  given name (a symbol), prepends the current ns as the package, and\n  writes the .class file to the *compile-path* directory.\n\n  One constructor will be defined, taking the designated fields.  Note\n  that the field names __meta, __extmap, __hash and __hasheq are currently\n  reserved and should not be used when defining your own types.\n\n  Given (deftype TypeName ...), a factory function called ->TypeName\n  will be defined, taking positional parameters for the fields", :end-row 505, :filename "clojure/core_deftype.clj", :macro true, :name "deftype", :ns "clojure.core", :row 423} {:arglist-strs ["[cache c f]"], :end-row 524, :filename "clojure/core_deftype.clj", :fixed-arities #{3}, :name "expand-method-impl-cache", :ns "clojure.core", :private true, :row 509} {:arglist-strs ["[c]"], :end-row 528, :filename "clojure/core_deftype.clj", :fixed-arities #{1}, :name "super-chain", :ns "clojure.core", :private true, :row 526} {:arglist-strs ["[]" "[a]" "[a b]"], :end-row 534, :filename "clojure/core_deftype.clj", :fixed-arities #{0 1 2}, :name "pref", :ns "clojure.core", :private true, :row 530} {:arglist-strs ["[protocol x]"], :end-row 545, :filename "clojure/core_deftype.clj", :fixed-arities #{2}, :name "find-protocol-impl", :ns "clojure.core", :row 536} {:arglist-strs ["[protocol methodk x]"], :end-row 548, :filename "clojure/core_deftype.clj", :fixed-arities #{3}, :name "find-protocol-method", :ns "clojure.core", :row 547} {:arglist-strs ["[maybe-p]"], :end-row 552, :filename "clojure/core_deftype.clj", :fixed-arities #{1}, :name "protocol?", :ns "clojure.core", :private true, :row 550} {:arglist-strs ["[protocol atype]"], :end-row 555, :filename "clojure/core_deftype.clj", :fixed-arities #{2}, :name "implements?", :ns "clojure.core", :private true, :row 554} {:arglist-strs ["[protocol atype]"], :doc "Returns true if atype extends protocol", :end-row 562, :filename "clojure/core_deftype.clj", :fixed-arities #{2}, :name "extends?", :ns "clojure.core", :row 557} {:arglist-strs ["[protocol]"], :doc "Returns a collection of the types explicitly extending protocol", :end-row 568, :filename "clojure/core_deftype.clj", :fixed-arities #{1}, :name "extenders", :ns "clojure.core", :row 564} {:arglist-strs ["[protocol x]"], :doc "Returns true if x satisfies the protocol", :end-row 574, :filename "clojure/core_deftype.clj", :fixed-arities #{2}, :name "satisfies?", :ns "clojure.core", :row 570} {:arglist-strs ["[pf x c interf]"], :end-row 586, :filename "clojure/core_deftype.clj", :fixed-arities #{4}, :name "-cache-protocol-fn", :ns "clojure.core", :row 576} {:arglist-strs ["[on-interface method on-method arglists extend-via-meta]"], :end-row 627, :filename "clojure/core_deftype.clj", :fixed-arities #{5}, :name "emit-method-builder", :ns "clojure.core", :private true, :row 588} {:arglist-strs ["[protocol]"], :end-row 632, :filename "clojure/core_deftype.clj", :fixed-arities #{1}, :name "-reset-methods", :ns "clojure.core", :row 629} {:arglist-strs ["[protocol-var method-syms]"], :end-row 643, :filename "clojure/core_deftype.clj", :fixed-arities #{2}, :name "assert-same-protocol", :ns "clojure.core", :private true, :row 634} {:arglist-strs ["[name opts+sigs]"], :end-row 711, :filename "clojure/core_deftype.clj", :fixed-arities #{2}, :name "emit-protocol", :ns "clojure.core", :private true, :row 645} {:arglist-strs ["[name & opts+sigs]"], :doc "A protocol is a named set of named methods and their signatures:\n  (defprotocol AProtocolName\n\n    ;optional doc string\n    \"A doc string for AProtocol abstraction\"\n\n   ;options\n   :extend-via-metadata true\n\n  ;method signatures\n    (bar [this a b] \"bar docs\")\n    (baz [this a] [this a b] [this a b c] \"baz docs\"))\n\n  No implementations are provided. Docs can be specified for the\n  protocol overall and for each method. The above yields a set of\n  polymorphic functions and a protocol object. All are\n  namespace-qualified by the ns enclosing the definition The resulting\n  functions dispatch on the type of their first argument, which is\n  required and corresponds to the implicit target object ('this' in \n  Java parlance). defprotocol is dynamic, has no special compile-time \n  effect, and defines no new types or classes. Implementations of \n  the protocol methods can be provided using extend.\n\n  When :extend-via-metadata is true, values can extend protocols by\n  adding metadata where keys are fully-qualified protocol function\n  symbols and values are function implementations. Protocol\n  implementations are checked first for direct definitions (defrecord,\n  deftype, reify), then metadata definitions, then external\n  extensions (extend, extend-type, extend-protocol)\n\n  defprotocol will automatically generate a corresponding interface,\n  with the same name as the protocol, i.e. given a protocol:\n  my.ns/Protocol, an interface: my.ns.Protocol. The interface will\n  have methods corresponding to the protocol functions, and the\n  protocol will automatically work with instances of the interface.\n\n  Note that you should not use this interface with deftype or\n  reify, as they support the protocol directly:\n\n  (defprotocol P \n    (foo [this]) \n    (bar-me [this] [this y]))\n\n  (deftype Foo [a b c] \n   P\n    (foo [this] a)\n    (bar-me [this] b)\n    (bar-me [this y] (+ c y)))\n  \n  (bar-me (Foo. 1 2 3) 42)\n  => 45\n\n  (foo \n    (let [x 42]\n      (reify P \n        (foo [this] 17)\n        (bar-me [this] x)\n        (bar-me [this y] x))))\n  => 17", :end-row 775, :filename "clojure/core_deftype.clj", :macro true, :name "defprotocol", :ns "clojure.core", :row 713} {:arglist-strs ["[atype & proto+mmaps]"], :doc "Implementations of protocol methods can be provided using the extend construct:\n\n  (extend AType\n    AProtocol\n     {:foo an-existing-fn\n      :bar (fn [a b] ...)\n      :baz (fn ([a]...) ([a b] ...)...)}\n    BProtocol \n      {...} \n    ...)\n \n  extend takes a type/class (or interface, see below), and one or more\n  protocol + method map pairs. It will extend the polymorphism of the\n  protocol's methods to call the supplied methods when an AType is\n  provided as the first argument. \n\n  Method maps are maps of the keyword-ized method names to ordinary\n  fns. This facilitates easy reuse of existing fns and fn maps, for\n  code reuse/mixins without derivation or composition. You can extend\n  an interface to a protocol. This is primarily to facilitate interop\n  with the host (e.g. Java) but opens the door to incidental multiple\n  inheritance of implementation since a class can inherit from more\n  than one interface, both of which extend the protocol. It is TBD how\n  to specify which impl to use. You can extend a protocol on nil.\n\n  If you are supplying the definitions explicitly (i.e. not reusing\n  exsting functions or mixin maps), you may find it more convenient to\n  use the extend-type or extend-protocol macros.\n\n  Note that multiple independent extend clauses can exist for the same\n  type, not all protocols need be defined in a single extend call.\n\n  See also:\n  extends?, satisfies?, extenders", :end-row 822, :filename "clojure/core_deftype.clj", :name "extend", :ns "clojure.core", :row 777} {:arglist-strs ["[[p fs]]"], :end-row 826, :filename "clojure/core_deftype.clj", :fixed-arities #{1}, :name "emit-impl", :ns "clojure.core", :private true, :row 824} {:arglist-strs ["[c [p fs]]"], :end-row 838, :filename "clojure/core_deftype.clj", :fixed-arities #{2}, :name "emit-hinted-impl", :ns "clojure.core", :private true, :row 828} {:arglist-strs ["[c specs]"], :end-row 843, :filename "clojure/core_deftype.clj", :fixed-arities #{2}, :name "emit-extend-type", :ns "clojure.core", :private true, :row 840} {:arglist-strs ["[t & specs]"], :doc "A macro that expands into an extend call. Useful when you are\n  supplying the definitions explicitly inline, extend-type\n  automatically creates the maps required by extend.  Propagates the\n  class as a type hint on the first argument of all fns.\n\n  (extend-type MyType \n    Countable\n      (cnt [c] ...)\n    Foo\n      (bar [x y] ...)\n      (baz ([x] ...) ([x y & zs] ...)))\n\n  expands into:\n\n  (extend MyType\n   Countable\n     {:cnt (fn [c] ...)}\n   Foo\n     {:baz (fn ([x] ...) ([x y & zs] ...))\n      :bar (fn [x y] ...)})", :end-row 868, :filename "clojure/core_deftype.clj", :macro true, :name "extend-type", :ns "clojure.core", :row 845} {:arglist-strs ["[p specs]"], :end-row 875, :filename "clojure/core_deftype.clj", :fixed-arities #{2}, :name "emit-extend-protocol", :ns "clojure.core", :private true, :row 870} {:arglist-strs ["[p & specs]"], :doc "Useful when you want to provide several implementations of the same\n  protocol all at once. Takes a single protocol and the implementation\n  of that protocol for one or more types. Expands into calls to\n  extend-type:\n\n  (extend-protocol Protocol\n    AType\n      (foo [x] ...)\n      (bar [x y] ...)\n    BType\n      (foo [x] ...)\n      (bar [x y] ...)\n    AClass\n      (foo [x] ...)\n      (bar [x y] ...)\n    nil\n      (foo [x] ...)\n      (bar [x y] ...))\n\n  expands into:\n\n  (do\n   (clojure.core/extend-type AType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type BType Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type AClass Protocol \n     (foo [x] ...) \n     (bar [x y] ...))\n   (clojure.core/extend-type nil Protocol \n     (foo [x] ...) \n     (bar [x y] ...)))", :end-row 915, :filename "clojure/core_deftype.clj", :macro true, :name "extend-protocol", :ns "clojure.core", :row 877} {:arglist-strs ["[meth]"], :end-row 21, :filename "clojure/core_proxy.clj", :fixed-arities #{1}, :name "method-sig", :ns "clojure.core", :row 20} {:arglist-strs ["[rtypes]"], :end-row 25, :filename "clojure/core_proxy.clj", :fixed-arities #{1}, :name "most-specific", :ns "clojure.core", :private true, :row 23} {:fixed-arities #{1}, :end-row 35, :private true, :ns "clojure.core", :name "group-by-sig", :filename "clojure/core_proxy.clj", :arglist-strs ["[coll]"], :doc "Takes a collection of [msig meth] and returns a seq of maps from\n   return-types to meths.", :row 27} {:arglist-strs ["[super interfaces]"], :end-row 46, :filename "clojure/core_proxy.clj", :fixed-arities #{2}, :name "proxy-name", :ns "clojure.core", :row 37} {:arglist-strs ["[super interfaces]"], :end-row 274, :filename "clojure/core_proxy.clj", :fixed-arities #{2}, :name "generate-proxy", :ns "clojure.core", :private true, :row 48} {:arglist-strs ["[bases]"], :end-row 279, :filename "clojure/core_proxy.clj", :fixed-arities #{1}, :name "get-super-and-interfaces", :ns "clojure.core", :private true, :row 276} {:arglist-strs ["[& bases]"], :doc "Takes an optional single class followed by zero or more\n  interfaces. If not supplied class defaults to Object.  Creates an\n  returns an instance of a proxy class derived from the supplied\n  classes. The resulting value is cached and used for any subsequent\n  requests for the same class set. Returns a Class object.", :end-row 293, :filename "clojure/core_proxy.clj", :name "get-proxy-class", :ns "clojure.core", :row 281} {:arglist-strs ["[c & ctor-args]"], :doc "Takes a proxy class and any arguments for its superclass ctor and\n  creates and returns an instance of the proxy.", :end-row 300, :filename "clojure/core_proxy.clj", :name "construct-proxy", :ns "clojure.core", :row 295} {:arglist-strs ["[proxy mappings]"], :doc "Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  sets the proxy's fn map.  Returns the proxy.", :end-row 311, :filename "clojure/core_proxy.clj", :fixed-arities #{2}, :name "init-proxy", :ns "clojure.core", :row 302} {:arglist-strs ["[proxy mappings]"], :doc "Takes a proxy instance and a map of strings (which must\n  correspond to methods of the proxy superclass/superinterfaces) to\n  fns (which must take arguments matching the corresponding method,\n  plus an additional (explicit) first arg corresponding to this, and\n  updates (via assoc) the proxy's fn map. nil can be passed instead of\n  a fn, in which case the corresponding method will revert to the\n  default behavior. Note that this function can be used to update the\n  behavior of an existing instance without changing its identity.\n  Returns the proxy.", :end-row 326, :filename "clojure/core_proxy.clj", :fixed-arities #{2}, :name "update-proxy", :ns "clojure.core", :row 313} {:arglist-strs ["[proxy]"], :doc "Takes a proxy instance and returns the proxy's fn map.", :end-row 332, :filename "clojure/core_proxy.clj", :fixed-arities #{1}, :name "proxy-mappings", :ns "clojure.core", :row 328} {:arglist-strs ["[class-and-interfaces args & fs]"], :doc "class-and-interfaces - a vector of class names\n\n  args - a (possibly empty) vector of arguments to the superclass\n  constructor.\n\n  f => (name [params*] body) or\n  (name ([params*] body) ([params+] body) ...)\n\n  Expands to code which creates a instance of a proxy class that\n  implements the named class/interface(s) by calling the supplied\n  fns. A single class, if provided, must be first. If not provided it\n  defaults to Object.\n\n  The interfaces names must be valid interface types. If a method fn\n  is not provided for a class method, the superclass method will be\n  called. If a method fn is not provided for an interface method, an\n  UnsupportedOperationException will be thrown should it be\n  called. Method fns are closures and can capture the environment in\n  which proxy is called. Each method fn takes an additional implicit\n  first arg, which is bound to 'this. Note that while method fns can\n  be provided to override protected methods, they have no other access\n  to protected members, nor to super, as these capabilities cannot be\n  proxied.", :end-row 387, :filename "clojure/core_proxy.clj", :macro true, :name "proxy", :ns "clojure.core", :row 334} {:arglist-strs ["[call this meth]"], :end-row 394, :filename "clojure/core_proxy.clj", :fixed-arities #{3}, :name "proxy-call-with-super", :ns "clojure.core", :row 389} {:arglist-strs ["[meth & args]"], :doc "Use to call a superclass method in the body of a proxy method. \n  Note, expansion captures 'this", :end-row 401, :filename "clojure/core_proxy.clj", :macro true, :name "proxy-super", :ns "clojure.core", :row 396} {:arglist-strs ["[x]"], :doc "Takes a Java object and returns a read-only implementation of the\n  map abstraction based upon its JavaBean properties.", :end-row 440, :filename "clojure/core_proxy.clj", :fixed-arities #{1}, :name "bean", :ns "clojure.core", :row 403} {:doc "*print-length* controls how many items of each collection the\n  printer will print. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  number of items of each collection to print. If a collection contains\n  more items, the printer will print items up to the limit followed by\n  '...' to represent the remaining items. The root binding is nil\n  indicating no limit.", :end-row 25, :filename "clojure/core_print.clj", :name "*print-length*", :ns "clojure.core", :row 16} {:doc "*print-level* controls how many levels deep the printer will\n  print nested objects. If it is bound to logical false, there is no\n  limit. Otherwise, it must be bound to an integer indicating the maximum\n  level to print. Each argument to print is at level 0; if an argument is a\n  collection, its items are at level 1; and so on. If an object is a\n  collection and is at a level greater than or equal to the value bound to\n  *print-level*, the printer prints '#' to represent it. The root binding\n  is nil indicating no limit.", :end-row 37, :filename "clojure/core_print.clj", :name "*print-level*", :ns "clojure.core", :row 27} {:end-row 39, :filename "clojure/core_print.clj", :name "*verbose-defrecords*", :ns "clojure.core", :row 39} {:doc "*print-namespace-maps* controls whether the printer will print\n  namespace map literal syntax. It defaults to false, but the REPL binds\n  to true.", :end-row 46, :filename "clojure/core_print.clj", :name "*print-namespace-maps*", :ns "clojure.core", :row 41} {:arglist-strs ["[begin print-one sep end sequence w]"], :end-row 70, :filename "clojure/core_print.clj", :fixed-arities #{6}, :name "print-sequential", :ns "clojure.core", :private true, :row 48} {:arglist-strs ["[o w]"], :end-row 81, :filename "clojure/core_print.clj", :fixed-arities #{2}, :name "print-meta", :ns "clojure.core", :private true, :row 72} {:arglist-strs ["[o w]"], :end-row 85, :filename "clojure/core_print.clj", :fixed-arities #{2}, :name "print-simple", :ns "clojure.core", :row 83} {:arglist-strs ["[o print-args w]"], :end-row 102, :filename "clojure/core_print.clj", :fixed-arities #{3}, :name "print-ctor", :ns "clojure.core", :row 97} {:arglist-strs ["[o rep w]"], :end-row 115, :filename "clojure/core_print.clj", :fixed-arities #{3}, :name "print-tagged-object", :ns "clojure.core", :private true, :row 104} {:arglist-strs ["[o w]"], :end-row 118, :filename "clojure/core_print.clj", :fixed-arities #{2}, :name "print-object", :ns "clojure.core", :private true, :row 117} {:doc "Returns escape string for char or nil if none", :end-row 210, :filename "clojure/core_print.clj", :name "char-escape-string", :ns "clojure.core", :row 200} {:arglist-strs ["[prefix kvs print-one w]"], :end-row 236, :filename "clojure/core_print.clj", :fixed-arities #{4}, :name "print-prefix-map", :ns "clojure.core", :private true, :row 229} {:arglist-strs ["[m print-one w]"], :end-row 239, :filename "clojure/core_print.clj", :fixed-arities #{3}, :name "print-map", :ns "clojure.core", :private true, :row 238} {:arglist-strs ["[named]"], :end-row 245, :filename "clojure/core_print.clj", :fixed-arities #{1}, :name "strip-ns", :ns "clojure.core", :private true, :row 241} {:fixed-arities #{1}, :end-row 261, :private true, :ns "clojure.core", :name "lift-ns", :filename "clojure/core_print.clj", :arglist-strs ["[m]"], :doc "Returns [lifted-ns lifted-kvs] or nil if m can't be lifted.", :row 247} {:doc "Returns name string for char or nil if none", :end-row 351, :filename "clojure/core_print.clj", :name "char-name-string", :ns "clojure.core", :row 342} {:end-row 380, :filename "clojure/core_print.clj", :name "primitives-classnames", :ns "clojure.core", :row 372} {:arglist-strs ["[o]"], :end-row 457, :filename "clojure/core_print.clj", :fixed-arities #{1}, :name "deref-as-map", :ns "clojure.core", :private true, :row 436} {:arglist-strs ["[o]"], :doc "Constructs a data representation for a StackTraceElement: [class method file line]", :end-row 469, :filename "clojure/core_print.clj", :fixed-arities #{1}, :name "StackTraceElement->vec", :ns "clojure.core", :row 465} {:arglist-strs ["[o]"], :doc "Constructs a data representation for a Throwable with keys:\n    :cause - root cause message\n    :phase - error phase\n    :via - cause chain, with cause keys:\n             :type - exception class symbol\n             :message - exception message\n             :data - ex-data\n             :at - top stack element\n    :trace - root cause stack elements", :end-row 505, :filename "clojure/core_print.clj", :fixed-arities #{1}, :name "Throwable->map", :ns "clojure.core", :row 471} {:arglist-strs ["[o w]"], :end-row 541, :filename "clojure/core_print.clj", :fixed-arities #{2}, :name "print-throwable", :ns "clojure.core", :private true, :row 507} {:end-row 557, :filename "clojure/core_print.clj", :name "print-initialized", :ns "clojure.core", :private true, :row 557} {:arglist-strs ["[flush-fn close-fn]"], :doc "implements java.io.PrintWriter given flush-fn, which will be called\n  when .flush() is called, with a string built up since the last call to .flush().\n  if not nil, close-fn will be called with no arguments when .close is called", :end-row 581, :filename "clojure/core_print.clj", :fixed-arities #{2}, :name "PrintWriter-on", :ns "clojure.core", :row 559} {:end-row 18, :filename "clojure/gvec.clj", :name "VecNode", :ns "clojure.core", :row 18} {:arglist-strs ["[edit arr]"], :end-row 18, :filename "clojure/gvec.clj", :fixed-arities #{2}, :name "->VecNode", :ns "clojure.core", :row 18} {:end-row 20, :filename "clojure/gvec.clj", :name "EMPTY-NODE", :ns "clojure.core", :row 20} {:end-row 28, :filename "clojure/gvec.clj", :name "IVecImpl", :ns "clojure.core", :row 22} {:arglist-strs ["[]"], :end-row 23, :filename "clojure/gvec.clj", :fixed-arities #{0}, :name "tailoff", :ns "clojure.core", :row 23} {:arglist-strs ["[i]"], :end-row 24, :filename "clojure/gvec.clj", :fixed-arities #{1}, :name "arrayFor", :ns "clojure.core", :row 24} {:arglist-strs ["[level parent tailnode]"], :end-row 25, :filename "clojure/gvec.clj", :fixed-arities #{3}, :name "pushTail", :ns "clojure.core", :row 25} {:arglist-strs ["[level node]"], :end-row 26, :filename "clojure/gvec.clj", :fixed-arities #{2}, :name "popTail", :ns "clojure.core", :row 26} {:arglist-strs ["[edit level node]"], :end-row 27, :filename "clojure/gvec.clj", :fixed-arities #{3}, :name "newPath", :ns "clojure.core", :row 27} {:arglist-strs ["[level node i val]"], :end-row 28, :filename "clojure/gvec.clj", :fixed-arities #{4}, :name "doAssoc", :ns "clojure.core", :row 28} {:end-row 35, :filename "clojure/gvec.clj", :name "ArrayManager", :ns "clojure.core", :row 30} {:arglist-strs ["[size]"], :end-row 31, :filename "clojure/gvec.clj", :fixed-arities #{1}, :name "array", :ns "clojure.core", :row 31} {:arglist-strs ["[arr]"], :end-row 32, :filename "clojure/gvec.clj", :fixed-arities #{1}, :name "alength", :ns "clojure.core", :row 32} {:arglist-strs ["[arr]"], :end-row 33, :filename "clojure/gvec.clj", :fixed-arities #{1}, :name "aclone", :ns "clojure.core", :row 33} {:arglist-strs ["[arr i]"], :end-row 34, :filename "clojure/gvec.clj", :fixed-arities #{2}, :name "aget", :ns "clojure.core", :row 34} {:arglist-strs ["[arr i val]"], :end-row 35, :filename "clojure/gvec.clj", :fixed-arities #{3}, :name "aset", :ns "clojure.core", :row 35} {:end-row 57, :filename "clojure/gvec.clj", :name "ArrayChunk", :ns "clojure.core", :row 37} {:arglist-strs ["[am arr off end]"], :end-row 57, :filename "clojure/gvec.clj", :fixed-arities #{4}, :name "->ArrayChunk", :ns "clojure.core", :row 37} {:end-row 165, :filename "clojure/gvec.clj", :name "VecSeq", :ns "clojure.core", :row 59} {:arglist-strs ["[am vec anode i offset _meta]"], :end-row 165, :filename "clojure/gvec.clj", :fixed-arities #{6}, :name "->VecSeq", :ns "clojure.core", :row 59} {:end-row 492, :filename "clojure/gvec.clj", :name "Vec", :ns "clojure.core", :row 170} {:arglist-strs ["[am cnt shift root tail _meta]"], :end-row 492, :filename "clojure/gvec.clj", :fixed-arities #{6}, :name "->Vec", :ns "clojure.core", :row 170} {:fixed-arities #{1}, :end-row 505, :private true, :ns "clojure.core", :name "mk-am", :filename "clojure/gvec.clj", :macro true, :arglist-strs ["[t]"], :row 497} {:end-row 515, :filename "clojure/gvec.clj", :name "ams", :ns "clojure.core", :private true, :row 507} {:fixed-arities #{1}, :end-row 521, :private true, :ns "clojure.core", :name "ams-check", :filename "clojure/gvec.clj", :macro true, :arglist-strs ["[t]"], :row 517} {:arglist-strs ["[t]" "[t x1]" "[t x1 x2]" "[t x1 x2 x3]" "[t x1 x2 x3 x4]" "[t x1 x2 x3 x4 & xn]"], :doc "Creates a new vector of a single primitive type t, where t is one\n  of :int :long :float :double :byte :short :char or :boolean. The\n  resulting vector complies with the interface of vectors in general,\n  but stores the values unboxed internally.\n\n  Optionally takes one or more elements to populate the vector.", :end-row 566, :filename "clojure/gvec.clj", :fixed-arities #{1 4 3 2 5}, :name "vector-of", :ns "clojure.core", :row 523}]} {:end-row 11, :filename "clojure/instant.clj", :name "clojure.instant", :row 9, :ns nil, :var-definitions [{:fixed-arities #{1}, :end-row 21, :private true, :ns "clojure.instant", :name "fail", :filename "clojure/instant.clj", :macro true, :arglist-strs ["[msg]"], :row 19} {:fixed-arities #{1 2}, :end-row 25, :private true, :ns "clojure.instant", :name "verify", :filename "clojure/instant.clj", :macro true, :arglist-strs ["[test msg]" "[test]"], :row 23} {:arglist-strs ["[num div]"], :end-row 29, :filename "clojure/instant.clj", :fixed-arities #{2}, :name "divisible?", :ns "clojure.instant", :private true, :row 27} {:arglist-strs ["[num div]"], :end-row 33, :filename "clojure/instant.clj", :fixed-arities #{2}, :name "indivisible?", :ns "clojure.instant", :private true, :row 31} {:arglist-strs ["[s]"], :end-row 40, :filename "clojure/instant.clj", :fixed-arities #{1}, :name "parse-int", :ns "clojure.instant", :private true, :row 39} {:arglist-strs ["[s width]"], :end-row 48, :filename "clojure/instant.clj", :fixed-arities #{2}, :name "zero-fill-right", :ns "clojure.instant", :private true, :row 42} {:end-row 51, :filename "clojure/instant.clj", :name "timestamp", :ns "clojure.instant", :private true, :row 50} {:arglist-strs ["[new-instant cs]"], :doc "Parse a string containing an RFC3339-like like timestamp.\n\nThe function new-instant is called with the following arguments.\n\n                min  max           default\n                ---  ------------  -------\n  years          0           9999      N/A (s must provide years)\n  months         1             12        1\n  days           1             31        1 (actual max days depends\n  hours          0             23        0  on month and year)\n  minutes        0             59        0\n  seconds        0             60        0 (though 60 is only valid\n  nanoseconds    0      999999999        0  when minutes is 59)\n  offset-sign   -1              1        0\n  offset-hours   0             23        0\n  offset-minutes 0             59        0\n\nThese are all integers and will be non-nil. (The listed defaults\nwill be passed if the corresponding field is not present in s.)\n\nGrammar (of s):\n\n  date-fullyear   = 4DIGIT\n  date-month      = 2DIGIT  ; 01-12\n  date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on\n                            ; month/year\n  time-hour       = 2DIGIT  ; 00-23\n  time-minute     = 2DIGIT  ; 00-59\n  time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second\n                            ; rules\n  time-secfrac    = '.' 1*DIGIT\n  time-numoffset  = ('+' / '-') time-hour ':' time-minute\n  time-offset     = 'Z' / time-numoffset\n\n  time-part       = time-hour [ ':' time-minute [ ':' time-second\n                    [time-secfrac] [time-offset] ] ]\n\n  timestamp       = date-year [ '-' date-month [ '-' date-mday\n                    [ 'T' time-part ] ] ]\n\nUnlike RFC3339:\n\n  - we only parse the timestamp format\n  - timestamp can elide trailing components\n  - time-offset is optional (defaults to +00:00)\n\nThough time-offset is syntactically optional, a missing time-offset\nwill be treated as if the time-offset zero (+00:00) had been\nspecified.\n", :end-row 121, :filename "clojure/instant.clj", :fixed-arities #{2}, :name "parse-timestamp", :ns "clojure.instant", :row 53} {:arglist-strs ["[year]"], :end-row 131, :filename "clojure/instant.clj", :fixed-arities #{1}, :name "leap-year?", :ns "clojure.instant", :private true, :row 127} {:end-row 137, :filename "clojure/instant.clj", :name "days-in-month", :ns "clojure.instant", :private true, :row 133} {:arglist-strs ["[new-instance]"], :doc "Return a function which constructs an instant by calling constructor\nafter first validating that those arguments are in range and otherwise\nplausible. The resulting function will throw an exception if called\nwith invalid arguments.", :end-row 157, :filename "clojure/instant.clj", :fixed-arities #{1}, :name "validated", :ns "clojure.instant", :row 139} {:end-row 170, :filename "clojure/instant.clj", :name "thread-local-utc-date-format", :ns "clojure.instant", :private true, :row 163} {:fixed-arities #{2}, :end-row 178, :private true, :ns "clojure.instant", :name "print-date", :filename "clojure/instant.clj", :arglist-strs ["[d w]"], :doc "Print a java.util.Date as RFC3339 timestamp, always in UTC.", :row 172} {:fixed-arities #{2}, :end-row 198, :private true, :ns "clojure.instant", :name "print-calendar", :filename "clojure/instant.clj", :arglist-strs ["[c w]"], :doc "Print a java.util.Calendar as RFC3339 timestamp, preserving timezone.", :row 188} {:end-row 215, :filename "clojure/instant.clj", :name "thread-local-utc-timestamp-format", :ns "clojure.instant", :private true, :row 209} {:fixed-arities #{2}, :end-row 226, :private true, :ns "clojure.instant", :name "print-timestamp", :filename "clojure/instant.clj", :arglist-strs ["[ts w]"], :doc "Print a java.sql.Timestamp as RFC3339 timestamp, always in UTC.", :row 217} {:fixed-arities #{10}, :end-row 251, :private true, :ns "clojure.instant", :name "construct-calendar", :filename "clojure/instant.clj", :arglist-strs ["[years months days hours minutes seconds nanoseconds offset-sign offset-hours offset-minutes]"], :doc "Construct a java.util.Calendar, preserving the timezone\noffset, but truncating the subsecond fraction to milliseconds.", :row 240} {:fixed-arities #{10}, :end-row 260, :private true, :ns "clojure.instant", :name "construct-date", :filename "clojure/instant.clj", :arglist-strs ["[years months days hours minutes seconds nanoseconds offset-sign offset-hours offset-minutes]"], :doc "Construct a java.util.Date, which expresses the original instant as\nmilliseconds since the epoch, UTC.", :row 253} {:fixed-arities #{10}, :end-row 272, :private true, :ns "clojure.instant", :name "construct-timestamp", :filename "clojure/instant.clj", :arglist-strs ["[years months days hours minutes seconds nanoseconds offset-sign offset-hours offset-minutes]"], :doc "Construct a java.sql.Timestamp, which has nanosecond precision.", :row 262} {:arglist-strs ["[cs]"], :doc "To read an instant as a java.util.Date, bind *data-readers* to a map with\nthis var as the value for the 'inst key. The timezone offset will be used\nto convert into UTC.", :end-row 279, :filename "clojure/instant.clj", :fixed-arities #{1}, :name "read-instant-date", :ns "clojure.instant", :row 274} {:arglist-strs ["[cs]"], :doc "To read an instant as a java.util.Calendar, bind *data-readers* to a map with\nthis var as the value for the 'inst key.  Calendar preserves the timezone\noffset.", :end-row 286, :filename "clojure/instant.clj", :fixed-arities #{1}, :name "read-instant-calendar", :ns "clojure.instant", :row 281} {:arglist-strs ["[cs]"], :doc "To read an instant as a java.sql.Timestamp, bind *data-readers* to a\nmap with this var as the value for the 'inst key. Timestamp preserves\nfractional seconds with nanosecond precision. The timezone offset will\nbe used to convert into UTC.", :end-row 294, :filename "clojure/instant.clj", :fixed-arities #{1}, :name "read-instant-timestamp", :ns "clojure.instant", :row 288}]} {:end-row 9, :filename "clojure/uuid.clj", :name "clojure.uuid", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[form]"], :end-row 13, :filename "clojure/uuid.clj", :fixed-arities #{1}, :name "default-uuid-reader", :ns "clojure.uuid", :private true, :row 11}]} {:author "Christophe Grand", :doc "Start a web browser from Clojure", :end-row 17, :filename "clojure/java/browse.clj", :name "clojure.java.browse", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[]"], :end-row 21, :filename "clojure/java/browse.clj", :fixed-arities #{0}, :name "macosx?", :ns "clojure.java.browse", :private true, :row 19} {:arglist-strs ["[]"], :end-row 29, :filename "clojure/java/browse.clj", :fixed-arities #{0}, :name "xdg-open-loc", :ns "clojure.java.browse", :private true, :row 23} {:arglist-strs ["[]"], :end-row 34, :filename "clojure/java/browse.clj", :fixed-arities #{0}, :name "open-url-script-val", :ns "clojure.java.browse", :private true, :row 31} {:end-row 42, :filename "clojure/java/browse.clj", :name "*open-url-script*", :ns "clojure.java.browse", :row 42} {:fixed-arities #{1}, :end-row 57, :private true, :ns "clojure.java.browse", :name "open-url-in-browser", :filename "clojure/java/browse.clj", :arglist-strs ["[url]"], :doc "Opens url (a string) in the default system web browser.  May not\n  work on all platforms.  Returns url on success, nil if not\n  supported.", :row 44} {:fixed-arities #{1}, :end-row 66, :private true, :ns "clojure.java.browse", :name "open-url-in-swing", :filename "clojure/java/browse.clj", :arglist-strs ["[url]"], :doc "Opens url (a string) in a Swing window.", :row 59} {:arglist-strs ["[url]"], :doc "Open url in a browser", :end-row 88, :filename "clojure/java/browse.clj", :fixed-arities #{1}, :name "browse-url", :ns "clojure.java.browse", :row 68}]} {:author "Christophe Grand", :doc "Helper namespace for clojure.java.browse.\n            Prevents console apps from becoming GUI unnecessarily.", :end-row 13, :filename "clojure/java/browse_ui.clj", :name "clojure.java.browse-ui", :row 9, :ns nil, :var-definitions [{:arglist-strs ["[url]"], :end-row 29, :filename "clojure/java/browse_ui.clj", :fixed-arities #{1}, :name "open-url-in-swing", :ns "clojure.java.browse-ui", :private true, :row 15}]} {:author "Stuart Sierra, Chas Emerick, Stuart Halloway", :doc "This file defines polymorphic I/O utility functions for Clojure.", :end-row 22, :filename "clojure/java/io.clj", :name "clojure.java.io", :row 9, :ns nil, :var-definitions [{:doc "Type object for a Java primitive byte array.", :end-row 28, :filename "clojure/java/io.clj", :name "byte-array-type", :ns "clojure.java.io", :private true, :row 24} {:doc "Type object for a Java primitive char array.", :end-row 33, :filename "clojure/java/io.clj", :name "char-array-type", :ns "clojure.java.io", :private true, :row 30} {:doc "Coerce between various 'resource-namish' things.", :end-row 38, :filename "clojure/java/io.clj", :name "Coercions", :ns "clojure.java.io", :row 35} {:arglist-strs ["[x]"], :doc "Coerce argument to a file.", :end-row 37, :filename "clojure/java/io.clj", :fixed-arities #{1}, :name "as-file", :ns "clojure.java.io", :row 37} {:arglist-strs ["[x]"], :doc "Coerce argument to a URL.", :end-row 38, :filename "clojure/java/io.clj", :fixed-arities #{1}, :name "as-url", :ns "clojure.java.io", :row 38} {:arglist-strs ["[s]"], :end-row 42, :filename "clojure/java/io.clj", :fixed-arities #{1}, :name "escaped-utf8-urlstring->str", :ns "clojure.java.io", :private true, :row 40} {:doc "Factory functions that create ready-to-use, buffered versions of\n   the various Java I/O stream types, on top of anything that can\n   be unequivocally converted to the requested kind of stream.\n\n   Common options include\n   \n     :append    true to open stream in append mode\n     :encoding  string name of encoding to use, e.g. \"UTF-8\".\n\n   Callers should generally prefer the higher level API provided by\n   reader, writer, input-stream, and output-stream.", :end-row 84, :filename "clojure/java/io.clj", :name "IOFactory", :ns "clojure.java.io", :row 69} {:arglist-strs ["[x opts]"], :doc "Creates a BufferedReader. See also IOFactory docs.", :end-row 81, :filename "clojure/java/io.clj", :fixed-arities #{2}, :name "make-reader", :ns "clojure.java.io", :row 81} {:arglist-strs ["[x opts]"], :doc "Creates a BufferedWriter. See also IOFactory docs.", :end-row 82, :filename "clojure/java/io.clj", :fixed-arities #{2}, :name "make-writer", :ns "clojure.java.io", :row 82} {:arglist-strs ["[x opts]"], :doc "Creates a BufferedInputStream. See also IOFactory docs.", :end-row 83, :filename "clojure/java/io.clj", :fixed-arities #{2}, :name "make-input-stream", :ns "clojure.java.io", :row 83} {:arglist-strs ["[x opts]"], :doc "Creates a BufferedOutputStream. See also IOFactory docs.", :end-row 84, :filename "clojure/java/io.clj", :fixed-arities #{2}, :name "make-output-stream", :ns "clojure.java.io", :row 84} {:arglist-strs ["[x & opts]"], :doc "Attempts to coerce its argument into an open java.io.Reader.\n   Default implementations always return a java.io.BufferedReader.\n\n   Default implementations are provided for Reader, BufferedReader,\n   InputStream, File, URI, URL, Socket, byte arrays, character arrays,\n   and String.\n\n   If argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the Reader is properly\n   closed.", :end-row 102, :filename "clojure/java/io.clj", :name "reader", :ns "clojure.java.io", :row 86} {:arglist-strs ["[x & opts]"], :doc "Attempts to coerce its argument into an open java.io.Writer.\n   Default implementations always return a java.io.BufferedWriter.\n\n   Default implementations are provided for Writer, BufferedWriter,\n   OutputStream, File, URI, URL, Socket, and String.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the Writer is properly\n   closed.", :end-row 119, :filename "clojure/java/io.clj", :name "writer", :ns "clojure.java.io", :row 104} {:arglist-strs ["[x & opts]"], :doc "Attempts to coerce its argument into an open java.io.InputStream.\n   Default implementations always return a java.io.BufferedInputStream.\n\n   Default implementations are defined for InputStream, File, URI, URL,\n   Socket, byte array, and String arguments.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the InputStream is properly\n   closed.", :end-row 136, :filename "clojure/java/io.clj", :name "input-stream", :ns "clojure.java.io", :row 121} {:arglist-strs ["[x & opts]"], :doc "Attempts to coerce its argument into an open java.io.OutputStream.\n   Default implementations always return a java.io.BufferedOutputStream.\n\n   Default implementations are defined for OutputStream, File, URI, URL,\n   Socket, and String arguments.\n\n   If the argument is a String, it tries to resolve it first as a URI, then\n   as a local file name.  URIs with a 'file' protocol are converted to\n   local file names.\n\n   Should be used inside with-open to ensure the OutputStream is\n   properly closed.", :end-row 153, :filename "clojure/java/io.clj", :name "output-stream", :ns "clojure.java.io", :row 138} {:arglist-strs ["[opts]"], :end-row 156, :filename "clojure/java/io.clj", :fixed-arities #{1}, :name "append?", :ns "clojure.java.io", :private true, :row 155} {:arglist-strs ["[opts]"], :end-row 159, :filename "clojure/java/io.clj", :fixed-arities #{1}, :name "encoding", :ns "clojure.java.io", :private true, :row 158} {:arglist-strs ["[opts]"], :end-row 162, :filename "clojure/java/io.clj", :fixed-arities #{1}, :name "buffer-size", :ns "clojure.java.io", :private true, :row 161} {:end-row 172, :filename "clojure/java/io.clj", :name "default-streams-impl", :ns "clojure.java.io", :row 164} {:arglist-strs ["[is opts]"], :end-row 176, :filename "clojure/java/io.clj", :fixed-arities #{2}, :name "inputstream->reader", :ns "clojure.java.io", :private true, :row 174} {:arglist-strs ["[os opts]"], :end-row 180, :filename "clojure/java/io.clj", :fixed-arities #{2}, :name "outputstream->writer", :ns "clojure.java.io", :private true, :row 178} {:doc "Internal helper for copy", :end-row 300, :filename "clojure/java/io.clj", :name "do-copy", :ns "clojure.java.io", :private true, :row 295} {:arglist-strs ["[input output & opts]"], :doc "Copies input to output.  Returns nil or throws IOException.\n  Input may be an InputStream, Reader, File, byte[], char[], or String.\n  Output may be an OutputStream, Writer, or File.\n\n  Options are key/value pairs and may be one of\n\n    :buffer-size  buffer size to use, default is 1024.\n    :encoding     encoding to use if converting between\n                  byte and char streams.   \n\n  Does not close any streams except those it opens itself \n  (on a File).", :end-row 406, :filename "clojure/java/io.clj", :name "copy", :ns "clojure.java.io", :row 391} {:arglist-strs ["[x]"], :doc "Take an as-file-able thing and return a string if it is\n   a relative path, else IllegalArgumentException.", :end-row 416, :filename "clojure/java/io.clj", :fixed-arities #{1}, :name "as-relative-path", :ns "clojure.java.io", :row 408} {:arglist-strs ["[arg]" "[parent child]" "[parent child & more]"], :doc "Returns a java.io.File, passing each arg to as-file.  Multiple-arg\n   versions treat the first argument as parent and subsequent args as\n   children relative to the parent.", :end-row 428, :filename "clojure/java/io.clj", :fixed-arities #{1 2}, :name "file", :ns "clojure.java.io", :row 418} {:arglist-strs ["[f & [silently]]"], :doc "Delete file f. If silently is nil or false, raise an exception on failure, else return the value of silently.", :end-row 436, :filename "clojure/java/io.clj", :name "delete-file", :ns "clojure.java.io", :row 430} {:arglist-strs ["[f & more]"], :doc "Given the same arg(s) as for file, creates all parent directories of\n   the file they represent.", :end-row 444, :filename "clojure/java/io.clj", :name "make-parents", :ns "clojure.java.io", :row 438} {:arglist-strs ["[n]" "[n loader]"], :doc "Returns the URL for a named resource. Use the context class loader\n   if no loader is specified.", :end-row 451, :filename "clojure/java/io.clj", :fixed-arities #{1 2}, :name "resource", :ns "clojure.java.io", :row 446}]} {:author "Chris Houser, Stuart Halloway", :doc "Conveniently launch a sub-process providing its stdin and\ncollecting its stdout", :end-row 16, :filename "clojure/java/shell.clj", :name "clojure.java.shell", :row 9, :ns nil, :var-definitions [{:end-row 18, :filename "clojure/java/shell.clj", :name "*sh-dir*", :ns "clojure.java.shell", :row 18} {:end-row 19, :filename "clojure/java/shell.clj", :name "*sh-env*", :ns "clojure.java.shell", :row 19} {:arglist-strs ["[dir & forms]"], :doc "Sets the directory for use with sh, see sh for details.", :end-row 26, :filename "clojure/java/shell.clj", :macro true, :name "with-sh-dir", :ns "clojure.java.shell", :row 21} {:arglist-strs ["[env & forms]"], :doc "Sets the environment for use with sh, see sh for details.", :end-row 33, :filename "clojure/java/shell.clj", :macro true, :name "with-sh-env", :ns "clojure.java.shell", :row 28} {:arglist-strs ["[type & xs]"], :doc "Concatenates arrays of given type.", :end-row 43, :filename "clojure/java/shell.clj", :name "aconcat", :ns "clojure.java.shell", :private true, :row 35} {:arglist-strs ["[args]"], :end-row 50, :filename "clojure/java/shell.clj", :fixed-arities #{1}, :name "parse-args", :ns "clojure.java.shell", :private true, :row 45} {:fixed-arities #{1}, :end-row 58, :private true, :ns "clojure.java.shell", :name "as-env-strings", :filename "clojure/java/shell.clj", :arglist-strs ["[arg]"], :doc "Helper so that callers can pass a Clojure map for the :env to sh.", :row 52} {:arglist-strs ["[in]"], :end-row 64, :filename "clojure/java/shell.clj", :fixed-arities #{1}, :name "stream-to-bytes", :ns "clojure.java.shell", :private true, :row 60} {:arglist-strs ["[in]" "[in enc]"], :end-row 71, :filename "clojure/java/shell.clj", :fixed-arities #{1 2}, :name "stream-to-string", :ns "clojure.java.shell", :private true, :row 66} {:arglist-strs ["[stream enc]"], :end-row 77, :filename "clojure/java/shell.clj", :fixed-arities #{2}, :name "stream-to-enc", :ns "clojure.java.shell", :private true, :row 73} {:arglist-strs ["[& args]"], :doc "Passes the given strings to Runtime.exec() to launch a sub-process.\n\n  Options are\n\n  :in      may be given followed by any legal input source for\n           clojure.java.io/copy, e.g. InputStream, Reader, File, byte[],\n           or String, to be fed to the sub-process's stdin.\n  :in-enc  option may be given followed by a String, used as a character\n           encoding name (for example \"UTF-8\" or \"ISO-8859-1\") to\n           convert the input string specified by the :in option to the\n           sub-process's stdin.  Defaults to UTF-8.\n           If the :in option provides a byte array, then the bytes are passed\n           unencoded, and this option is ignored.\n  :out-enc option may be given followed by :bytes or a String. If a\n           String is given, it will be used as a character encoding\n           name (for example \"UTF-8\" or \"ISO-8859-1\") to convert\n           the sub-process's stdout to a String which is returned.\n           If :bytes is given, the sub-process's stdout will be stored\n           in a byte array and returned.  Defaults to UTF-8.\n  :env     override the process env with a map (or the underlying Java\n           String[] if you are a masochist).\n  :dir     override the process dir with a String or java.io.File.\n\n  You can bind :env or :dir for multiple operations using with-sh-env\n  and with-sh-dir.\n\n  sh returns a map of\n    :exit => sub-process's exit code\n    :out  => sub-process's stdout (as byte[] or String)\n    :err  => sub-process's stderr (String via platform default encoding)", :end-row 128, :filename "clojure/java/shell.clj", :name "sh", :ns "clojure.java.shell", :row 79}]} {:author "Christophe Grand, Stuart Sierra", :doc "A repl helper to quickly open javadocs.", :end-row 14, :filename "clojure/java/javadoc.clj", :name "clojure.java.javadoc", :row 8, :ns nil, :var-definitions [{:end-row 16, :filename "clojure/java/javadoc.clj", :name "*feeling-lucky-url*", :ns "clojure.java.javadoc", :row 16} {:end-row 17, :filename "clojure/java/javadoc.clj", :name "*feeling-lucky*", :ns "clojure.java.javadoc", :row 17} {:end-row 19, :filename "clojure/java/javadoc.clj", :name "*local-javadocs*", :ns "clojure.java.javadoc", :row 19} {:end-row 31, :filename "clojure/java/javadoc.clj", :name "*core-java-api*", :ns "clojure.java.javadoc", :row 21} {:end-row 45, :filename "clojure/java/javadoc.clj", :name "*remote-javadocs*", :ns "clojure.java.javadoc", :row 33} {:arglist-strs ["[path]"], :doc "Adds to the list of local Javadoc paths.", :end-row 51, :filename "clojure/java/javadoc.clj", :fixed-arities #{1}, :name "add-local-javadoc", :ns "clojure.java.javadoc", :row 47} {:arglist-strs ["[package-prefix url]"], :doc "Adds to the list of remote Javadoc URLs.  package-prefix is the\n  beginning of the package name that has docs at this URL.", :end-row 58, :filename "clojure/java/javadoc.clj", :fixed-arities #{2}, :name "add-remote-javadoc", :ns "clojure.java.javadoc", :row 53} {:arglist-strs ["[url classname]"], :end-row 68, :filename "clojure/java/javadoc.clj", :fixed-arities #{2}, :name "fill-in-module-name", :ns "clojure.java.javadoc", :private true, :row 60} {:fixed-arities #{1}, :end-row 90, :private true, :ns "clojure.java.javadoc", :name "javadoc-url", :filename "clojure/java/javadoc.clj", :arglist-strs ["[classname]"], :doc "Searches for a URL for the given class name.  Tries\n  *local-javadocs* first, then *remote-javadocs*.  Returns a string.", :row 70} {:arglist-strs ["[class-or-object]"], :doc "Opens a browser window displaying the javadoc for the argument.\n  Tries *local-javadocs* first, then *remote-javadocs*.", :end-row 102, :filename "clojure/java/javadoc.clj", :fixed-arities #{1}, :name "javadoc", :ns "clojure.java.javadoc", :row 92}]} {:author "Alex Miller", :doc "Clojure wrapper functions for java.lang.Math static methods.\n\n  Function calls are inlined for performance, and type hinted for primitive\n  long or double parameters where appropriate. In general, Math methods are\n  optimized for performance and have bounds for error tolerance. If\n  greater precision is needed, use java.lang.StrictMath directly instead.\n\n  For more complete information, see:\n  https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html", :end-row 20, :filename "clojure/math.clj", :name "clojure.math", :row 9, :ns nil, :var-definitions [{:doc "Constant for e, the base for natural logarithms.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#E", :end-row 31, :filename "clojure/math.clj", :name "E", :ns "clojure.math", :row 24} {:doc "Constant for pi, the ratio of the circumference of a circle to its diameter.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#PI", :end-row 40, :filename "clojure/math.clj", :name "PI", :ns "clojure.math", :row 33} {:arglist-strs ["[a]"], :doc "Returns the sine of an angle.\n  If a is ##NaN, ##-Inf, ##Inf => ##NaN\n  If a is zero => zero with the same sign as a\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#sin-double-", :end-row 51, :filename "clojure/math.clj", :fixed-arities #{1}, :name "sin", :ns "clojure.math", :row 42} {:arglist-strs ["[a]"], :doc "Returns the cosine of an angle.\n  If a is ##NaN, ##-Inf, ##Inf => ##NaN\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#cos-double-", :end-row 61, :filename "clojure/math.clj", :fixed-arities #{1}, :name "cos", :ns "clojure.math", :row 53} {:arglist-strs ["[a]"], :doc "Returns the tangent of an angle.\n  If a is ##NaN, ##-Inf, ##Inf => ##NaN\n  If a is zero => zero with the same sign as a\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#tan-double-", :end-row 72, :filename "clojure/math.clj", :fixed-arities #{1}, :name "tan", :ns "clojure.math", :row 63} {:arglist-strs ["[a]"], :doc "Returns the arc sine of an angle, in the range -pi/2 to pi/2.\n  If a is ##NaN or |a|>1 => ##NaN\n  If a is zero => zero with the same sign as a\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#asin-double-", :end-row 83, :filename "clojure/math.clj", :fixed-arities #{1}, :name "asin", :ns "clojure.math", :row 74} {:arglist-strs ["[a]"], :doc "Returns the arc cosine of a, in the range 0.0 to pi.\n  If a is ##NaN or |a|>1 => ##NaN\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#acos-double-", :end-row 93, :filename "clojure/math.clj", :fixed-arities #{1}, :name "acos", :ns "clojure.math", :row 85} {:arglist-strs ["[a]"], :doc "Returns the arc tangent of a, in the range of -pi/2 to pi/2.\n  If a is ##NaN => ##NaN\n  If a is zero => zero with the same sign as a\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#atan-double-", :end-row 104, :filename "clojure/math.clj", :fixed-arities #{1}, :name "atan", :ns "clojure.math", :row 95} {:arglist-strs ["[deg]"], :doc "Converts an angle in degrees to an approximate equivalent angle in radians.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#toRadians-double-", :end-row 113, :filename "clojure/math.clj", :fixed-arities #{1}, :name "to-radians", :ns "clojure.math", :row 106} {:arglist-strs ["[r]"], :doc "Converts an angle in radians to an approximate equivalent angle in degrees.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#toDegrees-double-", :end-row 122, :filename "clojure/math.clj", :fixed-arities #{1}, :name "to-degrees", :ns "clojure.math", :row 115} {:arglist-strs ["[a]"], :doc "Returns Euler's number e raised to the power of a.\n  If a is ##NaN => ##NaN\n  If a is ##Inf => ##Inf\n  If a is ##-Inf => +0.0\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#exp-double-", :end-row 134, :filename "clojure/math.clj", :fixed-arities #{1}, :name "exp", :ns "clojure.math", :row 124} {:arglist-strs ["[a]"], :doc "Returns the natural logarithm (base e) of a.\n  If a is ##NaN or negative => ##NaN\n  If a is ##Inf => ##Inf\n  If a is zero => ##-Inf\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#log-double-", :end-row 146, :filename "clojure/math.clj", :fixed-arities #{1}, :name "log", :ns "clojure.math", :row 136} {:arglist-strs ["[a]"], :doc "Returns the logarithm (base 10) of a.\n  If a is ##NaN or negative => ##NaN\n  If a is ##Inf => ##Inf\n  If a is zero => ##-Inf\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#log10-double-", :end-row 158, :filename "clojure/math.clj", :fixed-arities #{1}, :name "log10", :ns "clojure.math", :row 148} {:arglist-strs ["[a]"], :doc "Returns the positive square root of a.\n  If a is ##NaN or negative => ##NaN\n  If a is ##Inf => ##Inf\n  If a is zero => a\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#sqrt-double-", :end-row 170, :filename "clojure/math.clj", :fixed-arities #{1}, :name "sqrt", :ns "clojure.math", :row 160} {:arglist-strs ["[a]"], :doc "Returns the cube root of a.\n  If a is ##NaN => ##NaN\n  If a is ##Inf or ##-Inf => a\n  If a is zero => zero with sign matching a\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#cbrt-double-", :end-row 182, :filename "clojure/math.clj", :fixed-arities #{1}, :name "cbrt", :ns "clojure.math", :row 172} {:arglist-strs ["[dividend divisor]"], :doc "Returns the remainder per IEEE 754 such that\n    remainder = dividend - divisor * n\n  where n is the integer closest to the exact value of dividend / divisor.\n  If two integers are equally close, then n is the even one.\n  If the remainder is zero, sign will match dividend.\n  If dividend or divisor is ##NaN, or dividend is ##Inf or ##-Inf, or divisor is zero => ##NaN\n  If dividend is finite and divisor is infinite => dividend\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#IEEEremainder-double-double-", :end-row 197, :filename "clojure/math.clj", :fixed-arities #{2}, :name "IEEE-remainder", :ns "clojure.math", :row 184} {:arglist-strs ["[a]"], :doc "Returns the smallest double greater than or equal to a, and equal to a\n  mathematical integer.\n  If a is ##NaN or ##Inf or ##-Inf or already equal to an integer => a\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#ceil-double-", :end-row 208, :filename "clojure/math.clj", :fixed-arities #{1}, :name "ceil", :ns "clojure.math", :row 199} {:arglist-strs ["[a]"], :doc "Returns the largest double less than or equal to a, and equal to a\n  mathematical integer.\n  If a is ##NaN or ##Inf or ##-Inf or already equal to an integer => a\n  If a is less than zero but greater than -1.0 => -0.0\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#floor-double-", :end-row 220, :filename "clojure/math.clj", :fixed-arities #{1}, :name "floor", :ns "clojure.math", :row 210} {:arglist-strs ["[a]"], :doc "Returns the double closest to a and equal to a mathematical integer.\n  If two values are equally close, return the even one.\n  If a is ##NaN or ##Inf or ##-Inf or zero => a\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#rint-double-", :end-row 231, :filename "clojure/math.clj", :fixed-arities #{1}, :name "rint", :ns "clojure.math", :row 222} {:arglist-strs ["[y x]"], :doc "Returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta).\n  Computes the phase theta by computing an arc tangent of y/x in the range of -pi to pi.\n  For more details on special cases, see:\n  https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#atan2-double-double-", :end-row 242, :filename "clojure/math.clj", :fixed-arities #{2}, :name "atan2", :ns "clojure.math", :row 233} {:arglist-strs ["[a b]"], :doc "Returns the value of a raised to the power of b.\n  For more details on special cases, see:\n  https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#pow-double-double-", :end-row 252, :filename "clojure/math.clj", :fixed-arities #{2}, :name "pow", :ns "clojure.math", :row 244} {:arglist-strs ["[a]"], :doc "Returns the closest long to a. If equally close to two values, return the one\n  closer to ##Inf.\n  If a is ##NaN => 0\n  If a is ##-Inf or < Long/MIN_VALUE => Long/MIN_VALUE\n  If a is ##Inf or > Long/MAX_VALUE => Long/MAX_VALUE\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#round-double-", :end-row 265, :filename "clojure/math.clj", :fixed-arities #{1}, :name "round", :ns "clojure.math", :row 254} {:arglist-strs ["[]"], :doc "Returns a positive double between 0.0 and 1.0, chosen pseudorandomly with\n  approximately random distribution.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#random--", :end-row 275, :filename "clojure/math.clj", :fixed-arities #{0}, :name "random", :ns "clojure.math", :row 267} {:arglist-strs ["[x y]"], :doc "Returns the sum of x and y, throws ArithmeticException on overflow.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#addExact-long-long-", :end-row 284, :filename "clojure/math.clj", :fixed-arities #{2}, :name "add-exact", :ns "clojure.math", :row 277} {:arglist-strs ["[x y]"], :doc "Returns the difference of x and y, throws ArithmeticException on overflow.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#subtractExact-long-long-", :end-row 293, :filename "clojure/math.clj", :fixed-arities #{2}, :name "subtract-exact", :ns "clojure.math", :row 286} {:arglist-strs ["[x y]"], :doc "Returns the product of x and y, throws ArithmeticException on overflow.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#multiplyExact-long-long-", :end-row 302, :filename "clojure/math.clj", :fixed-arities #{2}, :name "multiply-exact", :ns "clojure.math", :row 295} {:arglist-strs ["[a]"], :doc "Returns a incremented by 1, throws ArithmeticException on overflow.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#incrementExact-long-", :end-row 311, :filename "clojure/math.clj", :fixed-arities #{1}, :name "increment-exact", :ns "clojure.math", :row 304} {:arglist-strs ["[a]"], :doc "Returns a decremented by 1, throws ArithmeticException on overflow.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#decrementExact-long-", :end-row 320, :filename "clojure/math.clj", :fixed-arities #{1}, :name "decrement-exact", :ns "clojure.math", :row 313} {:arglist-strs ["[a]"], :doc "Returns the negation of a, throws ArithmeticException on overflow.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#negateExact-long-", :end-row 329, :filename "clojure/math.clj", :fixed-arities #{1}, :name "negate-exact", :ns "clojure.math", :row 322} {:arglist-strs ["[x y]"], :doc "Integer division that rounds to negative infinity (as opposed to zero).\n  The special case (floorDiv Long/MIN_VALUE -1) overflows and returns Long/MIN_VALUE.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#floorDiv-long-long-", :end-row 339, :filename "clojure/math.clj", :fixed-arities #{2}, :name "floor-div", :ns "clojure.math", :row 331} {:arglist-strs ["[x y]"], :doc "Integer modulus x - (floorDiv(x, y) * y). Sign matches y and is in the\n  range -|y| < r < |y|.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#floorMod-long-long-", :end-row 349, :filename "clojure/math.clj", :fixed-arities #{2}, :name "floor-mod", :ns "clojure.math", :row 341} {:arglist-strs ["[d]"], :doc "Returns the size of an ulp (unit in last place) for d.\n  If d is ##NaN => ##NaN\n  If d is ##Inf or ##-Inf => ##Inf\n  If d is zero => Double/MIN_VALUE\n  If d is +/- Double/MAX_VALUE => 2^971\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#ulp-double-", :end-row 362, :filename "clojure/math.clj", :fixed-arities #{1}, :name "ulp", :ns "clojure.math", :row 351} {:arglist-strs ["[d]"], :doc "Returns the signum function of d - zero for zero, 1.0 if >0, -1.0 if <0.\n  If d is ##NaN => ##NaN\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#signum-double-", :end-row 372, :filename "clojure/math.clj", :fixed-arities #{1}, :name "signum", :ns "clojure.math", :row 364} {:arglist-strs ["[x]"], :doc "Returns the hyperbolic sine of x, (e^x - e^-x)/2.\n  If x is ##NaN => ##NaN\n  If x is ##Inf or ##-Inf or zero => x\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#sinh-double-", :end-row 383, :filename "clojure/math.clj", :fixed-arities #{1}, :name "sinh", :ns "clojure.math", :row 374} {:arglist-strs ["[x]"], :doc "Returns the hyperbolic cosine of x, (e^x + e^-x)/2.\n  If x is ##NaN => ##NaN\n  If x is ##Inf or ##-Inf => ##Inf\n  If x is zero => 1.0\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#cosh-double-", :end-row 395, :filename "clojure/math.clj", :fixed-arities #{1}, :name "cosh", :ns "clojure.math", :row 385} {:arglist-strs ["[x]"], :doc "Returns the hyperbolic tangent of x, sinh(x)/cosh(x).\n  If x is ##NaN => ##NaN\n  If x is zero => zero, with same sign\n  If x is ##Inf => +1.0\n  If x is ##-Inf => -1.0\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#tanh-double-", :end-row 408, :filename "clojure/math.clj", :fixed-arities #{1}, :name "tanh", :ns "clojure.math", :row 397} {:arglist-strs ["[x y]"], :doc "Returns sqrt(x^2 + y^2) without intermediate underflow or overflow.\n  If x or y is ##Inf or ##-Inf => ##Inf\n  If x or y is ##NaN and neither is ##Inf or ##-Inf => ##NaN\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#hypot-double-double-", :end-row 419, :filename "clojure/math.clj", :fixed-arities #{2}, :name "hypot", :ns "clojure.math", :row 410} {:arglist-strs ["[x]"], :doc "Returns e^x - 1. Near 0, expm1(x)+1 is more accurate to e^x than exp(x).\n  If x is ##NaN => ##NaN\n  If x is ##Inf => #Inf\n  If x is ##-Inf => -1.0\n  If x is zero => x\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#expm1-double-", :end-row 432, :filename "clojure/math.clj", :fixed-arities #{1}, :name "expm1", :ns "clojure.math", :row 421} {:arglist-strs ["[x]"], :doc "Returns ln(1+x). For small values of x, log1p(x) is more accurate than\n  log(1.0+x).\n  If x is ##NaN or < -1 => ##NaN\n  If x is ##Inf => ##Inf\n  If x is -1 => ##-Inf\n  If x is 0 => 0 with sign matching x\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#log1p-double-", :end-row 446, :filename "clojure/math.clj", :fixed-arities #{1}, :name "log1p", :ns "clojure.math", :row 434} {:arglist-strs ["[magnitude sign]"], :doc "Returns a double with the magnitude of the first argument and the sign of\n  the second.\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#copySign-double-double-", :end-row 456, :filename "clojure/math.clj", :fixed-arities #{2}, :name "copy-sign", :ns "clojure.math", :row 448} {:arglist-strs ["[d]"], :doc "Returns the exponent of d.\n  If d is ##NaN, ##Inf, ##-Inf => Double/MAX_EXPONENT + 1\n  If d is zero or subnormal => Double/MIN_EXPONENT - 1\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#getExponent-double-", :end-row 467, :filename "clojure/math.clj", :fixed-arities #{1}, :name "get-exponent", :ns "clojure.math", :row 458} {:arglist-strs ["[start direction]"], :doc "Returns the adjacent floating point number to start in the direction of\n  the second argument. If the arguments are equal, the second is returned.\n  If either arg is #NaN => #NaN\n  If both arguments are signed zeros => direction\n  If start is +-Double/MIN_VALUE and direction would cause a smaller magnitude\n    => zero with sign matching start\n  If start is ##Inf or ##-Inf and direction would cause a smaller magnitude\n    => Double/MAX_VALUE with same sign as start\n  If start is equal to +=Double/MAX_VALUE and direction would cause a larger magnitude\n    => ##Inf or ##-Inf with sign matching start\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextAfter-double-double-", :end-row 485, :filename "clojure/math.clj", :fixed-arities #{2}, :name "next-after", :ns "clojure.math", :row 469} {:arglist-strs ["[d]"], :doc "Returns the adjacent double of d in the direction of ##Inf.\n  If d is ##NaN => ##NaN\n  If d is ##Inf => ##Inf\n  If d is zero => Double/MIN_VALUE\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextUp-double-", :end-row 497, :filename "clojure/math.clj", :fixed-arities #{1}, :name "next-up", :ns "clojure.math", :row 487} {:arglist-strs ["[d]"], :doc "Returns the adjacent double of d in the direction of ##-Inf.\n  If d is ##NaN => ##NaN\n  If d is ##-Inf => ##-Inf\n  If d is zero => -Double/MIN_VALUE\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextDown-double-", :end-row 509, :filename "clojure/math.clj", :fixed-arities #{1}, :name "next-down", :ns "clojure.math", :row 499} {:arglist-strs ["[d scaleFactor]"], :doc "Returns d * 2^scaleFactor, scaling by a factor of 2. If the exponent\n  is between Double/MIN_EXPONENT and Double/MAX_EXPONENT, the answer is exact.\n  If d is ##NaN => ##NaN\n  If d is ##Inf or ##-Inf => ##Inf or ##-Inf respectively\n  If d is zero => zero of same sign as d\n  See: https://docs.oracle.com/javase/8/docs/api/java/lang/Math.html#nextDown-double-", :end-row 522, :filename "clojure/math.clj", :fixed-arities #{2}, :name "scalb", :ns "clojure.math", :row 511}]} {:author "Tom Faulhaber", :doc "A Pretty Printer for Clojure\n\nclojure.pprint implements a flexible system for printing structured data\nin a pleasing, easy-to-understand format. Basic use of the pretty printer is \nsimple, just call pprint instead of println. More advanced users can use \nthe building blocks provided to create custom output formats. \n\nOut of the box, pprint supports a simple structured format for basic data \nand a specialized format for Clojure source code. More advanced formats, \nincluding formats that don't look like Clojure data at all like XML and \nJSON, can be rendered by creating custom dispatch functions. \n\nIn addition to the pprint function, this module contains cl-format, a text \nformatting function which is fully compatible with the format function in \nCommon Lisp. Because pretty printing directives are directly integrated with\ncl-format, it supports very concise custom dispatch. It also provides\na more powerful alternative to Clojure's standard format function.\n\nSee documentation for pprint and cl-format for more information or \ncomplete documentation on the Clojure web site on GitHub.", :end-row 39, :filename "clojure/pprint.clj", :name "clojure.pprint", :row 14, :ns nil, :var-definitions [{:fixed-arities #{3}, :end-row 23, :private true, :ns "clojure.pprint", :name "use-method", :filename "clojure/pprint/dispatch.clj", :arglist-strs ["[multifn dispatch-val func]"], :doc "Installs a function as a new method of multimethod associated with dispatch-value. ", :row 20} {:end-row 47, :filename "clojure/pprint/dispatch.clj", :name "reader-macros", :ns "clojure.pprint", :private true, :row 45} {:arglist-strs ["[alis]"], :end-row 54, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-reader-macro", :ns "clojure.pprint", :private true, :row 49} {:end-row 65, :filename "clojure/pprint/dispatch.clj", :name "pprint-map", :ns "clojure.pprint", :row 65} {:arglist-strs ["[obj]"], :end-row 73, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-meta", :ns "clojure.pprint", :private true, :row 67} {:arglist-strs ["[alis]"], :end-row 85, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-simple-list", :ns "clojure.pprint", :private true, :row 76} {:arglist-strs ["[alis]"], :end-row 89, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-list", :ns "clojure.pprint", :private true, :row 87} {:arglist-strs ["[avec]"], :end-row 101, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-vector", :ns "clojure.pprint", :private true, :row 92} {:end-row 103, :filename "clojure/pprint/dispatch.clj", :name "pprint-array", :ns "clojure.pprint", :private true, :row 103} {:arglist-strs ["[amap]"], :end-row 124, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-map", :ns "clojure.pprint", :private true, :row 106} {:arglist-strs ["[aset]"], :end-row 136, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-set", :ns "clojure.pprint", :private true, :row 127} {:end-row 140, :filename "clojure/pprint/dispatch.clj", :name "type-map", :ns "clojure.pprint", :private true, :row 138} {:fixed-arities #{1}, :end-row 147, :private true, :ns "clojure.pprint", :name "map-ref-type", :filename "clojure/pprint/dispatch.clj", :arglist-strs ["[name]"], :doc "Map ugly type names to something simpler", :row 142} {:arglist-strs ["[o]"], :end-row 163, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-ideref", :ns "clojure.pprint", :private true, :row 149} {:end-row 165, :filename "clojure/pprint/dispatch.clj", :name "pprint-pqueue", :ns "clojure.pprint", :private true, :row 165} {:arglist-strs ["[obj]"], :end-row 171, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-simple-default", :ns "clojure.pprint", :private true, :row 167} {:doc "The pretty print dispatch function for simple data structure format.", :end-row 178, :filename "clojure/pprint/dispatch.clj", :name "simple-dispatch", :ns "clojure.pprint", :row 174} {:end-row 194, :filename "clojure/pprint/dispatch.clj", :name "pprint-simple-code-list", :ns "clojure.pprint", :row 194} {:fixed-arities #{1}, :end-row 207, :private true, :ns "clojure.pprint", :name "brackets", :filename "clojure/pprint/dispatch.clj", :arglist-strs ["[form]"], :doc "Figure out which kind of brackets to use", :row 202} {:fixed-arities #{1}, :end-row 241, :private true, :ns "clojure.pprint", :name "pprint-ns-reference", :filename "clojure/pprint/dispatch.clj", :arglist-strs ["[reference]"], :doc "Pretty print a single reference (import, use, etc.) from a namespace decl", :row 209} {:fixed-arities #{1}, :end-row 267, :private true, :ns "clojure.pprint", :name "pprint-ns", :filename "clojure/pprint/dispatch.clj", :arglist-strs ["[alis]"], :doc "The pretty print dispatch chunk for the ns macro", :row 243} {:end-row 274, :filename "clojure/pprint/dispatch.clj", :name "pprint-hold-first", :ns "clojure.pprint", :private true, :row 274} {:arglist-strs ["[alis has-doc-str?]"], :end-row 287, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{2}, :name "single-defn", :ns "clojure.pprint", :private true, :row 281} {:arglist-strs ["[alis has-doc-str?]"], :end-row 292, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{2}, :name "multi-defn", :ns "clojure.pprint", :private true, :row 290} {:arglist-strs ["[alis]"], :end-row 315, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-defn", :ns "clojure.pprint", :private true, :row 296} {:arglist-strs ["[binding-vec]"], :end-row 334, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-binding-form", :ns "clojure.pprint", :private true, :row 321} {:arglist-strs ["[alis]"], :end-row 344, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-let", :ns "clojure.pprint", :private true, :row 336} {:end-row 351, :filename "clojure/pprint/dispatch.clj", :name "pprint-if", :ns "clojure.pprint", :private true, :row 351} {:arglist-strs ["[alis]"], :end-row 371, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-cond", :ns "clojure.pprint", :private true, :row 353} {:arglist-strs ["[alis]"], :end-row 390, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-condp", :ns "clojure.pprint", :private true, :row 373} {:end-row 393, :filename "clojure/pprint/dispatch.clj", :name "*symbol-map*", :ns "clojure.pprint", :private true, :row 393} {:arglist-strs ["[alis]"], :end-row 407, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-anon-func", :ns "clojure.pprint", :private true, :row 395} {:arglist-strs ["[alis]"], :end-row 426, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-simple-code-list", :ns "clojure.pprint", :private true, :row 417} {:arglist-strs ["[amap]"], :end-row 435, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "two-forms", :ns "clojure.pprint", :private true, :row 430} {:arglist-strs ["[amap]"], :end-row 444, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "add-core-ns", :ns "clojure.pprint", :private true, :row 437} {:end-row 461, :filename "clojure/pprint/dispatch.clj", :name "*code-table*", :ns "clojure.pprint", :private true, :row 446} {:arglist-strs ["[alis]"], :end-row 467, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-code-list", :ns "clojure.pprint", :private true, :row 463} {:arglist-strs ["[sym]"], :end-row 474, :filename "clojure/pprint/dispatch.clj", :fixed-arities #{1}, :name "pprint-code-symbol", :ns "clojure.pprint", :private true, :row 469} {:doc "The pretty print dispatch function for pretty printing Clojure code.", :end-row 480, :filename "clojure/pprint/dispatch.clj", :name "code-dispatch", :ns "clojure.pprint", :row 476} {:end-row 30, :filename "clojure/pprint/pretty_writer.clj", :name "get-miser-width", :ns "clojure.pprint", :row 30} {:fixed-arities #{1}, :end-row 41, :private true, :ns "clojure.pprint", :name "getf", :filename "clojure/pprint/pretty_writer.clj", :macro true, :arglist-strs ["[sym]"], :doc "Get the value of the field named by the argument (which should be a keyword).", :row 37} {:fixed-arities #{2}, :end-row 47, :private true, :ns "clojure.pprint", :name "setf", :filename "clojure/pprint/pretty_writer.clj", :macro true, :arglist-strs ["[sym new-val]"], :doc "Set the value of the field SYM to NEW-VAL", :row 43} {:arglist-strs ["[type-name & fields]"], :end-row 57, :filename "clojure/pprint/pretty_writer.clj", :macro true, :name "deftype", :ns "clojure.pprint", :private true, :row 49} {:end-row 65, :private true, :ns "clojure.pprint", :name "write-to-base", :filename "clojure/pprint/pretty_writer.clj", :macro true, :arglist-strs ["[& args]"], :doc "Call .write on Writer (getf :base) with proper type-hinting to\n  avoid reflection.", :row 59} {:arglist-strs ["[parent child]"], :end-row 82, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{2}, :name "ancestor?", :ns "clojure.pprint", :private true, :row 77} {:arglist-strs ["[l]"], :end-row 90, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{1}, :name "buffer-length", :ns "clojure.pprint", :private true, :row 86} {:end-row 108, :filename "clojure/pprint/pretty_writer.clj", :name "pp-newline", :ns "clojure.pprint", :private true, :row 108} {:end-row 110, :filename "clojure/pprint/pretty_writer.clj", :name "emit-nl", :ns "clojure.pprint", :row 110} {:end-row 112, :filename "clojure/pprint/pretty_writer.clj", :name "write-token", :ns "clojure.pprint", :private true, :row 112} {:arglist-strs ["[this tokens force-trailing-whitespace]"], :end-row 160, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{3}, :name "write-tokens", :ns "clojure.pprint", :private true, :row 150} {:arglist-strs ["[this tokens]"], :end-row 173, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{2}, :name "tokens-fit?", :ns "clojure.pprint", :private true, :row 168} {:arglist-strs ["[this lb section]"], :end-row 178, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{3}, :name "linear-nl?", :ns "clojure.pprint", :private true, :row 175} {:arglist-strs ["[this lb section]"], :end-row 185, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{3}, :name "miser-nl?", :ns "clojure.pprint", :private true, :row 180} {:end-row 187, :filename "clojure/pprint/pretty_writer.clj", :name "emit-nl?", :ns "clojure.pprint", :private true, :row 187} {:arglist-strs ["[buffer]"], :end-row 216, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{1}, :name "get-section", :ns "clojure.pprint", :private true, :row 211} {:arglist-strs ["[buffer]"], :end-row 224, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{1}, :name "get-sub-section", :ns "clojure.pprint", :private true, :row 218} {:arglist-strs ["[lb]"], :end-row 234, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{1}, :name "update-nl-state", :ns "clojure.pprint", :private true, :row 226} {:arglist-strs ["[this nl]"], :end-row 246, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{2}, :name "emit-nl", :ns "clojure.pprint", :private true, :row 236} {:arglist-strs ["[tokens]"], :end-row 250, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{1}, :name "split-at-newline", :ns "clojure.pprint", :private true, :row 248} {:end-row 254, :filename "clojure/pprint/pretty_writer.clj", :name "tok", :ns "clojure.pprint", :private true, :row 254} {:arglist-strs ["[toks]"], :end-row 261, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{1}, :name "toks", :ns "clojure.pprint", :private true, :row 261} {:arglist-strs ["[this tokens]"], :end-row 294, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{2}, :name "write-token-string", :ns "clojure.pprint", :private true, :row 266} {:arglist-strs ["[this]"], :end-row 305, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{1}, :name "write-line", :ns "clojure.pprint", :private true, :row 296} {:arglist-strs ["[this token]"], :end-row 314, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{2}, :name "add-to-buffer", :ns "clojure.pprint", :private true, :row 309} {:arglist-strs ["[this]"], :end-row 322, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{1}, :name "write-buffered-output", :ns "clojure.pprint", :private true, :row 317} {:arglist-strs ["[this]"], :end-row 329, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{1}, :name "write-white-space", :ns "clojure.pprint", :private true, :row 324} {:arglist-strs ["[this s]"], :end-row 357, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{2}, :name "write-initial-lines", :ns "clojure.pprint", :private true, :row 333} {:arglist-strs ["[this c]"], :end-row 371, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{2}, :name "p-write-char", :ns "clojure.pprint", :private true, :row 360} {:arglist-strs ["[writer max-columns miser-width]"], :end-row 435, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{3}, :name "pretty-writer", :ns "clojure.pprint", :private true, :row 379} {:arglist-strs ["[this prefix per-line-prefix suffix]"], :end-row 462, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{4}, :name "start-block", :ns "clojure.pprint", :private true, :row 442} {:arglist-strs ["[this]"], :end-row 478, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{1}, :name "end-block", :ns "clojure.pprint", :private true, :row 464} {:arglist-strs ["[this type]"], :end-row 484, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{2}, :name "nl", :ns "clojure.pprint", :private true, :row 480} {:arglist-strs ["[this relative-to offset]"], :end-row 497, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{3}, :name "indent", :ns "clojure.pprint", :private true, :row 486} {:arglist-strs ["[this]"], :end-row 500, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{1}, :name "get-miser-width", :ns "clojure.pprint", :private true, :row 499} {:arglist-strs ["[this new-miser-width]"], :end-row 503, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{2}, :name "set-miser-width", :ns "clojure.pprint", :private true, :row 502} {:arglist-strs ["[this f]"], :end-row 506, :filename "clojure/pprint/pretty_writer.clj", :fixed-arities #{2}, :name "set-logical-block-callback", :ns "clojure.pprint", :private true, :row 505} {:end-row 22, :filename "clojure/pprint/cl_format.clj", :name "compile-format", :ns "clojure.pprint", :row 22} {:end-row 23, :filename "clojure/pprint/cl_format.clj", :name "execute-format", :ns "clojure.pprint", :row 23} {:end-row 24, :filename "clojure/pprint/cl_format.clj", :name "init-navigator", :ns "clojure.pprint", :row 24} {:arglist-strs ["[writer format-in & args]"], :doc "An implementation of a Common Lisp compatible format function. cl-format formats its\narguments to an output stream or string based on the format control string given. It \nsupports sophisticated formatting of structured data.\n\nWriter is an instance of java.io.Writer, true to output to *out* or nil to output \nto a string, format-in is the format control string and the remaining arguments \nare the data to be formatted.\n\nThe format control string is a string to be output with embedded 'format directives' \ndescribing how to format the various arguments passed in.\n\nIf writer is nil, cl-format returns the formatted result string. Otherwise, cl-format \nreturns nil.\n\nFor example:\n (let [results [46 38 22]]\n        (cl-format true \"There ~[are~;is~:;are~]~:* ~d result~:p: ~{~d~^, ~}~%\" \n                   (count results) results))\n\nPrints to *out*:\n There are 3 results: 46, 38, 22\n\nDetailed documentation on format control strings is available in the \"Common Lisp the \nLanguage, 2nd edition\", Chapter 22 (available online at:\nhttp://www.cs.cmu.edu/afs/cs.cmu.edu/project/ai-repository/ai/html/cltl/clm/node200.html#SECTION002633000000000000000) \nand in the Common Lisp HyperSpec at \nhttp://www.lispworks.com/documentation/HyperSpec/Body/22_c.htm\n", :end-row 64, :filename "clojure/pprint/cl_format.clj", :name "cl-format", :ns "clojure.pprint", :row 27} {:end-row 66, :filename "clojure/pprint/cl_format.clj", :name "*format-str*", :ns "clojure.pprint", :private true, :row 66} {:arglist-strs ["[message offset]"], :end-row 71, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{2}, :name "format-error", :ns "clojure.pprint", :private true, :row 68} {:fixed-arities #{1}, :end-row 87, :private true, :ns "clojure.pprint", :name "init-navigator", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[s]"], :doc "Create a new arg-navigator from the sequence with the position set to 0", :row 82} {:arglist-strs ["[navigator]"], :end-row 94, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{1}, :name "next-arg", :ns "clojure.pprint", :private true, :row 90} {:arglist-strs ["[navigator]"], :end-row 100, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{1}, :name "next-arg-or-nil", :ns "clojure.pprint", :private true, :row 96} {:arglist-strs ["[navigator]"], :end-row 108, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{1}, :name "get-format-arg", :ns "clojure.pprint", :private true, :row 103} {:end-row 110, :filename "clojure/pprint/cl_format.clj", :name "relative-reposition", :ns "clojure.pprint", :row 110} {:arglist-strs ["[navigator position]"], :end-row 115, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{2}, :name "absolute-reposition", :ns "clojure.pprint", :private true, :row 112} {:arglist-strs ["[navigator position]"], :end-row 121, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{2}, :name "relative-reposition", :ns "clojure.pprint", :private true, :row 117} {:arglist-strs ["[[param [raw-val offset]] navigator]"], :end-row 148, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{2}, :name "realize-parameter", :ns "clojure.pprint", :private true, :row 134} {:arglist-strs ["[parameter-map navigator]"], :end-row 153, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{2}, :name "realize-parameter-list", :ns "clojure.pprint", :private true, :row 150} {:end-row 163, :filename "clojure/pprint/cl_format.clj", :name "opt-base-str", :ns "clojure.pprint", :row 163} {:end-row 166, :filename "clojure/pprint/cl_format.clj", :name "special-radix-markers", :ns "clojure.pprint", :private true, :row 165} {:arglist-strs ["[n]"], :end-row 180, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{1}, :name "format-simple-number", :ns "clojure.pprint", :private true, :row 168} {:arglist-strs ["[print-func params arg-navigator offsets]"], :end-row 198, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{4}, :name "format-ascii", :ns "clojure.pprint", :private true, :row 182} {:fixed-arities #{1}, :end-row 214, :private true, :ns "clojure.pprint", :name "integral?", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[x]"], :doc "returns true if a number is actually an integer (that is, has no fractional part)", :row 205} {:fixed-arities #{2}, :end-row 224, :private true, :ns "clojure.pprint", :name "remainders", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[base val]"], :doc "Return the list of remainders (essentially the 'digits') of val in the given base", :row 216} {:fixed-arities #{2}, :end-row 240, :private true, :ns "clojure.pprint", :name "base-str", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[base val]"], :doc "Return val as a string in the given base", :row 227} {:end-row 243, :filename "clojure/pprint/cl_format.clj", :name "java-base-formats", :ns "clojure.pprint", :private true, :row 242} {:fixed-arities #{2}, :end-row 252, :private true, :ns "clojure.pprint", :name "opt-base-str", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[base val]"], :doc "Return val as a string in the given base, using clojure.core/format if supported\nfor improved performance", :row 245} {:arglist-strs ["[unit lis]"], :end-row 257, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{2}, :name "group-by*", :ns "clojure.pprint", :private true, :row 254} {:arglist-strs ["[base params arg-navigator offsets]"], :end-row 283, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{4}, :name "format-integer", :ns "clojure.pprint", :private true, :row 259} {:end-row 293, :filename "clojure/pprint/cl_format.clj", :name "english-cardinal-units", :ns "clojure.pprint", :private true, :row 289} {:end-row 299, :filename "clojure/pprint/cl_format.clj", :name "english-ordinal-units", :ns "clojure.pprint", :private true, :row 295} {:end-row 303, :filename "clojure/pprint/cl_format.clj", :name "english-cardinal-tens", :ns "clojure.pprint", :private true, :row 301} {:end-row 308, :filename "clojure/pprint/cl_format.clj", :name "english-ordinal-tens", :ns "clojure.pprint", :private true, :row 305} {:end-row 320, :filename "clojure/pprint/cl_format.clj", :name "english-scale-numbers", :ns "clojure.pprint", :private true, :row 314} {:fixed-arities #{1}, :end-row 338, :private true, :ns "clojure.pprint", :name "format-simple-cardinal", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[num]"], :doc "Convert a number less than 1000 to a cardinal english string", :row 322} {:fixed-arities #{2}, :end-row 361, :private true, :ns "clojure.pprint", :name "add-english-scales", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[parts offset]"], :doc "Take a sequence of parts, add scale numbers (e.g., million) and combine into a string\noffset is a factor of 10^3 to multiply by", :row 340} {:arglist-strs ["[params navigator offsets]"], :end-row 378, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "format-cardinal-english", :ns "clojure.pprint", :private true, :row 363} {:fixed-arities #{1}, :end-row 400, :private true, :ns "clojure.pprint", :name "format-simple-ordinal", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[num]"], :doc "Convert a number less than 1000 to a ordinal english string\nNote this should only be used for the last one in the sequence", :row 380} {:arglist-strs ["[params navigator offsets]"], :end-row 432, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "format-ordinal-english", :ns "clojure.pprint", :private true, :row 402} {:end-row 444, :filename "clojure/pprint/cl_format.clj", :name "old-roman-table", :ns "clojure.pprint", :private true, :row 439} {:end-row 451, :filename "clojure/pprint/cl_format.clj", :name "new-roman-table", :ns "clojure.pprint", :private true, :row 446} {:fixed-arities #{4}, :end-row 475, :private true, :ns "clojure.pprint", :name "format-roman", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[table params navigator offsets]"], :doc "Format a roman numeral using the specified look-up table", :row 453} {:arglist-strs ["[params navigator offsets]"], :end-row 478, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "format-old-roman", :ns "clojure.pprint", :private true, :row 477} {:arglist-strs ["[params navigator offsets]"], :end-row 481, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "format-new-roman", :ns "clojure.pprint", :private true, :row 480} {:end-row 488, :filename "clojure/pprint/cl_format.clj", :name "special-chars", :ns "clojure.pprint", :private true, :row 487} {:arglist-strs ["[params navigator offsets]"], :end-row 502, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "pretty-character", :ns "clojure.pprint", :private true, :row 490} {:arglist-strs ["[params navigator offsets]"], :end-row 510, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "readable-character", :ns "clojure.pprint", :private true, :row 504} {:arglist-strs ["[params navigator offsets]"], :end-row 515, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "plain-character", :ns "clojure.pprint", :private true, :row 512} {:arglist-strs ["[context]"], :end-row 521, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{1}, :name "abort?", :ns "clojure.pprint", :private true, :row 519} {:arglist-strs ["[format args base-args]"], :end-row 535, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "execute-sub-format", :ns "clojure.pprint", :private true, :row 524} {:fixed-arities #{1}, :end-row 554, :private true, :ns "clojure.pprint", :name "float-parts-base", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[f]"], :doc "Produce string parts for the mantissa (normalized 1-9) and exponent", :row 542} {:fixed-arities #{1}, :end-row 567, :private true, :ns "clojure.pprint", :name "float-parts", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[f]"], :doc "Take care of leading and trailing zeros in decomposed floats", :row 557} {:fixed-arities #{1}, :end-row 583, :private true, :ns "clojure.pprint", :name "inc-s", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[s]"], :doc "Assumption: The input string consists of one or more decimal digits,\nand no other characters.  Return a string containing one or more\ndecimal digits containing a decimal number one larger than the input\nstring.  The output string will always be the same length as the input\nstring, or one character longer.", :row 569} {:arglist-strs ["[m e d w]"], :end-row 625, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{4}, :name "round-str", :ns "clojure.pprint", :private true, :row 585} {:arglist-strs ["[m e d]"], :end-row 635, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "expand-fixed", :ns "clojure.pprint", :private true, :row 627} {:fixed-arities #{2}, :end-row 643, :private true, :ns "clojure.pprint", :name "insert-decimal", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[m e]"], :doc "Insert the decimal point at the right spot in the number to match an exponent", :row 637} {:arglist-strs ["[m e d]"], :end-row 646, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "get-fixed", :ns "clojure.pprint", :private true, :row 645} {:fixed-arities #{2}, :end-row 653, :private true, :ns "clojure.pprint", :name "insert-scaled-decimal", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[m k]"], :doc "Insert the decimal point at the right spot in the number to match an exponent", :row 648} {:arglist-strs ["[x]"], :end-row 668, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{1}, :name "convert-ratio", :ns "clojure.pprint", :private true, :row 655} {:arglist-strs ["[params navigator offsets]"], :end-row 714, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "fixed-float", :ns "clojure.pprint", :private true, :row 672} {:arglist-strs ["[params navigator offsets]"], :end-row 787, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "exponential-float", :ns "clojure.pprint", :private true, :row 720} {:arglist-strs ["[params navigator offsets]"], :end-row 813, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "general-float", :ns "clojure.pprint", :private true, :row 794} {:arglist-strs ["[params navigator offsets]"], :end-row 833, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "dollar-float", :ns "clojure.pprint", :private true, :row 817} {:arglist-strs ["[params arg-navigator offsets]"], :end-row 852, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "choice-conditional", :ns "clojure.pprint", :private true, :row 843} {:arglist-strs ["[params arg-navigator offsets]"], :end-row 863, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "boolean-conditional", :ns "clojure.pprint", :private true, :row 855} {:arglist-strs ["[params arg-navigator offsets]"], :end-row 875, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "check-arg-conditional", :ns "clojure.pprint", :private true, :row 867} {:arglist-strs ["[params navigator offsets]"], :end-row 907, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "iterate-sublist", :ns "clojure.pprint", :private true, :row 886} {:arglist-strs ["[params navigator offsets]"], :end-row 930, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "iterate-list-of-sublists", :ns "clojure.pprint", :private true, :row 911} {:arglist-strs ["[params navigator offsets]"], :end-row 954, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "iterate-main-list", :ns "clojure.pprint", :private true, :row 934} {:arglist-strs ["[params navigator offsets]"], :end-row 975, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "iterate-main-sublists", :ns "clojure.pprint", :private true, :row 958} {:end-row 990, :filename "clojure/pprint/cl_format.clj", :name "format-logical-block", :ns "clojure.pprint", :row 990} {:end-row 991, :filename "clojure/pprint/cl_format.clj", :name "justify-clauses", :ns "clojure.pprint", :row 991} {:arglist-strs ["[params navigator offsets]"], :end-row 996, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "logical-block-or-justify", :ns "clojure.pprint", :private true, :row 993} {:arglist-strs ["[clauses navigator base-navigator]"], :end-row 1014, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "render-clauses", :ns "clojure.pprint", :private true, :row 1002} {:arglist-strs ["[params navigator offsets]"], :end-row 1062, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "justify-clauses", :ns "clojure.pprint", :private true, :row 1017} {:fixed-arities #{1}, :end-row 1088, :private true, :ns "clojure.pprint", :name "downcase-writer", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, converting all characters to lower case", :row 1072} {:fixed-arities #{1}, :end-row 1106, :private true, :ns "clojure.pprint", :name "upcase-writer", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, converting all characters to upper case", :row 1090} {:fixed-arities #{2}, :end-row 1130, :private true, :ns "clojure.pprint", :name "capitalize-string", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[s first?]"], :doc "Capitalizes the words in a string. If first? is false, don't capitalize the \n                                      first character of the string even if it's a letter.", :row 1108} {:fixed-arities #{1}, :end-row 1158, :private true, :ns "clojure.pprint", :name "capitalize-word-writer", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, capitalizing all words", :row 1132} {:fixed-arities #{1}, :end-row 1192, :private true, :ns "clojure.pprint", :name "init-cap-writer", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[writer]"], :doc "Returns a proxy that wraps writer, capitalizing the first word", :row 1160} {:arglist-strs ["[make-writer params navigator offsets]"], :end-row 1197, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{4}, :name "modify-case", :ns "clojure.pprint", :private true, :row 1194} {:arglist-strs ["[writer]"], :doc "Returns the java.io.Writer passed in wrapped in a pretty writer proxy, unless it's \nalready a pretty writer. Generally, it is unnecessary to call this function, since pprint,\nwrite, and cl-format all call it if they need to. However if you want the state to be \npreserved across calls, you will want to wrap them with this. \n\nFor example, when you want to generate column-aware output with multiple calls to cl-format, \ndo it like in this example:\n\n    (defn print-table [aseq column-width]\n      (binding [*out* (get-pretty-writer *out*)]\n        (doseq [row aseq]\n          (doseq [col row]\n            (cl-format true \"~4D~7,vT\" col column-width))\n          (prn))))\n\nNow when you run:\n\n    user> (print-table (map #(vector % (* % %) (* % % %)) (range 1 11)) 8)\n\nIt prints a table of squares and cubes for the numbers from 1 to 10:\n\n       1      1       1    \n       2      4       8    \n       3      9      27    \n       4     16      64    \n       5     25     125    \n       6     36     216    \n       7     49     343    \n       8     64     512    \n       9     81     729    \n      10    100    1000", :end-row 1239, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{1}, :name "get-pretty-writer", :ns "clojure.pprint", :row 1203} {:arglist-strs ["[]"], :doc "Make a newline if *out* is not already at the beginning of the line. If *out* is\nnot a pretty writer (which keeps track of columns), this function always outputs a newline.", :end-row 1253, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{0}, :name "fresh-line", :ns "clojure.pprint", :row 1245} {:arglist-strs ["[params navigator offsets]"], :end-row 1264, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "absolute-tabulation", :ns "clojure.pprint", :private true, :row 1255} {:arglist-strs ["[params navigator offsets]"], :end-row 1273, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "relative-tabulation", :ns "clojure.pprint", :private true, :row 1266} {:arglist-strs ["[params navigator offsets]"], :end-row 1298, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "format-logical-block", :ns "clojure.pprint", :private true, :row 1282} {:arglist-strs ["[params navigator offsets]"], :end-row 1303, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "set-indent", :ns "clojure.pprint", :private true, :row 1300} {:arglist-strs ["[params navigator offsets]"], :end-row 1312, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "conditional-newline", :ns "clojure.pprint", :private true, :row 1307} {:arglist-strs ["[[char params flags bracket-info & generator-fn]]"], :end-row 1326, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{1}, :name "process-directive-table-element", :ns "clojure.pprint", :private true, :row 1320} {:arglist-strs ["[& directives]"], :end-row 1332, :filename "clojure/pprint/cl_format.clj", :macro true, :name "defdirectives", :ns "clojure.pprint", :private true, :row 1328} {:end-row 1621, :filename "clojure/pprint/cl_format.clj", :name "param-pattern", :ns "clojure.pprint", :private true, :row 1620} {:end-row 1623, :filename "clojure/pprint/cl_format.clj", :name "special-params", :ns "clojure.pprint", :private true, :row 1622} {:arglist-strs ["[[s offset saw-comma]]"], :end-row 1637, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{1}, :name "extract-param", :ns "clojure.pprint", :private true, :row 1625} {:arglist-strs ["[s offset]"], :end-row 1641, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{2}, :name "extract-params", :ns "clojure.pprint", :private true, :row 1640} {:fixed-arities #{1}, :end-row 1653, :private true, :ns "clojure.pprint", :name "translate-param", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[[p offset]]"], :doc "Translate the string representation of a param to the internalized\n                                      representation", :row 1643} {:end-row 1656, :filename "clojure/pprint/cl_format.clj", :name "flag-defs", :ns "clojure.pprint", :private true, :row 1655} {:arglist-strs ["[s offset]"], :end-row 1671, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{2}, :name "extract-flags", :ns "clojure.pprint", :private true, :row 1658} {:arglist-strs ["[def flags]"], :end-row 1684, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{2}, :name "check-flags", :ns "clojure.pprint", :private true, :row 1673} {:fixed-arities #{4}, :end-row 1714, :private true, :ns "clojure.pprint", :name "map-params", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[def params flags offset]"], :doc "Takes a directive definition and the list of actual parameters and\na map of flags and returns a map of the parameters and flags with defaults\nfilled in. We check to make sure that there are the right types and number\nof parameters as well.", :row 1686} {:arglist-strs ["[s offset]"], :end-row 1734, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{2}, :name "compile-directive", :ns "clojure.pprint", :private true, :row 1716} {:arglist-strs ["[s offset]"], :end-row 1737, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{2}, :name "compile-raw-string", :ns "clojure.pprint", :private true, :row 1736} {:arglist-strs ["[this]"], :end-row 1739, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{1}, :name "right-bracket", :ns "clojure.pprint", :private true, :row 1739} {:arglist-strs ["[this]"], :end-row 1740, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{1}, :name "separator?", :ns "clojure.pprint", :private true, :row 1740} {:arglist-strs ["[this]"], :end-row 1743, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{1}, :name "else-separator?", :ns "clojure.pprint", :private true, :row 1741} {:end-row 1746, :filename "clojure/pprint/cl_format.clj", :name "collect-clauses", :ns "clojure.pprint", :row 1746} {:arglist-strs ["[this remainder]"], :end-row 1755, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{2}, :name "process-bracket", :ns "clojure.pprint", :private true, :row 1748} {:arglist-strs ["[bracket-info offset remainder]"], :end-row 1779, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "process-clause", :ns "clojure.pprint", :private true, :row 1757} {:arglist-strs ["[bracket-info offset remainder]"], :end-row 1828, :filename "clojure/pprint/cl_format.clj", :fixed-arities #{3}, :name "collect-clauses", :ns "clojure.pprint", :private true, :row 1781} {:fixed-arities #{1}, :end-row 1843, :private true, :ns "clojure.pprint", :name "process-nesting", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[format]"], :doc "Take a linearly compiled format and process the bracket directives to give it \n   the appropriate tree structure", :row 1830} {:fixed-arities #{1}, :end-row 1864, :private true, :ns "clojure.pprint", :name "compile-format", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[format-str]"], :doc "Compiles format-str into a compiled format which can be used as an argument\nto cl-format just like a plain format string. Use this function for improved \nperformance when you're using the same format string repeatedly", :row 1845} {:fixed-arities #{1}, :end-row 1877, :private true, :ns "clojure.pprint", :name "needs-pretty", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[format]"], :doc "determine whether a given compiled format has any directives that depend on the\ncolumn number or pretty printing", :row 1866} {:fixed-arities #{3 2}, :end-row 1910, :private true, :ns "clojure.pprint", :name "execute-format", :filename "clojure/pprint/cl_format.clj", :arglist-strs ["[stream format args]" "[format args]"], :doc "Executes the format with the arguments.", :row 1879} {:end-row 1914, :filename "clojure/pprint/cl_format.clj", :name "cached-compile", :ns "clojure.pprint", :private true, :row 1914} {:fixed-arities #{1}, :end-row 1934, :ns "clojure.pprint", :name "formatter", :filename "clojure/pprint/cl_format.clj", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [stream & args] ... and returns nil unless the stream is nil (meaning \noutput to a string) in which case it returns the resulting string.\n\nformat-in can be either a control string or a previously compiled format.", :row 1916} {:fixed-arities #{1}, :end-row 1949, :ns "clojure.pprint", :name "formatter-out", :filename "clojure/pprint/cl_format.clj", :macro true, :arglist-strs ["[format-in]"], :doc "Makes a function which can directly run format-in. The function is\nfn [& args] ... and returns nil. This version of the formatter macro is\ndesigned to be used with *out* set to an appropriate Writer. In particular,\nthis is meant to be used as part of a pretty printer dispatch method.\n\nformat-in can be either a control string or a previously compiled format.", :row 1936} {:doc "Bind to true if you want write to use pretty printing", :end-row 32, :filename "clojure/pprint/pprint_base.clj", :name "*print-pretty*", :ns "clojure.pprint", :row 30} {:doc "The pretty print dispatch function. Use with-pprint-dispatch or set-pprint-dispatch\nto modify.", :end-row 38, :filename "clojure/pprint/pprint_base.clj", :name "*print-pprint-dispatch*", :ns "clojure.pprint", :row 34} {:doc "Pretty printing will try to avoid anything going beyond this column.\nSet it to nil to have pprint let the line be arbitrarily long. This will ignore all \nnon-mandatory newlines.", :end-row 45, :filename "clojure/pprint/pprint_base.clj", :name "*print-right-margin*", :ns "clojure.pprint", :row 40} {:doc "The column at which to enter miser style. Depending on the dispatch table, \nmiser style add newlines in more places to try to keep lines short allowing for further \nlevels of nesting.", :end-row 52, :filename "clojure/pprint/pprint_base.clj", :name "*print-miser-width*", :ns "clojure.pprint", :row 47} {:doc "Maximum number of lines to print in a pretty print instance (N.B. This is not yet used)", :end-row 58, :filename "clojure/pprint/pprint_base.clj", :name "*print-lines*", :ns "clojure.pprint", :private true, :row 55} {:doc "Mark circular structures (N.B. This is not yet used)", :end-row 64, :filename "clojure/pprint/pprint_base.clj", :name "*print-circle*", :ns "clojure.pprint", :private true, :row 61} {:doc "Mark repeated structures rather than repeat them (N.B. This is not yet used)", :end-row 70, :filename "clojure/pprint/pprint_base.clj", :name "*print-shared*", :ns "clojure.pprint", :private true, :row 67} {:doc "Don't print namespaces with symbols. This is particularly useful when \npretty printing the results of macro expansions", :end-row 76, :filename "clojure/pprint/pprint_base.clj", :name "*print-suppress-namespaces*", :ns "clojure.pprint", :row 72} {:doc "Print a radix specifier in front of integers and rationals. If *print-base* is 2, 8, \nor 16, then the radix specifier used is #b, #o, or #x, respectively. Otherwise the \nradix specifier is in the form #XXr where XX is the decimal value of *print-base* ", :end-row 85, :filename "clojure/pprint/pprint_base.clj", :name "*print-radix*", :ns "clojure.pprint", :row 80} {:doc "The base to use for printing integers and rationals.", :end-row 90, :filename "clojure/pprint/pprint_base.clj", :name "*print-base*", :ns "clojure.pprint", :row 87} {:end-row 99, :filename "clojure/pprint/pprint_base.clj", :name "*current-level*", :ns "clojure.pprint", :private true, :row 99} {:end-row 101, :filename "clojure/pprint/pprint_base.clj", :name "*current-length*", :ns "clojure.pprint", :private true, :row 101} {:end-row 109, :filename "clojure/pprint/pprint_base.clj", :name "format-simple-number", :ns "clojure.pprint", :row 109} {:end-row 111, :filename "clojure/pprint/pprint_base.clj", :name "orig-pr", :ns "clojure.pprint", :private true, :row 111} {:arglist-strs ["[x]"], :end-row 116, :filename "clojure/pprint/pprint_base.clj", :fixed-arities #{1}, :name "pr-with-base", :ns "clojure.pprint", :private true, :row 113} {:end-row 134, :filename "clojure/pprint/pprint_base.clj", :name "write-option-table", :ns "clojure.pprint", :private true, :row 118} {:arglist-strs ["[amap & body]"], :end-row 144, :filename "clojure/pprint/pprint_base.clj", :macro true, :name "binding-map", :ns "clojure.pprint", :private true, :row 137} {:arglist-strs ["[t m]"], :end-row 149, :filename "clojure/pprint/pprint_base.clj", :fixed-arities #{2}, :name "table-ize", :ns "clojure.pprint", :private true, :row 146} {:fixed-arities #{1}, :end-row 153, :private true, :ns "clojure.pprint", :name "pretty-writer?", :filename "clojure/pprint/pprint_base.clj", :arglist-strs ["[x]"], :doc "Return true iff x is a PrettyWriter", :row 151} {:fixed-arities #{3}, :end-row 158, :private true, :ns "clojure.pprint", :name "make-pretty-writer", :filename "clojure/pprint/pprint_base.clj", :arglist-strs ["[base-writer right-margin miser-width]"], :doc "Wrap base-writer in a PrettyWriter with the specified right-margin and miser-width", :row 155} {:arglist-strs ["[base-writer & body]"], :end-row 167, :filename "clojure/pprint/pprint_base.clj", :macro true, :name "with-pretty-writer", :ns "clojure.pprint", :private true, :row 160} {:arglist-strs ["[object]"], :doc "Write an object to *out* subject to the current bindings of the printer control \nvariables. Use the kw-args argument to override individual variables for this call (and \nany recursive calls).\n\n*out* must be a PrettyWriter if pretty printing is enabled. This is the responsibility\nof the caller.\n\nThis method is primarily intended for use by pretty print dispatch functions that \nalready know that the pretty printer will have set up their environment appropriately.\nNormal library clients should use the standard \"write\" interface. ", :end-row 195, :filename "clojure/pprint/pprint_base.clj", :fixed-arities #{1}, :name "write-out", :ns "clojure.pprint", :row 171} {:arglist-strs ["[object & kw-args]"], :doc "Write an object subject to the current bindings of the printer control variables.\nUse the kw-args argument to override individual variables for this call (and any \nrecursive calls). Returns the string result if :stream is nil or nil otherwise.\n\nThe following keyword arguments can be passed with values:\n  Keyword              Meaning                              Default value\n  :stream              Writer for output or nil             true (indicates *out*)\n  :base                Base to use for writing rationals    Current value of *print-base*\n  :circle*             If true, mark circular structures    Current value of *print-circle*\n  :length              Maximum elements to show in sublists Current value of *print-length*\n  :level               Maximum depth                        Current value of *print-level*\n  :lines*              Maximum lines of output              Current value of *print-lines*\n  :miser-width         Width to enter miser mode            Current value of *print-miser-width*\n  :dispatch            The pretty print dispatch function   Current value of *print-pprint-dispatch*\n  :pretty              If true, do pretty printing          Current value of *print-pretty*\n  :radix               If true, prepend a radix specifier   Current value of *print-radix*\n  :readably*           If true, print readably              Current value of *print-readably*\n  :right-margin        The column for the right margin      Current value of *print-right-margin*\n  :suppress-namespaces If true, no namespaces in symbols    Current value of *print-suppress-namespaces*\n\n  * = not yet supported\n", :end-row 238, :filename "clojure/pprint/pprint_base.clj", :name "write", :ns "clojure.pprint", :row 197} {:arglist-strs ["[object]" "[object writer]"], :doc "Pretty print object to the optional output writer. If the writer is not provided, \nprint the object to the currently bound value of *out*.", :end-row 252, :filename "clojure/pprint/pprint_base.clj", :fixed-arities #{1 2}, :name "pprint", :ns "clojure.pprint", :row 241} {:fixed-arities #{0}, :end-row 258, :ns "clojure.pprint", :name "pp", :filename "clojure/pprint/pprint_base.clj", :macro true, :arglist-strs ["[]"], :doc "A convenience macro that pretty prints the last thing output. This is\nexactly equivalent to (pprint *1).", :row 254} {:arglist-strs ["[function]"], :doc "Set the pretty print dispatch function to a function matching (fn [obj] ...)\nwhere obj is the object to pretty print. That function will be called with *out* set\nto a pretty printing writer to which it should do its printing.\n\nFor example functions, see simple-dispatch and code-dispatch in \nclojure.pprint.dispatch.clj.", :end-row 272, :filename "clojure/pprint/pprint_base.clj", :fixed-arities #{1}, :name "set-pprint-dispatch", :ns "clojure.pprint", :row 260} {:arglist-strs ["[function & body]"], :doc "Execute body with the pretty print dispatch function bound to function.", :end-row 279, :filename "clojure/pprint/pprint_base.clj", :macro true, :name "with-pprint-dispatch", :ns "clojure.pprint", :row 274} {:arglist-strs ["[opts body]"], :end-row 290, :filename "clojure/pprint/pprint_base.clj", :fixed-arities #{2}, :name "parse-lb-options", :ns "clojure.pprint", :private true, :row 285} {:arglist-strs ["[arg choices]"], :end-row 297, :filename "clojure/pprint/pprint_base.clj", :fixed-arities #{2}, :name "check-enumerated-arg", :ns "clojure.pprint", :private true, :row 292} {:arglist-strs ["[]"], :end-row 300, :filename "clojure/pprint/pprint_base.clj", :fixed-arities #{0}, :name "level-exceeded", :ns "clojure.pprint", :private true, :row 299} {:arglist-strs ["[& args]"], :doc "Execute the body as a pretty printing logical block with output to *out* which \nmust be a pretty printing writer. When used from pprint or cl-format, this can be \nassumed. \n\nThis function is intended for use when writing custom dispatch functions.\n\nBefore the body, the caller can optionally specify options: :prefix, :per-line-prefix, \nand :suffix.", :end-row 327, :filename "clojure/pprint/pprint_base.clj", :macro true, :name "pprint-logical-block", :ns "clojure.pprint", :row 302} {:arglist-strs ["[kind]"], :doc "Print a conditional newline to a pretty printing stream. kind specifies if the \nnewline is :linear, :miser, :fill, or :mandatory. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", :end-row 339, :filename "clojure/pprint/pprint_base.clj", :fixed-arities #{1}, :name "pprint-newline", :ns "clojure.pprint", :row 329} {:arglist-strs ["[relative-to n]"], :doc "Create an indent at this point in the pretty printing stream. This defines how \nfollowing lines are indented. relative-to can be either :block or :current depending \nwhether the indent should be computed relative to the start of the logical block or\nthe current column position. n is an offset. \n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.", :end-row 353, :filename "clojure/pprint/pprint_base.clj", :fixed-arities #{2}, :name "pprint-indent", :ns "clojure.pprint", :row 341} {:arglist-strs ["[kind colnum colinc]"], :doc "Tab at this point in the pretty printing stream. kind specifies whether the tab\nis :line, :section, :line-relative, or :section-relative. \n\nColnum and colinc specify the target column and the increment to move the target\nforward if the output is already past the original target.\n\nThis function is intended for use when writing custom dispatch functions.\n\nOutput is sent to *out* which must be a pretty printing writer.\n\nTHIS FUNCTION IS NOT YET IMPLEMENTED.", :end-row 371, :filename "clojure/pprint/pprint_base.clj", :fixed-arities #{3}, :name "pprint-tab", :ns "clojure.pprint", :row 356} {:arglist-strs ["[var-sym body]"], :end-row 389, :filename "clojure/pprint/pprint_base.clj", :fixed-arities #{2}, :name "pll-mod-body", :ns "clojure.pprint", :private true, :row 380} {:arglist-strs ["[bindings & body]"], :doc "A version of loop that iterates at most *print-length* times. This is designed \nfor use in pretty-printer dispatch functions.", :end-row 401, :filename "clojure/pprint/pprint_base.clj", :macro true, :name "print-length-loop", :ns "clojure.pprint", :row 391} {:arglist-strs ["[ks rows]" "[rows]"], :doc "Prints a collection of maps in a textual table. Prints table headings\n   ks, and then a line of output for each row, corresponding to the keys\n   in ks. If ks are not specified, use the keys of the first item in rows.", :end-row 35, :filename "clojure/pprint/print_table.clj", :fixed-arities #{1 2}, :name "print-table", :ns "clojure.pprint", :row 11} {:arglist-strs ["[func initial-context lis]"], :end-row 35, :filename "clojure/pprint/utilities.clj", :fixed-arities #{3}, :name "map-passing-context", :ns "clojure.pprint", :private true, :row 26} {:arglist-strs ["[func initial-context]"], :end-row 43, :filename "clojure/pprint/utilities.clj", :fixed-arities #{2}, :name "consume", :ns "clojure.pprint", :private true, :row 37} {:arglist-strs ["[func initial-context]"], :end-row 51, :filename "clojure/pprint/utilities.clj", :fixed-arities #{2}, :name "consume-while", :ns "clojure.pprint", :private true, :row 45} {:fixed-arities #{1}, :end-row 59, :private true, :ns "clojure.pprint", :name "unzip-map", :filename "clojure/pprint/utilities.clj", :arglist-strs ["[m]"], :doc "Take a map that has pairs in the value slots and produce a pair of\n  maps, the first having all the first elements of the pairs and the\n  second all the second elements of the pairs", :row 53} {:fixed-arities #{2}, :end-row 64, :private true, :ns "clojure.pprint", :name "tuple-map", :filename "clojure/pprint/utilities.clj", :arglist-strs ["[m v1]"], :doc "For all the values, v, in the map, replace them with [v v1]", :row 61} {:fixed-arities #{2}, :end-row 76, :private true, :ns "clojure.pprint", :name "rtrim", :filename "clojure/pprint/utilities.clj", :arglist-strs ["[s c]"], :doc "Trim all instances of c from the end of sequence s", :row 66} {:fixed-arities #{2}, :end-row 87, :private true, :ns "clojure.pprint", :name "ltrim", :filename "clojure/pprint/utilities.clj", :arglist-strs ["[s c]"], :doc "Trim all instances of c from the beginning of sequence s", :row 78} {:fixed-arities #{2}, :end-row 98, :private true, :ns "clojure.pprint", :name "prefix-count", :filename "clojure/pprint/utilities.clj", :arglist-strs ["[aseq val]"], :doc "Return the number of times that val occurs at the start of sequence aseq,\n  if val is a seq itself, count the number of times any element of val\n  occurs at the beginning of aseq", :row 89} {:arglist-strs ["[& args]"], :doc "Println to *err*", :end-row 104, :filename "clojure/pprint/utilities.clj", :name "prerr", :ns "clojure.pprint", :private true, :row 100} {:end-row 110, :private true, :ns "clojure.pprint", :name "prlabel", :filename "clojure/pprint/utilities.clj", :macro true, :arglist-strs ["[prefix arg & more-args]"], :doc "Print args to *err* in name = value format", :row 106} {:end-row 114, :filename "clojure/pprint/utilities.clj", :name "PrettyFlush", :ns "clojure.pprint", :row 113} {:arglist-strs ["[]"], :end-row 114, :filename "clojure/pprint/utilities.clj", :fixed-arities #{0}, :name "ppflush", :ns "clojure.pprint", :row 114} {:end-row 23, :filename "clojure/pprint/column_writer.clj", :name "*default-page-width*", :ns "clojure.pprint", :private true, :row 23} {:arglist-strs ["[this sym]"], :end-row 26, :filename "clojure/pprint/column_writer.clj", :fixed-arities #{2}, :name "get-field", :ns "clojure.pprint", :private true, :row 25} {:arglist-strs ["[this sym new-val]"], :end-row 29, :filename "clojure/pprint/column_writer.clj", :fixed-arities #{3}, :name "set-field", :ns "clojure.pprint", :private true, :row 28} {:arglist-strs ["[this]"], :end-row 32, :filename "clojure/pprint/column_writer.clj", :fixed-arities #{1}, :name "get-column", :ns "clojure.pprint", :private true, :row 31} {:arglist-strs ["[this]"], :end-row 35, :filename "clojure/pprint/column_writer.clj", :fixed-arities #{1}, :name "get-line", :ns "clojure.pprint", :private true, :row 34} {:arglist-strs ["[this]"], :end-row 38, :filename "clojure/pprint/column_writer.clj", :fixed-arities #{1}, :name "get-max-column", :ns "clojure.pprint", :private true, :row 37} {:arglist-strs ["[this new-max]"], :end-row 42, :filename "clojure/pprint/column_writer.clj", :fixed-arities #{2}, :name "set-max-column", :ns "clojure.pprint", :private true, :row 40} {:arglist-strs ["[this]"], :end-row 45, :filename "clojure/pprint/column_writer.clj", :fixed-arities #{1}, :name "get-writer", :ns "clojure.pprint", :private true, :row 44} {:arglist-strs ["[this c]"], :end-row 53, :filename "clojure/pprint/column_writer.clj", :fixed-arities #{2}, :name "c-write-char", :ns "clojure.pprint", :private true, :row 47} {:arglist-strs ["[writer]" "[writer max-columns]"], :end-row 83, :filename "clojure/pprint/column_writer.clj", :fixed-arities #{1 2}, :name "column-writer", :ns "clojure.pprint", :private true, :row 55}]} {:author "Chris Houser, Christophe Grand, Stephen Gilardi, Michel Salim", :doc "Utilities meant to be used interactively at the REPL", :end-row 17, :filename "clojure/repl.clj", :name "clojure.repl", :row 11, :ns nil, :var-definitions [{:end-row 73, :filename "clojure/repl.clj", :name "special-doc-map", :ns "clojure.repl", :private true, :row 19} {:arglist-strs ["[name-symbol]"], :end-row 78, :filename "clojure/repl.clj", :fixed-arities #{1}, :name "special-doc", :ns "clojure.repl", :private true, :row 75} {:arglist-strs ["[nspace]"], :end-row 81, :filename "clojure/repl.clj", :fixed-arities #{1}, :name "namespace-doc", :ns "clojure.repl", :private true, :row 80} {:arglist-strs ["[{n :ns nm :name :keys [forms arglists special-form doc url macro spec] :as m}]"], :end-row 113, :filename "clojure/repl.clj", :fixed-arities #{1}, :name "print-doc", :ns "clojure.repl", :private true, :row 83} {:arglist-strs ["[re-string-or-pattern]"], :doc "Prints documentation for any var whose documentation or name\n contains a match for re-string-or-pattern", :end-row 129, :filename "clojure/repl.clj", :fixed-arities #{1}, :name "find-doc", :ns "clojure.repl", :row 115} {:fixed-arities #{1}, :end-row 142, :ns "clojure.repl", :name "doc", :filename "clojure/repl.clj", :macro true, :arglist-strs ["[name]"], :doc "Prints documentation for a var or special form given its name,\n   or for a spec if given a keyword", :row 131} {:arglist-strs ["[x]"], :doc "Returns a string of the source code for the given symbol, if it can\n  find it.  This requires that the symbol resolve to a Var defined in\n  a namespace for which the .clj is in the classpath.  Returns nil if\n  it can't find the source.  For most REPL usage, 'source' is more\n  convenient.\n\n  Example: (source-fn 'filter)", :end-row 170, :filename "clojure/repl.clj", :fixed-arities #{1}, :name "source-fn", :ns "clojure.repl", :row 147} {:fixed-arities #{1}, :end-row 179, :ns "clojure.repl", :name "source", :filename "clojure/repl.clj", :macro true, :arglist-strs ["[n]"], :doc "Prints the source code for the given symbol, if it can find it.\n  This requires that the symbol resolve to a Var defined in a\n  namespace for which the .clj is in the classpath.\n\n  Example: (source filter)", :row 172} {:arglist-strs ["[str-or-pattern]"], :doc "Given a regular expression or stringable thing, return a seq of all\npublic definitions in all currently-loaded namespaces that match the\nstr-or-pattern.", :end-row 193, :filename "clojure/repl.clj", :fixed-arities #{1}, :name "apropos", :ns "clojure.repl", :row 181} {:arglist-strs ["[ns]"], :doc "Returns a sorted seq of symbols naming public vars in\n  a namespace or namespace alias. Looks for aliases in *ns*", :end-row 199, :filename "clojure/repl.clj", :fixed-arities #{1}, :name "dir-fn", :ns "clojure.repl", :row 195} {:fixed-arities #{1}, :end-row 205, :ns "clojure.repl", :name "dir", :filename "clojure/repl.clj", :macro true, :arglist-strs ["[nsname]"], :doc "Prints a sorted directory of public vars in a namespace", :row 201} {:arglist-strs ["[fn-name]"], :doc "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", :end-row 212, :filename "clojure/repl.clj", :fixed-arities #{1}, :name "demunge", :ns "clojure.repl", :row 207} {:arglist-strs ["[t]"], :doc "Returns the initial cause of an exception or error by peeling off all of\n  its wrappers", :end-row 225, :filename "clojure/repl.clj", :fixed-arities #{1}, :name "root-cause", :ns "clojure.repl", :row 214} {:arglist-strs ["[el]"], :doc "Returns a (possibly unmunged) string representation of a StackTraceElement", :end-row 238, :filename "clojure/repl.clj", :fixed-arities #{1}, :name "stack-element-str", :ns "clojure.repl", :row 227} {:arglist-strs ["[]" "[e-or-depth]" "[e depth]"], :doc "Prints a stack trace of the exception, to the depth requested. If none supplied, uses the root cause of the\n  most recent repl exception (*e), and a depth of 12.", :end-row 268, :filename "clojure/repl.clj", :fixed-arities #{0 1 2}, :name "pst", :ns "clojure.repl", :row 240} {:arglist-strs ["[]" "[thread]"], :doc "Returns a function that takes one arg and uses that as an exception message\n  to stop the given thread.  Defaults to the current thread", :end-row 277, :filename "clojure/repl.clj", :fixed-arities #{0 1}, :name "thread-stopper", :ns "clojure.repl", :row 273} {:arglist-strs ["[]" "[f]"], :doc "Register INT signal handler.  After calling this, Ctrl-C will cause\n  the given function f to be called with a single argument, the signal.\n  Uses thread-stopper if no function given.", :end-row 289, :filename "clojure/repl.clj", :fixed-arities #{0 1}, :name "set-break-handler!", :ns "clojure.repl", :row 279}]} {:author "Stuart Sierra", :doc "This file defines a generic tree walker for Clojure data\nstructures.  It takes any data structure (list, vector, map, set,\nseq), calls a function on every element, and uses the return value\nof the function in place of the original.  This makes it fairly\neasy to write recursive search-and-replace functions, as shown in\nthe examples.\n\nNote: \"walk\" supports all Clojure data structures EXCEPT maps\ncreated with sorted-map-by.  There is no (obvious) way to retrieve\nthe sorting function.", :end-row 33, :filename "clojure/walk.clj", :name "clojure.walk", :row 21, :ns nil, :var-definitions [{:arglist-strs ["[inner outer form]"], :doc "Traverses form, an arbitrary data structure.  inner and outer are\n  functions.  Applies inner to each element of form, building up a\n  data structure of the same type, then applies outer to the result.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :end-row 51, :filename "clojure/walk.clj", :fixed-arities #{3}, :name "walk", :ns "clojure.walk", :row 35} {:arglist-strs ["[f form]"], :doc "Performs a depth-first, post-order traversal of form.  Calls f on\n  each sub-form, uses f's return value in place of the original.\n  Recognizes all Clojure data structures. Consumes seqs as with doall.", :end-row 59, :filename "clojure/walk.clj", :fixed-arities #{2}, :name "postwalk", :ns "clojure.walk", :row 53} {:arglist-strs ["[f form]"], :doc "Like postwalk, but does pre-order traversal.", :end-row 65, :filename "clojure/walk.clj", :fixed-arities #{2}, :name "prewalk", :ns "clojure.walk", :row 61} {:arglist-strs ["[form]"], :doc "Demonstrates the behavior of postwalk by printing each form as it is\n  walked.  Returns form.", :end-row 85, :filename "clojure/walk.clj", :fixed-arities #{1}, :name "postwalk-demo", :ns "clojure.walk", :row 80} {:arglist-strs ["[form]"], :doc "Demonstrates the behavior of prewalk by printing each form as it is\n  walked.  Returns form.", :end-row 92, :filename "clojure/walk.clj", :fixed-arities #{1}, :name "prewalk-demo", :ns "clojure.walk", :row 87} {:arglist-strs ["[m]"], :doc "Recursively transforms all map keys from strings to keywords.", :end-row 100, :filename "clojure/walk.clj", :fixed-arities #{1}, :name "keywordize-keys", :ns "clojure.walk", :row 94} {:arglist-strs ["[m]"], :doc "Recursively transforms all map keys from keywords to strings.", :end-row 108, :filename "clojure/walk.clj", :fixed-arities #{1}, :name "stringify-keys", :ns "clojure.walk", :row 102} {:arglist-strs ["[smap form]"], :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the root of the tree first.", :end-row 116, :filename "clojure/walk.clj", :fixed-arities #{2}, :name "prewalk-replace", :ns "clojure.walk", :row 110} {:arglist-strs ["[smap form]"], :doc "Recursively transforms form by replacing keys in smap with their\n  values.  Like clojure/replace but works on any data structure.  Does\n  replacement at the leaves of the tree first.", :end-row 124, :filename "clojure/walk.clj", :fixed-arities #{2}, :name "postwalk-replace", :ns "clojure.walk", :row 118} {:arglist-strs ["[form]"], :doc "Recursively performs all possible macroexpansions in form.", :end-row 130, :filename "clojure/walk.clj", :fixed-arities #{1}, :name "macroexpand-all", :ns "clojure.walk", :row 126}]} {:author "Stephen C. Gilardi and Rich Hickey", :doc "Top-level main function for Clojure REPL and scripts.", :end-row 22, :filename "clojure/main.clj", :name "clojure.main", :row 11, :ns nil, :var-definitions [{:end-row 24, :filename "clojure/main.clj", :name "main", :ns "clojure.main", :row 24} {:arglist-strs ["[fn-name]"], :doc "Given a string representation of a fn class,\n  as in a stack trace element, returns a readable version.", :end-row 33, :filename "clojure/main.clj", :fixed-arities #{1}, :name "demunge", :ns "clojure.main", :row 28} {:arglist-strs ["[t]"], :doc "Returns the initial cause of an exception or error by peeling off all of\n  its wrappers", :end-row 46, :filename "clojure/main.clj", :fixed-arities #{1}, :name "root-cause", :ns "clojure.main", :row 35} {:end-row 54, :filename "clojure/main.clj", :name "core-namespaces", :ns "clojure.main", :private true, :row 50} {:arglist-strs ["[class-name]"], :end-row 60, :filename "clojure/main.clj", :fixed-arities #{1}, :name "core-class?", :ns "clojure.main", :private true, :row 56} {:arglist-strs ["[el]"], :doc "Returns a (possibly unmunged) string representation of a StackTraceElement", :end-row 73, :filename "clojure/main.clj", :fixed-arities #{1}, :name "stack-element-str", :ns "clojure.main", :row 62} {:arglist-strs ["[& body]"], :doc "Executes body in the context of thread-local bindings for several vars\n  that often need to be set!: *ns* *warn-on-reflection* *math-context*\n  *print-meta* *print-length* *print-level* *compile-path*\n  *command-line-args* *1 *2 *3 *e", :end-row 101, :filename "clojure/main.clj", :macro true, :name "with-bindings", :ns "clojure.main", :row 77} {:arglist-strs ["[]"], :doc "Default :prompt hook for repl", :end-row 106, :filename "clojure/main.clj", :fixed-arities #{0}, :name "repl-prompt", :ns "clojure.main", :row 103} {:arglist-strs ["[s]"], :doc "If the next character on stream s is a newline, skips it, otherwise\n  leaves the stream untouched. Returns :line-start, :stream-end, or :body\n  to indicate the relative location of the next character on s. The stream\n  must either be an instance of LineNumberingPushbackReader or duplicate\n  its behavior of both supporting .unread and collapsing all of CR, LF, and\n  CRLF to a single \\newline.", :end-row 120, :filename "clojure/main.clj", :fixed-arities #{1}, :name "skip-if-eol", :ns "clojure.main", :row 108} {:arglist-strs ["[s]"], :doc "Skips whitespace characters on stream s. Returns :line-start, :stream-end,\n  or :body to indicate the relative location of the next character on s.\n  Interprets comma as whitespace and semicolon as comment to end of line.\n  Does not interpret #! as comment to end of line because only one\n  character of lookahead is available. The stream must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF to a single\n  \\newline.", :end-row 138, :filename "clojure/main.clj", :fixed-arities #{1}, :name "skip-whitespace", :ns "clojure.main", :row 122} {:arglist-strs ["[opts reader line-number]"], :doc "Reads from reader, which must be a LineNumberingPushbackReader, while capturing\n  the read string. If the read is successful, reset the line number and re-read.\n  The line number on re-read is the passed line-number unless :line or\n  :clojure.core/eval-file meta are explicitly set on the read value.", :end-row 152, :filename "clojure/main.clj", :fixed-arities #{3}, :name "renumbering-read", :ns "clojure.main", :row 140} {:arglist-strs ["[request-prompt request-exit]"], :doc "Default :read hook for repl. Reads from *in* which must either be an\n  instance of LineNumberingPushbackReader or duplicate its behavior of both\n  supporting .unread and collapsing all of CR, LF, and CRLF into a single\n  \\newline. repl-read:\n    - skips whitespace, then\n      - returns request-prompt on start of line, or\n      - returns request-exit on end of stream, or\n      - reads an object from the input stream, then\n        - skips the next input character if it's end of line, then\n        - returns the object.", :end-row 170, :filename "clojure/main.clj", :fixed-arities #{2}, :name "repl-read", :ns "clojure.main", :row 154} {:arglist-strs ["[throwable]"], :doc "Returns the root cause of throwables", :end-row 175, :filename "clojure/main.clj", :fixed-arities #{1}, :name "repl-exception", :ns "clojure.main", :row 172} {:fixed-arities #{1}, :end-row 183, :private true, :ns "clojure.main", :name "file-name", :filename "clojure/main.clj", :arglist-strs ["[full-path]"], :doc "Helper to get just the file name part of a path or nil", :row 177} {:fixed-arities #{1}, :end-row 196, :private true, :ns "clojure.main", :name "file-path", :filename "clojure/main.clj", :arglist-strs ["[full-path]"], :doc "Helper to get the relative path to the source file or nil", :row 185} {:fixed-arities #{2}, :end-row 206, :private true, :ns "clojure.main", :name "java-loc->source", :filename "clojure/main.clj", :arglist-strs ["[clazz method]"], :doc "Convert Java class name and method symbol to source symbol, either a\n  Clojure function or Java class and method.", :row 198} {:arglist-strs ["[datafied-throwable]"], :doc "Returns an analysis of the phase, error, cause, and location of an error that occurred\n  based on Throwable data, as returned by Throwable->map. All attributes other than phase\n  are optional:\n    :clojure.error/phase - keyword phase indicator, one of:\n      :read-source :compile-syntax-check :compilation :macro-syntax-check :macroexpansion\n      :execution :read-eval-result :print-eval-result\n    :clojure.error/source - file name (no path)\n    :clojure.error/path - source path\n    :clojure.error/line - integer line number\n    :clojure.error/column - integer column number\n    :clojure.error/symbol - symbol being expanded/compiled/invoked\n    :clojure.error/class - cause exception class symbol\n    :clojure.error/cause - cause exception message\n    :clojure.error/spec - explain-data for spec error", :end-row 267, :filename "clojure/main.clj", :fixed-arities #{1}, :name "ex-triage", :ns "clojure.main", :row 208} {:arglist-strs ["[{:clojure.error/keys [phase source path line column symbol class cause spec] :as triage-data}]"], :doc "Returns a string from exception data, as produced by ex-triage.\n  The first line summarizes the exception phase and location.\n  The subsequent lines describe the cause.", :end-row 341, :filename "clojure/main.clj", :fixed-arities #{1}, :name "ex-str", :ns "clojure.main", :row 269} {:arglist-strs ["[e]"], :doc "Helper to return an error message string from an exception.", :end-row 346, :filename "clojure/main.clj", :fixed-arities #{1}, :name "err->msg", :ns "clojure.main", :row 343} {:arglist-strs ["[e]"], :doc "Default :caught hook for repl", :end-row 353, :filename "clojure/main.clj", :fixed-arities #{1}, :name "repl-caught", :ns "clojure.main", :row 348} {:doc "A sequence of lib specs that are applied to `require`\nby default when a new command-line REPL is started.", :end-row 359, :filename "clojure/main.clj", :name "repl-requires", :ns "clojure.main", :row 355} {:arglist-strs ["[& body]"], :doc "Evaluates body with *read-eval* set to a \"known\" value,\n   i.e. substituting true for :unknown if necessary.", :end-row 366, :filename "clojure/main.clj", :macro true, :name "with-read-known", :ns "clojure.main", :row 361} {:arglist-strs ["[& options]"], :doc "Generic, reusable, read-eval-print loop. By default, reads from *in*,\n  writes to *out*, and prints exception summaries to *err*. If you use the\n  default :read hook, *in* must either be an instance of\n  LineNumberingPushbackReader or duplicate its behavior of both supporting\n  .unread and collapsing CR, LF, and CRLF into a single \\newline. Options\n  are sequential keyword-value pairs. Available options and their defaults:\n\n     - :init, function of no arguments, initialization hook called with\n       bindings for set!-able vars in place.\n       default: #()\n\n     - :need-prompt, function of no arguments, called before each\n       read-eval-print except the first, the user will be prompted if it\n       returns true.\n       default: (if (instance? LineNumberingPushbackReader *in*)\n                  #(.atLineStart *in*)\n                  #(identity true))\n\n     - :prompt, function of no arguments, prompts for more input.\n       default: repl-prompt\n\n     - :flush, function of no arguments, flushes output\n       default: flush\n\n     - :read, function of two arguments, reads from *in*:\n         - returns its first argument to request a fresh prompt\n           - depending on need-prompt, this may cause the repl to prompt\n             before reading again\n         - returns its second argument to request an exit from the repl\n         - else returns the next object read from the input stream\n       default: repl-read\n\n     - :eval, function of one argument, returns the evaluation of its\n       argument\n       default: eval\n\n     - :print, function of one argument, prints its argument to the output\n       default: prn\n\n     - :caught, function of one argument, a throwable, called when\n       read, eval, or print throws an exception or error\n       default: repl-caught", :end-row 466, :filename "clojure/main.clj", :name "repl", :ns "clojure.main", :row 368} {:arglist-strs ["[path]"], :doc "Loads Clojure source from a file or resource given its path. Paths\n  beginning with @ or @/ are considered relative to classpath.", :end-row 475, :filename "clojure/main.clj", :fixed-arities #{1}, :name "load-script", :ns "clojure.main", :row 468} {:fixed-arities #{1}, :end-row 480, :private true, :ns "clojure.main", :name "init-opt", :filename "clojure/main.clj", :arglist-strs ["[path]"], :doc "Load a script", :row 477} {:fixed-arities #{1}, :end-row 492, :private true, :ns "clojure.main", :name "eval-opt", :filename "clojure/main.clj", :arglist-strs ["[str]"], :doc "Evals expressions in str, prints each non-nil result using prn", :row 482} {:fixed-arities #{1}, :end-row 500, :private true, :ns "clojure.main", :name "init-dispatch", :filename "clojure/main.clj", :arglist-strs ["[opt]"], :doc "Returns the handler associated with an init opt", :row 494} {:fixed-arities #{2}, :end-row 508, :private true, :ns "clojure.main", :name "initialize", :filename "clojure/main.clj", :arglist-strs ["[args inits]"], :doc "Common initialize routine for repl, script, and null opts", :row 502} {:fixed-arities #{2}, :end-row 516, :private true, :ns "clojure.main", :name "main-opt", :filename "clojure/main.clj", :arglist-strs ["[[_ main-ns & args] inits]"], :doc "Call the -main function from a namespace with string arguments from\n  the command line.", :row 510} {:fixed-arities #{2}, :end-row 528, :private true, :ns "clojure.main", :name "repl-opt", :filename "clojure/main.clj", :arglist-strs ["[[_ & args] inits]"], :doc "Start a repl with args and inits. Print greeting if no eval options were\n  present", :row 518} {:fixed-arities #{2}, :end-row 537, :private true, :ns "clojure.main", :name "script-opt", :filename "clojure/main.clj", :arglist-strs ["[[path & args] inits]"], :doc "Run a script from a file, resource, or standard in with args and inits", :row 530} {:fixed-arities #{2}, :end-row 543, :private true, :ns "clojure.main", :name "null-opt", :filename "clojure/main.clj", :arglist-strs ["[args inits]"], :doc "No repl or script opt present, just bind args and run inits", :row 539} {:fixed-arities #{2}, :end-row 548, :private true, :ns "clojure.main", :name "help-opt", :filename "clojure/main.clj", :arglist-strs ["[_ _]"], :doc "Print help text for main", :row 545} {:fixed-arities #{1}, :end-row 562, :private true, :ns "clojure.main", :name "main-dispatch", :filename "clojure/main.clj", :arglist-strs ["[opt]"], :doc "Returns the handler associated with a main option", :row 550} {:fixed-arities #{1}, :end-row 572, :private true, :ns "clojure.main", :name "legacy-repl", :filename "clojure/main.clj", :arglist-strs ["[args]"], :doc "Called by the clojure.lang.Repl.main stub to run a repl with args\n  specified the old way", :row 564} {:fixed-arities #{1}, :end-row 582, :private true, :ns "clojure.main", :name "legacy-script", :filename "clojure/main.clj", :arglist-strs ["[args]"], :doc "Called by the clojure.lang.Script.main stub to run a script with args\n  specified the old way", :row 574} {:arglist-strs ["[t & {:keys [target] :or {target \"file\"} :as opts}]"], :doc "Create and output an exception report for a Throwable to target.\n\n  Options:\n    :target - \"file\" (default), \"stderr\", \"none\"\n\n  If file is specified but cannot be written, falls back to stderr.", :end-row 614, :filename "clojure/main.clj", :name "report-error", :ns "clojure.main", :row 584} {:arglist-strs ["[& args]"], :doc "Usage: java -cp clojure.jar clojure.main [init-opt*] [main-opt] [arg*]\n\n  With no options or args, runs an interactive Read-Eval-Print Loop\n\n  init options:\n    -i, --init path     Load a file or resource\n    -e, --eval string   Evaluate expressions in string; print non-nil values\n    --report target     Report uncaught exception to \"file\" (default), \"stderr\",\n                        or \"none\", overrides System property clojure.main.report\n\n  main options:\n    -m, --main ns-name  Call the -main function from a namespace with args\n    -r, --repl          Run a repl\n    path                Run a script from a file or resource\n    -                   Run a script from standard input\n    -h, -?, --help      Print this help message and exit\n\n  operation:\n\n    - Establishes thread-local bindings for commonly set!-able vars\n    - Enters the user namespace\n    - Binds *command-line-args* to a seq of strings containing command line\n      args that appear after any main option\n    - Runs all init options in order\n    - Calls a -main function or runs a repl or script if requested\n\n  The init options may be repeated and mixed freely, but must appear before\n  any main option. The appearance of any eval option before running a repl\n  suppresses the usual repl greeting message: \"Clojure ~(clojure-version)\".\n\n  Paths may be absolute or relative in the filesystem or relative to\n  classpath. Classpath-relative paths have prefix of @ or @/", :end-row 674, :filename "clojure/main.clj", :name "main", :ns "clojure.main", :row 616}]} {:author "Stuart Sierra", :doc "Macros that expand to repeated copies of a template expression.", :end-row 28, :filename "clojure/template.clj", :name "clojure.template", :row 25, :ns nil, :var-definitions [{:arglist-strs ["[argv expr values]"], :doc "For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)", :end-row 43, :filename "clojure/template.clj", :fixed-arities #{3}, :name "apply-template", :ns "clojure.template", :row 30} {:arglist-strs ["[argv expr & values]"], :doc "Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))", :end-row 55, :filename "clojure/template.clj", :macro true, :name "do-template", :ns "clojure.template", :row 45}]} {:author "Rich Hickey", :doc "A library for reduction and parallel folding. Alpha and subject\n      to change.", :end-row 15, :filename "clojure/core/reducers.clj", :name "clojure.core.reducers", :row 9, :ns nil, :var-definitions [{:end-row 22, :filename "clojure/core/reducers.clj", :name "pool", :ns "clojure.core.reducers", :row 22} {:arglist-strs ["[f]"], :end-row 25, :filename "clojure/core/reducers.clj", :fixed-arities #{1}, :name "fjtask", :ns "clojure.core.reducers", :row 24} {:arglist-strs ["[f]"], :end-row 30, :filename "clojure/core/reducers.clj", :fixed-arities #{1}, :name "fjinvoke", :ns "clojure.core.reducers", :private true, :row 27} {:arglist-strs ["[task]"], :end-row 32, :filename "clojure/core/reducers.clj", :fixed-arities #{1}, :name "fjfork", :ns "clojure.core.reducers", :private true, :row 32} {:arglist-strs ["[task]"], :end-row 34, :filename "clojure/core/reducers.clj", :fixed-arities #{1}, :name "fjjoin", :ns "clojure.core.reducers", :private true, :row 34} {:arglist-strs ["[f coll]" "[f init coll]"], :doc "Like core/reduce except:\n     When init is not provided, (f) is used.\n     Maps are reduced with reduce-kv", :end-row 46, :filename "clojure/core/reducers.clj", :fixed-arities #{3 2}, :name "reduce", :ns "clojure.core.reducers", :row 38} {:end-row 49, :filename "clojure/core/reducers.clj", :name "CollFold", :ns "clojure.core.reducers", :row 48} {:arglist-strs ["[coll n combinef reducef]"], :end-row 49, :filename "clojure/core/reducers.clj", :fixed-arities #{4}, :name "coll-fold", :ns "clojure.core.reducers", :row 49} {:arglist-strs ["[reducef coll]" "[combinef reducef coll]" "[n combinef reducef coll]"], :doc "Reduces a collection using a (potentially parallel) reduce-combine\n  strategy. The collection is partitioned into groups of approximately\n  n (default 512), each of which is reduced with reducef (with a seed\n  value obtained by calling (combinef) with no arguments). The results\n  of these reductions are then reduced with combinef (default\n  reducef). combinef must be associative, and, when called with no\n  arguments, (combinef) must produce its identity element. These\n  operations may be performed in parallel, but the results will\n  preserve order.", :end-row 65, :filename "clojure/core/reducers.clj", :fixed-arities #{4 3 2}, :name "fold", :ns "clojure.core.reducers", :row 51} {:arglist-strs ["[coll xf]"], :doc "Given a reducible collection, and a transformation function xf,\n  returns a reducible collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.", :end-row 79, :filename "clojure/core/reducers.clj", :fixed-arities #{2}, :name "reducer", :ns "clojure.core.reducers", :row 67} {:arglist-strs ["[coll xf]"], :doc "Given a foldable collection, and a transformation function xf,\n  returns a foldable collection, where any supplied reducing\n  fn will be transformed by xf. xf is a function of reducing fn to\n  reducing fn.", :end-row 97, :filename "clojure/core/reducers.clj", :fixed-arities #{2}, :name "folder", :ns "clojure.core.reducers", :row 81} {:arglist-strs ["[name doc meta args body]"], :end-row 104, :filename "clojure/core/reducers.clj", :fixed-arities #{5}, :name "do-curried", :ns "clojure.core.reducers", :private true, :row 99} {:end-row 110, :private true, :ns "clojure.core.reducers", :name "defcurried", :filename "clojure/core/reducers.clj", :macro true, :arglist-strs ["[name doc meta args & body]"], :doc "Builds another arity of the fn that returns a fn awaiting the last\n  param", :row 106} {:arglist-strs ["[f1 k fkv]"], :end-row 121, :filename "clojure/core/reducers.clj", :fixed-arities #{3}, :name "do-rfn", :ns "clojure.core.reducers", :private true, :row 112} {:fixed-arities #{2}, :end-row 126, :private true, :ns "clojure.core.reducers", :name "rfn", :filename "clojure/core/reducers.clj", :macro true, :arglist-strs ["[[f1 k] fkv]"], :doc "Builds 3-arity reducing fn given names of wrapped fn and key, and k/v impl.", :row 123} {:arglist-strs ["[f coll]"], :doc "Applies f to every value in the reduction of coll. Foldable.", :end-row 136, :filename "clojure/core/reducers.clj", :fixed-arities #{2}, :name "map", :ns "clojure.core.reducers", :row 128} {:arglist-strs ["[f coll]"], :doc "Applies f to every value in the reduction of coll, concatenating the result\n  colls of (f val). Foldable.", :end-row 152, :filename "clojure/core/reducers.clj", :fixed-arities #{2}, :name "mapcat", :ns "clojure.core.reducers", :row 138} {:arglist-strs ["[pred coll]"], :doc "Retains values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.", :end-row 165, :filename "clojure/core/reducers.clj", :fixed-arities #{2}, :name "filter", :ns "clojure.core.reducers", :row 154} {:arglist-strs ["[pred coll]"], :doc "Removes values in the reduction of coll for which (pred val)\n  returns logical true. Foldable.", :end-row 172, :filename "clojure/core/reducers.clj", :fixed-arities #{2}, :name "remove", :ns "clojure.core.reducers", :row 167} {:arglist-strs ["[coll]"], :doc "Takes any nested combination of sequential things (lists, vectors,\n  etc.) and returns their contents as a single, flat foldable\n  collection.", :end-row 187, :filename "clojure/core/reducers.clj", :fixed-arities #{1}, :name "flatten", :ns "clojure.core.reducers", :row 174} {:arglist-strs ["[pred coll]"], :doc "Ends the reduction of coll when (pred val) returns logical false.", :end-row 199, :filename "clojure/core/reducers.clj", :fixed-arities #{2}, :name "take-while", :ns "clojure.core.reducers", :row 189} {:arglist-strs ["[n coll]"], :doc "Ends the reduction of coll after consuming n values.", :end-row 213, :filename "clojure/core/reducers.clj", :fixed-arities #{2}, :name "take", :ns "clojure.core.reducers", :row 201} {:arglist-strs ["[n coll]"], :doc "Elides the first n values from the reduction of coll.", :end-row 227, :filename "clojure/core/reducers.clj", :fixed-arities #{2}, :name "drop", :ns "clojure.core.reducers", :row 215} {:end-row 253, :filename "clojure/core/reducers.clj", :name "Cat", :ns "clojure.core.reducers", :row 230} {:arglist-strs ["[cnt left right]"], :end-row 253, :filename "clojure/core/reducers.clj", :fixed-arities #{3}, :name "->Cat", :ns "clojure.core.reducers", :row 230} {:arglist-strs ["[]" "[ctor]" "[left right]"], :doc "A high-performance combining fn that yields the catenation of the\n  reduced values. The result is reducible, foldable, seqable and\n  counted, providing the identity collections are reducible, seqable\n  and counted. The single argument version will build a combining fn\n  with the supplied identity constructor. Tests for identity\n  with (zero? (count x)). See also foldcat.", :end-row 273, :filename "clojure/core/reducers.clj", :fixed-arities #{0 1 2}, :name "cat", :ns "clojure.core.reducers", :row 255} {:arglist-strs ["[acc x]"], :doc ".adds x to acc and returns acc", :end-row 279, :filename "clojure/core/reducers.clj", :fixed-arities #{2}, :name "append!", :ns "clojure.core.reducers", :row 275} {:arglist-strs ["[coll]"], :doc "Equivalent to (fold cat append! coll)", :end-row 285, :filename "clojure/core/reducers.clj", :fixed-arities #{1}, :name "foldcat", :ns "clojure.core.reducers", :row 281} {:arglist-strs ["[op ctor]"], :doc "Builds a combining fn out of the supplied operator and identity\n  constructor. op must be associative and ctor called with no args\n  must return an identity value for it.", :end-row 295, :filename "clojure/core/reducers.clj", :fixed-arities #{2}, :name "monoid", :ns "clojure.core.reducers", :row 287} {:arglist-strs ["[v n combinef reducef]"], :end-row 312, :filename "clojure/core/reducers.clj", :fixed-arities #{4}, :name "foldvec", :ns "clojure.core.reducers", :private true, :row 298}]} {:author "Alex Miller", :doc "Socket server support", :end-row 19, :filename "clojure/core/server.clj", :name "clojure.core.server", :row 9, :ns nil, :var-definitions [{:end-row 23, :filename "clojure/core/server.clj", :name "*session*", :ns "clojure.core.server", :row 23} {:end-row 26, :filename "clojure/core/server.clj", :name "lock", :ns "clojure.core.server", :private true, :row 26} {:end-row 27, :filename "clojure/core/server.clj", :name "servers", :ns "clojure.core.server", :private true, :row 27} {:arglist-strs ["[lock-expr & body]"], :end-row 36, :filename "clojure/core/server.clj", :macro true, :name "with-lock", :ns "clojure.core.server", :private true, :row 29} {:arglist-strs ["[name daemon & body]"], :end-row 42, :filename "clojure/core/server.clj", :macro true, :name "thread", :ns "clojure.core.server", :private true, :row 38} {:fixed-arities #{2}, :end-row 48, :private true, :ns "clojure.core.server", :name "required", :filename "clojure/core/server.clj", :arglist-strs ["[opts prop]"], :doc "Throw if opts does not contain prop.", :row 44} {:fixed-arities #{1}, :end-row 55, :private true, :ns "clojure.core.server", :name "validate-opts", :filename "clojure/core/server.clj", :arglist-strs ["[{:keys [name port accept] :as opts}]"], :doc "Validate server config options", :row 50} {:fixed-arities #{8}, :end-row 82, :private true, :ns "clojure.core.server", :name "accept-connection", :filename "clojure/core/server.clj", :arglist-strs ["[conn name client-id in out err accept args]"], :doc "Start accept function, to be invoked on a client thread, given:\n    conn - client socket\n    name - server name\n    client-id - client identifier\n    in - in stream\n    out - out stream\n    err - err stream\n    accept - accept fn symbol to invoke\n    args - to pass to accept-fn", :row 57} {:arglist-strs ["[opts]"], :doc "Start a socket server given the specified opts:\n    :address Host or address, string, defaults to loopback address\n    :port Port, integer, required\n    :name Name, required\n    :accept Namespaced symbol of the accept function to invoke, required\n    :args Vector of args to pass to accept function\n    :bind-err Bind *err* to socket out stream?, defaults to true\n    :server-daemon Is server thread a daemon?, defaults to true\n    :client-daemon Are client threads daemons?, defaults to true\n   Returns server socket.", :end-row 123, :filename "clojure/core/server.clj", :fixed-arities #{1}, :name "start-server", :ns "clojure.core.server", :row 84} {:arglist-strs ["[]" "[name]"], :doc "Stop server with name or use the server-name from *session* if none supplied.\n  Returns true if server stopped successfully, nil if not found, or throws if\n  there is an error closing the socket.", :end-row 137, :filename "clojure/core/server.clj", :fixed-arities #{0 1}, :name "stop-server", :ns "clojure.core.server", :row 125} {:arglist-strs ["[]"], :doc "Stop all servers ignores all errors, and returns nil.", :end-row 144, :filename "clojure/core/server.clj", :fixed-arities #{0}, :name "stop-servers", :ns "clojure.core.server", :row 139} {:fixed-arities #{1}, :end-row 155, :private true, :ns "clojure.core.server", :name "parse-props", :filename "clojure/core/server.clj", :arglist-strs ["[props]"], :doc "Parse clojure.server.* from properties to produce a map of server configs.", :row 146} {:arglist-strs ["[system-props]"], :doc "Start all servers specified in the system properties.", :end-row 161, :filename "clojure/core/server.clj", :fixed-arities #{1}, :name "start-servers", :ns "clojure.core.server", :row 157} {:arglist-strs ["[]"], :doc "Initialize repl in user namespace and make standard repl requires.", :end-row 167, :filename "clojure/core/server.clj", :fixed-arities #{0}, :name "repl-init", :ns "clojure.core.server", :row 163} {:arglist-strs ["[request-prompt request-exit]"], :doc "Enhanced :read hook for repl supporting :repl/quit.", :end-row 178, :filename "clojure/core/server.clj", :fixed-arities #{2}, :name "repl-read", :ns "clojure.core.server", :row 169} {:arglist-strs ["[]"], :doc "REPL with predefined hooks for attachable socket server.", :end-row 185, :filename "clojure/core/server.clj", :fixed-arities #{0}, :name "repl", :ns "clojure.core.server", :row 180} {:arglist-strs ["[ex phase]"], :end-row 189, :filename "clojure/core/server.clj", :fixed-arities #{2}, :name "ex->data", :ns "clojure.core.server", :private true, :row 187} {:arglist-strs ["[in-reader out-fn & {:keys [stdin]}]"], :doc "a REPL with structured output (for programs)\n  reads forms to eval from in-reader (a LineNumberingPushbackReader)\n  Closing the input or passing the form :repl/quit will cause it to return\n\n  Calls out-fn with data, one of:\n  {:tag :ret\n   :val val ;;eval result, or Throwable->map data if exception thrown\n   :ns ns-name-string\n   :ms long ;;eval time in milliseconds\n   :form string ;;iff successfully read\n   :exception true ;;iff exception thrown\n  }\n  {:tag :out\n   :val string} ;chars from during-eval *out*\n  {:tag :err\n   :val string} ;chars from during-eval *err*\n  {:tag :tap\n   :val val} ;values from tap>\n\n  You might get more than one :out or :err per eval, but exactly one :ret\n  tap output can happen at any time (i.e. between evals)\n  If during eval an attempt is made to read *in* it will read from in-reader unless :stdin is supplied\n\n  Alpha, subject to change.", :end-row 261, :filename "clojure/core/server.clj", :name "prepl", :ns "clojure.core.server", :row 191} {:arglist-strs ["[valf]"], :end-row 270, :filename "clojure/core/server.clj", :fixed-arities #{1}, :name "resolve-fn", :ns "clojure.core.server", :private true, :row 263} {:arglist-strs ["[& {:keys [valf] :or {valf pr-str}}]"], :doc "prepl bound to *in* and *out*, suitable for use with e.g. server/repl (socket-repl).\n  :ret and :tap vals will be processed by valf, a fn of one argument\n  or a symbol naming same (default pr-str)\n\n  Alpha, subject to change.", :end-row 293, :filename "clojure/core/server.clj", :name "io-prepl", :ns "clojure.core.server", :row 272} {:arglist-strs ["[host port in-reader out-fn & {:keys [valf readf] :or {valf read-string readf #(read %1 false %2)}}]"], :doc "Implements a prepl on in-reader and out-fn by forwarding to a\n  remote [io-]prepl over a socket.  Messages will be read by readf, a\n  fn of a LineNumberingPushbackReader and EOF value or a symbol naming\n  same (default #(read %1 false %2)),\n  :ret and :tap vals will be processed by valf, a fn of one argument\n  or a symbol naming same (default read-string). If that function\n  throws, :val will be unprocessed.\n\n  Alpha, subject to change.", :end-row 338, :filename "clojure/core/server.clj", :name "remote-prepl", :ns "clojure.core.server", :row 295}]} {:end-row 9, :filename "clojure/core/protocols.clj", :name "clojure.core.protocols", :row 9, :ns nil, :var-definitions [{:doc "Protocol for collection types that can implement reduce faster than\n  first/next recursion. Called by clojure.core/reduce. Baseline\n  implementation defined in terms of Iterable.", :end-row 17, :filename "clojure/core/protocols.clj", :name "CollReduce", :ns "clojure.core.protocols", :row 13} {:arglist-strs ["[coll f]" "[coll f val]"], :end-row 17, :filename "clojure/core/protocols.clj", :fixed-arities #{3 2}, :name "coll-reduce", :ns "clojure.core.protocols", :row 17} {:doc "Protocol for concrete seq types that can reduce themselves\n   faster than first/next recursion. Called by clojure.core/reduce.", :end-row 22, :filename "clojure/core/protocols.clj", :name "InternalReduce", :ns "clojure.core.protocols", :row 19} {:arglist-strs ["[seq f start]"], :end-row 22, :filename "clojure/core/protocols.clj", :fixed-arities #{3}, :name "internal-reduce", :ns "clojure.core.protocols", :row 22} {:arglist-strs ["[coll f]" "[coll f val]"], :end-row 31, :filename "clojure/core/protocols.clj", :fixed-arities #{3 2}, :name "seq-reduce", :ns "clojure.core.protocols", :private true, :row 24} {:arglist-strs ["[coll f]" "[coll f val]"], :end-row 53, :filename "clojure/core/protocols.clj", :fixed-arities #{3 2}, :name "iter-reduce", :ns "clojure.core.protocols", :private true, :row 33} {:fixed-arities #{3}, :end-row 66, :private true, :ns "clojure.core.protocols", :name "naive-seq-reduce", :filename "clojure/core/protocols.clj", :arglist-strs ["[s f val]"], :doc "Reduces a seq, ignoring any opportunities to switch to a more\n  specialized implementation.", :row 55} {:fixed-arities #{3}, :end-row 73, :private true, :ns "clojure.core.protocols", :name "interface-or-naive-reduce", :filename "clojure/core/protocols.clj", :arglist-strs ["[coll f val]"], :doc "Reduces via IReduceInit if possible, else naively.", :row 68} {:doc "Protocol for concrete associative types that can reduce themselves\n   via a function of key and val faster than first/next recursion over map\n   entries. Called by clojure.core/reduce-kv, and has same\n   semantics (just different arg order).", :end-row 180, :filename "clojure/core/protocols.clj", :name "IKVReduce", :ns "clojure.core.protocols", :row 175} {:arglist-strs ["[amap f init]"], :end-row 180, :filename "clojure/core/protocols.clj", :fixed-arities #{3}, :name "kv-reduce", :ns "clojure.core.protocols", :row 180} {:end-row 185, :filename "clojure/core/protocols.clj", :name "Datafiable", :ns "clojure.core.protocols", :row 182} {:arglist-strs ["[o]"], :doc "return a representation of o as data (default identity)", :end-row 185, :filename "clojure/core/protocols.clj", :fixed-arities #{1}, :name "datafy", :ns "clojure.core.protocols", :row 185} {:end-row 198, :filename "clojure/core/protocols.clj", :name "Navigable", :ns "clojure.core.protocols", :row 194} {:arglist-strs ["[coll k v]"], :doc "return (possibly transformed) v in the context of coll and k (a key/index or nil),\ndefaults to returning v.", :end-row 198, :filename "clojure/core/protocols.clj", :fixed-arities #{3}, :name "nav", :ns "clojure.core.protocols", :row 197}]}]